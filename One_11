#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: sql_to_business_converter.py
Description:
  A widget/tab that leverages advanced_lineage.parse_sql_dependencies(...) to parse a rule's SQL,
  then replaces table (and possibly column) names with user-supplied "business" names.
  
Database Requirements:
  - Must have BRM_RULES table with columns RULE_ID, RULE_SQL
  - parse_sql_dependencies(...) is imported from advanced_lineage
"""

import sys
import json
import logging

from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QPlainTextEdit,
    QPushButton, QMessageBox, QLineEdit
)

# We reference parse_sql_dependencies from advanced_lineage
from advanced_lineage import parse_sql_dependencies

class SqlToBusinessLanguageConverterTab(QWidget):
    """
    A widget that:
      • Loads all BRM_RULES in a combo box
      • When user chooses one, fetch RULE_SQL
      • Accepts a JSON mapping { "schema.table" : "BusinessName", ... }
      • Replaces those references in the SQL
      • Displays the converted SQL plus a summary (like # of replacements)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self._setup_auto_refresh()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Rule Selection
        rule_layout = QHBoxLayout()
        rule_layout.addWidget(QLabel("Select Rule:"))
        self.rule_selector = QComboBox()
        self.populate_rule_selector()
        rule_layout.addWidget(self.rule_selector)
        layout.addLayout(rule_layout)

        # JSON Mapping Input
        map_layout = QHBoxLayout()
        map_layout.addWidget(QLabel("Business Name Mapping (JSON):"))
        self.mapping_input = QPlainTextEdit()
        self.mapping_input.setPlaceholderText('E.g. {"dbo.Customers":"Customers","dbo.Orders":"Orders"}')
        map_layout.addWidget(self.mapping_input)
        layout.addLayout(map_layout)

        # Convert Button
        self.convert_button = QPushButton("Convert SQL to Business Language")
        self.convert_button.clicked.connect(self.convert_sql)
        layout.addWidget(self.convert_button)

        # Output Display
        layout.addWidget(QLabel("Converted SQL:"))
        self.output_display = QPlainTextEdit()
        self.output_display.setReadOnly(True)
        layout.addWidget(self.output_display)

        self.setLayout(layout)

    def populate_rule_selector(self):
        """
        Load all rule IDs and names from BRM_RULES into the combo box.
        """
        self.rule_selector.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            rows = c.fetchall()
            for row in rows:
                rid, rname = row
                self.rule_selector.addItem(f"{rid} - {rname}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Could not load rules: {ex}")

    def convert_sql(self):
        """
        Fetch the selected rule's SQL, parse it, apply the user-supplied JSON mapping,
        then display the converted SQL.
        """
        rule_id = self.rule_selector.currentData()
        if rule_id is None:
            QMessageBox.warning(self, "No Rule", "Please select a rule from the combo box.")
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row or not row[0]:
                QMessageBox.warning(self, "No SQL", "Selected rule has no SQL.")
                return

            sql_text = row[0]
            parse_info = parse_sql_dependencies(sql_text)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error fetching/parsing SQL: {ex}")
            return

        # load JSON mapping
        mapping_text = self.mapping_input.toPlainText().strip()
        business_mapping = {}
        if mapping_text:
            try:
                business_mapping = json.loads(mapping_text)
            except Exception as ex:
                QMessageBox.warning(self, "Mapping Error", f"Invalid JSON: {ex}")
                return

        # Convert
        converted_sql = self.apply_business_mapping(sql_text, parse_info, business_mapping)
        self.output_display.setPlainText(converted_sql)
        replaced_count = self.count_replacements(parse_info, business_mapping)
        QMessageBox.information(self, "Conversion Complete", f"Replaced {replaced_count} identifiers.")

    def apply_business_mapping(self, sql_text, parse_info, mapping):
        converted = sql_text
        # For each table reference
        for (schema, table, alias, is_sub) in parse_info.get("tables", []):
            key = f"{schema}.{table}" if schema else table
            if key in mapping:
                bname = mapping[key]
                # We'll do a naive replace with word boundaries
                converted = self._replace_identifier(converted, table, bname)
        return converted

    def _replace_identifier(self, text, identifier, replacement):
        import re
        pattern = r'\b' + re.escape(identifier) + r'\b'
        return re.sub(pattern, replacement, text)

    def count_replacements(self, parse_info, mapping):
        count = 0
        for (schema, table, alias, is_sub) in parse_info.get("tables", []):
            key = f"{schema}.{table}" if schema else table
            if key in mapping:
                count += 1
        return count

    def _setup_auto_refresh(self):
        """
        Auto-refresh rule selector and re-do conversion if the user has something displayed.
        (For demonstration, every 30 seconds.)
        """
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.auto_refresh)
        self.refresh_timer.start(30000)

    def auto_refresh(self):
        old_rule = self.rule_selector.currentData()
        self.populate_rule_selector()
        if self.output_display.toPlainText().strip():
            # re-run conversion if rule is still valid
            if old_rule:
                idx = self.rule_selector.findData(old_rule)
                if idx>=0:
                    self.rule_selector.setCurrentIndex(idx)
                self.convert_sql()