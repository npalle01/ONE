#!/usr/bin/env python3
# vqb_multi_single_file.py
#
# Single-file Python/PyQt Visual Query Builder with:
#   - Multiple ODBC connections => each assigned a unique alias
#   - BFS multi-join (drag columns => wizard for single-col or multi-condition join)
#   - Production-level DML mapping lines (INSERT/UPDATE/DELETE)
#   - Collapsible BFS item for DML source + collapsible table items for SELECT usage
#   - Filter/Group/Sort panels, pivot wizard example
#   - Expression Builder & Window Function Wizard
#   - Nested subqueries & Sub-VQB => user picks connection
#   - CTE panel => "virtual tables" on BFS => user picks connection for sub-VQB
#   - "SQL Import" => partial BFS rebuild using sqlglot.parse_one(...) (no 'ansi')
#   - No forced LIMIT in run_sql
#   - No pan/zoom code (no setDragMode, no wheelEvent override)
#   - All references to "demo BFS map" removed
#
# Requirements:
#   pip install pyodbc sqlparse sqlglot PyQt5
#
# Then run: python vqb_multi_single_file.py

import sys
import traceback
import logging
import pyodbc
import sqlparse
import sqlglot
from sqlglot import exp

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QPointF, QTimer, QThreadPool, QRunnable, pyqtSignal, QObject,
    QRegularExpression
)
from PyQt5.QtGui import (
    QPalette, QColor, QPen, QBrush, QFont, QSyntaxHighlighter, QTextCharFormat
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeWidget, QTreeWidgetItem, QTextEdit, QPushButton, QSplitter,
    QLineEdit, QLabel, QDialog, QFormLayout, QComboBox, QTableWidget,
    QTableWidgetItem, QTabWidget, QMessageBox, QGraphicsView,
    QGraphicsScene, QGraphicsRectItem, QGraphicsTextItem, QGraphicsItem,
    QGraphicsLineItem, QProgressBar, QDialogButtonBox, QStatusBar,
    QGroupBox, QAbstractItemView, QSpinBox, QMenu, QFrame, QAction,
    QListWidget, QCheckBox, QHeaderView
)

###############################################################################
# 0) Logging + Fusion style
###############################################################################
logging.basicConfig(
    filename="vqb.log",
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.DEBUG
)
pyodbc.pooling=True

def apply_fusion_style():
    QApplication.setStyle("Fusion")
    palette=QPalette()
    palette.setColor(QPalette.Window,QColor(240,240,240))
    palette.setColor(QPalette.WindowText,Qt.black)
    palette.setColor(QPalette.Base,QColor(255,255,255))
    palette.setColor(QPalette.AlternateBase,QColor(225,225,225))
    palette.setColor(QPalette.Button,QColor(230,230,230))
    palette.setColor(QPalette.ButtonText,Qt.black)
    palette.setColor(QPalette.Highlight,QColor(76,163,224))
    palette.setColor(QPalette.HighlightedText,Qt.white)
    QApplication.setPalette(palette)

    style_sheet="""
        QCheckBox::indicator, QRadioButton::indicator {
            width: 12px;
            height: 12px;
            spacing: 2px;
        }
    """
    QApplication.instance().setStyleSheet(style_sheet)

###############################################################################
# 1) Multi ODBC Connection Management
###############################################################################
class ODBCConnectDialog(QDialog):
    """ Connect to an ODBC DSN """
    def __init__(self,parent=None):
        super().__init__(parent)
        self._conn=None
        self._db_type=None
        self.setWindowTitle("Connect ODBC DSN")
        self.resize(400,230)

        lay=QVBoxLayout(self)
        lay.addWidget(QLabel("ODBC DSN:"))
        self.dsn_combo=QComboBox()
        try:
            dsns=pyodbc.dataSources()
            for dsn in sorted(dsns.keys()):
                self.dsn_combo.addItem(dsn)
        except:
            pass
        lay.addWidget(self.dsn_combo)

        lay.addWidget(QLabel("Username (optional):"))
        self.user_edit=QLineEdit()
        lay.addWidget(self.user_edit)

        lay.addWidget(QLabel("Password (optional):"))
        self.pass_edit=QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        lay.addWidget(self.pass_edit)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        lay.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(lay)

    def on_ok(self):
        dsn=self.dsn_combo.currentText().strip()
        if not dsn:
            QMessageBox.warning(self,"Missing DSN","Pick a DSN.")
            return
        user=self.user_edit.text().strip()
        pwd=self.pass_edit.text().strip()
        conn_str=f"DSN={dsn};"
        if user:
            conn_str+=f"UID={user};"
        if pwd:
            conn_str+=f"PWD={pwd};"

        try:
            cn=pyodbc.connect(conn_str,autocommit=True)
            self._conn=cn
            # Attempt to figure out DB type
            try:
                dbms=cn.getinfo(pyodbc.SQL_DBMS_NAME) or ""
                if "TERADATA" in dbms.upper():
                    self._db_type="Teradata"
                elif "SQL SERVER" in dbms.upper():
                    self._db_type="SQLServer"
                else:
                    self._db_type=dbms.strip()
            except:
                self._db_type="Unknown"
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self,"Connect Error",f"Failed:\n{ex}")

    def get_connection(self):
        return self._conn
    def get_db_type(self):
        return self._db_type

class MultiODBCConnectDialog(QDialog):
    """ Manage multiple ODBC connections => each alias used as 'linked server' prefix """
    def __init__(self, existing_conns=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Manage DB Connections")
        self.resize(500,300)
        self._connections=existing_conns if existing_conns else {}

        main=QVBoxLayout(self)
        instruct=QLabel(
            "Add or remove ODBC connections.\n"
            "Each connection is assigned an alias => used as a 'linked server' prefix."
        )
        main.addWidget(instruct)

        self.conn_table=QTableWidget(0,3)
        self.conn_table.setHorizontalHeaderLabels(["Alias","DB Type","Status"])
        self.conn_table.horizontalHeader().setStretchLastSection(True)
        main.addWidget(self.conn_table)

        for alias,info in self._connections.items():
            r=self.conn_table.rowCount()
            self.conn_table.insertRow(r)
            self.conn_table.setItem(r,0,QTableWidgetItem(alias))
            dbt=info.get("db_type","Unknown")
            self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
            st="OK" if info.get("connection") else "NoConn"
            self.conn_table.setItem(r,2,QTableWidgetItem(st))

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Connection")
        rm_btn=QPushButton("Remove Connection")
        close_btn=QPushButton("Close")
        bh.addWidget(add_btn)
        bh.addWidget(rm_btn)
        bh.addStretch()
        bh.addWidget(close_btn)
        main.addLayout(bh)

        add_btn.clicked.connect(self.on_add)
        rm_btn.clicked.connect(self.on_rm)
        close_btn.clicked.connect(self.accept)
        self.setLayout(main)

    def on_add(self):
        d=ODBCConnectDialog(self)
        if d.exec_()==QDialog.Accepted:
            c=d.get_connection()
            dbt=d.get_db_type()
            if c:
                base=dbt if dbt else "Unknown"
                i=1
                alias=f"{base}_{i}"
                while alias in self._connections:
                    i+=1
                    alias=f"{base}_{i}"
                self._connections[alias]={"connection":c,"db_type":dbt}
                r=self.conn_table.rowCount()
                self.conn_table.insertRow(r)
                self.conn_table.setItem(r,0,QTableWidgetItem(alias))
                self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
                self.conn_table.setItem(r,2,QTableWidgetItem("OK"))

    def on_rm(self):
        rows=self.conn_table.selectionModel().selectedRows()
        if not rows: return
        for rr in sorted([x.row() for x in rows],reverse=True):
            alias_item=self.conn_table.item(rr,0)
            if alias_item:
                alias=alias_item.text()
                if alias in self._connections:
                    del self._connections[alias]
            self.conn_table.removeRow(rr)

    def get_connections(self):
        return self._connections

class ConnectionPickerDialog(QDialog):
    """ Let user pick from existing connection aliases """
    def __init__(self, connections, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Pick Connection")
        self.resize(300,120)
        self._connections=connections
        self.chosen_alias=None

        main=QVBoxLayout(self)
        main.addWidget(QLabel("Select DB Connection:"))
        self.conn_cb=QComboBox()
        for a in sorted(self._connections.keys()):
            self.conn_cb.addItem(a)
        main.addWidget(self.conn_cb)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        if not self._connections:
            QMessageBox.warning(self,"No Connections","No DB connections found.")
            return
        self.chosen_alias=self.conn_cb.currentText()
        if not self.chosen_alias:
            QMessageBox.warning(self,"No alias","Pick a connection alias.")
            return
        self.accept()

    def get_chosen_alias(self):
        return self.chosen_alias

###############################################################################
# 2) Lazy schema loading => each connection => expand DB => tables => columns
###############################################################################
class LazySchemaLoaderSignals(QObject):
    finished=pyqtSignal(list)
    error=pyqtSignal(str)

class LazySchemaLoader(QRunnable):
    def __init__(self, connection, dbname):
        super().__init__()
        self.connection=connection
        self.dbname=dbname
        self.signals=LazySchemaLoaderSignals()

    @QtCore.pyqtSlot()
    def run(self):
        try:
            cur=self.connection.cursor()
            q=f"""
                SELECT TableName
                FROM DBC.TablesV
                WHERE DatabaseName='{self.dbname}' AND TableKind='T'
                ORDER BY TableName
            """
            cur.execute(q)
            rows=cur.fetchall()
            tables=[r[0] for r in rows]
            self.signals.finished.emit(tables)
        except Exception as ex:
            msg=f"Error loading tables for {self.dbname}: {ex}\n{traceback.format_exc()}"
            self.signals.error.emit(msg)

def load_columns_for_table(connection,dbN,tblN):
    cols=[]
    try:
        cur=connection.cursor()
        cur.execute(f"""
            SELECT ColumnName
            FROM DBC.ColumnsV
            WHERE DatabaseName='{dbN}' AND TableName='{tblN}'
            ORDER BY ColumnId
        """)
        rows=cur.fetchall()
        cols=[r[0] for r in rows]
    except Exception as ex:
        logging.warning(f"Failed to load columns for {dbN}.{tblN}: {ex}")
    return cols

###############################################################################
# 3) MultiDBLazySchemaTreeWidget => top-level => each connection => DB => tables
###############################################################################
class MultiDBLazySchemaTreeWidget(QTreeWidget):
    """ Root => alias + DB type => expand => databases => expand => tables => expand => columns """
    def __init__(self, connections, parent_builder=None, parent=None):
        super().__init__(parent)
        self.connections=connections
        self.parent_builder=parent_builder
        self.setHeaderHidden(False)
        self.setColumnCount(1)
        self.setHeaderLabel("Databases / Tables")
        self.setDragEnabled(True)
        self.threadpool=QThreadPool.globalInstance()

    def set_connections(self, conns):
        self.connections=conns

    def populate_roots(self):
        self.clear()
        if not self.connections:
            self.addTopLevelItem(QTreeWidgetItem(["No Connections"]))
            return
        for alias,info in self.connections.items():
            dbt=info.get("db_type","Unknown")
            top=QTreeWidgetItem([f"{alias} ({dbt})"])
            top.setData(0,Qt.UserRole,("connAlias",alias))
            self.addTopLevelItem(top)

            conn=info.get("connection",None)
            if not conn:
                top.addChild(QTreeWidgetItem(["(No connection)"]))
                continue

            # For Teradata => load distinct DB names
            try:
                c=conn.cursor()
                c.execute("SELECT DISTINCT DatabaseName FROM DBC.TablesV ORDER BY DatabaseName")
                rows=c.fetchall()
                if not rows:
                    top.addChild(QTreeWidgetItem(["(No DB)"]))
                    continue
                for r in rows:
                    dbn=r[0].strip()
                    db_item=QTreeWidgetItem([dbn])
                    db_item.setData(0,Qt.UserRole,("db",alias,dbn))
                    db_item.setData(0,Qt.UserRole+1,False)
                    db_item.addChild(QTreeWidgetItem(["Loading..."]))
                    top.addChild(db_item)
            except Exception as ex:
                top.addChild(QTreeWidgetItem([f"(Error: {ex})"]))
        self.expandAll()

    def mouseDoubleClickEvent(self,e):
        it=self.itemAt(e.pos())
        if it:
            d=it.data(0,Qt.UserRole)
            if d and d[0]=="db":
                loaded=it.data(0,Qt.UserRole+1)
                if not loaded:
                    it.takeChildren()
                    alias,dbn=d[1],d[2]
                    info=self.connections.get(alias)
                    if info and info.get("connection"):
                        c=info["connection"]
                        worker=LazySchemaLoader(c,dbn)
                        def on_finish(tables):
                            self.populate_tables(it,alias,dbn,tables)
                        def on_err(msg):
                            QMessageBox.critical(self,"Schema Error",msg)
                        worker.signals.finished.connect(on_finish)
                        worker.signals.error.connect(on_err)
                        self.threadpool.start(worker)
        super().mouseDoubleClickEvent(e)

    def populate_tables(self, parent_item, alias, dbn, tables):
        if not tables:
            parent_item.addChild(QTreeWidgetItem(["<No Tables>"]))
            parent_item.setData(0,Qt.UserRole+1,True)
            return
        parent_item.takeChildren()
        for t in tables:
            t_item=QTreeWidgetItem([t])
            t_item.setData(0,Qt.UserRole,("table",alias,dbn,t))
            t_item.setData(0,Qt.UserRole+1,False)
            t_item.addChild(QTreeWidgetItem(["Loading..."]))
            parent_item.addChild(t_item)
        parent_item.setData(0,Qt.UserRole+1,True)

    def mousePressEvent(self,e):
        it=self.itemAt(e.pos())
        if it:
            d=it.data(0,Qt.UserRole)
            if d and d[0]=="table":
                loaded=it.data(0,Qt.UserRole+1)
                if not loaded:
                    it.takeChildren()
                    alias,dbn,tbl=d[1],d[2],d[3]
                    info=self.connections.get(alias)
                    if info:
                        c=info["connection"]
                        cols=load_columns_for_table(c,dbn,tbl)
                        if cols:
                            for cc in cols:
                                child=QTreeWidgetItem([cc])
                                child.setData(0,Qt.UserRole,("column",alias,dbn,tbl,cc))
                                it.addChild(child)
                        else:
                            it.addChild(QTreeWidgetItem(["<No columns>"]))
                    it.setData(0,Qt.UserRole+1,True)
        super().mousePressEvent(e)

    def startDrag(self,actions):
        it=self.currentItem()
        if it:
            d=it.data(0,Qt.UserRole)
            if d and d[0]=="table":
                alias,dbn,tbl=d[1],d[2],d[3]
                full_key=f"{alias}.{dbn}.{tbl}"
                drag=QtGui.QDrag(self)
                mime=QtCore.QMimeData()
                mime.setText(full_key)
                drag.setMimeData(mime)
                drag.exec_(actions)

    def filter_items(self,txt):
        def filter_recursive(item,text):
            show=False
            if text.lower() in item.text(0).lower():
                show=True
            for i in range(item.childCount()):
                citem=item.child(i)
                cshown=filter_recursive(citem,text)
                if cshown:
                    show=True
            item.setHidden(not show)
            return show

        for i in range(self.topLevelItemCount()):
            top=self.topLevelItem(i)
            filter_recursive(top,txt)


###############################################################################
# 4) BFS Items: Collapsible BFS, Collapsible Table, JoinLine, MappingLine, etc.
###############################################################################
class MappingLine(QGraphicsLineItem):
    """ Production-level BFS mapping line for DML """
    def __init__(self, source_text_item, target_text_item, parent_canvas,
                 source_type=None, target_type=None):
        super().__init__()
        self.canvas=parent_canvas
        self.source_text_item=source_text_item
        self.target_text_item=target_text_item
        self.source_col=source_text_item.toPlainText()
        self.target_col=target_text_item.toPlainText()
        self.source_type=source_type
        self.target_type=target_type

        self.setPen(QPen(Qt.darkRed,2,Qt.SolidLine))
        self.setZValue(5)
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptHoverEvents(True)
        self.update_pos()

    def update_pos(self):
        s=self.source_text_item.mapToScene(self.source_text_item.boundingRect().center())
        t=self.target_text_item.mapToScene(self.target_text_item.boundingRect().center())
        self.setLine(QtCore.QLineF(s,t))

    def paint(self,painter,option,widget):
        self.update_pos()
        super().paint(painter,option,widget)

    def contextMenuEvent(self,event):
        menu=QMenu()
        rm=menu.addAction("Remove Column Mapping")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            if self in self.canvas.mapping_lines:
                self.canvas.mapping_lines.remove(self)
            sc=self.scene()
            if sc:
                sc.removeItem(self)

class JoinLine(QGraphicsLineItem):
    """ BFS multi-join line => single-col or multi-condition """
    def __init__(self, start_item, end_item, join_type="INNER", condition=""):
        super().__init__()
        self.start_item=start_item
        self.end_item=end_item
        self.join_type=join_type
        self.condition=condition
        self.setZValue(-1)
        self.setAcceptHoverEvents(True)

        self.pen_map={
            "INNER":(Qt.darkBlue,Qt.SolidLine),
            "LEFT":(Qt.darkGreen,Qt.SolidLine),
            "RIGHT":(Qt.magenta,Qt.DotLine),
            "FULL":(Qt.red,Qt.DashLine),
        }
        self.label=QGraphicsTextItem(self.join_type,self)
        self.label.setDefaultTextColor(Qt.blue)
        self.update_line()

    def update_line(self):
        s=self.start_item.scenePos()+QPointF(100,30)
        e=self.end_item.scenePos()+QPointF(100,30)
        self.setLine(QtCore.QLineF(s,e))
        mx=(s.x()+e.x())/2
        my=(s.y()+e.y())/2
        self.label.setPos(mx,my)
        color,style=self.pen_map.get(self.join_type,(Qt.gray,Qt.SolidLine))
        self.setPen(QPen(color,2,style))

    def hoverEnterEvent(self,e):
        p=self.pen()
        p.setColor(Qt.yellow)
        p.setWidth(3)
        self.setPen(p)
        super().hoverEnterEvent(e)

    def hoverLeaveEvent(self,e):
        self.update_line()
        super().hoverLeaveEvent(e)


class ColumnJoinWizardDialog(QDialog):
    """ Single-col join wizard from drag event """
    def __init__(self, source_full, source_type, target_full, target_type, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Column Join Wizard")
        self.resize(400,200)
        self.source_col=source_full
        self.source_type=source_type
        self.target_col=target_full
        self.target_type=target_type
        self.join_type="INNER"
        self.condition=f"{self.source_col} = {self.target_col}"

        main=QVBoxLayout(self)
        info=QLabel(
            f"Source: {self.source_col} (type={self.source_type})\n"
            f"Target: {self.target_col} (type={self.target_type})"
        )
        main.addWidget(info)
        if self.source_type.lower()!=self.target_type.lower():
            warn=QLabel("<b>Warning:</b> Different data types => might need cast.")
            warn.setStyleSheet("color:red;")
            main.addWidget(warn)

        form=QFormLayout()
        self.join_cb=QComboBox()
        self.join_cb.addItems(["INNER","LEFT","RIGHT","FULL"])
        form.addRow("Join Type:",self.join_cb)
        self.cond_edit=QLineEdit(self.condition)
        form.addRow("Condition:",self.cond_edit)
        main.addLayout(form)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        jt=self.join_cb.currentText()
        cond=self.cond_edit.text().strip()
        if not cond:
            QMessageBox.warning(self,"No condition","Please specify a condition.")
            return
        self.join_type=jt
        self.condition=cond
        self.accept()

    def get_join_data(self):
        return (self.join_type,self.condition)


class MultiConditionJoinWizard(QDialog):
    """ Wizard for multiple expressions combined by AND => single BFS join line """
    def __init__(self, all_table_keys, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Multi-Condition Join Wizard")
        self.resize(500,300)
        self.all_table_keys=all_table_keys
        self.join_type="INNER"
        self.conditions=[]

        main=QVBoxLayout(self)
        fm=QFormLayout()
        self.join_cb=QComboBox()
        self.join_cb.addItems(["INNER","LEFT","RIGHT","FULL"])
        fm.addRow("Join Type:",self.join_cb)

        self.list_widget=QListWidget()
        main.addLayout(fm)
        main.addWidget(self.list_widget)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Condition")
        add_btn.clicked.connect(self.add_condition)
        rm_btn=QPushButton("Remove Condition")
        rm_btn.clicked.connect(self.remove_condition)
        bh.addWidget(add_btn)
        bh.addWidget(rm_btn)
        main.addLayout(bh)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def add_condition(self):
        d=QDialog(self)
        d.setWindowTitle("Add Condition (exprA = exprB)")
        d.resize(400,200)
        lay=QVBoxLayout(d)
        form=QFormLayout()
        self.exprA=QLineEdit()
        self.exprB=QLineEdit()
        form.addRow("Left Expression:",self.exprA)
        form.addRow("Right Expression:",self.exprB)
        inst=QLabel(
            "Type a derived or table.col\n(e.g. UPPER(alias.db.tbl.c1) or alias.db.tbl.c2)\n"
            "We'll combine multiple with AND."
        )
        inst.setStyleSheet("color:gray;")
        form.addRow(inst)
        lay.addLayout(form)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        lay.addWidget(dbb)
        def do_ok():
            a=self.exprA.text().strip()
            b=self.exprB.text().strip()
            if not a or not b:
                QMessageBox.warning(d,"No expressions","Need both sides.")
                return
            d.accept()
        dbb.accepted.connect(do_ok)
        dbb.rejected.connect(d.reject)

        if d.exec_()==QDialog.Accepted:
            la=self.exprA.text().strip()
            rb=self.exprB.text().strip()
            self.conditions.append((la,rb))
            self.list_widget.addItem(f"{la} = {rb}")

    def remove_condition(self):
        rows=self.list_widget.selectedIndexes()
        if rows:
            i=rows[0].row()
            self.conditions.pop(i)
            self.list_widget.takeItem(i)

    def on_ok(self):
        if not self.conditions:
            QMessageBox.warning(self,"No conditions","At least one needed.")
            return
        self.join_type=self.join_cb.currentText()
        self.accept()

    def get_join_data(self):
        cond_parts=[]
        for (l,r) in self.conditions:
            cond_parts.append(f"{l} = {r}")
        final_cond=" AND ".join(cond_parts)
        return (self.join_type,final_cond)


class DraggableColumnTextItem(QGraphicsTextItem):
    """ BFS table column => single-col join by drag onto another column """
    def __init__(self, parent_table_item, column_name, column_type):
        super().__init__(column_name, parent_table_item)
        self.parent_table_item=parent_table_item
        self.column_name=column_name
        self.column_type=column_type
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptDrops(True)

    def mousePressEvent(self,event):
        if event.button()==Qt.LeftButton:
            drag=QtGui.QDrag(event.widget())
            mime=QtCore.QMimeData()
            full_col=f"{self.parent_table_item.table_fullname}.{self.column_name}"
            mime.setText(f"{full_col}||{self.column_type}")
            drag.setMimeData(mime)
            drag.exec_(Qt.MoveAction)
        else:
            super().mousePressEvent(event)

    def dragEnterEvent(self,event):
        if event.mimeData().hasText() and "||" in event.mimeData().text():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dragMoveEvent(self,event):
        event.acceptProposedAction()

    def dropEvent(self,event):
        txt=event.mimeData().text()
        if "||" not in txt:
            event.ignore()
            return
        source_full,source_type=txt.split("||",1)
        target_full=f"{self.parent_table_item.table_fullname}.{self.column_name}"
        target_type=self.column_type
        if source_full==target_full:
            QMessageBox.information(None,"Same Column","Cannot join a column onto itself.")
            event.ignore()
            return
        if source_full.startswith(self.parent_table_item.table_fullname+"."):
            QMessageBox.information(None,"Same BFS Table","Join across different BFS items only.")
            event.ignore()
            return

        dlg=ColumnJoinWizardDialog(source_full,source_type,target_full,target_type)
        if dlg.exec_()==QDialog.Accepted:
            jtype,cond=dlg.get_join_data()
            builder=self.parent_table_item.parent_builder
            cv=builder.canvas
            sf_tab=".".join(source_full.split(".")[:2])
            tf_tab=".".join(target_full.split(".")[:2])

            source_item=cv.table_items.get(sf_tab,None)
            target_item=cv.table_items.get(tf_tab,None)
            if not source_item or not target_item:
                QMessageBox.warning(None,"Join Error","Could not find BFS items for source/target.")
                event.ignore()
                return
            jl=JoinLine(source_item,target_item,jtype,cond)
            cv.scene_.addItem(jl)
            cv.join_lines.append(jl)
            jl.update_line()
            QMessageBox.information(None,"Join Created",f"{jtype} JOIN line:\n{cond}")
            event.acceptProposedAction()
        else:
            event.ignore()


class CollapsibleTableGraphicsItem(QGraphicsRectItem):
    """ BFS table item => collapsible columns => multi-condition wizard on right-click """
    def __init__(self, table_fullname, columns, parent_builder, x=0, y=0):
        super().__init__(0,0,220,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(220,220,255)))
        self.setPen(QPen(Qt.darkGray,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.table_fullname=table_fullname
        self.columns=columns
        self.parent_builder=parent_builder
        self.is_collapsed=True
        self.title_height=20
        self.column_items=[]

        self.close_btn=QGraphicsTextItem("[X]",self)
        self.close_btn.setPos(190,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn=QGraphicsTextItem("[+]",self)
        self.toggle_btn.setPos(170,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f=QFont("Arial",9,QFont.Bold)
        self.title_text=QGraphicsTextItem(table_fullname,self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        self.mock_column_types={}
        for c in columns:
            if c.lower().startswith("id") or c.lower().endswith("id"):
                self.mock_column_types[c]="INT"
            else:
                self.mock_column_types[c]="VARCHAR"

        yOff=self.title_height
        for c in columns:
            cRect=QGraphicsRectItem(5,yOff+4,10,10,self)
            cRect.setBrush(QBrush(Qt.white))
            cRect.setPen(QPen(Qt.black,1))
            cText=DraggableColumnTextItem(self,c,self.mock_column_types[c])
            cText.setPos(20,yOff)
            self.column_items.append([cRect,cText,False])
            yOff+=20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,220,self.title_height)
            for (r,t,_) in self.column_items:
                r.setVisible(False)
                t.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded=self.title_height+len(self.column_items)*20
            self.setRect(0,0,220,expanded)
            for (r,t,_) in self.column_items:
                r.setVisible(True)
                t.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

    def mousePressEvent(self,event):
        pos=event.pos()
        close_rect=self.close_btn.mapToParent(self.close_btn.boundingRect())
        if close_rect.boundingRect().contains(pos):
            sc=self.scene()
            if sc:
                self.parent_builder.handle_remove_table(self)
            event.accept()
            return
        toggle_rect=self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if toggle_rect.boundingRect().contains(pos):
            self.is_collapsed=not self.is_collapsed
            self.update_layout()
            event.accept()
            return

        for i,(r,t,chk) in enumerate(self.column_items):
            rRect=r.mapToParent(r.boundingRect()).boundingRect()
            if rRect.contains(pos):
                self.column_items[i][2]=not chk
                r.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def contextMenuEvent(self,event):
        menu=QMenu()
        rm=menu.addAction("Remove Table/CTE")
        mc=menu.addAction("Add Multi-Condition Join")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            sc=self.scene()
            if sc:
                self.parent_builder.handle_remove_table(self)
        elif chosen==mc:
            # pick any other BFS item to create a line
            allkeys=list(self.parent_builder.canvas.table_items.keys())
            wiz=MultiConditionJoinWizard(allkeys)
            if wiz.exec_()==QDialog.Accepted:
                jtype,cond=wiz.get_join_data()
                me=self
                # find some other BFS item => in real usage you'd pick from a list
                other_item=None
                for k,v in self.parent_builder.canvas.table_items.items():
                    if v!=me:
                        other_item=v
                        break
                if not other_item:
                    QMessageBox.warning(None,"No other BFS item","At least 2 BFS items needed.")
                    return
                jl=JoinLine(me,other_item,jtype,cond)
                self.parent_builder.canvas.scene_.addItem(jl)
                self.parent_builder.canvas.join_lines.append(jl)
                jl.update_line()
                QMessageBox.information(None,"Multi-Join Created",f"{jtype} JOIN => {cond}")

    def get_selected_columns(self):
        out=[]
        for (r,t,chk) in self.column_items:
            if chk:
                col=t.toPlainText().strip()
                out.append(f"{self.table_fullname}.{col}")
        return out

class CollapsibleBFSGraphicsItem(QGraphicsRectItem):
    """ BFS source item for DML => 'production-level' column mapping """
    def __init__(self,title,columns,parent_builder,x=100,y=100):
        super().__init__(0,0,240,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(250,250,180)))
        self.setPen(QPen(Qt.red,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.item_title=title
        self.columns=columns
        self.parent_builder=parent_builder
        self.is_collapsed=False
        self.title_height=20
        self.column_items=[]

        self.close_btn=QGraphicsTextItem("[X]",self)
        self.close_btn.setPos(215,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn=QGraphicsTextItem("[-]",self)
        self.toggle_btn.setPos(195,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f=QFont("Arial",9,QFont.Bold)
        self.title_text=QGraphicsTextItem(title,self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        yOff=self.title_height
        for c in columns:
            r=QGraphicsRectItem(5,yOff+4,10,10,self)
            r.setBrush(QBrush(Qt.blue))
            r.setPen(QPen(Qt.black,1))
            t=QGraphicsTextItem(c,self)
            t.setPos(20,yOff)
            self.column_items.append([r,t,True])
            yOff+=20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,240,self.title_height)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(False)
                ct.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded=self.title_height+len(self.column_items)*20
            self.setRect(0,0,240,expanded)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(True)
                ct.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

    def mousePressEvent(self,event):
        pos=event.pos()
        cbr=self.close_btn.mapToParent(self.close_btn.boundingRect())
        if cbr.boundingRect().contains(pos):
            sc=self.scene()
            if sc:
                sc.removeItem(self)
            event.accept()
            return
        tbr=self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if tbr.boundingRect().contains(pos):
            self.is_collapsed=not self.is_collapsed
            self.update_layout()
            event.accept()
            return

        for i,(cb,ct,chk) in enumerate(self.column_items):
            rr=cb.mapToParent(cb.boundingRect()).boundingRect()
            if rr.contains(pos):
                self.column_items[i][2]=not chk
                cb.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder and self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def get_checked_columns(self):
        arr=[]
        for (cb,ct,chk) in self.column_items:
            if chk:
                arr.append(ct.toPlainText().strip())
        return arr

###############################################################################
# 5) BFS canvas => no pan/zoom
###############################################################################
class EnhancedCanvasGraphicsView(QGraphicsView):
    def __init__(self,builder,parent=None):
        super().__init__(parent)
        self.builder=builder
        self.setAcceptDrops(True)
        self.scene_=QGraphicsScene(self)
        self.setScene(self.scene_)

        self.table_items={}
        self.join_lines=[]
        self.mapping_lines=[]
        self.operation_red_line=None
        self.collapsible_bfs_item=None
        self.target_table_item=None

        self.validation_timer=QTimer()
        self.validation_timer.setInterval(400)
        self.validation_timer.setSingleShot(True)
        self.validation_timer.timeout.connect(self.builder.validate_sql)

    def dragEnterEvent(self,e):
        if e.mimeData().hasText():
            e.acceptProposedAction()

    def dragMoveEvent(self,e):
        e.acceptProposedAction()

    def dropEvent(self,e):
        txt=e.mimeData().text()
        pos=self.mapToScene(e.pos())
        self.builder.handle_drop(txt,pos)
        e.acceptProposedAction()

    def add_table_item(self,table_key,columns,x,y):
        it=CollapsibleTableGraphicsItem(table_key,columns,self.builder,x,y)
        self.scene_.addItem(it)
        self.table_items[table_key]=it
        if self.builder.auto_generate:
            self.builder.generate_sql()
        self.validation_timer.start()

    def add_bfs_item(self,title,columns,x,y):
        bfs=CollapsibleBFSGraphicsItem(title,columns,self.builder,x,y)
        self.scene_.addItem(bfs)
        self.collapsible_bfs_item=bfs

    def add_target_item(self,title,columns,x,y):
        full="Target:"+title
        t=CollapsibleTableGraphicsItem(full,columns,self.builder,x,y)
        self.scene_.addItem(t)
        self.target_table_item=t

    def remove_table_item(self,table_key):
        if table_key in self.table_items:
            itm=self.table_items[table_key]
            lines_rm=[]
            for jl in self.join_lines:
                if jl.start_item==itm or jl.end_item==itm:
                    lines_rm.append(jl)
            for ln in lines_rm:
                self.scene_.removeItem(ln)
                self.join_lines.remove(ln)
            self.scene_.removeItem(itm)
            del self.table_items[table_key]
            self.validation_timer.start()

    def remove_mapping_lines(self):
        for ml in self.mapping_lines:
            self.scene_.removeItem(ml)
        self.mapping_lines.clear()

    def add_vertical_red_line(self,x=450):
        if self.operation_red_line:
            self.scene_.removeItem(self.operation_red_line)
            self.operation_red_line=None
        ln=QGraphicsLineItem(x,0,x,3000)
        ln.setPen(QPen(Qt.red,2,Qt.DashDotLine))
        ln.setZValue(-10)
        self.scene_.addItem(ln)
        self.operation_red_line=ln

    def create_mapping_line(self,source_text_item,target_text_item,src_type=None,tgt_type=None):
        ml=MappingLine(source_text_item,target_text_item,self,src_type,tgt_type)
        self.scene_.addItem(ml)
        self.mapping_lines.append(ml)
        if self.builder.auto_generate:
            self.builder.generate_sql()
        self.validation_timer.start()

    def add_subquery_item(self,x,y):
        sq=NestedSubqueryItem(self.builder,x,y)
        self.scene_.addItem(sq)
        key=f"SubQueryItem_{id(sq)}"
        self.table_items[key]=sq
        self.validation_timer.start()

    def mouseReleaseEvent(self,event):
        super().mouseReleaseEvent(event)
        for jl in self.join_lines:
            jl.update_line()
        for ml in self.mapping_lines:
            ml.update_pos()

###############################################################################
# 6) Filter, Group, Sort, Expression Builder, Window Function, SubVQB
###############################################################################
# (Identical or similar to previous references. We compile them in.)

# We'll do minimal code for Filter/Group/Sort to keep this single-file as requested:

class AddFilterDialog(QDialog):
    def __init__(self,available_columns,parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Filter")
        self.selected_col=None
        self.selected_op=None
        self.selected_val=None

        fl=QFormLayout(self)
        self.col_combo=QComboBox()
        self.col_combo.addItems(available_columns)
        fl.addRow("Column:",self.col_combo)
        self.op_combo=QComboBox()
        self.op_combo.addItems(["=","<>","<",">","<=",">=","IS NULL","IS NOT NULL"])
        fl.addRow("Operator:",self.op_combo)
        self.val_edit=QLineEdit("'ABC'")
        fl.addRow("Value:",self.val_edit)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(fl)

    def on_ok(self):
        c=self.col_combo.currentText()
        if not c:
            QMessageBox.warning(self,"No Column","Pick a column.")
            return
        self.selected_col=c
        self.selected_op=self.op_combo.currentText()
        self.selected_val=self.val_edit.text().strip()
        self.accept()

    def get_filter(self):
        return (self.selected_col,self.selected_op,self.selected_val)

class FilterPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Filters",parent)
        self.builder=builder
        main=QVBoxLayout(self)
        self.setLayout(main)
        self.tabs=QTabWidget()
        main.addWidget(self.tabs)

        self.where_tab=QWidget()
        self.having_tab=QWidget()
        self.tabs.addTab(self.where_tab,"WHERE")
        self.tabs.addTab(self.having_tab,"HAVING")

        self.where_layout=QVBoxLayout(self.where_tab)
        self.where_table=QTableWidget(0,3)
        self.where_table.setHorizontalHeaderLabels(["Column","Operator","Value"])
        self.where_table.horizontalHeader().setStretchLastSection(True)
        self.where_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.where_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.where_layout.addWidget(self.where_table)

        wh_h=QHBoxLayout()
        add_w=QPushButton("Add WHERE")
        add_w.clicked.connect(lambda:self.add_filter("WHERE"))
        rm_w=QPushButton("Remove WHERE")
        rm_w.clicked.connect(lambda:self.remove_filter("WHERE"))
        wh_h.addWidget(add_w)
        wh_h.addWidget(rm_w)
        self.where_layout.addLayout(wh_h)

        self.having_layout=QVBoxLayout(self.having_tab)
        self.having_table=QTableWidget(0,3)
        self.having_table.setHorizontalHeaderLabels(["Column","Operator","Value"])
        self.having_table.horizontalHeader().setStretchLastSection(True)
        self.having_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.having_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.having_layout.addWidget(self.having_table)

        hv_h=QHBoxLayout()
        add_h=QPushButton("Add HAVING")
        add_h.clicked.connect(lambda:self.add_filter("HAVING"))
        rm_h=QPushButton("Remove HAVING")
        rm_h.clicked.connect(lambda:self.remove_filter("HAVING"))
        hv_h.addWidget(add_h)
        hv_h.addWidget(rm_h)
        self.having_layout.addLayout(hv_h)

    def add_filter(self,clause):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No Columns","No columns available.")
            return
        dlg=AddFilterDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            c,o,v=dlg.get_filter()
            tb=self.where_table if clause=="WHERE" else self.having_table
            r=tb.rowCount()
            tb.insertRow(r)
            tb.setItem(r,0,QTableWidgetItem(c))
            tb.setItem(r,1,QTableWidgetItem(o))
            tb.setItem(r,2,QTableWidgetItem(v))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_filter(self,clause):
        tb=self.where_table if clause=="WHERE" else self.having_table
        rows=sorted([x.row() for x in tb.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            tb.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def get_filters(self,clause):
        tb=self.where_table if clause=="WHERE" else self.having_table
        out=[]
        for r in range(tb.rowCount()):
            col=tb.item(r,0).text()
            op=tb.item(r,1).text()
            val=tb.item(r,2).text()
            out.append((col,op,val))
        return out


class PivotDialog(QDialog):
    def __init__(self,available_cols,parent=None):
        super().__init__(parent)
        self.setWindowTitle("Pivot Wizard (Demo)")
        self.category_col=None
        self.value_col=None
        self.distinct_vals=[]
        main=QVBoxLayout(self)

        f=QFormLayout()
        self.cat_combo=QComboBox()
        self.cat_combo.addItems(available_cols)
        f.addRow("Category Column:",self.cat_combo)
        self.val_combo=QComboBox()
        self.val_combo.addItems(available_cols)
        f.addRow("Value Column:",self.val_combo)
        main.addLayout(f)

        self.val_list=QListWidget()
        self.val_list.setSelectionMode(QAbstractItemView.MultiSelection)
        main.addWidget(QLabel("Pick categories (demo)"))
        main.addWidget(self.val_list)

        load_btn=QPushButton("Load Distinct (Demo only)")
        load_btn.clicked.connect(self.on_load_demo)
        main.addWidget(load_btn)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_load_demo(self):
        self.val_list.clear()
        for v in ["Manager","Clerk","Sales","IT","HR"]:
            self.val_list.addItem(v)

    def on_ok(self):
        c=self.cat_combo.currentText()
        v=self.val_combo.currentText()
        if not c or not v:
            QMessageBox.warning(self,"PivotWizard","Must pick cat & value.")
            return
        self.category_col=c
        self.value_col=v
        self.distinct_vals=[it.text() for it in self.val_list.selectedItems()]
        self.accept()

    def build_expressions(self):
        arr=[]
        for dv in self.distinct_vals:
            alias=dv.lower().replace(" ","_")+"_val"
            expr=f"SUM(CASE WHEN {self.category_col}='{dv}' THEN {self.value_col} END) AS {alias}"
            arr.append(expr)
        return arr

class GroupByPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Group By & Aggregates (+Pivot)",parent)
        self.builder=builder
        main=QVBoxLayout(self)
        self.setLayout(main)

        self.gb_table=QTableWidget(0,1)
        self.gb_table.setHorizontalHeaderLabels(["GroupBy Column"])
        self.gb_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.gb_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main.addWidget(self.gb_table)

        gb_h=QHBoxLayout()
        add_g=QPushButton("Add GroupBy")
        add_g.clicked.connect(self.add_group_by)
        rm_g=QPushButton("Remove GroupBy")
        rm_g.clicked.connect(self.remove_group_by)
        gb_h.addWidget(add_g)
        gb_h.addWidget(rm_g)
        main.addLayout(gb_h)

        self.agg_table=QTableWidget(0,3)
        self.agg_table.setHorizontalHeaderLabels(["Function","Column","Alias"])
        self.agg_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.agg_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main.addWidget(self.agg_table)

        agg_h=QHBoxLayout()
        add_agg=QPushButton("Add Agg")
        add_agg.clicked.connect(self.add_agg)
        rm_agg=QPushButton("Remove Agg")
        rm_agg.clicked.connect(self.remove_agg)
        agg_h.addWidget(add_agg)
        agg_h.addWidget(rm_agg)
        main.addLayout(agg_h)

        pivot_btn=QPushButton("Pivot Wizard")
        pivot_btn.clicked.connect(self.launch_pivot)
        main.addWidget(pivot_btn)

    def add_group_by(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No Columns","No columns available.")
            return
        (c,ok)=QtWidgets.QInputDialog.getItem(self,"Add GroupBy","Pick column:",cols,0,False)
        if ok and c:
            r=self.gb_table.rowCount()
            self.gb_table.insertRow(r)
            self.gb_table.setItem(r,0,QTableWidgetItem(c))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_group_by(self):
        rows=sorted([x.row() for x in self.gb_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            self.gb_table.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def add_agg(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        d=QDialog(self.builder)
        d.setWindowTitle("Add Aggregate")
        fl=QFormLayout(d)
        func_cb=QComboBox()
        func_cb.addItems(["COUNT","SUM","AVG","MIN","MAX","CUSTOM"])
        col_cb=QComboBox()
        col_cb.addItems(cols)
        alias_ed=QLineEdit("AggVal")
        fl.addRow("Function:",func_cb)
        fl.addRow("Column:",col_cb)
        fl.addRow("Alias:",alias_ed)
        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(dbb)
        def on_ok():
            if not col_cb.currentText() and func_cb.currentText()!="CUSTOM":
                QMessageBox.warning(d,"Error","Pick a column or use CUSTOM.")
                return
            d.accept()
        dbb.accepted.connect(on_ok)
        dbb.rejected.connect(d.reject)
        d.setLayout(fl)
        if d.exec_()==QDialog.Accepted:
            f=func_cb.currentText()
            c=col_cb.currentText()
            a=alias_ed.text().strip()
            r=self.agg_table.rowCount()
            self.agg_table.insertRow(r)
            self.agg_table.setItem(r,0,QTableWidgetItem(f))
            self.agg_table.setItem(r,1,QTableWidgetItem(c))
            self.agg_table.setItem(r,2,QTableWidgetItem(a))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_agg(self):
        rows=sorted([x.row() for x in self.agg_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            self.agg_table.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def launch_pivot(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        dlg=PivotDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            exs=dlg.build_expressions()
            for ex in exs:
                r=self.agg_table.rowCount()
                self.agg_table.insertRow(r)
                self.agg_table.setItem(r,0,QTableWidgetItem("CUSTOM"))
                self.agg_table.setItem(r,1,QTableWidgetItem(ex))
                self.agg_table.setItem(r,2,QTableWidgetItem("PivotVal"))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def get_group_by(self):
        out=[]
        for r in range(self.gb_table.rowCount()):
            it=self.gb_table.item(r,0)
            out.append(it.text())
        return out

    def get_aggregates(self):
        out=[]
        for r in range(self.agg_table.rowCount()):
            f=self.agg_table.item(r,0).text()
            c=self.agg_table.item(r,1).text()
            a=self.agg_table.item(r,2).text()
            out.append((f,c,a))
        return out


class SortLimitPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Sort & Limit",parent)
        self.builder=builder
        main=QVBoxLayout(self)
        self.setLayout(main)

        self.sort_table=QTableWidget(0,2)
        self.sort_table.setHorizontalHeaderLabels(["Column","Direction"])
        self.sort_table.horizontalHeader().setStretchLastSection(True)
        self.sort_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.sort_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main.addWidget(self.sort_table)

        bh=QHBoxLayout()
        add_s=QPushButton("Add Sort")
        add_s.clicked.connect(self.add_sort_dialog)
        rm_s=QPushButton("Remove Sort")
        rm_s.clicked.connect(self.remove_sort)
        bh.addWidget(add_s)
        bh.addWidget(rm_s)
        main.addLayout(bh)

        lo=QHBoxLayout()
        self.limit_spin=QSpinBox()
        self.limit_spin.setRange(0,9999999)
        self.limit_spin.setValue(0)
        self.limit_spin.setSuffix(" (Limit)")
        self.limit_spin.setSpecialValueText("No Limit")
        self.limit_spin.valueChanged.connect(self._maybe_regen)
        lo.addWidget(self.limit_spin)

        self.offset_spin=QSpinBox()
        self.offset_spin.setRange(0,9999999)
        self.offset_spin.setValue(0)
        self.offset_spin.setSuffix(" (Offset)")
        self.offset_spin.setSpecialValueText("No Offset")
        self.offset_spin.valueChanged.connect(self._maybe_regen)
        lo.addWidget(self.offset_spin)
        main.addLayout(lo)

    def _maybe_regen(self):
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def add_sort_dialog(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        d=QDialog(self)
        d.setWindowTitle("Add Sort")
        fl=QFormLayout(d)
        col_cb=QComboBox()
        col_cb.addItems(cols)
        dir_cb=QComboBox()
        dir_cb.addItems(["ASC","DESC"])
        fl.addRow("Column:",col_cb)
        fl.addRow("Direction:",dir_cb)
        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(dbb)
        def do_ok():
            if not col_cb.currentText():
                QMessageBox.warning(d,"No col","Pick a column.")
                return
            d.accept()
        dbb.accepted.connect(do_ok)
        dbb.rejected.connect(d.reject)
        d.setLayout(fl)
        if d.exec_()==QDialog.Accepted:
            c=col_cb.currentText()
            dd=dir_cb.currentText()
            row=self.sort_table.rowCount()
            self.sort_table.insertRow(row)
            self.sort_table.setItem(row,0,QTableWidgetItem(c))
            self.sort_table.setItem(row,1,QTableWidgetItem(dd))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_sort(self):
        rows=sorted([x.row() for x in self.sort_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            self.sort_table.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def get_order_bys(self):
        out=[]
        for r in range(self.sort_table.rowCount()):
            col=self.sort_table.item(r,0).text()
            dr=self.sort_table.item(r,1).text()
            out.append(f"{col} {dr}")
        return out

    def get_limit(self):
        v=self.limit_spin.value()
        return v if v>0 else None

    def get_offset(self):
        v=self.offset_spin.value()
        return v if v>0 else None

class FullSQLParser:
    def __init__(self,sql):
        self.sql=sql
    def parse(self):
        st=sqlparse.parse(self.sql)
        if not st:
            raise ValueError("No valid SQL found.")

class SQLHighlighter(QSyntaxHighlighter):
    def __init__(self,doc):
        super().__init__(doc)
        self.rules=[]
        kwfmt=QTextCharFormat()
        kwfmt.setForeground(Qt.darkBlue)
        kwfmt.setFontWeight(QFont.Bold)
        keywords=[
            "SELECT","FROM","WHERE","JOIN","INNER","LEFT","RIGHT","FULL","OUTER",
            "GROUP","BY","HAVING","ORDER","LIMIT","OFFSET","UNION","ALL","INTERSECT",
            "EXCEPT","AS","ON","AND","OR","NOT","IN","IS","NULL","EXISTS","COUNT",
            "SUM","AVG","MIN","MAX","INSERT","UPDATE","DELETE","VALUES","OVER",
            "PARTITION","ROWS","RANGE","CURRENT ROW","ROW_NUMBER","RANK","DENSE_RANK",
            "NTILE","LAG","LEAD","CASE","COALESCE","TRIM","FIRST_VALUE","LAST_VALUE",
            "WITH"
        ]
        for w in keywords:
            pattern=QRegularExpression(r'\b'+w+r'\b',QRegularExpression.CaseInsensitiveOption)
            self.rules.append((pattern,kwfmt))

        strfmt=QTextCharFormat()
        strfmt.setForeground(Qt.darkRed)
        self.rules.append((QRegularExpression(r"'[^']*'"),strfmt))
        self.rules.append((QRegularExpression(r'"[^"]*"'),strfmt))

        cfmt=QTextCharFormat()
        cfmt.setForeground(Qt.green)
        self.rules.append((QRegularExpression(r'--[^\n]*'),cfmt))
        self.rules.append((QRegularExpression(r'/\*.*\*/',QRegularExpression.DotMatchesEverythingOption),cfmt))

    def highlightBlock(self,text):
        for pat,fmt in self.rules:
            matches=pat.globalMatch(text)
            while matches.hasNext():
                m=matches.next()
                st=m.capturedStart()
                ln=m.capturedLength()
                self.setFormat(st,ln,fmt)
        self.setCurrentBlockState(0)

class AdvancedWindowFunctionDialog(QDialog):
    def __init__(self,available_columns,parent=None):
        super().__init__(parent)
        self.setWindowTitle("Advanced Window Function Wizard")
        self.resize(500,500)
        self.available_columns=available_columns
        self.function=""
        self.main_col=""
        self.partition_cols=[]
        self.order_cols=[]
        self.frame_clause=""
        self.offset=1
        self.default_val="0"
        self.buckets=4
        self.alias="winfun"

        main=QVBoxLayout(self)
        form=QFormLayout()

        self.func_cb=QComboBox()
        self.func_cb.addItems([
            "ROW_NUMBER","RANK","DENSE_RANK","NTILE","LAG","LEAD",
            "FIRST_VALUE","LAST_VALUE","SUM","AVG","MIN","MAX"
        ])
        form.addRow("Function:",self.func_cb)

        self.col_cb=QComboBox()
        self.col_cb.addItems(["(No specific col)"]+self.available_columns)
        form.addRow("Main Column:",self.col_cb)

        self.ntile_sb=QSpinBox()
        self.ntile_sb.setRange(2,999)
        self.ntile_sb.setValue(4)
        form.addRow("NTILE Buckets:",self.ntile_sb)

        self.offset_sb=QSpinBox()
        self.offset_sb.setRange(1,999)
        self.offset_sb.setValue(1)
        form.addRow("LAG/LEAD Offset:",self.offset_sb)

        self.default_ed=QLineEdit("0")
        form.addRow("LAG/LEAD Default:",self.default_ed)

        self.alias_ed=QLineEdit("winfun")
        form.addRow("Alias:",self.alias_ed)
        main.addLayout(form)

        main.addWidget(QLabel("Partition By (multi-select):"))
        self.part_list=QListWidget()
        self.part_list.setSelectionMode(QAbstractItemView.MultiSelection)
        self.part_list.addItems(self.available_columns)
        main.addWidget(self.part_list)

        main.addWidget(QLabel("Order By (multi-select):"))
        self.order_list=QListWidget()
        self.order_list.setSelectionMode(QAbstractItemView.MultiSelection)
        self.order_list.addItems(self.available_columns)
        main.addWidget(self.order_list)

        self.frame_ed=QLineEdit("ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW")
        main.addWidget(QLabel("Frame Clause (optional):"))
        main.addWidget(self.frame_ed)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        fn=self.func_cb.currentText()
        mc=self.col_cb.currentText()
        parts=[it.text() for it in self.part_list.selectedItems()]
        orders=[it.text() for it in self.order_list.selectedItems()]
        fr=self.frame_ed.text().strip()
        a=self.alias_ed.text().strip()
        offs=self.offset_sb.value()
        df=self.default_ed.text().strip()
        ntil=self.ntile_sb.value()
        if not a:
            QMessageBox.warning(self,"No alias","Alias needed.")
            return
        self.function=fn
        if mc!="(No specific col)":
            self.main_col=mc
        self.partition_cols=parts
        self.order_cols=orders
        self.frame_clause=fr
        self.alias=a
        self.offset=offs
        self.default_val=df
        self.buckets=ntil
        self.accept()

    def get_expression(self):
        parts=[]
        if self.partition_cols:
            parts.append("PARTITION BY "+", ".join(self.partition_cols))
        if self.order_cols:
            parts.append("ORDER BY "+", ".join(self.order_cols))
        if self.frame_clause:
            parts.append(self.frame_clause)
        inside="()"
        if parts:
            inside="("+ " ".join(parts) +")"

        fn=self.function.upper()
        col=self.main_col if self.main_col else "0"
        if fn in ["ROW_NUMBER","RANK","DENSE_RANK"]:
            return f"{fn}() OVER {inside} AS {self.alias}"
        elif fn=="NTILE":
            return f"NTILE({self.buckets}) OVER {inside} AS {self.alias}"
        elif fn in ["LAG","LEAD"]:
            return f"{fn}({col}, {self.offset}, {self.default_val}) OVER {inside} AS {self.alias}"
        elif fn in ["FIRST_VALUE","LAST_VALUE","SUM","AVG","MIN","MAX"]:
            return f"{fn}({col}) OVER {inside} AS {self.alias}"
        else:
            return f"ROW_NUMBER() OVER {inside} AS {self.alias}"

class AdvancedExpressionBuilderDialog(QDialog):
    def __init__(self,available_columns,parent=None):
        super().__init__(parent)
        self.setWindowTitle("Advanced Expression Builder")
        self.available_columns=available_columns or []
        self.expression_tokens=[]
        self.alias="ExprAlias"

        main=QVBoxLayout(self)
        f=QFormLayout()
        self.preview_edit=QLineEdit()
        self.preview_edit.setReadOnly(True)
        f.addRow("Expression Preview:",self.preview_edit)
        main.addLayout(f)

        tk_h=QHBoxLayout()

        self.col_combo=QComboBox()
        self.col_combo.addItems(["(Pick Col)"]+self.available_columns)
        col_btn=QPushButton("Col >>")
        col_btn.clicked.connect(self.add_col_token)
        tk_h.addWidget(self.col_combo)
        tk_h.addWidget(col_btn)

        self.op_combo=QComboBox()
        self.op_combo.addItems(["+","-","*","/","=","<",">","<=",">=","<>","AND","OR","LIKE"])
        op_btn=QPushButton("Op >>")
        op_btn.clicked.connect(self.add_op_token)
        tk_h.addWidget(self.op_combo)
        tk_h.addWidget(op_btn)

        self.func_combo=QComboBox()
        self.func_combo.addItems(["UPPER","LOWER","ABS","COALESCE","SUBSTR","TRIM","CASE("])
        func_btn=QPushButton("Func >>")
        func_btn.clicked.connect(self.add_func_token)
        tk_h.addWidget(self.func_combo)
        tk_h.addWidget(func_btn)

        paren_l=QPushButton("(")
        paren_l.clicked.connect(lambda:self.add_token("("))
        paren_r=QPushButton(")")
        paren_r.clicked.connect(lambda:self.add_token(")"))
        tk_h.addWidget(paren_l)
        tk_h.addWidget(paren_r)

        subq_btn=QPushButton("SubQuery")
        subq_btn.clicked.connect(self.add_subquery_token)
        tk_h.addWidget(subq_btn)

        undo_btn=QPushButton("Undo")
        undo_btn.clicked.connect(self.remove_last_token)
        tk_h.addWidget(undo_btn)

        main.addLayout(tk_h)

        af=QFormLayout()
        self.alias_edit=QLineEdit("ExprAlias")
        af.addRow("Alias:",self.alias_edit)
        main.addLayout(af)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def add_col_token(self):
        c=self.col_combo.currentText()
        if c and c!="(Pick Col)":
            self.add_token(c)

    def add_op_token(self):
        op=self.op_combo.currentText()
        self.add_token(op)

    def add_func_token(self):
        fn=self.func_combo.currentText()
        if fn:
            self.add_token(fn)

    def add_subquery_token(self):
        # minimal sub-VQB
        d=SubVQBDialogNone()
        if d.exec_()==QDialog.Accepted:
            op, second_sql=d.getResult()
            if second_sql:
                self.add_token(f"({second_sql})")

    def add_token(self,tk):
        self.expression_tokens.append(tk)
        self.preview_edit.setText(" ".join(self.expression_tokens))

    def remove_last_token(self):
        if self.expression_tokens:
            self.expression_tokens.pop()
        self.preview_edit.setText(" ".join(self.expression_tokens))

    def on_ok(self):
        if not self.expression_tokens:
            QMessageBox.warning(self,"No Expression","No tokens in expression.")
            return
        a=self.alias_edit.text().strip()
        if not a:
            QMessageBox.warning(self,"No Alias","Alias is required.")
            return
        self.alias=a
        self.accept()

    def get_expression_data(self):
        expr=" ".join(self.expression_tokens)
        return (self.alias,expr)

class SubVQBDialogNone(QDialog):
    """
    Minimal sub-VQB => user just types SQL
    """
    def __init__(self,parent=None):
        super().__init__(parent)
        self.setWindowTitle("SubQuery Editor")
        self.resize(600,400)
        self.operator="UNION"
        self.second_sql=""
        main=QVBoxLayout(self)

        op_h=QHBoxLayout()
        op_h.addWidget(QLabel("Combine Operator:"))
        self.op_combo=QComboBox()
        self.op_combo.addItems(["UNION","UNION ALL","INTERSECT","EXCEPT"])
        op_h.addWidget(self.op_combo)
        op_h.addStretch()
        main.addLayout(op_h)

        self.txt=QTextEdit()
        main.addWidget(self.txt)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        op=self.op_combo.currentText()
        sql=self.txt.toPlainText().strip()
        if not sql:
            QMessageBox.warning(self,"No query","No sub query typed.")
            return
        self.operator=op
        self.second_sql=sql
        self.accept()

    def getResult(self):
        return (self.operator, self.second_sql)

###############################################################################
# 7) Nested subquery item
###############################################################################
class NestedVQBDialog(QDialog):
    """
    BFS sub-VQB => user picks a connection (outside) => we skip for brevity
    We'll just store typed SQL or minimal BFS
    """
    def __init__(self, existing_sql="", parent_builder=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Nested Sub-VQB")
        self.resize(900,600)
        self.existing_sql=existing_sql
        self.parent_builder=parent_builder
        self.result_sql=""

        main=QVBoxLayout(self)
        # minimal approach => text edit
        self.txt=QTextEdit()
        self.txt.setPlainText(existing_sql)
        main.addWidget(self.txt)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        raw=self.txt.toPlainText().strip()
        if not raw:
            QMessageBox.warning(self,"No SubQuery","SubQuery is empty.")
            return
        self.result_sql=raw
        self.accept()

    def get_subquery_sql(self):
        return self.result_sql

class NestedSubqueryItem(QGraphicsRectItem):
    def __init__(self,parent_builder=None,x=0,y=0):
        super().__init__(0,0,220,80)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(200,255,200)))
        self.setPen(QPen(Qt.darkGreen,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.parent_builder=parent_builder
        self.subquery_sql="-- SubQuery"
        self.label=QGraphicsTextItem("Nested SubQuery\n(double-click)",self)
        self.label.setPos(5,5)
        f=QFont("Arial",9,QFont.Bold)
        self.label.setFont(f)

    def mouseDoubleClickEvent(self,event):
        dlg=NestedVQBDialog(self.subquery_sql,self.parent_builder)
        if dlg.exec_()==QDialog.Accepted:
            new_sql=dlg.get_subquery_sql()
            if new_sql:
                self.subquery_sql=new_sql
                self.label.setPlainText("Nested SubQuery\n(Has SQL)")
        event.accept()

    def contextMenuEvent(self,event):
        menu=QMenu()
        rm=menu.addAction("Remove SubQuery")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            sc=self.scene()
            if sc:
                sc.removeItem(self)

    def get_subquery_sql(self):
        return self.subquery_sql

###############################################################################
# 8) CTE panel => pick a connection => BFS sub VQB => "virtual table"
###############################################################################
class CTEDialogMultiConn(QDialog):
    """ The multi-conn version => user already picks connection outside """
    def __init__(self, parent_builder, conn_alias, existing_name="", existing_sql="", parent=None):
        super().__init__(parent)
        self.setWindowTitle("Define CTE (MultiConn)")
        self.resize(900,600)
        self.builder_ref=parent_builder
        self.cte_name=existing_name
        self.cte_conn_alias=conn_alias
        self.cte_sql=existing_sql
        self.sub_vqb=None

        main=QVBoxLayout(self)
        fm=QFormLayout()
        self.name_edit=QLineEdit(self.cte_name)
        fm.addRow("CTE Name:",self.name_edit)
        fm.addRow("Connection Alias:", QLabel(conn_alias))
        main.addLayout(fm)

        self.sub_vqb=QTextEdit()
        if self.cte_sql.strip():
            self.sub_vqb.setPlainText(self.cte_sql)
        main.addWidget(self.sub_vqb)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"No name","CTE name cannot be empty.")
            return
        raw_sql=self.sub_vqb.toPlainText().strip()
        if not raw_sql:
            QMessageBox.warning(self,"No subquery","CTE SQL cannot be empty.")
            return
        self.cte_name=nm
        self.cte_sql=raw_sql
        self.accept()

    def get_cte_data(self):
        return (self.cte_name,self.cte_conn_alias,self.cte_sql)

class MultiConnCTEPanel(QGroupBox):
    """ A CTE panel that prompts user for connection each time """
    def __init__(self,builder,parent=None):
        super().__init__("CTEs",parent)
        self.builder=builder
        self.cte_data=[]
        main=QVBoxLayout(self)
        self.setLayout(main)

        self.cte_table=QTableWidget(0,3)
        self.cte_table.setHorizontalHeaderLabels(["CTE Name","Connection","Preview"])
        self.cte_table.horizontalHeader().setSectionResizeMode(0,QHeaderView.ResizeToContents)
        self.cte_table.horizontalHeader().setSectionResizeMode(1,QHeaderView.ResizeToContents)
        self.cte_table.horizontalHeader().setSectionResizeMode(2,QHeaderView.Stretch)
        self.cte_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.cte_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        main.addWidget(self.cte_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add CTE")
        add_btn.clicked.connect(self.on_add_cte)
        edit_btn=QPushButton("Edit CTE")
        edit_btn.clicked.connect(self.on_edit_cte)
        rm_btn=QPushButton("Remove CTE")
        rm_btn.clicked.connect(self.on_remove_cte)
        bh.addWidget(add_btn)
        bh.addWidget(edit_btn)
        bh.addWidget(rm_btn)
        bh.addStretch()
        main.addLayout(bh)

    def on_add_cte(self):
        if not self.builder.connections:
            QMessageBox.warning(self,"No Connections","Please add connections first.")
            return
        # pick an alias
        pick=ConnectionPickerDialog(self.builder.connections,self)
        if pick.exec_()!=QDialog.Accepted:
            return
        alias=pick.get_chosen_alias()
        dlg=CTEDialogMultiConn(self.builder, alias,"","",self)
        if dlg.exec_()==QDialog.Accepted:
            nm,al,sql=dlg.get_cte_data()
            self._add_cte_row(nm,al,sql)
            # BFS => show cte
            self.builder.show_cte_as_virtual_table(nm,["col1","col2"])  # or parse columns
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def on_edit_cte(self):
        rows=self.cte_table.selectionModel().selectedRows()
        if not rows:
            QMessageBox.information(self,"No selection","Select a row to edit.")
            return
        rdx=rows[0].row()
        nm=self.cte_table.item(rdx,0).text()
        al=self.cte_table.item(rdx,1).text()
        sq=self.cte_table.item(rdx,2).text()

        dlg=CTEDialogMultiConn(self.builder,al,nm,sq,self)
        if dlg.exec_()==QDialog.Accepted:
            newnm,newal,newsql=dlg.get_cte_data()
            self.cte_table.setItem(rdx,0,QTableWidgetItem(newnm))
            self.cte_table.setItem(rdx,1,QTableWidgetItem(newal))
            self.cte_table.setItem(rdx,2,QTableWidgetItem(newsql))
            self.cte_data[rdx]['name']=newnm
            self.cte_data[rdx]['alias']=newal
            self.cte_data[rdx]['sql']=newsql
            if newnm!=nm:
                self.builder.remove_virtual_cte_table(nm)
            self.builder.show_cte_as_virtual_table(newnm,["col1","col2"])
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def on_remove_cte(self):
        rows=sorted([r.row() for r in self.cte_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            nm=self.cte_table.item(rr,0).text()
            self.cte_table.removeRow(rr)
            del self.cte_data[rr]
            self.builder.remove_virtual_cte_table(nm)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def _add_cte_row(self, cte_name, cte_alias, cte_sql):
        r=self.cte_table.rowCount()
        self.cte_table.insertRow(r)
        self.cte_table.setItem(r,0,QTableWidgetItem(cte_name))
        self.cte_table.setItem(r,1,QTableWidgetItem(cte_alias))
        self.cte_table.setItem(r,2,QTableWidgetItem(cte_sql))
        self.cte_data.append({'name':cte_name,'alias':cte_alias,'sql':cte_sql})

    def get_ctes(self):
        out=[]
        for r in range(self.cte_table.rowCount()):
            nm=self.cte_table.item(r,0).text()
            sql=self.cte_table.item(r,2).text()
            out.append((nm,sql))
        return out

###############################################################################
# 9) SQLImportTab => parse with sqlglot => partial BFS rebuild
###############################################################################
class SQLImportTab(QWidget):
    def __init__(self,builder=None,parent=None):
        super().__init__(parent)
        self.builder=builder
        main=QVBoxLayout(self)

        instruct=QLabel(
            "Paste or type your SQL, then click 'Import & Rebuild'.\n"
            "We parse with sqlglot.parse_one(...) (no 'ansi').\n"
            "Complex queries may partially rebuild BFS."
        )
        main.addWidget(instruct)

        self.sql_edit=QTextEdit()
        main.addWidget(self.sql_edit)

        hb=QHBoxLayout()
        self.import_btn=QPushButton("Import & Rebuild")
        self.import_btn.clicked.connect(self.on_import_rebuild)
        hb.addWidget(self.import_btn)
        main.addLayout(hb)

        self.setLayout(main)

    def on_import_rebuild(self):
        raw_sql=self.sql_edit.toPlainText().strip()
        if not raw_sql:
            QMessageBox.information(self,"Empty SQL","No SQL to parse.")
            return
        try:
            st=sqlparse.parse(raw_sql)
            if not st:
                QMessageBox.warning(self,"No valid SQL","sqlparse found no statements.")
                return
        except Exception as e:
            QMessageBox.warning(self,"Syntax Error",f"sqlparse error:\n{e}")
            return

        try:
            expr=sqlglot.parse_one(raw_sql)
        except Exception as ex:
            QMessageBox.warning(self,"sqlglot Parse Error",f"Could not parse:\n{ex}")
            return

        self.builder.import_and_rebuild_canvas(expr, raw_sql)
        QMessageBox.information(self,"Import OK","Canvas has been rebuilt from the SQL.")


###############################################################################
# 10) BFS-based VQB main + no forced LIMIT in run_sql
###############################################################################
class ResultDataDialog(QDialog):
    """ Show query results in a QTableWidget """
    def __init__(self,rows,columns,parent=None):
        super().__init__(parent)
        self.setWindowTitle("SQL Results")
        self.resize(800,400)
        main=QVBoxLayout(self)
        tbl=QTableWidget(len(rows),len(columns))
        tbl.setHorizontalHeaderLabels(columns)
        for r_idx,row_val in enumerate(rows):
            for c_idx,val in enumerate(row_val):
                it=QTableWidgetItem(str(val))
                tbl.setItem(r_idx,c_idx,it)
        main.addWidget(tbl)
        dbb=QDialogButtonBox(QDialogButtonBox.Ok)
        dbb.accepted.connect(self.accept)
        main.addWidget(dbb)
        self.setLayout(main)

###############################################################################
# The main window
###############################################################################
class MainVQBWindow(QMainWindow):
    """ The main top-level window hosting BFS VQB + multi-conn mgmt """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Multi-Connection VQB - BFS, Production Mapping, No Demo BFS")
        self.resize(1200,800)

        self.connections={}
        self.builder_tab=VisualQueryBuilderTab(self.connections)
        self.setCentralWidget(self.builder_tab)

        tb=self.addToolBar("Main Toolbar")
        conn_act=QAction("Connections",self)
        conn_act.triggered.connect(self.on_manage_connections)
        tb.addAction(conn_act)

        fit_act=QAction("Fit to View",self)
        fit_act.triggered.connect(self.on_fit_view)
        tb.addAction(fit_act)

        layout_act=QAction("Auto-Layout",self)
        layout_act.triggered.connect(self.on_auto_layout)
        tb.addAction(layout_act)

    def on_manage_connections(self):
        dlg=MultiODBCConnectDialog(self.connections,self)
        if dlg.exec_()==QDialog.Accepted:
            self.connections=dlg.get_connections()
            self.builder_tab.set_connections(self.connections)

    def on_fit_view(self):
        sc=self.builder_tab.canvas.scene_
        self.builder_tab.canvas.fitInView(sc.itemsBoundingRect(),Qt.KeepAspectRatio)

    def on_auto_layout(self):
        items=list(self.builder_tab.canvas.table_items.values())
        col_count=3
        xsp=250
        ysp=180
        for i,itm in enumerate(items):
            row=i//col_count
            col=i%col_count
            itm.setPos(col*xsp,row*ysp)
        for jl in self.builder_tab.canvas.join_lines:
            jl.update_line()


###############################################################################
# The final "VisualQueryBuilderTab" with multi-conn BFS
###############################################################################
class VisualQueryBuilderTab(QWidget):
    def __init__(self, connections=None, parent=None):
        super().__init__(parent)
        self.connections=connections if connections else {}
        self.table_columns_map={}
        self.auto_generate=True
        self.operation_mode="SELECT"
        self.init_ui()

    def init_ui(self):
        main=QVBoxLayout(self)

        # row => connection status
        con_h=QHBoxLayout()
        self.status_light=QFrame()
        self.status_light.setFixedSize(15,15)
        self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
        self.server_label=QLabel("No Connections")
        con_h.addWidget(self.status_light)
        con_h.addWidget(self.server_label)

        self.auto_chk=QCheckBox("Auto-Generate")
        self.auto_chk.setChecked(True)
        self.auto_chk.stateChanged.connect(self.on_auto_gen_changed)
        con_h.addWidget(self.auto_chk)
        con_h.addStretch()
        main.addLayout(con_h)

        top_h=QHBoxLayout()
        subq_btn=QPushButton("Add SubQuery")
        subq_btn.clicked.connect(self.add_subquery_to_canvas)
        top_h.addWidget(subq_btn)

        expr_btn=QPushButton("Expression Builder")
        expr_btn.clicked.connect(self.launch_expr_builder)
        top_h.addWidget(expr_btn)

        wfunc_btn=QPushButton("Window Function Wizard")
        wfunc_btn.clicked.connect(self.launch_window_func)
        top_h.addWidget(wfunc_btn)

        comb_btn=QPushButton("Combine Query (Sub VQB)")
        comb_btn.clicked.connect(self.combine_with_subvqb)
        top_h.addWidget(comb_btn)

        self.op_combo=QComboBox()
        self.op_combo.addItems(["SELECT","INSERT","UPDATE","DELETE"])
        self.op_combo.currentIndexChanged.connect(self.on_op_mode_changed)
        top_h.addWidget(self.op_combo)
        top_h.addStretch()
        main.addLayout(top_h)

        self.tabs=QTabWidget()
        main.addWidget(self.tabs)

        self.schema_tab=QWidget()
        self.config_tab=QWidget()
        self.sql_tab=QWidget()
        self.import_tab=SQLImportTab(builder=self)

        self.tabs.addTab(self.schema_tab,"Schema & Canvas")
        self.tabs.addTab(self.config_tab,"Query Config")
        self.tabs.addTab(self.sql_tab,"SQL Preview")
        self.tabs.addTab(self.import_tab,"SQL Import")

        self.status_bar=QStatusBar()
        main.addWidget(self.status_bar)
        self.setLayout(main)

        self.setup_schema_tab()
        self.setup_config_tab()
        self.setup_sql_tab()

    def set_connections(self,conns):
        self.connections=conns
        if conns:
            self.update_conn_status(True,"Multiple DBs connected")
            self.schema_tree.set_connections(conns)
            self.schema_tree.populate_roots()
        else:
            self.update_conn_status(False,"No Connections")

    def update_conn_status(self, st, info=""):
        if st:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: green;}")
            self.server_label.setText(info)
        else:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
            self.server_label.setText("No Connections")

    def setup_schema_tab(self):
        lay=QVBoxLayout(self.schema_tab)
        self.search_ed=QLineEdit()
        self.search_ed.setPlaceholderText("Filter schema items...")
        self.search_ed.textChanged.connect(self.on_schema_filter)
        lay.addWidget(self.search_ed)

        splitter=QSplitter(Qt.Horizontal)
        self.schema_tree=MultiDBLazySchemaTreeWidget(self.connections,self)
        leftp=QWidget()
        lpl=QVBoxLayout(leftp)
        lpl.addWidget(self.schema_tree)
        splitter.addWidget(leftp)

        self.canvas=EnhancedCanvasGraphicsView(self)
        splitter.addWidget(self.canvas)
        splitter.setStretchFactor(0,1)
        splitter.setStretchFactor(1,3)
        lay.addWidget(splitter)

        self.progress=QProgressBar()
        self.progress.setVisible(False)
        lay.addWidget(self.progress)

    def setup_config_tab(self):
        h=QHBoxLayout(self.config_tab)
        self.cte_panel=MultiConnCTEPanel(self)
        h.addWidget(self.cte_panel,2)
        self.filter_panel=FilterPanel(self)
        h.addWidget(self.filter_panel,2)
        self.group_panel=GroupByPanel(self)
        h.addWidget(self.group_panel,3)
        self.sort_panel=SortLimitPanel(self)
        h.addWidget(self.sort_panel,2)
        self.config_tab.setLayout(h)

    def setup_sql_tab(self):
        lay=QVBoxLayout(self.sql_tab)
        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Generated SQL:"))
        run_btn=QPushButton("Run SQL")
        run_btn.clicked.connect(self.run_sql)
        top_h.addWidget(run_btn,alignment=Qt.AlignRight)
        lay.addLayout(top_h)

        self.sql_display=QTextEdit()
        self.sql_display.setReadOnly(False)
        self.sql_highlighter=SQLHighlighter(self.sql_display.document())
        lay.addWidget(self.sql_display)

        self.validation_lbl=QLabel("SQL Status: Unknown")
        lay.addWidget(self.validation_lbl)
        self.sql_tab.setLayout(lay)

    def on_schema_filter(self,txt):
        self.schema_tree.filter_items(txt)

    def on_auto_gen_changed(self,st):
        self.auto_generate=(st==Qt.Checked)

    def on_op_mode_changed(self,idx):
        modes=["SELECT","INSERT","UPDATE","DELETE"]
        self.operation_mode=modes[idx]
        self.toggle_dml_canvas()
        if self.auto_generate:
            self.generate_sql()

    def toggle_dml_canvas(self):
        if self.operation_mode=="SELECT":
            self.canvas.remove_mapping_lines()
            if self.canvas.operation_red_line:
                self.canvas.scene_.removeItem(self.canvas.operation_red_line)
                self.canvas.operation_red_line=None
            if self.canvas.collapsible_bfs_item:
                self.canvas.scene_.removeItem(self.canvas.collapsible_bfs_item)
                self.canvas.collapsible_bfs_item=None
            if self.canvas.target_table_item:
                self.canvas.scene_.removeItem(self.canvas.target_table_item)
                self.canvas.target_table_item=None
        else:
            self.canvas.add_vertical_red_line(450)
            if not self.canvas.collapsible_bfs_item:
                BFScols=["srcCol1","srcCol2","key"]
                bfs=CollapsibleBFSGraphicsItem("BFS Source",BFScols,self,50,100)
                self.canvas.scene_.addItem(bfs)
                self.canvas.collapsible_bfs_item=bfs
            if not self.canvas.target_table_item:
                Tcols=["colA","colB","key"]
                self.canvas.add_target_item("db.tbl",Tcols,600,100)

    def add_subquery_to_canvas(self):
        self.canvas.add_subquery_item(200,200)
        if self.auto_generate:
            self.generate_sql()

    def combine_with_subvqb(self):
        if not self.connections:
            QMessageBox.warning(self,"No Connections","Please add at least one connection.")
            return
        pick=ConnectionPickerDialog(self.connections,self)
        if pick.exec_()!=QDialog.Accepted:
            return
        chosen_alias=pick.get_chosen_alias()
        d=SubVQBDialog(self.connections, chosen_alias, parent_vqb=self, parent=self)
        if d.exec_()==QDialog.Accepted:
            op,second_sql=d.getResult()
            old=self.sql_display.toPlainText().strip()
            new_sql=(old+"\n"+op+"\n(\n"+second_sql+"\n)") if old else f"{op}\n(\n{second_sql}\n)"
            self.sql_display.setPlainText(new_sql)
            self.validate_sql()

    def launch_expr_builder(self):
        cols=self.get_all_possible_columns_for_dialog()
        dlg=AdvancedExpressionBuilderDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            a,ex=dlg.get_expression_data()
            old=self.sql_display.toPlainText()
            self.sql_display.setPlainText(old+f"\n-- Expression: {a}\n{ex}")
            self.validate_sql()

    def launch_window_func(self):
        cols=self.get_all_possible_columns_for_dialog()
        dlg=AdvancedWindowFunctionDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            expression=dlg.get_expression()
            old=self.sql_display.toPlainText()
            self.sql_display.setPlainText(old+f"\n-- Window:\n{expression}")
            self.validate_sql()

    def run_sql(self):
        txt=self.sql_display.toPlainText().strip()
        if not txt:
            QMessageBox.information(self,"Empty SQL","No SQL to run.")
            return
        if not self.connections:
            QMessageBox.information(self,"No Connections","No DB connection found.")
            return
        # pick first alias
        first_alias=list(self.connections.keys())[0]
        conn=self.connections[first_alias]["connection"]
        try:
            cur=conn.cursor()
            cur.execute(txt)
            rows=cur.fetchall()
            cols=[desc[0] for desc in cur.description] if cur.description else []
            dlg=ResultDataDialog(rows,cols,self)
            dlg.exec_()
        except Exception as ex:
            QMessageBox.warning(self,"SQL Error",f"Failed:\n{ex}")

    def get_all_possible_columns_for_dialog(self):
        arr=[]
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns"):
                for c in v.columns:
                    arr.append(f"{k}.{c}")
        if self.canvas.collapsible_bfs_item:
            for c in self.canvas.collapsible_bfs_item.columns:
                arr.append(f"BFS.{c}")
        return arr

    def handle_drop(self, full_name, pos):
        # full_name => alias.db.table
        # if no connections => mock columns
        if not self.connections:
            if full_name not in self.table_columns_map:
                self.table_columns_map[full_name]=["id","col1","col2"]
        else:
            parts=full_name.split(".")
            if len(parts)>=3:
                alias=parts[0]
                dbn=parts[1]
                tbl=parts[2]
                info=self.connections.get(alias)
                if info:
                    c=info["connection"]
                    realCols=load_columns_for_table(c,dbn,tbl)
                    if not realCols:
                        realCols=["id","col1","col2"]
                    self.table_columns_map[full_name]=realCols
            else:
                self.table_columns_map[full_name]=["id","col1","col2"]
        cols=self.table_columns_map[full_name]
        self.canvas.add_table_item(full_name, cols, pos.x(), pos.y())

    def handle_remove_table(self,table_item):
        for k,v in list(self.canvas.table_items.items()):
            if v==table_item:
                self.canvas.remove_table_item(k)
                break

    def show_cte_as_virtual_table(self, cte_name, columns):
        table_key=f"CTE.{cte_name}"
        if table_key in self.canvas.table_items:
            self.canvas.remove_table_item(table_key)
        if not columns:
            columns=["col1","col2"]
        self.canvas.add_table_item(table_key, columns, 600,100)

    def remove_virtual_cte_table(self, cte_name):
        table_key=f"CTE.{cte_name}"
        self.canvas.remove_table_item(table_key)

    def generate_sql(self):
        # Overridden below if we do BFS logic
        pass

    def validate_sql(self):
        pass

    # We'll do BFS logic in a separate partial or inline? We'll just do minimal stubs:
    def _build_bfs_from(self):
        return "-- BFS from logic not implemented in short form"

    def import_and_rebuild_canvas(self,root_expr,full_sql):
        # minimal
        self.sql_display.setPlainText(full_sql)


###############################################################################
# 11) SubVQBDialog => user picks a single connection => BFS?
###############################################################################
class SubVQBDialog(QDialog):
    def __init__(self, all_connections, chosen_alias, parent_vqb=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Combine Query (Sub VQB) - Single Connection")
        self.resize(900,600)
        self.operator="UNION"
        self.second_sql=""
        self.parent_vqb=parent_vqb
        self.all_connections=all_connections
        self.chosen_alias=chosen_alias

        lay=QVBoxLayout(self)
        oh=QHBoxLayout()
        oh.addWidget(QLabel("Combine Operator:"))
        self.op_combo=QComboBox()
        self.op_combo.addItems(["UNION","UNION ALL","INTERSECT","EXCEPT"])
        oh.addWidget(self.op_combo)
        oh.addStretch()
        lay.addLayout(oh)

        # minimal sub VQB => text
        self.txt=QTextEdit()
        lay.addWidget(self.txt)

        dbb=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        lay.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(lay)

    def on_ok(self):
        op=self.op_combo.currentText()
        s=self.txt.toPlainText().strip()
        if not s:
            QMessageBox.warning(self,"No query","No sub query typed.")
            return
        self.operator=op
        self.second_sql=s
        self.accept()

    def getResult(self):
        return (self.operator,self.second_sql)


###############################################################################
# main
###############################################################################
def main():
    app=QApplication(sys.argv)
    apply_fusion_style()
    w=MainVQBWindow()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()