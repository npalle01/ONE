#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_data_validations.py
Description:
  Provides a comprehensive data validation manager for the BRM Tool. 
  It includes:
   • A `DataValidationManagerTab` UI widget for CRUD on validation rules.
   • Functions to run validations for a single table or all tables, returning pass/fail.
   • Logging of results into DATA_VALIDATION_LOGS with timestamp, pass/fail, details.
   • Integration hooks so BFS or scheduling can call `run_validations_for_rule` or `run_all_validations`.

This module is designed to integrate seamlessly with:
 - brm_core_foundation (for logger, fetch helpers, etc.)
 - brm_rule_engine or scheduling modules if you want to incorporate validations into BFS.
"""

import sys
import json
import logging
import re
from datetime import datetime
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTableWidget, QTableWidgetItem,
    QLineEdit, QInputDialog, QMessageBox, QComboBox, QLabel
)
from PyQt5.QtCore import Qt

# Suppose from brm_core_foundation we import:
from brm_core_foundation import (
    logger, fetch_all_dict, fetch_one_dict
)

# ---------------------------------------------------------------------------
# Core Validation Runner Functions
# ---------------------------------------------------------------------------
def run_single_validation(conn, validation_id):
    """
    Fetch the validation rule from DATA_VALIDATIONS by ID,
    interpret the type (NOT NULL, RANGE, REGEX, etc.), run an appropriate check,
    log the result to DATA_VALIDATION_LOGS.

    Returns a tuple: (pass_flag, details_string)
    """
    c=conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
        WHERE VALIDATION_ID=?
    """,(validation_id,))
    row=c.fetchone()
    if not row:
        logger.error(f"Validation ID {validation_id} not found.")
        return (False,f"Validation rule not found (ID={validation_id}).")

    (vid, table_, col_, vtype, params_) = row
    pass_flag=True
    details=""

    try:
        if not table_ or not col_:
            pass_flag=False
            details="Invalid table/column."
        else:
            pass_flag, details = _execute_validation_check(conn, table_, col_, vtype, params_)

    except Exception as ex:
        pass_flag=False
        details=str(ex)

    # Log result
    c2=conn.cursor()
    res_flag="PASS" if pass_flag else "FAIL"
    c2.execute("""
        INSERT INTO DATA_VALIDATION_LOGS(
          VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP, TABLE_NAME, COLUMN_NAME
        )
        VALUES(?,?,?,?,?,?)
    """,(vid, res_flag, details, datetime.now(), table_, col_))
    conn.commit()

    return (pass_flag, details)

def _execute_validation_check(conn, table_name, column_name, validation_type, params_):
    """
    The actual logic for each validation type. 
    Return (bool_pass, detail_message).
    """
    vtype=validation_type.upper().strip()
    c=conn.cursor()
    if vtype=="NOT NULL":
        qry=f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL"
        c.execute(qry)
        row=c.fetchone()
        cnt=row[0] if row else 0
        if cnt>0:
            return (False, f"{cnt} NULL values found in {table_name}.{column_name}")
        else:
            return (True,"No NULL found => PASS")
    elif vtype=="RANGE":
        # interpret params as "MIN,MAX"
        parts=(params_ or "").split(",")
        if len(parts)!=2:
            return (False,"Invalid range params => expecting 'min,max'")
        try:
            minv=float(parts[0])
            maxv=float(parts[1])
            qry=f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} < {minv} OR {column_name} > {maxv}"
            c.execute(qry)
            row=c.fetchone()
            out_of_range=row[0] if row else 0
            if out_of_range>0:
                return (False, f"{out_of_range} row(s) out of [{minv},{maxv}] in {table_name}.{column_name}")
            else:
                return (True,"All values in range => PASS")
        except:
            return (False,"Failed to parse range params => e.g. '0,100'")
    elif vtype=="REGEX":
        # Implementation approach depends on T-SQL or Python usage. We'll do naive approach:
        pat_text=params_ or ".*"
        # we fetch up to X rows? This might be large. For demonstration, let's do a small approach:
        # We'll do a naive approach: 
        c.execute(f"SELECT {column_name} FROM {table_name}")
        rows=c.fetchall()
        pattern=re.compile(pat_text)
        mismatch_count=0
        for (val,) in rows:
            if val is None:
                mismatch_count+=1
            else:
                sval=str(val)
                if not pattern.match(sval):
                    mismatch_count+=1
        if mismatch_count>0:
            return (False,f"{mismatch_count} row(s) did not match regex '{pat_text}' in {table_name}.{column_name}")
        else:
            return (True,f"All rows matched regex => PASS")
    else:
        return (False,f"Unknown validation type '{validation_type}'")

def run_validations_for_table(conn, table_name):
    """
    Load all validations for `table_name` from DATA_VALIDATIONS, run them, 
    return a list of (validation_id, pass_flag, details).
    """
    c=conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID
        FROM DATA_VALIDATIONS
        WHERE LOWER(TABLE_NAME)=LOWER(?)
    """,(table_name,))
    vrows=c.fetchall()
    results=[]
    for (vid,) in vrows:
        (pf, dt)=run_single_validation(conn, vid)
        results.append((vid,pf,dt))
    return results

def run_all_validations(conn):
    """
    Run every validation in DATA_VALIDATIONS => returns an array of 
    (validation_id, table_name, column_name, pass_flag, details).
    """
    c=conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID
        FROM DATA_VALIDATIONS
        ORDER BY VALIDATION_ID
    """)
    allvids=[r[0] for r in c.fetchall()]
    results=[]
    for vid in allvids:
        (pf, dt)=run_single_validation(conn, vid)
        c2=conn.cursor()
        c2.execute("SELECT TABLE_NAME, COLUMN_NAME FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        row2=c2.fetchone()
        tb="?"
        col="?"
        if row2:
            tb=row2[0]
            col=row2[1]
        results.append((vid, tb, col, pf, dt))
    return results

def run_validations_for_rule(conn, rule_id):
    """
    If you want to run validations for all tables used by a rule => parse dependencies => 
    run for each table. Return pass/fail, plus details on any failure.
    """
    # we assume there's a table BRM_RULE_TABLE_DEPENDENCIES => (RULE_ID,DATABASE_NAME,TABLE_NAME,...)
    c=conn.cursor()
    c.execute("""
        SELECT DISTINCT DATABASE_NAME, TABLE_NAME
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE RULE_ID=?
    """,(rule_id,))
    deps=c.fetchall()
    all_pass=True
    fail_details=[]
    for (dbn, tbn) in deps:
        if not tbn:
            continue
        fulltbl=f"{dbn}.{tbn}".lower()
        table_results=run_validations_for_table(conn, fulltbl)
        for (vid,pf,dt) in table_results:
            if not pf:
                all_pass=False
                fail_details.append((vid,dt))
    return (all_pass, fail_details)


# ---------------------------------------------------------------------------
# UI Tab for Data Validations
# ---------------------------------------------------------------------------
class DataValidationManagerTab(QWidget):
    """
    A tab that lists data validations from DATA_VALIDATIONS, allows add/edit/delete, 
    and a "Run Validations" button (for all or for a chosen table).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.init_ui()
        self.load_validations()

    def init_ui(self):
        layout=QVBoxLayout(self)

        self.val_table=QTableWidget(0,5)
        self.val_table.setHorizontalHeaderLabels(["ValidationID","TableName","ColumnName","Type","Params"])
        self.val_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.val_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_h.addWidget(add_btn)

        del_btn=QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_validation)
        btn_h.addWidget(del_btn)

        run_btn=QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all)
        btn_h.addWidget(run_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_validations)
        btn_h.addWidget(ref_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def load_validations(self):
        self.val_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
            ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.val_table.rowCount()
            self.val_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val is not None else "")
                self.val_table.setItem(r_i,col_i,it)

    def add_validation(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name (e.g. 'dbo.Customers'):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(NOT NULL,RANGE,REGEX,...)")
        if not ok3 or not vtype.strip():
            return
        params_,ok4=QInputDialog.getText(self,"Params","(Example for RANGE:'0,100' / for REGEX:'^[A-Z]+$')")
        if not ok4:
            params_=""
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(
                  TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS,CREATED_TIMESTAMP
                )
                VALUES(?,?,?,?,GETDATE())
            """,(tbl.strip(), col.strip(), vtype.strip(), params_.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Validation rule added.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def remove_validation(self):
        row=self.val_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        val_id_item=self.val_table.item(row,0)
        if not val_id_item:
            return
        vid=int(val_id_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation ID={vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
            self.connection.commit()
            QMessageBox.information(self,"Removed","Validation rule removed.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def run_all(self):
        results=run_all_validations(self.connection)
        fails=[r for r in results if not r[3]]
        if fails:
            fail_str="\n".join([f"ID={f[0]} => {f[4]}" for f in fails])
            QMessageBox.warning(self,"Validation Results",f"Some validations failed:\n{fail_str}")
        else:
            QMessageBox.information(self,"Validation Results","All validations passed.")