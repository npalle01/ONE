#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: brm_tool_main.py
Description:
  This is the final, fully integrated, production‑ready BRM Tool.
  It combines advanced modules including:
    • Database connection, login, and basic helpers.
    • Business rules dashboard with full CRUD, force‑activation/deactivation,
      and simulation logging that captures impacted record counts and success/fail details.
    • Multi‑step approvals with real‑time notifications and auto‑refresh.
    • Global/Critical administration (with forced override, locking, and audit logging).
    • Hierarchy view with drag‑and‑drop re‑parenting.
    • Advanced lineage visualization (Ervin ER‑style with flow arrows, color‑coded live statuses,
      and search by column, table, or database).
    • Custom rule groups management with backup/restore and real‑time context menus.
    • Scheduling management with advanced simulation and dry‑run logging.
    • Control tables viewer and metrics dashboard for performance stats.
    • Group and user management.
    
All simulation actions and key operations are logged, and every dry‑run returns detailed information on the
number of records impacted along with success/failure notifications.
"""

import sys
import json
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QComboBox, QPushButton, QLabel, QMessageBox, QDialog, QLineEdit, QAction,
    QInputDialog
)
from PyQt5.QtCore import QTimer

# -----------------------------------------------------------------------------
# Assume that the following modules have been defined as part of the tool:
#   - db_connection_and_helpers.py (DatabaseConnectionDialog, LoginDialog, sync_metadata_improved, insert_audit_log, etc.)
#   - rule_execution_and_bfs.py (execute_rules_with_conflicts_composites_bfs, dry_run_rule_sql, ChainSimulationDialog,
#                                GroupSimulationDialog, SingleRuleSimulationDialog)
#   - scheduling_and_simulations.py (EnhancedScheduleDialog, ScheduleManagementTab, check_due_schedules)
#   - audit_and_rule_editors.py (AuditLogViewer, RuleSearchDialog, VersionHistoryDialog, RuleDashboard, RuleEditorDialog, delete_rule)
#   - approvals_and_lineage.py (MultiStepApprovalTab, GlobalCriticalAdminTab, HierarchyViewTab, EnhancedLineageGraphWidget)
#   - metrics_and_control_tables.py (MetricsDashboardTab, CtrlTablesTab, GroupManagementTab, UserManagementTab, run_data_validations)
#   - custom_rule_groups_and_alerts.py (CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab)
#
# For this integrated module, we import the above as needed.
# -----------------------------------------------------------------------------

# Set up root logger
logging.basicConfig(
    filename='brm_tool_production.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger("brm_tool_main")


class BRMTool(QMainWindow):
    """
    Main integration window for the BRM Tool.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Final Integration (Production Ready)")
        self.resize(1300, 900)

        self.connection = None
        self.user_id = None
        self.logged_in_username = None
        self.user_group = None

        # Step 1: Establish Database Connection
        from db_connection_and_helpers import DatabaseConnectionDialog
        db_dialog = DatabaseConnectionDialog()
        if db_dialog.exec_() == QDialog.Accepted:
            self.connection = db_dialog.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Step 2: User Login
        from db_connection_and_helpers import LoginDialog
        login_dialog = LoginDialog(self.connection)
        if login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dialog.user_id
        self.user_group = login_dialog.user_group

        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID = ?", (self.user_id,))
        row = c.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "UnknownUser"

        # Optional: Onboarding Wizard could be called here if needed.
        # from db_connection_and_helpers import OnboardingWizard
        # wizard = OnboardingWizard(self.connection)
        # wizard.exec_()

        self.init_ui()

    def init_ui(self):
        # Create Menu Bar with actions
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        help_menu = menubar.addMenu("Help")
        tools_menu = menubar.addMenu("Tools")

        # File Menu Actions
        sync_action = QAction("Sync Metadata", self)
        sync_action.triggered.connect(self.sync_metadata)
        file_menu.addAction(sync_action)

        dv_action = QAction("Run All Data Validations", self)
        dv_action.triggered.connect(self.run_all_data_validations)
        file_menu.addAction(dv_action)

        perf_action = QAction("Show Performance Trends", self)
        perf_action.triggered.connect(self.show_performance_trends)
        file_menu.addAction(perf_action)

        chain_sim_action = QAction("Simulate Rule Chain", self)
        chain_sim_action.triggered.connect(self.launch_chain_simulation)
        file_menu.addAction(chain_sim_action)

        group_sim_action = QAction("Simulate Custom Group", self)
        group_sim_action.triggered.connect(self.launch_group_simulation)
        file_menu.addAction(group_sim_action)

        # Help Menu Action
        help_action = QAction("Show Help", self)
        help_action.triggered.connect(self.show_help)
        help_menu.addAction(help_action)

        # Tools Menu Actions
        audit_action = QAction("View Audit Logs", self)
        audit_action.triggered.connect(self.launch_audit_logs)
        tools_menu.addAction(audit_action)

        search_action = QAction("Search Rules", self)
        search_action.triggered.connect(self.launch_rule_search)
        tools_menu.addAction(search_action)

        version_action = QAction("Version History", self)
        version_action.triggered.connect(self.launch_version_history)
        tools_menu.addAction(version_action)

        # Central widget layout
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)

        # Admin Impersonation Section (visible only if user is Admin)
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            self.impersonate_combo = QComboBox()
            self.impersonate_btn = QPushButton("Switch User")
            self.impersonate_btn.clicked.connect(self.switch_user)
            imp_layout.addWidget(QLabel("Impersonate:"))
            imp_layout.addWidget(self.impersonate_combo)
            imp_layout.addWidget(self.impersonate_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)
            self.load_impersonation_options()

        # Create main tab widget
        self.main_tabs = QTabWidget()
        central_layout.addWidget(self.main_tabs)

        # Business Rules Dashboard Tab
        from audit_and_rule_editors import RuleDashboard, RuleEditorDialog, delete_rule
        self.rule_dashboard = RuleDashboard(self.connection, self.user_id, self.user_group)
        br_tab = QWidget()
        br_layout = QVBoxLayout(br_tab)

        # Top control buttons for rules
        rule_ctrl_layout = QHBoxLayout()
        add_rule_btn = QPushButton("Add Rule")
        add_rule_btn.clicked.connect(self.add_rule)
        rule_ctrl_layout.addWidget(add_rule_btn)

        update_rule_btn = QPushButton("Update Rule")
        update_rule_btn.clicked.connect(self.update_rule)
        rule_ctrl_layout.addWidget(update_rule_btn)

        force_activate_btn = QPushButton("Force Activate")
        force_activate_btn.clicked.connect(self.force_activate_rule)
        rule_ctrl_layout.addWidget(force_activate_btn)

        force_deactivate_btn = QPushButton("Force Deactivate")
        force_deactivate_btn.clicked.connect(self.force_deactivate_rule)
        rule_ctrl_layout.addWidget(force_deactivate_btn)

        delete_rule_btn = QPushButton("Delete Rule")
        delete_rule_btn.clicked.connect(self.delete_rule)
        rule_ctrl_layout.addWidget(delete_rule_btn)

        etl_bfs_btn = QPushButton("Run ETL BFS")
        etl_bfs_btn.clicked.connect(self.run_etl_bfs)
        rule_ctrl_layout.addWidget(etl_bfs_btn)

        simulate_rule_btn = QPushButton("Simulate Single Rule")
        simulate_rule_btn.clicked.connect(self.simulate_single_rule)
        rule_ctrl_layout.addWidget(simulate_rule_btn)

        rule_ctrl_layout.addStretch()
        br_layout.addLayout(rule_ctrl_layout)
        br_layout.addWidget(self.rule_dashboard)
        br_tab.setLayout(br_layout)
        self.main_tabs.addTab(br_tab, "Business Rules")

        # Approvals Tab
        from approvals_and_lineage import MultiStepApprovalTab
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.main_tabs.addTab(self.approvals_tab, "Approvals")

        # Global/Critical Admin Tab (Admin only)
        if self.user_group == "Admin":
            from approvals_and_lineage import GlobalCriticalAdminTab
            self.gcr_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.main_tabs.addTab(self.gcr_admin_tab, "Global/Critical Admin")

        # Hierarchy View Tab
        from approvals_and_lineage import HierarchyViewTab
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.main_tabs.addTab(self.hierarchy_tab, "Hierarchy")

        # Advanced Lineage Visualization Tab
        from approvals_and_lineage import EnhancedLineageGraphWidget
        lineage_tab = QWidget()
        lineage_layout = QVBoxLayout(lineage_tab)
        title_label = QLabel("Advanced Lineage Visualization")
        title_label.setStyleSheet("font-weight:bold; font-size:14px;")
        lineage_layout.addWidget(title_label)
        self.lineage_view = EnhancedLineageGraphWidget(self.connection)
        lineage_layout.addWidget(self.lineage_view)
        # Lineage search bar
        lineage_search_layout = QHBoxLayout()
        self.lineage_search_edit = QLineEdit()
        self.lineage_search_edit.setPlaceholderText("Search by column, table, or database...")
        lineage_search_layout.addWidget(self.lineage_search_edit)
        search_btn = QPushButton("Search")
        search_btn.clicked.connect(self.search_lineage)
        lineage_search_layout.addWidget(search_btn)
        reset_btn = QPushButton("Reset")
        reset_btn.clicked.connect(self.lineage_view.reset_dim_highlight)
        lineage_search_layout.addWidget(reset_btn)
        lineage_search_layout.addStretch()
        lineage_layout.addLayout(lineage_search_layout)
        self.main_tabs.addTab(lineage_tab, "Lineage")

        # Custom Rule Groups Tab
        from custom_rule_groups_and_alerts import CustomRuleGroupEnhancedTab
        self.custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.main_tabs.addTab(self.custom_groups_tab, "Custom Groups")

        # Scheduling Tab
        from scheduling_and_simulations import ScheduleManagementTab
        self.scheduling_tab = ScheduleManagementTab(self.connection)
        self.main_tabs.addTab(self.scheduling_tab, "Scheduling")

        # Control Tables Tab
        from metrics_and_control_tables import CtrlTablesTab
        self.control_tables_tab = CtrlTablesTab(self.connection)
        self.main_tabs.addTab(self.control_tables_tab, "Control Tables")

        # Metrics Dashboard Tab
        from metrics_and_control_tables import MetricsDashboardTab
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.main_tabs.addTab(self.metrics_tab, "Metrics")

        # Alerts & Dashboards Tab
        from custom_rule_groups_and_alerts import AlertsAndDashboardsTab
        self.alerts_tab = AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.main_tabs.addTab(self.alerts_tab, "Alerts & Dashboards")

        # Group Management Tab
        from metrics_and_control_tables import GroupManagementTab
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.main_tabs.addTab(self.group_mgmt_tab, "Group Management")

        # User Management Tab (Admin only)
        if self.user_group == "Admin":
            from metrics_and_control_tables import UserManagementTab
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.main_tabs.addTab(self.user_mgmt_tab, "User Management")

        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)

        # Setup auto-refresh timers
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approvals_timer.start(5000)  # every 5 seconds

        self.schedules_timer = QTimer(self)
        self.schedules_timer.timeout.connect(self.check_due_schedules)
        self.schedules_timer.start(60000)  # every 60 seconds

    # ---------------------------
    # Menu Action Handlers
    # ---------------------------
    def sync_metadata(self):
        try:
            from db_connection_and_helpers import sync_metadata_improved
            msg = sync_metadata_improved(self.connection)
            QMessageBox.information(self, "Sync Metadata", msg)
        except Exception as ex:
            logger.error(f"Sync metadata error: {ex}")
            QMessageBox.critical(self, "Sync Metadata Error", str(ex))

    def run_all_data_validations(self):
        try:
            from metrics_and_control_tables import run_data_validations
            run_data_validations(self.connection)
            QMessageBox.information(self, "Data Validations", "All data validations executed. Check logs for details.")
        except Exception as ex:
            logger.error(f"Data validations error: {ex}")
            QMessageBox.critical(self, "Data Validation Error", str(ex))

    def show_performance_trends(self):
        try:
            from metrics_and_control_tables import MetricsDashboardTab
            dlg = QDialog(self)
            dlg.setWindowTitle("Performance Trends")
            dlg.resize(800, 600)
            layout = QVBoxLayout(dlg)
            perf_chart = MetricsDashboardTab(self.connection)
            layout.addWidget(perf_chart)
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dlg.close)
            layout.addWidget(close_btn)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Performance trends error: {ex}")
            QMessageBox.critical(self, "Performance Trends Error", str(ex))

    def launch_chain_simulation(self):
        try:
            from rule_execution_and_bfs import ChainSimulationDialog
            dlg = ChainSimulationDialog(self.connection, self)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Chain simulation error: {ex}")
            QMessageBox.critical(self, "Chain Simulation Error", str(ex))

    def launch_group_simulation(self):
        try:
            from rule_execution_and_bfs import GroupSimulationDialog
            dlg = GroupSimulationDialog(self.connection, self)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Group simulation error: {ex}")
            QMessageBox.critical(self, "Group Simulation Error", str(ex))

    def launch_audit_logs(self):
        try:
            from audit_and_rule_editors import AuditLogViewer
            dlg = AuditLogViewer(self.connection, self.user_group, self)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Audit logs error: {ex}")
            QMessageBox.critical(self, "Audit Logs Error", str(ex))

    def launch_rule_search(self):
        try:
            from audit_and_rule_editors import RuleSearchDialog
            dlg = RuleSearchDialog(self.connection, self.user_group, self)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Rule search error: {ex}")
            QMessageBox.critical(self, "Rule Search Error", str(ex))

    def launch_version_history(self):
        rid, ok = QInputDialog.getInt(self, "Version History", "Enter rule ID:")
        if not ok:
            return
        try:
            from audit_and_rule_editors import VersionHistoryDialog
            dlg = VersionHistoryDialog(self.connection, rid, self)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Version history error: {ex}")
            QMessageBox.critical(self, "Version History Error", str(ex))

    # ---------------------------
    # Business Rules Operations
    # ---------------------------
    def add_rule(self):
        try:
            from audit_and_rule_editors import RuleEditorDialog
            dlg = RuleEditorDialog(self.connection, self.user_group, None, self)
            if dlg.exec_() == QDialog.Accepted:
                self.rule_dashboard.load_rules()
        except Exception as ex:
            logger.error(f"Add rule error: {ex}")
            QMessageBox.critical(self, "Add Rule Error", str(ex))

    def update_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if len(selected) != 1:
            QMessageBox.warning(self, "Selection Error", "Select exactly one rule to update.")
            return
        rid = selected[0]
        try:
            from audit_and_rule_editors import RuleEditorDialog
            c = self.connection.cursor()
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", "Rule not found.")
                return
            cols = [desc[0] for desc in c.description]
            rule_data = dict(zip(cols, row))
            dlg = RuleEditorDialog(self.connection, self.user_group, rule_data, self)
            if dlg.exec_() == QDialog.Accepted:
                self.rule_dashboard.load_rules()
        except Exception as ex:
            logger.error(f"Update rule error: {ex}")
            QMessageBox.critical(self, "Update Rule Error", str(ex))

    def force_activate_rule(self):
        if self.user_group != "Admin":
            QMessageBox.warning(self, "Permission Denied", "Only Admin can force activate rules.")
            return
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            return
        c = self.connection.cursor()
        success = 0
        error_msgs = []
        for rid in selected:
            try:
                c.execute("""
                    UPDATE BRM_RULES
                    SET STATUS = 'ACTIVE', LIFECYCLE_STATE = 'ACTIVE', APPROVAL_STATUS = 'APPROVED'
                    WHERE RULE_ID = ?
                """, (rid,))
                from db_connection_and_helpers import insert_audit_log
                insert_audit_log(self.connection, "FORCE_ACTIVATE", "BRM_RULES", rid, "Admin", None, {"new_status": "ACTIVE"})
                self.connection.commit()
                success += 1
            except Exception as ex:
                error_msgs.append(str(ex))
        msg = f"Force activated {success} rule(s)."
        if error_msgs:
            msg += "\nErrors:\n" + "\n".join(error_msgs)
        QMessageBox.information(self, "Force Activate", msg)
        self.rule_dashboard.load_rules()

    def force_deactivate_rule(self):
        if self.user_group != "Admin":
            QMessageBox.warning(self, "Permission Denied", "Only Admin can force deactivate rules.")
            return
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            return
        c = self.connection.cursor()
        success = 0
        error_msgs = []
        for rid in selected:
            try:
                c.execute("""
                    WITH Descendants AS (
                        SELECT RULE_ID FROM BRM_RULES WHERE RULE_ID = ?
                        UNION ALL
                        SELECT R.RULE_ID FROM BRM_RULES R JOIN Descendants D ON R.PARENT_RULE_ID = D.RULE_ID
                    )
                    UPDATE BRM_RULES
                    SET STATUS = 'INACTIVE', LIFECYCLE_STATE = 'INACTIVE', APPROVAL_STATUS = 'FORCE_DEACTIVATED'
                    WHERE RULE_ID IN (SELECT RULE_ID FROM Descendants)
                """, (rid,))
                from db_connection_and_helpers import insert_audit_log
                insert_audit_log(self.connection, "FORCE_DEACTIVATE", "BRM_RULES", rid, "Admin", None, {"new_status": "INACTIVE"})
                self.connection.commit()
                success += 1
            except Exception as ex:
                error_msgs.append(str(ex))
        msg = f"Force deactivated {success} rule(s)."
        if error_msgs:
            msg += "\nErrors:\n" + "\n".join(error_msgs)
        QMessageBox.information(self, "Force Deactivate", msg)
        self.rule_dashboard.load_rules()

    def delete_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            return
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete {len(selected)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        try:
            from audit_and_rule_editors import delete_rule
            success = 0
            error_msgs = []
            for rid in selected:
                try:
                    delete_rule(self.connection, rid, f"User:{self.user_id}", self.user_group)
                    success += 1
                except Exception as ex:
                    error_msgs.append(str(ex))
            msg = f"Deleted {success} rule(s)."
            if error_msgs:
                msg += "\nErrors:\n" + "\n".join(error_msgs)
            QMessageBox.information(self, "Delete Rule", msg)
            self.rule_dashboard.load_rules()
        except Exception as ex:
            logger.error(f"Delete rule error: {ex}")
            QMessageBox.critical(self, "Delete Rule Error", str(ex))

    def run_etl_bfs(self):
        try:
            from rule_execution_and_bfs import execute_rules_with_conflicts_composites_bfs
            executed, skipped = execute_rules_with_conflicts_composites_bfs(self.connection)
            msg = f"ETL BFS Simulation:\nExecuted: {executed}\nSkipped: {list(skipped)}"
            logger.info(msg)
            QMessageBox.information(self, "ETL BFS Simulation", msg)
            self.rule_dashboard.load_rules()
        except Exception as ex:
            logger.error(f"ETL BFS error: {ex}")
            QMessageBox.critical(self, "ETL BFS Error", str(ex))

    def simulate_single_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if len(selected) != 1:
            QMessageBox.warning(self, "Selection Error", "Select exactly one rule for simulation.")
            return
        rid = selected[0]
        try:
            from rule_execution_and_bfs import SingleRuleSimulationDialog
            dlg = SingleRuleSimulationDialog(self.connection, rid, self)
            dlg.exec_()
        except Exception as ex:
            logger.error(f"Single rule simulation error: {ex}")
            QMessageBox.critical(self, "Simulation Error", str(ex))

    def check_due_schedules(self):
        try:
            from scheduling_and_simulations import check_due_schedules
            check_due_schedules(self.connection)
            self.scheduling_tab.load_schedules()
        except Exception as ex:
            logger.error(f"Schedule check error: {ex}")

    def search_lineage(self):
        text = self.lineage_search_edit.text().strip()
        if not text:
            self.lineage_view.reset_dim_highlight()
        else:
            self.lineage_view.dim_non_matches_and_highlight(text)

    # ---------------------------
    # Admin Impersonation
    # ---------------------------
    def switch_user(self):
        data = self.impersonate_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID = ?", (self.user_id,))
        row = c.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "UnknownUser"
        QMessageBox.information(self, "Switched User", f"Now impersonating {self.logged_in_username} ({self.user_group}).")
        # Refresh relevant tabs with new user data
        self.approvals_tab.logged_in_username = self.logged_in_username
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.rule_dashboard.user_id = self.user_id
        self.rule_dashboard.user_group = self.user_group
        self.rule_dashboard.load_rules()
        if hasattr(self, "gcr_admin_tab"):
            self.gcr_admin_tab.load_rule_list()
        if hasattr(self, "hierarchy_tab"):
            self.hierarchy_tab.load_hierarchy()
        if hasattr(self, "alerts_tab"):
            self.alerts_tab.check_alerts()
        if hasattr(self, "group_mgmt_tab"):
            self.group_mgmt_tab.user_id = self.user_id
            self.group_mgmt_tab.user_group = self.user_group
            self.group_mgmt_tab.load_data()
        if hasattr(self, "user_mgmt_tab"):
            self.user_mgmt_tab.load_users()

    def load_impersonation_options(self):
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for row in c.fetchall():
                uid, uname, ugroup = row
                display = f"{uname} ({ugroup})"
                self.impersonate_combo.addItem(display, (uid, ugroup))
        except Exception as ex:
            logger.error(f"Error loading impersonation options: {ex}")

    # ---------------------------
    # Close and Cleanup
    # ---------------------------
    def closeEvent(self, event):
        try:
            if self.connection:
                self.connection.close()
        except Exception as ex:
            logger.error(f"Error closing connection: {ex}")
        event.accept()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    tool = BRMTool()
    tool.show()
    sys.exit(app.exec_())