#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module 8 – BRM Tool Main Integration
--------------------------------------
This module integrates all enhanced functionalities from the previous modules into one production‑ready application.

Key enhancements include:
  • Advanced security (support for encryption flags on sensitive fields)
  • Asynchronous/parallel execution for heavy ETL/simulation tasks using QThreadPool/QRunnable
  • Real‑time notifications and auto‑refresh via QTimer
  • Modern UI enhancements (clean layout, plugin‑friendly architecture, improved styling)
  • Centralized logging and monitoring integrated via Python’s logging module
  • Deep decision table integration and advanced ER‑style lineage visualization (with search, flow arrows, and live color‑coded statuses)
  • Full integration of business rules, approvals, global/critical administration, hierarchy, scheduling, control tables, metrics, alerts/dashboards, and user management

All modules are assumed to be available (core_module, business_rules_module, approvals_module, gcr_module, hierarchy_module, lineage_module, scheduling_module, control_module, custom_groups_and_alerts, decision_tables_module).

Author: Your Name
Date: YYYY-MM-DD
"""

import sys
import logging
import json
from datetime import datetime

# PyQt5 imports
from PyQt5.QtWidgets import (QMainWindow, QApplication, QWidget, QVBoxLayout, QHBoxLayout,
                             QTabWidget, QMenu, QAction, QInputDialog, QMessageBox, QDialog, QLineEdit)
from PyQt5.QtCore import Qt, QTimer, QRunnable, QThreadPool, pyqtSignal, QObject

# -----------------------------------------------------------------------------
# Centralized Logging Configuration
# -----------------------------------------------------------------------------
logger = logging.getLogger("BRMToolMain")
logger.setLevel(logging.DEBUG)
if not logger.handlers:
    ch = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s:%(levelname)s:%(name)s:%(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

# -----------------------------------------------------------------------------
# Asynchronous ETL Simulation Task
# -----------------------------------------------------------------------------
class ETLSimulationWorkerSignals(QObject):
    finished = pyqtSignal(list, list)  # executed_rules, skipped_rules
    error = pyqtSignal(str)

class ETLSimulationTask(QRunnable):
    """
    Runs the heavy ETL (BFS) simulation task asynchronously.
    Emits the number of rules executed and skipped.
    """
    def __init__(self, connection):
        super().__init__()
        self.connection = connection
        self.signals = ETLSimulationWorkerSignals()
    
    def run(self):
        try:
            # Call the production-ready ETL simulation function from business_rules_module.
            # This function should run a dry-run execution and return two lists: executed and skipped rule IDs.
            from business_rules_module import execute_rules_with_conflicts_composites_bfs
            executed, skipped = execute_rules_with_conflicts_composites_bfs(self.connection)
            logger.info("ETL Simulation completed: Executed: %s; Skipped: %s", executed, skipped)
            self.signals.finished.emit(executed, list(skipped))
        except Exception as ex:
            logger.exception("ETL Simulation error: %s", ex)
            self.signals.error.emit(str(ex))

# -----------------------------------------------------------------------------
# Main Application Window (BRM Tool)
# -----------------------------------------------------------------------------
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Integrated Production Ready")
        self.resize(1300, 850)

        self.connection = None
        self.user_id = None
        self.logged_in_username = None
        self.user_group = None

        # Create a thread pool for asynchronous tasks
        self.thread_pool = QThreadPool()

        # Step 1: Database Connection
        from core_module import DatabaseConnectionDialog  # Module 1: Core and Connection
        db_dialog = DatabaseConnectionDialog()
        if db_dialog.exec_() == QDialog.Accepted:
            self.connection = db_dialog.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Step 2: User Login
        from core_module import LoginDialog  # Module 1: Login
        login_dialog = LoginDialog(self.connection)
        if login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dialog.user_id
        self.user_group = login_dialog.user_group

        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID = ?", (self.user_id,))
        row = c.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "UnknownUser"

        # Optional Onboarding (if desired)
        # from core_module import OnboardingWizard
        # wizard = OnboardingWizard(self.connection)
        # wizard.exec_()

        self.init_ui()

    def init_ui(self):
        # Menu Bar Setup
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")

        # Sync Metadata Action
        from core_module import sync_metadata_improved
        sync_action = QAction("Sync Metadata", self)
        sync_action.triggered.connect(lambda: sync_metadata_improved(self.connection))
        file_menu.addAction(sync_action)

        # Run Data Validations Action
        run_val_action = QAction("Run Data Validations", self)
        run_val_action.triggered.connect(self.run_data_validations)
        file_menu.addAction(run_val_action)

        # ETL Simulation (Dry-Run) Action
        etl_sim_action = QAction("Run ETL Simulation (Dry-Run)", self)
        etl_sim_action.triggered.connect(self.run_etl_simulation)
        file_menu.addAction(etl_sim_action)

        # Help Menu
        help_menu = menubar.addMenu("Help")
        tips_action = QAction("Show Tips", self)
        tips_action.triggered.connect(self.show_tips)
        help_menu.addAction(tips_action)

        # Central Widget Setup with Tabs
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)

        # Admin Impersonation Bar (if Admin)
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            imp_layout.addWidget(QLabel("Impersonate:"))
            imp_layout.addWidget(self.switch_combo)
            imp_layout.addWidget(self.switch_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)
            self.load_user_switch_combo()

        # Create Tab Widget
        self.tabs = QTabWidget()

        # Business Rules Tab
        from business_rules_module import RuleDashboard, RuleEditorDialog, simulate_rule_dry_run
        self.rule_dashboard = RuleDashboard(self.connection, self.user_id, self.user_group)
        br_tab = QWidget()
        br_layout = QVBoxLayout(br_tab)
        # Action buttons
        action_layout = QHBoxLayout()
        add_rule_btn = QPushButton("Add Rule")
        add_rule_btn.clicked.connect(self.on_add_rule)
        action_layout.addWidget(add_rule_btn)
        update_rule_btn = QPushButton("Update Rule")
        update_rule_btn.clicked.connect(self.on_update_rule)
        action_layout.addWidget(update_rule_btn)
        delete_rule_btn = QPushButton("Delete Rule")
        delete_rule_btn.clicked.connect(self.on_delete_rule)
        action_layout.addWidget(delete_rule_btn)
        run_single_btn = QPushButton("Simulate Single Rule Dry-Run")
        run_single_btn.clicked.connect(self.simulate_single_rule)
        action_layout.addWidget(run_single_btn)
        action_layout.addStretch()
        br_layout.addLayout(action_layout)
        br_layout.addWidget(self.rule_dashboard)
        br_tab.setLayout(br_layout)
        self.tabs.addTab(br_tab, "Business Rules")

        # Approvals Tab
        from approvals_module import MultiStepApprovalTab
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")

        # Global/Critical Admin Tab (Admin Only)
        if self.user_group == "Admin":
            from gcr_module import GlobalCriticalAdminTab
            self.gcr_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_admin_tab, "Global/Critical Admin")

        # Hierarchy Tab
        from hierarchy_module import HierarchyViewTab
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy")

        # Advanced Lineage Tab
        from lineage_module import EnhancedLineageGraphWidget
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        self.tabs.addTab(self.lineage_tab, "Advanced Lineage")

        # Custom Groups Tab
        from custom_groups_and_alerts import CustomRuleGroupManager
        self.custom_groups_tab = CustomRuleGroupManager(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_groups_tab, "Custom Groups")

        # Scheduling Tab
        from scheduling_module import ScheduleManagementTab
        self.scheduling_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.scheduling_tab, "Scheduling")

        # Control Tables Tab
        from control_module import CtrlTablesTab
        self.control_tables_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.control_tables_tab, "Control Tables")

        # Metrics Tab
        from control_module import MetricsDashboardTab, GroupManagementTab, UserManagementTab
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics")

        # Alerts & Dashboards Tab
        from custom_groups_and_alerts import AlertsDashboard
        self.alerts_tab = AlertsDashboard(self.connection)
        self.tabs.addTab(self.alerts_tab, "Alerts & Dashboards")

        # Group Management Tab
        from control_module import GroupManagementTab
        self.group_management_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.group_management_tab, "Group Management")

        # User Management Tab (Admin Only)
        if self.user_group == "Admin":
            from control_module import UserManagementTab
            self.user_management_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_management_tab, "User Management")

        central_layout.addWidget(self.tabs)
        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)

        # Setup auto‑refresh timers
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approvals_timer.start(5000)

        self.scheduling_timer = QTimer(self)
        self.scheduling_timer.timeout.connect(self.check_due_schedules)
        self.scheduling_timer.start(60000)

    # ------------------- Menu Actions -------------------
    def run_data_validations(self):
        from control_module import run_data_validations  # production-ready validations
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Data Validations", "Data validations executed successfully.")
        except Exception as ex:
            logger.exception("Error running data validations: %s", ex)
            QMessageBox.critical(self, "Error", f"Error running data validations:\n{ex}")

    def run_etl_simulation(self):
        task = ETLSimulationTask(self.connection)
        task.signals.finished.connect(self.on_etl_simulation_finished)
        task.signals.error.connect(self.on_etl_simulation_error)
        self.thread_pool.start(task)
        QMessageBox.information(self, "ETL Simulation", "ETL Simulation started (dry-run). Check logs for details.")

    def on_etl_simulation_finished(self, executed, skipped):
        msg = f"ETL Simulation completed.\nExecuted: {len(executed)} rules.\nSkipped: {len(skipped)} rules."
        logger.info(msg)
        QMessageBox.information(self, "ETL Simulation Result", msg)
        self.rule_dashboard.load_rules()

    def on_etl_simulation_error(self, error_msg):
        logger.error("ETL Simulation error: %s", error_msg)
        QMessageBox.critical(self, "ETL Simulation Error", error_msg)

    def check_due_schedules(self):
        from scheduling_module import check_due_schedules  # production-ready schedule checker
        try:
            check_due_schedules(self.connection)
            self.scheduling_tab.load_schedules()
        except Exception as ex:
            logger.exception("Error checking schedules: %s", ex)

    def show_tips(self):
        tips = (
            f"BRM Tool – Integrated Version\nLogged in as: {self.logged_in_username} (Group: {self.user_group})\n\n"
            "Tabs:\n"
            "- Business Rules: Create, update, delete, and simulate rules.\n"
            "- Approvals: Manage multi‑level approvals.\n"
            "- Global/Critical Admin: (Admin only) Override and manage GCR linking.\n"
            "- Hierarchy: Drag‑and‑drop re‑parenting of rules.\n"
            "- Advanced Lineage: Visualize end‑to‑end lineage with ER‑style flow arrows.\n"
            "- Custom Groups: Manage custom rule groups with backup/restore.\n"
            "- Scheduling: Manage rule schedules.\n"
            "- Control Tables: View system control tables.\n"
            "- Metrics: View performance and usage metrics.\n"
            "- Alerts & Dashboards: Real‑time alerts for approvals, schedules, and performance.\n"
            "- Group/User Management: (Admin only) Manage users and business groups.\n"
        )
        QMessageBox.information(self, "Tips", tips)

    # ------------------- Business Rules Actions -------------------
    def on_add_rule(self):
        from business_rules_module import RuleEditorDialog
        dlg = RuleEditorDialog(self.connection, self.user_group, None, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dashboard.load_rules()

    def on_update_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if len(selected) != 1:
            QMessageBox.warning(self, "Selection Error", "Select exactly one rule to update.")
            return
        rid = selected[0]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Rule {rid} not found.")
            return
        colnames = [desc[0] for desc in c.description]
        rule_data = dict(zip(colnames, row))
        from business_rules_module import RuleEditorDialog
        dlg = RuleEditorDialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dashboard.load_rules()

    def on_delete_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            QMessageBox.warning(self, "Selection Error", "No rule selected for deletion.")
            return
        confirm = QMessageBox.question(self, "Confirm Deletion", f"Delete {len(selected)} selected rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        try:
            from business_rules_module import delete_rule
            for rid in selected:
                delete_rule(self.connection, rid, f"User:{self.user_id}", self.user_group)
            QMessageBox.information(self, "Deleted", f"Deleted {len(selected)} rule(s).")
            self.rule_dashboard.load_rules()
        except Exception as ex:
            logger.exception("Error deleting rules: %s", ex)
            QMessageBox.critical(self, "Error", f"Error deleting rules:\n{ex}")

    def simulate_single_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if len(selected) != 1:
            QMessageBox.warning(self, "Selection Error", "Select exactly one rule to simulate.")
            return
        rid = selected[0]
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL, OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Rule {rid} not found.")
            return
        sql_text, op_type = row
        from business_rules_module import simulate_rule_dry_run
        try:
            ok, msg, rec_count = simulate_rule_dry_run(self.connection, rid)
            result_msg = (f"Rule {rid} Simulation:\nResult: {'PASS' if ok else 'FAIL'}\n"
                          f"Message: {msg}\nRecords Impacted: {rec_count}")
            QMessageBox.information(self, "Simulation Result", result_msg)
        except Exception as ex:
            logger.exception("Error in single rule simulation: %s", ex)
            QMessageBox.critical(self, "Error", f"Error in simulation:\n{ex}")

    # ------------------- Impersonation -------------------
    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID = ?", (self.user_id,))
        row = c.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "UnknownUser"
        QMessageBox.information(self, "Switched", f"Now impersonating: {self.logged_in_username} ({self.user_group}).")
        # Refresh dependent tabs
        self.approvals_tab.logged_in_username = self.logged_in_username
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.rule_dashboard.user_id = self.user_id
        self.rule_dashboard.user_group = self.user_group
        self.rule_dashboard.load_rules()
        if hasattr(self, "gcr_admin_tab"):
            self.gcr_admin_tab.load_rule_list()
            self.gcr_admin_tab.load_link_view()
        if hasattr(self, "hierarchy_tab"):
            self.hierarchy_tab.load_hierarchy()
        if hasattr(self, "group_management_tab"):
            self.group_management_tab.user_id = self.user_id
            self.group_management_tab.user_group = self.user_group
            self.group_management_tab.load_data()
        if hasattr(self, "user_management_tab"):
            self.user_management_tab.load_users()

    def load_user_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for uid, uname, ugroup in c.fetchall():
            display = f"{uname} ({ugroup})"
            self.switch_combo.addItem(display, (uid, ugroup))

    # ------------------- Lineage Search -------------------
    def lineage_search_action(self):
        text = self.lineage_tab.search_lineage_text(text=self.lineage_tab.get_search_text())
        # In a full implementation, the EnhancedLineageGraphWidget would provide methods to highlight/dim nodes.
        # For example: self.lineage_tab.highlight_nodes(text)
        # Here we assume that method is implemented.
        # If no text is provided, reset view.
        if not text:
            self.lineage_tab.reset_view()

    # ------------------- Close Application -------------------
    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except Exception as ex:
                logger.exception("Error closing DB connection: %s", ex)
        event.accept()

# -----------------------------------------------------------------------------
# Main Launcher
# -----------------------------------------------------------------------------
def main():
    app = QApplication(sys.argv)
    tool = BRMTool()
    tool.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()