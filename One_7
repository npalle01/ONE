#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_decision_tables.py
Description:
  Provides comprehensive decision table management:
    • DecisionTableManager QDialog for listing/adding/updating/deleting
    • Execution method to “run” a decision table’s query
      – Could be integrated with BFS rule engine or called standalone
    • Logging results (optional) to DECISION_TABLE_EXEC_LOG or similar
    • Real-time UI updates for pass/fail, impacted records, etc.
"""

import sys
import logging
import json
from datetime import datetime
from collections import defaultdict

# PyQt5
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QMessageBox, QInputDialog, QLabel, QLineEdit, QTextEdit
)

import pyodbc

# from brm_core_foundation
from brm_core_foundation import logger


###############################################################################
# DecisionTableManager
###############################################################################
class DecisionTableManager(QDialog):
    """
    A dialog that manages a DECISION_TABLES table with columns:
      - DECISION_TABLE_ID (PK)
      - TABLE_NAME (string)
      - DESCRIPTION (string)
      - DECISION_QUERY (SQL to run, typically returning row[0]==1 => PASS)
    
    Features:
      - Add a new decision table (table name, desc, query).
      - Edit an existing decision table.
      - Delete a decision table.
      - Run (execute) it in a dry-run style => pass/fail => #records => store logs if desired.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Decision Table Manager (brm_decision_tables)")
        self.resize(700, 500)
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Table display
        self.dt_table = QTableWidget(0,4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","Table Name","Description","Query (DECISION_QUERY)"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        # Buttons
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_decision_table)
        btn_h.addWidget(add_btn)

        edit_btn = QPushButton("Edit Decision Table")
        edit_btn.clicked.connect(self.edit_decision_table)
        btn_h.addWidget(edit_btn)

        del_btn = QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.delete_decision_table)
        btn_h.addWidget(del_btn)

        run_btn = QPushButton("Run Decision Table")
        run_btn.clicked.connect(self.run_decision_table)
        btn_h.addWidget(run_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_decision_tables)
        btn_h.addWidget(ref_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        # Execution log area (optional)
        self.exec_log = QTextEdit()
        self.exec_log.setReadOnly(True)
        self.exec_log.setPlaceholderText("Execution Log...")
        layout.addWidget(self.exec_log)

        self.setLayout(layout)
        self.load_decision_tables()

    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_i = self.dt_table.rowCount()
                self.dt_table.insertRow(r_i)
                for col_i,val in enumerate(row):
                    it = QTableWidgetItem(str(val) if val else "")
                    self.dt_table.setItem(r_i, col_i, it)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading decision tables: {ex}")

    def add_decision_table(self):
        table_name, ok = QInputDialog.getText(self, "Add Decision Table", "Enter table name:")
        if not ok or not table_name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Description", "Optional description:")
        if not ok2:
            desc=""
        query, ok3 = QInputDialog.getMultiLineText(self, "Decision Query (SQL)", "SELECT 1 AS RESULT")
        if not ok3 or not query.strip():
            return

        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION, DECISION_QUERY)
                VALUES(?,?,?)
            """,(table_name.strip(), desc.strip(), query.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Decision table created.")
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Add error: {ex}")

    def edit_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No decision table selected.")
            return
        dt_id_it = self.dt_table.item(row,0)
        if not dt_id_it:
            return
        dt_id = int(dt_id_it.text())
        # fetch current
        c = self.connection.cursor()
        c.execute("SELECT TABLE_NAME, DESCRIPTION, DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        row_ = c.fetchone()
        if not row_:
            QMessageBox.warning(self,"Not Found",f"DT ID {dt_id} not found.")
            return
        old_table, old_desc, old_qry = row_

        new_table,ok = QInputDialog.getText(self,"Edit Table Name","", text=old_table if old_table else "")
        if not ok or not new_table.strip():
            return
        new_desc,ok2 = QInputDialog.getMultiLineText(self,"Edit Description","", text=old_desc if old_desc else "")
        if not ok2:
            new_desc=old_desc
        new_qry,ok3 = QInputDialog.getMultiLineText(self,"Edit SQL Query","", text=old_qry if old_qry else "")
        if not ok3 or not new_qry.strip():
            return

        try:
            c.execute("""
                UPDATE DECISION_TABLES
                SET TABLE_NAME=?, DESCRIPTION=?, DECISION_QUERY=?
                WHERE DECISION_TABLE_ID=?
            """,(new_table.strip(), new_desc.strip(), new_qry.strip(), dt_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Decision table {dt_id} updated.")
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Update error: {ex}")

    def delete_decision_table(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No table selected.")
            return
        dt_id_item=self.dt_table.item(row,0)
        dt_id=int(dt_id_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Decision table {dt_id} removed.")
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Delete error: {ex}")

    def run_decision_table(self):
        """
        Dry-run execution => if the query returns row[0]==1 => PASS, else FAIL.
        Logs # of records impacted, message, etc. Could be extended to BFS or partial commit.
        """
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No table selected.")
            return
        dt_id_it=self.dt_table.item(row,0)
        if not dt_id_it:
            return
        dt_id=int(dt_id_it.text())
        c=self.connection.cursor()
        c.execute("SELECT TABLE_NAME, DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        r_=c.fetchone()
        if not r_:
            QMessageBox.warning(self,"Not Found",f"No record for DT ID {dt_id}")
            return
        table_n, dec_qry = r_
        if not dec_qry or not dec_qry.strip():
            QMessageBox.warning(self,"No Query","That table has no DECISION_QUERY.")
            return

        c.execute("BEGIN TRANSACTION")
        success=False
        message=""
        rec_count=0
        try:
            c.execute(dec_qry)
            rows = c.fetchall()
            rec_count=len(rows)
            if rows and rows[0]:
                val = rows[0][0]
                success=(val==1)
                message=f"Returned: {val}"
            else:
                success=True
                message="No rows => PASS"
            # always rollback => it's a dry run
            c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success=False
            message=str(ex)

        # display
        final_msg=(f"DecisionTable {dt_id}: {'PASS' if success else 'FAIL'}\n"
                   f"Records: {rec_count}\nMessage: {message}\n")
        self.exec_log.append(final_msg)
        if success:
            QMessageBox.information(self,"Run DT",final_msg)
        else:
            QMessageBox.warning(self,"Run DT",final_msg)


###############################################################################
# End of brm_decision_tables
###############################################################################