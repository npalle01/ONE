#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: custom_rule_groups_and_alerts.py
Description:
  1) CustomRuleGroupEnhancedTab:
     • Allows creation, rename, delete of custom groups (table: BRM_CUSTOM_RULE_GROUPS).
     • Backup/restore group config (table: BRM_CUSTOM_GROUP_BACKUPS).
     • Assign/remove rules from a group, with color-coding to indicate rule properties:
       - Global rules (light blue)
       - Critical rules (light red)
       - Decision tables (pale yellow)
     • Real-time context menu for rule removal or forced lock/unlock.

  2) AlertsAndDashboardsTab:
     • Displays alerts on overdue approvals, upcoming schedules, performance issues,
       all auto-refreshed every minute.
     • Integrates partial real-time notifications (e.g., new pipeline failures).

Database Requirements (sample):
  - BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID pk, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP, etc.)
  - BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
  - BRM_CUSTOM_GROUP_BACKUPS(BACKUP_ID pk, CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON)
  - BRM_RULES(RULE_ID, RULE_NAME, IS_GLOBAL, CRITICAL_RULE, OPERATION_TYPE='DECISION_TABLE' or others, LOCKED_BY, etc.)
  - RULE_SCHEDULES, BRM_RULE_APPROVALS, RULE_PERF_STATS, etc. for the alerts portion.
"""

import sys
import json
import logging
import pyodbc
from datetime import datetime
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QListWidget, 
    QListWidgetItem, QPlainTextEdit, QPushButton, QLabel, QLineEdit, QMessageBox,
    QInputDialog, QMenu
)
from core_foundation import logger, insert_audit_log

# -----------------------------------------------------------------------------
# 1) CustomRuleGroupEnhancedTab
# -----------------------------------------------------------------------------
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Advanced interface for custom rule groups:
      - create, rename, delete
      - backup/restore
      - assign/remove rules
      - color-coded rule properties in the tree
      - real-time context menus for removal/force lock/unlock
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
        self.refresh_all()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Top controls for group creation/backup
        top_h = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        # Main horizontal splitter: left is group tree, right is available rules
        main_h = QHBoxLayout()

        # Left: Custom group tree
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        main_h.addWidget(self.group_tree, 1)

        # Right: available rules
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)

        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search available rules...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)

        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        right_layout.addWidget(self.rule_list)

        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)

        right_layout.addStretch()
        main_h.addWidget(right_widget, 1)

        layout.addLayout(main_h)
        self.setLayout(layout)

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.group_tree.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
                FROM BRM_CUSTOM_RULE_GROUPS
                ORDER BY CUSTOM_GROUP_ID DESC
            """)
            groups = c.fetchall()
            for (cgid, cgname, ownerbg) in groups:
                disp = f"{cgname} (Owner={ownerbg})"
                group_item = QTreeWidgetItem([disp])
                group_item.setData(0, Qt.UserRole, cgid)
                # color group item
                group_item.setBackground(0, QBrush(QColor("#E0E0E0")))
                self.group_tree.addTopLevelItem(group_item)

                # load assigned rules
                c2 = self.connection.cursor()
                c2.execute("""
                    SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE,
                           R.OPERATION_TYPE, R.LOCKED_BY
                    FROM BRM_CUSTOM_GROUP_MEMBERS M
                    JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
                    WHERE M.CUSTOM_GROUP_ID=?
                """,(cgid,))
                rule_rows = c2.fetchall()
                for (rid, rname, isg, crit, op_type, lby) in rule_rows:
                    txt = f"Rule {rid}: {rname}"
                    rule_item = QTreeWidgetItem([txt])
                    rule_item.setData(0, Qt.UserRole, rid)
                    # color coding
                    if isg==1:
                        rule_item.setBackground(0, QBrush(QColor("#D5EEFF"))) # light blue
                    if crit==1:
                        rule_item.setBackground(0, QBrush(QColor("#FFD1D1"))) # light red
                    if op_type and op_type.upper()=="DECISION_TABLE":
                        rule_item.setBackground(0, QBrush(QColor("#FFFFCC"))) # pale yellow
                    if lby:
                        rule_item.setToolTip(0, f"Locked by {lby}")
                    group_item.addChild(rule_item)

            self.group_tree.expandAll()
        except Exception as ex:
            logger.error(f"Error loading group tree: {ex}")
            QMessageBox.critical(self, "Group Tree Error", str(ex))

    def load_available_rules(self):
        self.rule_list.clear()
        search_term = self.rule_search_edit.text().strip()
        c = self.connection.cursor()
        try:
            if search_term:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                    FROM BRM_RULES
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """,(f"%{search_term}%",f"%{search_term}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """)
            rows = c.fetchall()

            # exclude already assigned
            c2 = self.connection.cursor()
            c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
            assigned = {r[0] for r in c2.fetchall()}

            for (rid, rn, og) in rows:
                if rid in assigned:
                    continue
                display = f"Rule {rid}: {rn} (Owner={og})"
                item = QListWidgetItem(display)
                item.setData(Qt.UserRole, rid)
                self.rule_list.addItem(item)

        except Exception as ex:
            logger.error(f"Error loading available rules: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            # context for a rule within a group
            menu = QMenu()
            remove_action = menu.addAction("Remove Rule from Group")
            lock_toggle_action = menu.addAction("Toggle Lock/Unlock")
            choice = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            group_id = parent.data(0, Qt.UserRole)
            rule_id = item.data(0, Qt.UserRole)
            if choice==remove_action:
                self.remove_rule_from_group(group_id, rule_id)
            elif choice==lock_toggle_action:
                self.toggle_lock(rule_id)
        else:
            # context for a group item
            pass

    def remove_rule_from_group(self, group_id, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
            """,(group_id, rule_id))
            self.connection.commit()
            QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error removing rule: {ex}")
            QMessageBox.critical(self, "Removal Error", str(ex))

    def toggle_lock(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", f"Rule {rule_id} not found.")
                return
            locked_by = row[0]
            if not locked_by:
                # lock
                new_lock = f"User:{self.user_id}"
                c.execute("""
                    UPDATE BRM_RULES
                    SET LOCK_STATUS=1, LOCKED_BY=?, LOCKED_AT=GETDATE()
                    WHERE RULE_ID=?
                """,(new_lock, rule_id))
                c.connection.commit()
                QMessageBox.information(self, "Locked", f"Rule {rule_id} now locked by {new_lock}.")
            else:
                # unlock if user is same or admin
                if locked_by==f"User:{self.user_id}" or self.user_group=="Admin":
                    c.execute("""
                        UPDATE BRM_RULES
                        SET LOCK_STATUS=0, LOCKED_BY=NULL, LOCKED_AT=NULL
                        WHERE RULE_ID=?
                    """,(rule_id,))
                    c.connection.commit()
                    QMessageBox.information(self, "Unlocked", f"Rule {rule_id} is now unlocked.")
                else:
                    QMessageBox.warning(self, "Locked", f"Rule {rule_id} is locked by {locked_by}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"toggle_lock error: {ex}")
            QMessageBox.critical(self, "Lock Error", str(ex))

    def create_group(self):
        gname = self.new_group_edit.text().strip()
        if not gname:
            QMessageBox.warning(self, "Input Error", "Please enter a group name.")
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_CUSTOM_RULE_GROUPS
                (CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """,(gname, self.user_group, f"User:{self.user_id}"))
            c.connection.commit()
            QMessageBox.information(self, "Created", f"Custom group '{gname}' created.")
            self.new_group_edit.clear()
            self.refresh_all()
        except Exception as ex:
            logger.error(f"create_group error: {ex}")
            QMessageBox.critical(self, "Create Error", str(ex))

    def rename_group(self):
        sel_items = self.group_tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "Select Group", "Please select a group to rename.")
            return
        group_item = sel_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        old_text = group_item.text(0)
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"Enter new name for '{old_text}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME=?
                WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(), group_id))
            c.connection.commit()
            QMessageBox.information(self, "Renamed", f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"rename_group error: {ex}")
            QMessageBox.critical(self, "Rename Error", str(ex))

    def delete_group(self):
        sel_items = self.group_tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "Selection Error", "Select a group to delete.")
            return
        group_item = sel_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        confirm = QMessageBox.question(self, "Confirm", f"Delete group ID {group_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            c.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group {group_id} deleted.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"delete_group error: {ex}")
            QMessageBox.critical(self, "Delete Error", str(ex))

    def backup_group(self):
        sel_items = self.group_tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "Selection Error", "Select a group to backup.")
            return
        group_item = sel_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", "Group not found.")
                return
            group_name = row[0]

            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            members = [r[0] for r in c.fetchall()]
            backup_data = {"group_name":group_name, "members":members}

            c.execute("""
                SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
                FROM BRM_CUSTOM_GROUP_BACKUPS
                WHERE CUSTOM_GROUP_ID=?
            """,(group_id,))
            version_row = c.fetchone()
            new_ver = version_row[0] if version_row else 1

            c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
                    CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON
                )
                VALUES(?, GETDATE(), ?, ?)
            """,(group_id, new_ver, json.dumps(backup_data)))
            c.connection.commit()
            QMessageBox.information(self, "Backup", f"Version {new_ver} created for group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"backup_group error: {ex}")
            QMessageBox.critical(self, "Backup Error", str(ex))

    def restore_group(self):
        sel_items = self.group_tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "Selection Error", "Select a group to restore.")
            return
        group_item = sel_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
                FROM BRM_CUSTOM_GROUP_BACKUPS
                WHERE CUSTOM_GROUP_ID=?
                ORDER BY BACKUP_VERSION DESC
            """,(group_id,))
            backups = c.fetchall()
            if not backups:
                QMessageBox.information(self, "No Backup", "No backups found for this group.")
                return
            items = [f"Version {b[0]} (ts={b[1]})" for b in backups]
            sel, ok = QInputDialog.getItem(self, "Restore Backup", "Select version:", items, 0, False)
            if not ok or not sel:
                return
            import re
            m = re.search(r"Version\s+(\d+)", sel)
            if not m:
                return
            ver = int(m.group(1))
            backup_json = None
            for b in backups:
                if b[0]==ver:
                    backup_json = b[2]
                    break
            if not backup_json:
                QMessageBox.warning(self, "Not Found", "Backup not found.")
                return
            confirm = QMessageBox.question(self, "Confirm", f"Restore group {group_id} to version {ver}?")
            if confirm!=QMessageBox.Yes:
                return

            # parse backup
            try:
                data = json.loads(backup_json)
            except Exception as ex:
                QMessageBox.critical(self, "JSON Error", str(ex))
                return

            new_group_name = data.get("group_name")
            members = data.get("members", [])
            c.execute("BEGIN TRANSACTION")
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME=?
                WHERE CUSTOM_GROUP_ID=?
            """,(new_group_name, group_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            for r in members:
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
                    VALUES(?,?)
                """,(group_id, r))
            c.execute("COMMIT")
            QMessageBox.information(self, "Restored", f"Group {group_id} restored to v{ver}.")
            self.refresh_all()

        except Exception as ex:
            c.execute("ROLLBACK")
            logger.error(f"restore_group error: {ex}")
            QMessageBox.critical(self, "Restore Error", str(ex))

    def assign_rules(self):
        sel_items = self.group_tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "No Group", "Please select a custom group from the tree.")
            return
        group_item = sel_items[0]
        parent_data = group_item.parent()
        if parent_data:
            # if user selected a rule item, climb up
            group_item = group_item.parent()
        group_id = group_item.data(0, Qt.UserRole)
        if not group_id:
            QMessageBox.warning(self, "Error", "Invalid group selected.")
            return
        sel_rules = self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self, "No Rules", "No rules selected from the list.")
            return
        c = self.connection.cursor()
        count = 0
        for item in sel_rules:
            rid = item.data(Qt.UserRole)
            try:
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
                    VALUES(?,?)
                """,(group_id, rid))
                count+=1
            except Exception:
                # might be unique constraint or other error
                pass
        c.connection.commit()
        QMessageBox.information(self, "Assigned", f"{count} rule(s) assigned to group {group_id}.")
        self.refresh_all()

# -----------------------------------------------------------------------------
# 2) AlertsAndDashboardsTab
# -----------------------------------------------------------------------------
class AlertsAndDashboardsTab(QWidget):
    """
    Displays overdue approvals (older than 3 days), upcoming schedules (next 24 hours),
    and performance alerts if rule perf stats exceed certain thresholds. 
    Auto-refresh every minute.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
        self.check_alerts()
        self.start_auto_refresh()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        refresh_btn = QPushButton("Refresh Alerts")
        refresh_btn.clicked.connect(self.check_alerts)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()

        # 1) Old approvals (older than 3 days)
        try:
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                       DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) as AgeDays
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.APPROVED_FLAG=0
                  AND A.APPROVAL_STAGE = (
                     SELECT MIN(APPROVAL_STAGE)
                     FROM BRM_RULE_APPROVALS
                     WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
                  )
                  AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE())>3
            """)
            old_approvals = c.fetchall()
            if old_approvals:
                lines.append("Approvals older than 3 days:")
                for (rid, stg, rnm, age) in old_approvals:
                    lines.append(f" - Rule {rid} (stage={stg}, {rnm}), age={age} days")
            else:
                lines.append("No approvals older than 3 days.")
        except Exception as ex:
            lines.append(f"Error checking old approvals: {ex}")

        lines.append("")

        # 2) Upcoming schedules (within next 24h)
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled'
                  AND SCHEDULE_TIME>=GETDATE()
                  AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            scheds = c.fetchall()
            if scheds:
                lines.append("Upcoming schedules (next 24h):")
                for (sid, rid, stime) in scheds:
                    lines.append(f" - Sched {sid}: rule {rid} at {stime}")
            else:
                lines.append("No upcoming schedules in the next 24 hours.")
        except Exception as ex:
            lines.append(f"Error checking schedules: {ex}")

        lines.append("")

        # 3) Performance alerts
        try:
            threshold_ms = 2000
            c.execute("""
                SELECT RULE_ID, AVG(EXEC_TIME_MS)
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY,-7,GETDATE()),112)
                GROUP BY RULE_ID
                HAVING AVG(EXEC_TIME_MS)>?
                ORDER BY AVG(EXEC_TIME_MS) DESC
            """,(threshold_ms,))
            perf_rows = c.fetchall()
            if perf_rows:
                lines.append("Performance Alerts (>2000 ms avg last 7 days):")
                for (rid,avg_ms) in perf_rows:
                    lines.append(f" - Rule {rid} => avg {avg_ms:.1f} ms")
            else:
                lines.append("No performance alerts (last 7 days).")
        except Exception as ex:
            lines.append(f"Error checking performance: {ex}")

        self.alert_text.setPlainText("\n".join(lines))
        logger.info("Alerts updated.")

    def start_auto_refresh(self):
        self.alert_timer = QTimer(self)
        self.alert_timer.timeout.connect(self.check_alerts)
        self.alert_timer.start(60000)  # every 60s