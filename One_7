#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: custom_rule_groups_and_alerts.py
Description:
  This module provides two major production‑ready components:
  
  1. CustomRuleGroupEnhancedTab:
     - Fully manages custom rule groups with advanced features:
         • Create, rename, delete custom groups.
         • Backup and restore groups with versioning.
         • Assign or remove rules from groups.
         • Real‑time context menu for rule locking/unlocking.
         • Deep integration with underlying rule properties (e.g. decision table flags,
           critical status, encryption state) with color‑coded visual cues.
  
  2. AlertsAndDashboardsTab:
     - Displays real‑time alerts and dashboards including:
         • Overdue approvals (older than 3 days).
         • Upcoming schedules (within 24 hours).
         • Performance alerts (e.g. high average execution times from RULE_PERF_STATS).
     - Auto‑refreshes every minute and provides detailed log messages.
     
Both components include robust error handling, detailed logging, and are designed to scale for large platforms with modern UI/UX requirements.
"""

import sys
import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QLabel,
    QLineEdit, QDialog, QMessageBox, QInputDialog, QComboBox, QMenu, QFileDialog
)

# Set up module logger
logger = logging.getLogger("custom_rule_groups_and_alerts")
logger.setLevel(logging.DEBUG)


# -----------------------------------------------------------------------------
# Custom Rule Group Enhanced Tab
# -----------------------------------------------------------------------------
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Provides an advanced interface for managing custom rule groups.
    Features:
      - Create, rename, delete custom groups.
      - Backup and restore group configuration (with versioning).
      - Assign and remove rules with full locking/unlocking support.
      - Real‑time context menus on the tree view allow for in‑place rule removal
        or forced lock/unlock actions.
      - Uses color‑coding to indicate special rule properties:
          • Global rules (light blue)
          • Critical rules (light red)
          • Decision table rules (pale yellow)
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Top controls for group creation/backup
        top_layout = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_layout.addWidget(self.new_group_edit)

        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_layout.addWidget(create_btn)

        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_layout.addWidget(rename_btn)

        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        top_layout.addWidget(delete_btn)

        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_layout.addWidget(backup_btn)

        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_layout.addWidget(restore_btn)

        top_layout.addStretch()
        layout.addLayout(top_layout)

        # Horizontal splitter layout: left is group tree; right is available rules list
        splitter_layout = QHBoxLayout()

        # Left: Custom Group Tree
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter_layout.addWidget(self.group_tree, 1)

        # Right: List of available rules to assign
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search available rules...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)

        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)

        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        right_layout.addStretch()
        splitter_layout.addWidget(right_widget, 1)

        layout.addLayout(splitter_layout)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.group_tree.clear()
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP 
                FROM BRM_CUSTOM_RULE_GROUPS 
                ORDER BY CUSTOM_GROUP_ID DESC
            """)
            groups = c.fetchall()
            for (group_id, group_name, owner) in groups:
                display_text = f"{group_name} (Owner={owner})"
                group_item = QTreeWidgetItem([display_text])
                group_item.setData(0, Qt.UserRole, group_id)
                group_item.setBackground(0, QBrush(QColor("lightgray")))
                self.group_tree.addTopLevelItem(group_item)

                # Load assigned rules for this group
                c2 = self.connection.cursor()
                c2.execute("""
                    SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE,
                           R.OPERATION_TYPE, R.LOCKED_BY
                    FROM BRM_CUSTOM_GROUP_MEMBERS M
                    JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
                    WHERE M.CUSTOM_GROUP_ID = ?
                """, (group_id,))
                rules = c2.fetchall()
                for (rule_id, rule_name, is_global, is_critical, op_type, locked_by) in rules:
                    rule_text = f"Rule {rule_id}: {rule_name}"
                    rule_item = QTreeWidgetItem([rule_text])
                    rule_item.setData(0, Qt.UserRole, rule_id)
                    # Apply color coding based on properties:
                    if is_global == 1:
                        rule_item.setBackground(0, QBrush(QColor("#D5EEFF")))  # light blue
                    if is_critical == 1:
                        rule_item.setBackground(0, QBrush(QColor("#FFD1D1")))  # light red
                    if op_type.upper() == "DECISION_TABLE":
                        rule_item.setBackground(0, QBrush(QColor("#FFFFCC")))  # pale yellow
                    # Append lock info if locked
                    if locked_by:
                        rule_item.setToolTip(0, f"Locked by {locked_by}")
                    group_item.addChild(rule_item)
            self.group_tree.expandAll()
        except Exception as ex:
            logger.error(f"Error loading group tree: {ex}")
            QMessageBox.critical(self, "Group Tree Error", str(ex))

    def load_available_rules(self):
        self.rule_list.clear()
        try:
            c = self.connection.cursor()
            search_term = self.rule_search_edit.text().strip()
            if search_term:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP 
                    FROM BRM_RULES 
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """, (f"%{search_term}%", f"%{search_term}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP 
                    FROM BRM_RULES 
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """)
            rows = c.fetchall()

            # Exclude rules that are already assigned
            c2 = self.connection.cursor()
            c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
            assigned = {row[0] for row in c2.fetchall()}

            for (rule_id, rule_name, owner) in rows:
                if rule_id in assigned:
                    continue
                display_text = f"Rule {rule_id}: {rule_name} (Owner={owner})"
                item = QListWidgetItem(display_text)
                item.setData(Qt.UserRole, rule_id)
                self.rule_list.addItem(item)
        except Exception as ex:
            logger.error(f"Error loading available rules: {ex}")
            QMessageBox.critical(self, "Available Rules Error", str(ex))

    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            # Context menu for a rule item within a group
            menu = QMenu()
            remove_action = menu.addAction("Remove Rule from Group")
            lock_action = menu.addAction("Toggle Lock/Unlock")
            choice = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            group_id = parent.data(0, Qt.UserRole)
            rule_id = item.data(0, Qt.UserRole)
            if choice == remove_action:
                self.remove_rule_from_group(group_id, rule_id)
            elif choice == lock_action:
                self.toggle_rule_lock(rule_id)
        else:
            # Context menu for a group item (if needed)
            pass

    def remove_rule_from_group(self, group_id, rule_id):
        try:
            c = self.connection.cursor()
            c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID = ? AND RULE_ID = ?
            """, (group_id, rule_id))
            self.connection.commit()
            QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error removing rule from group: {ex}")
            QMessageBox.critical(self, "Removal Error", str(ex))

    def toggle_rule_lock(self, rule_id):
        try:
            c = self.connection.cursor()
            c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", f"Rule {rule_id} not found.")
                return
            current_lock = row[0]
            if not current_lock:
                # Lock the rule
                lock_by = f"User:{self.user_id}"
                c.execute("""
                    UPDATE BRM_RULES
                    SET LOCKED_BY = ?, LOCKED_AT = GETDATE()
                    WHERE RULE_ID = ?
                """, (lock_by, rule_id))
                self.connection.commit()
                QMessageBox.information(self, "Locked", f"Rule {rule_id} is now locked by {lock_by}.")
            else:
                # Unlock if current user or if admin
                if current_lock == f"User:{self.user_id}" or self.user_group == "Admin":
                    c.execute("""
                        UPDATE BRM_RULES
                        SET LOCKED_BY = NULL, LOCKED_AT = NULL
                        WHERE RULE_ID = ?
                    """, (rule_id,))
                    self.connection.commit()
                    QMessageBox.information(self, "Unlocked", f"Rule {rule_id} is now unlocked.")
                else:
                    QMessageBox.warning(self, "Locked", f"Rule {rule_id} is locked by {current_lock}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error toggling rule lock: {ex}")
            QMessageBox.critical(self, "Lock Error", str(ex))

    def create_group(self):
        group_name = self.new_group_edit.text().strip()
        if not group_name:
            QMessageBox.warning(self, "Input Error", "Please enter a group name.")
            return
        try:
            c = self.connection.cursor()
            c.execute("""
                INSERT INTO BRM_CUSTOM_RULE_GROUPS(
                    CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP
                )
                VALUES(?,?,?,GETDATE())
            """, (group_name, self.user_group, f"User:{self.user_id}"))
            self.connection.commit()
            QMessageBox.information(self, "Created", f"Custom group '{group_name}' created successfully.")
            self.new_group_edit.clear()
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error creating custom group: {ex}")
            QMessageBox.critical(self, "Create Group Error", str(ex))

    def rename_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Selection Error", "Please select a group to rename.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        old_name = group_item.text(0)
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"Enter new name for group '{old_name}':")
        if not ok or not new_name.strip():
            return
        try:
            c = self.connection.cursor()
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME = ?
                WHERE CUSTOM_GROUP_ID = ?
            """, (new_name.strip(), group_id))
            self.connection.commit()
            QMessageBox.information(self, "Renamed", f"Group renamed to '{new_name.strip()}'.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error renaming custom group: {ex}")
            QMessageBox.critical(self, "Rename Group Error", str(ex))

    def delete_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Selection Error", "Please select a group to delete.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        confirm = QMessageBox.question(self, "Confirm", f"Are you sure you want to delete group ID {group_id}?")
        if confirm != QMessageBox.Yes:
            return
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group {group_id} deleted.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error deleting custom group: {ex}")
            QMessageBox.critical(self, "Delete Group Error", str(ex))

    def backup_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Selection Error", "Please select a group to backup.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        try:
            c = self.connection.cursor()
            c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Error", "Group not found.")
                return
            group_name = row[0]
            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            members = [r[0] for r in c.fetchall()]
            backup_data = {"group_name": group_name, "members": members}
            c.execute("""
                SELECT ISNULL(MAX(BACKUP_VERSION), 0) + 1
                FROM BRM_CUSTOM_GROUP_BACKUPS
                WHERE CUSTOM_GROUP_ID = ?
            """, (group_id,))
            rowv = c.fetchone()
            new_version = rowv[0] if rowv else 1
            c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
                    CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON
                )
                VALUES (?, GETDATE(), ?, ?)
            """, (group_id, new_version, json.dumps(backup_data)))
            self.connection.commit()
            QMessageBox.information(self, "Backup", f"Backup version {new_version} created for group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error backing up custom group: {ex}")
            QMessageBox.critical(self, "Backup Error", str(ex))

    def restore_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Selection Error", "Please select a group to restore.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
                FROM BRM_CUSTOM_GROUP_BACKUPS
                WHERE CUSTOM_GROUP_ID = ?
                ORDER BY BACKUP_VERSION DESC
            """, (group_id,))
            backups = c.fetchall()
            if not backups:
                QMessageBox.information(self, "No Backup", "No backups found for this group.")
                return
            items = [f"Version {b[0]} (ts={b[1]})" for b in backups]
            sel, ok = QInputDialog.getItem(self, "Restore Backup", "Select backup version:", items, 0, False)
            if not ok or not sel:
                return
            m = re.search(r"Version\s+(\d+)", sel)
            if not m:
                return
            version = int(m.group(1))
            backup_json = None
            for b in backups:
                if b[0] == version:
                    backup_json = b[2]
                    break
            if not backup_json:
                QMessageBox.warning(self, "Error", "Backup not found.")
                return
            confirm = QMessageBox.question(self, "Confirm", f"Restore group {group_id} to version {version}?")
            if confirm != QMessageBox.Yes:
                return
            try:
                backup_data = json.loads(backup_json)
            except Exception as ex:
                QMessageBox.critical(self, "JSON Error", f"Error parsing backup data: {ex}")
                return
            new_group_name = backup_data.get("group_name")
            members = backup_data.get("members", [])
            c.execute("BEGIN TRANSACTION")
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME = ?
                WHERE CUSTOM_GROUP_ID = ?
            """, (new_group_name, group_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            for member_rule in members:
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
                    VALUES (?, ?)
                """, (group_id, member_rule))
            c.execute("COMMIT")
            QMessageBox.information(self, "Restored", f"Group {group_id} restored to version {version}.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            logger.error(f"Error restoring custom group: {ex}")
            QMessageBox.critical(self, "Restore Error", str(ex))

    def assign_rules(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Selection Error", "Please select a custom group from the tree.")
            return
        group_item = selected_items[0]
        if group_item.parent():
            group_item = group_item.parent()
        group_id = group_item.data(0, Qt.UserRole)
        if not group_id:
            QMessageBox.warning(self, "Error", "No valid group selected.")
            return
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "Selection Error", "No rules selected from the available list.")
            return
        try:
            c = self.connection.cursor()
            count = 0
            for item in selected_rules:
                rule_id = item.data(Qt.UserRole)
                try:
                    c.execute("""
                        INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
                        VALUES (?, ?)
                    """, (group_id, rule_id))
                    count += 1
                except Exception:
                    # Skip duplicates or errors
                    continue
            self.connection.commit()
            QMessageBox.information(self, "Assigned", f"{count} rule(s) assigned to group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error assigning rules to group: {ex}")
            QMessageBox.critical(self, "Assignment Error", str(ex))


# -----------------------------------------------------------------------------
# Alerts and Dashboards Tab
# -----------------------------------------------------------------------------
class AlertsAndDashboardsTab(QWidget):
    """
    Displays comprehensive alerts and dashboard information including:
      - Approvals older than 3 days.
      - Upcoming schedules within the next 24 hours.
      - Performance alerts based on RULE_PERF_STATS (if avg exec time or memory usage exceeds thresholds).
      - Real‑time auto‑refresh (every minute) with detailed logs.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
        self.check_alerts()
        self.start_auto_refresh()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        refresh_btn = QPushButton("Refresh Alerts")
        refresh_btn.clicked.connect(self.check_alerts)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()

        # Old approvals (older than 3 days)
        try:
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                       DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) AS AgeDays
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.APPROVED_FLAG = 0
                  AND A.APPROVAL_STAGE = (
                      SELECT MIN(APPROVAL_STAGE)
                      FROM BRM_RULE_APPROVALS
                      WHERE RULE_ID = A.RULE_ID AND APPROVED_FLAG = 0
                  )
                  AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) > 3
            """)
            old_approvals = c.fetchall()
            if old_approvals:
                lines.append("Approvals older than 3 days:")
                for (rule_id, stage, rule_name, age) in old_approvals:
                    lines.append(f" - Rule {rule_id} (Stage {stage}, {rule_name}): {age} days old")
            else:
                lines.append("No approvals older than 3 days.")
        except Exception as ex:
            lines.append(f"Error checking old approvals: {ex}")

        lines.append("")

        # Upcoming schedules (next 24 hours)
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS = 'Scheduled'
                  AND SCHEDULE_TIME >= GETDATE()
                  AND SCHEDULE_TIME <= DATEADD(HOUR, 24, GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules = c.fetchall()
            if schedules:
                lines.append("Upcoming schedules in next 24 hours:")
                for (sched_id, rule_id, sched_time) in schedules:
                    lines.append(f" - Schedule {sched_id}: Rule {rule_id} at {sched_time}")
            else:
                lines.append("No upcoming schedules within 24 hours.")
        except Exception as ex:
            lines.append(f"Error checking schedules: {ex}")

        lines.append("")

        # Performance alerts (using RULE_PERF_STATS or RULE_EXECUTION_LOGS)
        threshold_ms = 2000  # 2 sec threshold
        try:
            c.execute("""
                SELECT RULE_ID, AVG(EXEC_TIME_MS) as AvgTime
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY, -7, GETDATE()), 112)
                GROUP BY RULE_ID
                HAVING AVG(EXEC_TIME_MS) > ?
                ORDER BY AvgTime DESC
            """, (threshold_ms,))
            perf_alerts = c.fetchall()
            if perf_alerts:
                lines.append("Performance Alerts (Avg Exec Time > 2000 ms in last 7 days):")
                for (rule_id, avg_time) in perf_alerts:
                    lines.append(f" - Rule {rule_id}: Avg Exec Time = {avg_time:.2f} ms")
            else:
                lines.append("No performance alerts detected.")
        except Exception as ex:
            lines.append(f"Error checking performance alerts: {ex}")

        # Display the alerts log in the text area
        self.alert_text.setPlainText("\n".join(lines))
        logger.info("Alerts checked and updated.")

    def start_auto_refresh(self):
        self.alert_timer = QTimer(self)
        self.alert_timer.timeout.connect(self.check_alerts)
        self.alert_timer.start(60000)  # Refresh every 60 seconds

# -----------------------------------------------------------------------------
# End of Module 7
# -----------------------------------------------------------------------------

if __name__ == '__main__':
    # For testing purposes: open a window with two tabs.
    from PyQt5.QtWidgets import QApplication, QTabWidget
    app = QApplication(sys.argv)
    try:
        conn = pyodbc.connect("DSN=YourDSN;Trusted_Connection=yes;")
    except Exception as e:
        QMessageBox.critical(None, "DB Connection Error", f"Error connecting to DB: {e}")
        sys.exit(1)
    tabs = QTabWidget()
    tabs.addTab(CustomRuleGroupEnhancedTab(conn, "AdminUser", "Admin"), "Custom Rule Groups")
    tabs.addTab(AlertsAndDashboardsTab(conn, "AdminUser", "Admin"), "Alerts & Dashboards")
    tabs.resize(1000, 700)
    tabs.show()
    sys.exit(app.exec_())