# custom_groups_and_alerts.py
"""
Module 7 – Custom Rule Groups and Alerts/Dashboards

This module provides:
  • A fully featured Custom Rule Group Manager with:
      – Creating, renaming, and deleting custom groups.
      – Viewing custom groups with their assigned rules in a hierarchical QTreeWidget.
      – Backup and restore functionality (with versioning) for custom groups.
      – Assigning available rules (from BRM_RULES) to custom groups.
      – Context menu actions for removal and lock/unlock operations.
  • An Alerts and Dashboards panel that:
      – Aggregates alerts from various sources (old approvals, upcoming schedules, performance trends).
      – Displays real‑time notifications.
      – Uses robust error handling and logging.
      
All UI elements are implemented with PyQt5. The module assumes a production‑ready database connection is passed in.
"""

import sys
import json
import logging
import re
from datetime import datetime

from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QListWidget,
    QListWidgetItem, QPushButton, QLabel, QLineEdit, QInputDialog, QMessageBox,
    QPlainTextEdit, QComboBox, QMenu, QApplication
)

# Setup module logger
logger = logging.getLogger("CustomGroupsAndAlerts")
logger.setLevel(logging.DEBUG)
if not logger.handlers:
    ch = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s:%(levelname)s:%(name)s:%(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)


# =============================================================================
# CustomRuleGroupManager: Manages custom groups and rule assignments
# =============================================================================
class CustomRuleGroupManager(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # Top control buttons for group management
        control_layout = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        control_layout.addWidget(self.new_group_edit)
        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        control_layout.addWidget(create_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        control_layout.addWidget(rename_btn)
        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        control_layout.addWidget(delete_btn)
        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        control_layout.addWidget(backup_btn)
        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        control_layout.addWidget(restore_btn)
        control_layout.addStretch()
        layout.addLayout(control_layout)

        # Horizontal layout: Left – custom group tree; Right – available rules list
        main_h_layout = QHBoxLayout()

        # Left side: Custom Group Tree
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        main_h_layout.addWidget(self.group_tree, 1)

        # Right side: Available Rules list
        right_layout = QVBoxLayout()
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search available rules...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)
        self.available_rules_list = QListWidget()
        self.available_rules_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.available_rules_list)
        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        main_h_layout.addLayout(right_layout, 1)

        layout.addLayout(main_h_layout)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        """Load custom groups and their assigned rules from the database."""
        try:
            self.group_tree.clear()
            c = self.connection.cursor()
            c.execute("""
                SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP 
                FROM BRM_CUSTOM_RULE_GROUPS 
                ORDER BY CUSTOM_GROUP_ID DESC
            """)
            groups = c.fetchall()
            for group_id, group_name, owner in groups:
                display_text = f"{group_name} (Owner: {owner})"
                group_item = QTreeWidgetItem([display_text])
                group_item.setData(0, Qt.UserRole, group_id)
                group_item.setBackground(0, QBrush(QColor("lightgray")))
                # Retrieve assigned rules for the group
                c.execute("""
                    SELECT M.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE, R.OPERATION_TYPE, R.LOCKED_BY 
                    FROM BRM_CUSTOM_GROUP_MEMBERS M 
                    JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID 
                    WHERE M.CUSTOM_GROUP_ID = ?
                """, (group_id,))
                rules = c.fetchall()
                for rule in rules:
                    rule_id, rule_name, is_global, is_critical, op_type, locked_by = rule
                    rule_display = f"Rule {rule_id}: {rule_name}"
                    rule_item = QTreeWidgetItem([rule_display])
                    rule_item.setData(0, Qt.UserRole, rule_id)
                    # Color code based on properties
                    if is_global == 1:
                        rule_item.setBackground(0, QBrush(QColor("#D5EEFF")))  # light blue
                    if is_critical == 1:
                        rule_item.setBackground(0, QBrush(QColor("#FFD1D1")))  # light red
                    if op_type == "DECISION_TABLE":
                        rule_item.setBackground(0, QBrush(QColor("#FFFFCC")))  # pale yellow
                    if locked_by:
                        rule_item.setToolTip(0, f"Locked by {locked_by}")
                    group_item.addChild(rule_item)
                self.group_tree.addTopLevelItem(group_item)
            self.group_tree.expandAll()
            logger.info("Custom group tree loaded successfully.")
        except Exception as ex:
            logger.exception("Error loading custom group tree: %s", ex)
            QMessageBox.critical(self, "Error", f"Error loading custom group tree:\n{ex}")

    def load_available_rules(self):
        """Load rules from BRM_RULES that are not yet assigned to any custom group."""
        try:
            self.available_rules_list.clear()
            search_text = self.rule_search_edit.text().strip()
            c = self.connection.cursor()
            if search_text:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP 
                    FROM BRM_RULES 
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ? 
                    ORDER BY RULE_ID DESC 
                    OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """, (f"%{search_text}%", f"%{search_text}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP 
                    FROM BRM_RULES 
                    ORDER BY RULE_ID DESC 
                    OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """)
            rules = c.fetchall()
            # Exclude rules already assigned
            c.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
            assigned = {row[0] for row in c.fetchall()}
            for rule_id, rule_name, owner in rules:
                if rule_id in assigned:
                    continue
                display = f"Rule {rule_id}: {rule_name} (Owner: {owner})"
                item = QListWidgetItem(display)
                item.setData(Qt.UserRole, rule_id)
                self.available_rules_list.addItem(item)
            logger.info("Available rules loaded successfully.")
        except Exception as ex:
            logger.exception("Error loading available rules: %s", ex)
            QMessageBox.critical(self, "Error", f"Error loading available rules:\n{ex}")

    def create_group(self):
        group_name = self.new_group_edit.text().strip()
        if not group_name:
            QMessageBox.warning(self, "Input Error", "Please enter a group name.")
            return
        try:
            c = self.connection.cursor()
            # Default owner is current user’s group
            c.execute("""
                INSERT INTO BRM_CUSTOM_RULE_GROUPS (CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP)
                VALUES (?, ?, ?, GETDATE())
            """, (group_name, self.user_group, f"User:{self.user_id}"))
            self.connection.commit()
            logger.info("Custom group '%s' created.", group_name)
            QMessageBox.information(self, "Success", f"Custom group '{group_name}' created.")
            self.new_group_edit.clear()
            self.refresh_all()
        except Exception as ex:
            logger.exception("Error creating custom group: %s", ex)
            QMessageBox.critical(self, "Error", f"Error creating custom group:\n{ex}")

    def rename_group(self):
        group_id, group_disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "Selection Error", "Please select a custom group to rename.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for '{group_disp}':")
        if not ok or not new_name.strip():
            return
        try:
            c = self.connection.cursor()
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME = ?
                WHERE CUSTOM_GROUP_ID = ?
            """, (new_name.strip(), group_id))
            self.connection.commit()
            logger.info("Custom group %s renamed to '%s'.", group_id, new_name.strip())
            QMessageBox.information(self, "Renamed", f"Custom group renamed to '{new_name.strip()}'.")
            self.refresh_all()
        except Exception as ex:
            logger.exception("Error renaming custom group: %s", ex)
            QMessageBox.critical(self, "Error", f"Error renaming custom group:\n{ex}")

    def delete_group(self):
        group_id, group_disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "Selection Error", "Please select a custom group to delete.")
            return
        confirm = QMessageBox.question(self, "Confirm Delete", f"Are you sure you want to delete group '{group_disp}'?")
        if confirm != QMessageBox.Yes:
            return
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            self.connection.commit()
            logger.info("Custom group %s deleted.", group_id)
            QMessageBox.information(self, "Deleted", f"Custom group '{group_disp}' deleted.")
            self.refresh_all()
        except Exception as ex:
            logger.exception("Error deleting custom group: %s", ex)
            QMessageBox.critical(self, "Error", f"Error deleting custom group:\n{ex}")

    def backup_group(self):
        group_id, group_disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "Selection Error", "Please select a group to backup.")
            return
        try:
            c = self.connection.cursor()
            c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Error", "Group not found.")
                return
            group_name = row[0]
            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            members = [r[0] for r in c.fetchall()]
            backup_data = {"group_name": group_name, "members": members}
            c.execute("SELECT ISNULL(MAX(BACKUP_VERSION), 0) + 1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            new_version = c.fetchone()[0]
            c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_BACKUPS (CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON)
                VALUES (?, GETDATE(), ?, ?)
            """, (group_id, new_version, json.dumps(backup_data)))
            self.connection.commit()
            logger.info("Backup for group %s version %s created.", group_id, new_version)
            QMessageBox.information(self, "Backup Created", f"Backup version {new_version} for group '{group_disp}' created.")
            self.refresh_all()
        except Exception as ex:
            logger.exception("Error creating backup: %s", ex)
            QMessageBox.critical(self, "Error", f"Error creating backup:\n{ex}")

    def restore_group(self):
        group_id, group_disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "Selection Error", "Please select a group to restore.")
            return
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
                FROM BRM_CUSTOM_GROUP_BACKUPS
                WHERE CUSTOM_GROUP_ID = ?
                ORDER BY BACKUP_VERSION DESC
            """, (group_id,))
            backups = c.fetchall()
            if not backups:
                QMessageBox.information(self, "No Backups", "No backups found for the selected group.")
                return
            items = [f"Version {b[0]} (ts={b[1]})" for b in backups]
            selected_item, ok = QInputDialog.getItem(self, "Restore Backup", "Select backup version:", items, 0, False)
            if not ok or not selected_item:
                return
            m = re.search(r"Version\s+(\d+)", selected_item)
            if not m:
                return
            version_to_restore = int(m.group(1))
            backup_json = None
            for b in backups:
                if b[0] == version_to_restore:
                    backup_json = b[2]
                    break
            if not backup_json:
                QMessageBox.warning(self, "Error", "Selected backup not found.")
                return
            confirm = QMessageBox.question(self, "Confirm Restore", f"Restore group '{group_disp}' to version {version_to_restore}?")
            if confirm != QMessageBox.Yes:
                return
            data = json.loads(backup_json)
            new_group_name = data.get("group_name")
            members = data.get("members", [])
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME = ? WHERE CUSTOM_GROUP_ID = ?", (new_group_name, group_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            for rule_id in members:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS (CUSTOM_GROUP_ID, RULE_ID) VALUES (?, ?)", (group_id, rule_id))
            c.execute("COMMIT")
            self.connection.commit()
            logger.info("Group %s restored to version %s.", group_id, version_to_restore)
            QMessageBox.information(self, "Restored", f"Group '{group_disp}' restored to version {version_to_restore}.")
            self.refresh_all()
        except Exception as ex:
            try:
                c.execute("ROLLBACK")
            except:
                pass
            logger.exception("Error restoring group: %s", ex)
            QMessageBox.critical(self, "Error", f"Error restoring group:\n{ex}")

    def assign_rules(self):
        group_id, group_disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "Selection Error", "Please select a custom group from the tree.")
            return
        selected_items = self.available_rules_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Selection Error", "No rules selected to assign.")
            return
        c = self.connection.cursor()
        count = 0
        for item in selected_items:
            rule_id = item.data(Qt.UserRole)
            try:
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS (CUSTOM_GROUP_ID, RULE_ID)
                    VALUES (?, ?)
                """, (group_id, rule_id))
                count += 1
            except Exception as ex:
                logger.error("Error assigning rule %s to group %s: %s", rule_id, group_id, ex)
                continue
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"{count} rule(s) assigned to group '{group_disp}'.")
        self.refresh_all()

    def get_selected_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            return (None, None)
        item = selected_items[0]
        # If a rule is selected, then its parent is the group
        if item.parent():
            item = item.parent()
        group_id = item.data(0, Qt.UserRole)
        group_text = item.text(0)
        return (group_id, group_text)

    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        # If a rule is selected under a group, offer removal and lock/unlock options
        if parent:
            menu = QMenu(self)
            remove_action = menu.addAction("Remove Rule from Group")
            lock_action = menu.addAction("Toggle Lock for Rule")
            chosen = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if chosen == remove_action:
                group_id = parent.data(0, Qt.UserRole)
                rule_id = item.data(0, Qt.UserRole)
                self.remove_rule_from_group(group_id, rule_id)
            elif chosen == lock_action:
                rule_id = item.data(0, Qt.UserRole)
                self.toggle_rule_lock(rule_id)
        # If a group (top-level) is right-clicked, no additional actions are provided.
        else:
            pass

    def remove_rule_from_group(self, group_id, rule_id):
        try:
            c = self.connection.cursor()
            c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID = ? AND RULE_ID = ?
            """, (group_id, rule_id))
            self.connection.commit()
            logger.info("Removed rule %s from group %s.", rule_id, group_id)
            QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group.")
            self.refresh_all()
        except Exception as ex:
            logger.exception("Error removing rule from group: %s", ex)
            QMessageBox.critical(self, "Error", f"Error removing rule:\n{ex}")

    def toggle_rule_lock(self, rule_id):
        try:
            c = self.connection.cursor()
            c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", "Rule not found.")
                return
            current_lock = row[0]
            if not current_lock:
                # Lock the rule by current user
                c.execute("""
                    UPDATE BRM_RULES SET LOCKED_BY = ?,
                    LOCKED_AT = GETDATE()
                    WHERE RULE_ID = ?
                """, (f"User:{self.user_id}", rule_id))
                self.connection.commit()
                QMessageBox.information(self, "Locked", f"Rule {rule_id} is now locked.")
            else:
                # If locked by current user or if admin, unlock it
                if current_lock == f"User:{self.user_id}" or self.user_group == "Admin":
                    c.execute("""
                        UPDATE BRM_RULES SET LOCKED_BY = NULL,
                        LOCKED_AT = NULL
                        WHERE RULE_ID = ?
                    """, (rule_id,))
                    self.connection.commit()
                    QMessageBox.information(self, "Unlocked", f"Rule {rule_id} has been unlocked.")
                else:
                    QMessageBox.warning(self, "Locked", f"Rule {rule_id} is locked by another user ({current_lock}).")
            self.refresh_all()
        except Exception as ex:
            logger.exception("Error toggling rule lock: %s", ex)
            QMessageBox.critical(self, "Error", f"Error toggling lock:\n{ex}")

# =============================================================================
# AlertsDashboard: Displays aggregated alerts for approvals, schedules, and performance.
# =============================================================================
class AlertsDashboard(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        alerts = []
        c = self.connection.cursor()
        try:
            # Approvals older than 3 days
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                       DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) AS Age
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.APPROVED_FLAG = 0
                  AND A.APPROVAL_STAGE = (
                        SELECT MIN(APPROVAL_STAGE)
                        FROM BRM_RULE_APPROVALS
                        WHERE RULE_ID = A.RULE_ID AND APPROVED_FLAG = 0
                  )
                  AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) > 3
            """)
            approvals = c.fetchall()
            if approvals:
                alerts.append("Approvals older than 3 days:")
                for rid, stage, name, age in approvals:
                    alerts.append(f"  - Rule {rid} ({name}), Stage: {stage}, Age: {age} days")
            else:
                alerts.append("No stale approvals found.")

            alerts.append("")

            # Upcoming schedules in next 24 hours
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS = 'Scheduled'
                  AND SCHEDULE_TIME >= GETDATE()
                  AND SCHEDULE_TIME <= DATEADD(HOUR, 24, GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules = c.fetchall()
            if schedules:
                alerts.append("Upcoming schedules within 24 hours:")
                for sid, rid, sch_time in schedules:
                    alerts.append(f"  - Schedule {sid}: Rule {rid} at {sch_time}")
            else:
                alerts.append("No upcoming schedules within 24 hours.")

            alerts.append("")

            # Performance alerts: if average execution time > threshold in last 7 days
            threshold_ms = 2000  # 2 seconds
            c.execute("""
                SELECT RULE_ID, AVG(EXECUTION_TIME_MS) AS AvgTime
                FROM RULE_PERF_STATS
                WHERE CREATED_TS >= DATEADD(DAY, -7, GETDATE())
                GROUP BY RULE_ID
                HAVING AVG(EXECUTION_TIME_MS) > ?
            """, (threshold_ms,))
            perf = c.fetchall()
            if perf:
                alerts.append("Performance alerts (avg exec time > 2000ms in last 7 days):")
                for rid, avg_time in perf:
                    alerts.append(f"  - Rule {rid}: Avg Exec Time = {avg_time:.2f} ms")
            else:
                alerts.append("No performance issues detected.")

            self.alert_text.setPlainText("\n".join(alerts))
            logger.info("Alerts checked successfully.")
        except Exception as ex:
            logger.exception("Error checking alerts: %s", ex)
            self.alert_text.setPlainText(f"Error checking alerts:\n{ex}")

# =============================================================================
# Expose Module Classes
# =============================================================================
__all__ = [
    "CustomRuleGroupManager",
    "AlertsDashboard"
]

if __name__ == "__main__":
    # Standalone test for Module 7
    try:
        import pyodbc
        # Replace with an actual connection string or DSN.
        connection = pyodbc.connect("DSN=YourDSN;Trusted_Connection=yes;")
    except Exception as ex:
        logger.error("Database connection error: %s", ex)
        sys.exit(1)

    app = QApplication(sys.argv)
    main_widget = QWidget()
    layout = QVBoxLayout(main_widget)
    
    # Create tabs for custom groups and alerts
    tab_widget = QTabWidget()
    custom_group_manager = CustomRuleGroupManager(connection, user_id=1, user_group="Admin")
    alerts_dashboard = AlertsDashboard(connection)
    tab_widget.addTab(custom_group_manager, "Custom Groups")
    tab_widget.addTab(alerts_dashboard, "Alerts & Dashboards")
    
    layout.addWidget(tab_widget)
    main_widget.setLayout(layout)
    main_widget.setWindowTitle("Custom Groups & Alerts Module Test")
    main_widget.resize(1000, 600)
    main_widget.show()
    sys.exit(app.exec_())