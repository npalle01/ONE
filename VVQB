#!/usr/bin/env python3
# vqb_master_integrated.py
#
# Single-file Python/PyQt Visual Query Builder with fixes:
#   - Missing QInputDialog import added
#   - Removed duplicate BFS sub-VQB classes
#   - Ensured references match actual class names
#   - Code should run without crash if all imports and DB drivers are installed

import sys
import traceback
import logging
import pyodbc
import sqlparse
import sqlglot
from sqlglot import exp

import matplotlib
matplotlib.use("Agg")  # for no display environment
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QPointF, QTimer, QThreadPool, QRunnable, pyqtSignal, QObject,
    QRegularExpression
)
from PyQt5.QtGui import (
    QPalette, QColor, QPen, QBrush, QFont, QSyntaxHighlighter, QTextCharFormat
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeWidget, QTreeWidgetItem, QTextEdit, QPushButton, QSplitter,
    QLineEdit, QLabel, QDialog, QFormLayout, QComboBox, QTableWidget,
    QTableWidgetItem, QTabWidget, QMessageBox, QGraphicsView,
    QGraphicsScene, QGraphicsRectItem, QGraphicsTextItem, QGraphicsItem,
    QGraphicsLineItem, QProgressBar, QDialogButtonBox, QStatusBar,
    QGroupBox, QAbstractItemView, QSpinBox, QMenu, QFrame, QAction,
    QListWidget, QCheckBox, QHeaderView, QInputDialog  # <--- IMPORTANT FIX
)

###############################################################################
# Logging + "Fusion" style
###############################################################################
logging.basicConfig(
    filename="vqb.log",
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.DEBUG
)
pyodbc.pooling = True

def apply_fusion_style():
    QApplication.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(240,240,240))
    palette.setColor(QPalette.WindowText, Qt.black)
    palette.setColor(QPalette.Base, QColor(255,255,255))
    palette.setColor(QPalette.AlternateBase, QColor(225,225,225))
    palette.setColor(QPalette.Button, QColor(230,230,230))
    palette.setColor(QPalette.ButtonText, Qt.black)
    palette.setColor(QPalette.Highlight, QColor(76,163,224))
    palette.setColor(QPalette.HighlightedText, Qt.white)
    QApplication.setPalette(palette)

    style_sheet = """
        QCheckBox::indicator, QRadioButton::indicator {
            width: 12px;
            height: 12px;
            spacing: 2px;
        }
    """
    QApplication.instance().setStyleSheet(style_sheet)

###############################################################################
# ODBC + multi-conn
###############################################################################
class ODBCConnectDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._conn = None
        self._db_type = None
        self.setWindowTitle("Connect ODBC DSN")
        self.resize(400,230)

        lay = QVBoxLayout(self)
        lay.addWidget(QLabel("ODBC DSN:"))
        self.dsn_combo = QComboBox()
        try:
            dsns = pyodbc.dataSources()
            for dsn in sorted(dsns.keys()):
                self.dsn_combo.addItem(dsn)
        except:
            pass
        lay.addWidget(self.dsn_combo)

        lay.addWidget(QLabel("Username (optional):"))
        self.user_edit = QLineEdit()
        lay.addWidget(self.user_edit)

        lay.addWidget(QLabel("Password (optional):"))
        self.pass_edit = QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        lay.addWidget(self.pass_edit)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        lay.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(lay)

    def on_ok(self):
        dsn = self.dsn_combo.currentText().strip()
        if not dsn:
            QMessageBox.warning(self, "Missing DSN", "Pick a DSN.")
            return
        user = self.user_edit.text().strip()
        pwd = self.pass_edit.text().strip()
        conn_str = f"DSN={dsn};"
        if user:
            conn_str += f"UID={user};"
        if pwd:
            conn_str += f"PWD={pwd};"

        try:
            cn = pyodbc.connect(conn_str, autocommit=True)
            self._conn = cn
            try:
                dbms = cn.getinfo(pyodbc.SQL_DBMS_NAME) or ""
                if "TERADATA" in dbms.upper():
                    self._db_type = "Teradata"
                elif "SQL SERVER" in dbms.upper():
                    self._db_type = "SQLServer"
                else:
                    self._db_type = dbms.strip()
            except:
                self._db_type = "Unknown"
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Connect Error", f"Failed:\n{ex}")

    def get_connection(self):
        return self._conn
    def get_db_type(self):
        return self._db_type

class MultiODBCConnectDialog(QDialog):
    def __init__(self, existing_conns=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Manage DB Connections")
        self.resize(500,300)
        self._connections = existing_conns if existing_conns else {}

        main = QVBoxLayout(self)
        instruct = QLabel(
            "Add or remove ODBC connections.\n"
            "Each connection is assigned an alias => used as 'linked server' prefix."
        )
        main.addWidget(instruct)

        self.conn_table = QTableWidget(0,3)
        self.conn_table.setHorizontalHeaderLabels(["Alias","DB Type","Status"])
        self.conn_table.horizontalHeader().setStretchLastSection(True)
        main.addWidget(self.conn_table)

        for alias, info in self._connections.items():
            r = self.conn_table.rowCount()
            self.conn_table.insertRow(r)
            self.conn_table.setItem(r,0,QTableWidgetItem(alias))
            dbt = info.get("db_type","Unknown")
            self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
            st = "OK" if info.get("connection") else "NoConn"
            self.conn_table.setItem(r,2,QTableWidgetItem(st))

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Connection")
        rm_btn = QPushButton("Remove Connection")
        close_btn = QPushButton("Close")
        bh.addWidget(add_btn)
        bh.addWidget(rm_btn)
        bh.addStretch()
        bh.addWidget(close_btn)
        main.addLayout(bh)

        add_btn.clicked.connect(self.on_add)
        rm_btn.clicked.connect(self.on_rm)
        close_btn.clicked.connect(self.accept)
        self.setLayout(main)

    def on_add(self):
        d = ODBCConnectDialog(self)
        if d.exec_() == QDialog.Accepted:
            c = d.get_connection()
            dbt = d.get_db_type()
            if c:
                base = dbt if dbt else "Unknown"
                i = 1
                alias = f"{base}_{i}"
                while alias in self._connections:
                    i += 1
                    alias = f"{base}_{i}"
                self._connections[alias] = {"connection": c, "db_type": dbt}
                r = self.conn_table.rowCount()
                self.conn_table.insertRow(r)
                self.conn_table.setItem(r,0,QTableWidgetItem(alias))
                self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
                self.conn_table.setItem(r,2,QTableWidgetItem("OK"))

    def on_rm(self):
        rows = self.conn_table.selectionModel().selectedRows()
        if not rows: 
            return
        for rr in sorted([x.row() for x in rows], reverse=True):
            alias_item = self.conn_table.item(rr,0)
            if alias_item:
                alias = alias_item.text()
                if alias in self._connections:
                    del self._connections[alias]
            self.conn_table.removeRow(rr)

    def get_connections(self):
        return self._connections

class ConnectionPickerDialog(QDialog):
    """ Let user pick from existing connection aliases """
    def __init__(self, connections, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Pick Connection")
        self.resize(300,120)
        self._connections = connections
        self.chosen_alias = None

        main = QVBoxLayout(self)
        main.addWidget(QLabel("Select DB Connection:"))
        self.conn_cb = QComboBox()
        for a in sorted(self._connections.keys()):
            self.conn_cb.addItem(a)
        main.addWidget(self.conn_cb)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        if not self._connections:
            QMessageBox.warning(self,"No Connections","No DB connections found.")
            return
        self.chosen_alias = self.conn_cb.currentText()
        if not self.chosen_alias:
            QMessageBox.warning(self,"No alias","Pick a connection alias.")
            return
        self.accept()

    def get_chosen_alias(self):
        return self.chosen_alias

###############################################################################
# FK auto-join
###############################################################################
def load_foreign_keys(connection, db_type=None):
    fk_map = {}
    if (not connection) or (db_type and "TERADATA" not in db_type.upper()):
        return fk_map
    try:
        cur = connection.cursor()
        q = """
        SELECT
            ChildDatabaseName, ChildTableName, ChildKeyColumnName,
            ParentDatabaseName, ParentTableName, ParentKeyColumnName
        FROM DBC.All_RI_Children
        """
        cur.execute(q)
        rows = cur.fetchall()
        for row in rows:
            cd = row.ChildDatabaseName.strip()
            ct = row.ChildTableName.strip()
            cc = row.ChildKeyColumnName.strip()
            pd = row.ParentDatabaseName.strip()
            pt = row.ParentTableName.strip()
            pc = row.ParentKeyColumnName.strip()
            child_key = f"{cd}.{ct}.{cc}"
            parent_key = f"{pd}.{pt}.{pc}"
            fk_map[child_key] = parent_key
    except Exception as ex:
        logging.warning(f"No or partial FK load: {ex}")
    return fk_map

###############################################################################
# BFS lazy schema => alias => db => tables => columns
###############################################################################
class LazySchemaLoaderSignals(QtCore.QObject):
    finished = pyqtSignal(list)
    error = pyqtSignal(str)

class LazySchemaLoader(QtCore.QRunnable):
    def __init__(self, connection, dbname):
        super().__init__()
        self.connection = connection
        self.dbname = dbname
        self.signals = LazySchemaLoaderSignals()

    @QtCore.pyqtSlot()
    def run(self):
        try:
            cur = self.connection.cursor()
            q = f"""
                SELECT TableName
                FROM DBC.TablesV
                WHERE DatabaseName='{self.dbname}' AND TableKind='T'
                ORDER BY TableName
            """
            cur.execute(q)
            rows = cur.fetchall()
            tables = [r[0] for r in rows]
            self.signals.finished.emit(tables)
        except Exception as ex:
            msg = f"Error loading tables for {self.dbname}: {ex}\n{traceback.format_exc()}"
            self.signals.error.emit(msg)

def load_columns_for_table(connection, dbN, tblN):
    cols = []
    try:
        cur = connection.cursor()
        cur.execute(f"""
            SELECT ColumnName
            FROM DBC.ColumnsV
            WHERE DatabaseName='{dbN}' AND TableName='{tblN}'
            ORDER BY ColumnId
        """)
        rows = cur.fetchall()
        cols = [r[0] for r in rows]
    except Exception as ex:
        logging.warning(f"Failed to load columns for {dbN}.{tblN}: {ex}")
    return cols

class MultiDBLazySchemaTreeWidget(QTreeWidget):
    def __init__(self, connections, parent_builder=None, parent=None):
        super().__init__(parent)
        self.connections = connections
        self.parent_builder = parent_builder
        self.setHeaderHidden(False)
        self.setColumnCount(1)
        self.setHeaderLabel("Databases / Tables")
        self.setDragEnabled(True)
        self.threadpool = QThreadPool.globalInstance()

    def set_connections(self, conns):
        self.connections = conns

    def populate_roots(self):
        self.clear()
        if not self.connections:
            self.addTopLevelItem(QTreeWidgetItem(["No Connections"]))
            return
        for alias, info in self.connections.items():
            dbt = info.get("db_type","Unknown")
            top = QTreeWidgetItem([f"{alias} ({dbt})"])
            top.setData(0, Qt.UserRole, ("connAlias", alias))
            self.addTopLevelItem(top)

            conn = info.get("connection", None)
            if not conn:
                top.addChild(QTreeWidgetItem(["(No connection)"]))
                continue

            try:
                c = conn.cursor()
                c.execute("SELECT DISTINCT DatabaseName FROM DBC.TablesV ORDER BY DatabaseName")
                rows = c.fetchall()
                if not rows:
                    top.addChild(QTreeWidgetItem(["(No DB)"]))
                    continue
                for r in rows:
                    dbn = r[0].strip()
                    db_item = QTreeWidgetItem([dbn])
                    db_item.setData(0, Qt.UserRole, ("db",alias,dbn))
                    db_item.setData(0, Qt.UserRole+1, False)
                    db_item.addChild(QTreeWidgetItem(["Loading..."]))
                    top.addChild(db_item)
            except Exception as ex:
                top.addChild(QTreeWidgetItem([f"(Error: {ex})"]))
        self.expandAll()

    def mouseDoubleClickEvent(self, e):
        it = self.itemAt(e.pos())
        if it:
            d = it.data(0, Qt.UserRole)
            loaded = it.data(0, Qt.UserRole+1)
            if d and d[0] == "db" and not loaded:
                alias, dbn = d[1], d[2]
                it.takeChildren()
                info = self.connections.get(alias)
                if info and info.get("connection"):
                    c = info["connection"]
                    worker = LazySchemaLoader(c, dbn)
                    def on_finish(tables):
                        self.populate_tables(it, alias, dbn, tables)
                    def on_err(msg):
                        QMessageBox.critical(self,"Schema Error",msg)
                    worker.signals.finished.connect(on_finish)
                    worker.signals.error.connect(on_err)
                    self.threadpool.start(worker)
        super().mouseDoubleClickEvent(e)

    def populate_tables(self, parent_item, alias, dbn, tables):
        if not tables:
            parent_item.addChild(QTreeWidgetItem(["<No Tables>"]))
            parent_item.setData(0, Qt.UserRole+1, True)
            return
        parent_item.takeChildren()
        for t in tables:
            t_item = QTreeWidgetItem([t])
            t_item.setData(0, Qt.UserRole, ("table",alias,dbn,t))
            t_item.setData(0, Qt.UserRole+1, False)
            t_item.addChild(QTreeWidgetItem(["Loading..."]))
            parent_item.addChild(t_item)
        parent_item.setData(0, Qt.UserRole+1, True)

    def mousePressEvent(self, e):
        it = self.itemAt(e.pos())
        if it:
            d = it.data(0, Qt.UserRole)
            if d and d[0] == "table":
                loaded = it.data(0, Qt.UserRole+1)
                if not loaded:
                    it.takeChildren()
                    alias, dbn, tbl = d[1], d[2], d[3]
                    info = self.connections.get(alias)
                    if info:
                        c = info["connection"]
                        cols = load_columns_for_table(c, dbn, tbl)
                        if cols:
                            for cc in cols:
                                child = QTreeWidgetItem([cc])
                                child.setData(0, Qt.UserRole, ("column",alias,dbn,tbl,cc))
                                it.addChild(child)
                        else:
                            it.addChild(QTreeWidgetItem(["<No columns>"]))
                    it.setData(0, Qt.UserRole+1, True)
        super().mousePressEvent(e)

    def startDrag(self, actions):
        it = self.currentItem()
        if it:
            d = it.data(0, Qt.UserRole)
            if d and d[0] == "table":
                alias, dbn, tbl = d[1], d[2], d[3]
                full_key = f"{alias}.{dbn}.{tbl}"
                drag = QtGui.QDrag(self)
                mime = QtCore.QMimeData()
                mime.setText(full_key)
                drag.setMimeData(mime)
                drag.exec_(actions)

    def filter_items(self, txt):
        def filter_recursive(item, text):
            show = False
            if text.lower() in item.text(0).lower():
                show = True
            for i in range(item.childCount()):
                citem = item.child(i)
                cshown = filter_recursive(citem, text)
                if cshown:
                    show = True
            item.setHidden(not show)
            return show

        for i in range(self.topLevelItemCount()):
            top = self.topLevelItem(i)
            filter_recursive(top, txt)

###############################################################################
# Data Profiler => outlier chart
###############################################################################
class ProfilerChartCanvas(FigureCanvasQTAgg):
    def __init__(self, data_list, col_name="", parent=None):
        fig = Figure()
        super().__init__(fig)
        self.setParent(parent)
        self.axes = fig.add_subplot(111)
        self.data = data_list
        self.col_name = col_name
        self.plot_data()

    def plot_data(self):
        self.axes.clear()
        if not self.data:
            self.axes.text(0.5,0.5,"No numeric data",ha='center',va='center')
            self.draw()
            return
        self.axes.boxplot(self.data, labels=[self.col_name])
        self.axes.set_title(f"Outlier Chart: {self.col_name}")
        self.draw()

class DataProfilerDialog(QDialog):
    def __init__(self, table_key, columns, connection, db_type=None, parent=None):
        super().__init__(parent)
        self.table_key = table_key
        self.columns = columns
        self.connection = connection
        self.db_type = db_type
        self.setWindowTitle(f"Data Profiler - {table_key}")
        self.resize(900,500)

        main = QVBoxLayout(self)
        info = QLabel(
            f"Profiling {table_key} => COUNT(*), DISTINCT, MIN, MAX, AVG => 'ERR' on fail.\n"
            "Use 'Outlier Chart' for numeric columns."
        )
        main.addWidget(info)

        self.prof_table = QTableWidget(0,7)
        self.prof_table.setHorizontalHeaderLabels(["Column","COUNT","DISTINCT","MIN","MAX","AVG","Error"])
        main.addWidget(self.prof_table)

        bh = QHBoxLayout()
        chart_btn = QPushButton("Outlier Chart")
        chart_btn.clicked.connect(self.show_outlier_chart)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        bh.addWidget(chart_btn)
        bh.addStretch()
        bh.addWidget(close_btn)
        main.addLayout(bh)

        self.setLayout(main)
        self.run_profiler()

    def run_profiler(self):
        if not self.connection:
            QMessageBox.warning(self,"No Connection","No DB connection for profiling.")
            return
        c = self.connection.cursor()

        self.prof_table.setRowCount(0)

        # We'll just do queries directly (alias.db.tbl, or db.tbl)
        for colFQ in self.columns:
            short_col = colFQ.split(".")[-1]
            r_idx = self.prof_table.rowCount()
            self.prof_table.insertRow(r_idx)
            self.prof_table.setItem(r_idx,0,QTableWidgetItem(short_col))

            # COUNT(*)
            co_val = ""
            try:
                q = f"SELECT COUNT(*) FROM {self.table_key}"
                c.execute(q)
                rr = c.fetchone()
                co_val = str(rr[0]) if rr else "0"
            except Exception as ex:
                co_val = f"ERR({ex})"
            self.prof_table.setItem(r_idx,1,QTableWidgetItem(co_val))

            # DISTINCT
            dist_val = ""
            try:
                q = f"SELECT COUNT(DISTINCT {short_col}) FROM {self.table_key}"
                c.execute(q)
                rr = c.fetchone()
                dist_val = str(rr[0]) if rr else "0"
            except Exception as ex:
                dist_val = f"ERR({ex})"
            self.prof_table.setItem(r_idx,2,QTableWidgetItem(dist_val))

            minv, maxv, avgv = "N/A","N/A","N/A"
            err_msg = ""
            try:
                q = f"SELECT MIN({short_col}) FROM {self.table_key}"
                c.execute(q)
                r = c.fetchone()
                if r and r[0] is not None:
                    minv = str(r[0])
                else:
                    minv = "NULL"
            except Exception as ex:
                minv = "ERR"
                err_msg = str(ex)
            try:
                q = f"SELECT MAX({short_col}) FROM {self.table_key}"
                c.execute(q)
                r = c.fetchone()
                if r and r[0] is not None:
                    maxv = str(r[0])
                else:
                    maxv = "NULL"
            except Exception as ex:
                maxv = "ERR"
                if not err_msg:
                    err_msg = str(ex)
            try:
                q = f"SELECT AVG({short_col}) FROM {self.table_key}"
                c.execute(q)
                r = c.fetchone()
                if r and r[0] is not None:
                    avgv = str(r[0])
                else:
                    avgv = "NULL"
            except Exception as ex:
                avgv = "ERR"
                if not err_msg:
                    err_msg = str(ex)

            self.prof_table.setItem(r_idx,3,QTableWidgetItem(minv))
            self.prof_table.setItem(r_idx,4,QTableWidgetItem(maxv))
            self.prof_table.setItem(r_idx,5,QTableWidgetItem(avgv))
            self.prof_table.setItem(r_idx,6,QTableWidgetItem(err_msg))

    def show_outlier_chart(self):
        rows = self.prof_table.selectionModel().selectedRows()
        if not rows:
            QMessageBox.information(self,"No Selection","Pick a row first.")
            return
        row_idx = rows[0].row()
        col_name = self.prof_table.item(row_idx,0).text()

        data_list = []
        try:
            c = self.connection.cursor()
            q = f"SELECT {col_name} FROM {self.table_key} WHERE {col_name} IS NOT NULL"
            c.execute(q)
            rr = c.fetchall()
            for r in rr:
                val = r[0]
                data_list.append(float(val))
        except Exception as ex:
            QMessageBox.warning(self,"Outlier Error",f"Could not fetch numeric data:\n{ex}")
            return

        if not data_list:
            QMessageBox.information(self,"No Data","No numeric data or table is empty.")
            return

        d = QDialog(self)
        d.setWindowTitle(f"Outlier Chart: {col_name}")
        d.resize(600,400)
        lay = QVBoxLayout(d)
        canvas = ProfilerChartCanvas(data_list,col_name,d)
        lay.addWidget(canvas)
        dbb = QDialogButtonBox(QDialogButtonBox.Ok)
        lay.addWidget(dbb)
        dbb.accepted.connect(d.accept)
        d.setLayout(lay)
        d.exec_()

###############################################################################
# BFS multi-join lines => single-col or multi-condition
###############################################################################
class ColumnJoinWizardDialog(QDialog):
    def __init__(self, source_full, source_type, target_full, target_type, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Column Join Wizard")
        self.resize(400,200)

        self.source_col = source_full
        self.source_type = source_type
        self.target_col = target_full
        self.target_type = target_type
        self.join_type = "INNER"
        self.condition = f"{self.source_col} = {self.target_col}"

        main = QVBoxLayout(self)
        info = QLabel(
            f"Source: {self.source_col} (type={self.source_type})\n"
            f"Target: {self.target_col} (type={self.target_type})"
        )
        main.addWidget(info)
        if self.source_type.lower() != self.target_type.lower():
            warn = QLabel("<b>Warning:</b> Different data types (may need cast).")
            warn.setStyleSheet("color:red;")
            main.addWidget(warn)

        form = QFormLayout()
        self.join_cb = QComboBox()
        self.join_cb.addItems(["INNER","LEFT","RIGHT","FULL"])
        form.addRow("Join Type:", self.join_cb)

        self.cond_edit = QLineEdit(self.condition)
        form.addRow("Condition:", self.cond_edit)
        main.addLayout(form)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        jt = self.join_cb.currentText()
        cond = self.cond_edit.text().strip()
        if not cond:
            QMessageBox.warning(self,"No condition","Condition must not be empty.")
            return
        self.join_type = jt
        self.condition = cond
        self.accept()

    def get_join_data(self):
        return (self.join_type, self.condition)

class MultiConditionJoinWizard(QDialog):
    """Add multiple left=right expressions => AND them => pick join type"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Multi-Condition Join Wizard")
        self.resize(400,300)
        self.join_type = "INNER"
        self.conditions = []

        main = QVBoxLayout(self)
        form = QFormLayout()
        self.join_cb = QComboBox()
        self.join_cb.addItems(["INNER","LEFT","RIGHT","FULL"])
        form.addRow("Join Type:", self.join_cb)
        main.addLayout(form)

        self.list_widget = QListWidget()
        main.addWidget(self.list_widget)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Condition")
        add_btn.clicked.connect(self.add_condition)
        rm_btn = QPushButton("Remove Condition")
        rm_btn.clicked.connect(self.remove_condition)
        bh.addWidget(add_btn)
        bh.addWidget(rm_btn)
        main.addLayout(bh)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def add_condition(self):
        d = QDialog(self)
        d.setWindowTitle("Add Condition (LeftExpr = RightExpr)")
        d.resize(400,200)
        lay = QVBoxLayout(d)
        fm = QFormLayout()
        self.left_edit = QLineEdit()
        self.right_edit = QLineEdit()
        fm.addRow("Left Expression:", self.left_edit)
        fm.addRow("Right Expression:", self.right_edit)
        inst = QLabel("Use e.g. UPPER(alias.db.tbl.col). We'll AND them.")
        inst.setStyleSheet("color:gray;")
        fm.addRow(inst)
        lay.addLayout(fm)
        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        lay.addWidget(dbb)
        def do_ok():
            le = self.left_edit.text().strip()
            re = self.right_edit.text().strip()
            if not le or not re:
                QMessageBox.warning(d,"No expressions","Need both sides.")
                return
            d.accept()
        dbb.accepted.connect(do_ok)
        dbb.rejected.connect(d.reject)

        if d.exec_() == QDialog.Accepted:
            la = self.left_edit.text().strip()
            rb = self.right_edit.text().strip()
            self.conditions.append((la, rb))
            self.list_widget.addItem(f"{la} = {rb}")

    def remove_condition(self):
        rows = self.list_widget.selectedIndexes()
        if rows:
            r = rows[0].row()
            self.conditions.pop(r)
            self.list_widget.takeItem(r)

    def on_ok(self):
        if not self.conditions:
            QMessageBox.warning(self,"No conditions","At least one needed.")
            return
        self.join_type = self.join_cb.currentText()
        self.accept()

    def get_join_data(self):
        parts = []
        for (l,r) in self.conditions:
            parts.append(f"{l} = {r}")
        final = " AND ".join(parts)
        return (self.join_type, final)

class MappingLine(QGraphicsLineItem):
    """DML BFS mapping line"""
    def __init__(self, source_text_item, target_text_item, parent_canvas,
                 source_type=None, target_type=None):
        super().__init__()
        self.canvas = parent_canvas
        self.source_text_item = source_text_item
        self.target_text_item = target_text_item
        self.source_col = source_text_item.toPlainText()
        self.target_col = target_text_item.toPlainText()
        self.source_type = source_type
        self.target_type = target_type

        self.setPen(QPen(Qt.darkRed,2,Qt.SolidLine))
        self.setZValue(5)
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptHoverEvents(True)
        self.update_pos()

    def update_pos(self):
        s = self.source_text_item.mapToScene(self.source_text_item.boundingRect().center())
        t = self.target_text_item.mapToScene(self.target_text_item.boundingRect().center())
        self.setLine(QtCore.QLineF(s,t))

    def paint(self, painter, option, widget):
        self.update_pos()
        super().paint(painter,option,widget)

    def contextMenuEvent(self, event):
        menu = QMenu()
        rm = menu.addAction("Remove Column Mapping")
        chosen = menu.exec_(event.screenPos())
        if chosen == rm:
            if self in self.canvas.mapping_lines:
                self.canvas.mapping_lines.remove(self)
            sc = self.scene()
            if sc:
                sc.removeItem(self)

class JoinLine(QGraphicsLineItem):
    """ BFS multi-join line => single-col or multi-condition"""
    def __init__(self, start_item, end_item, join_type="INNER", condition=""):
        super().__init__()
        self.start_item = start_item
        self.end_item = end_item
        self.join_type = join_type
        self.condition = condition
        self.setZValue(-1)
        self.setAcceptHoverEvents(True)

        self.pen_map = {
            "INNER": (Qt.darkBlue, Qt.SolidLine),
            "LEFT": (Qt.darkGreen, Qt.SolidLine),
            "RIGHT": (Qt.magenta, Qt.DotLine),
            "FULL": (Qt.red, Qt.DashLine),
        }
        self.label = QGraphicsTextItem(self.join_type, self)
        self.label.setDefaultTextColor(Qt.blue)
        self.update_line()

    def update_line(self):
        s = self.start_item.scenePos() + QPointF(100,30)
        e = self.end_item.scenePos() + QPointF(100,30)
        self.setLine(QtCore.QLineF(s,e))
        mx = (s.x()+e.x())/2
        my = (s.y()+e.y())/2
        self.label.setPos(mx, my)
        color, style = self.pen_map.get(self.join_type, (Qt.gray, Qt.SolidLine))
        self.setPen(QPen(color,2,style))

    def hoverEnterEvent(self, e):
        p = self.pen()
        p.setColor(Qt.yellow)
        p.setWidth(3)
        self.setPen(p)
        super().hoverEnterEvent(e)

    def hoverLeaveEvent(self, e):
        self.update_line()
        super().hoverLeaveEvent(e)

###############################################################################
# BFS table items => DraggableColumnTextItem, CollapsibleTableGraphicsItem
###############################################################################
class DraggableColumnTextItem(QGraphicsTextItem):
    """ BFS table column => single-col join wizard by drag onto another column """
    def __init__(self, parent_table_item, column_name, column_type):
        super().__init__(column_name, parent_table_item)
        self.parent_table_item = parent_table_item
        self.column_name = column_name
        self.column_type = column_type
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptDrops(True)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            drag = QtGui.QDrag(event.widget())
            mime = QtCore.QMimeData()
            full_col = f"{self.parent_table_item.table_fullname}.{self.column_name}"
            mime.setText(f"{full_col}||{self.column_type}")
            drag.setMimeData(mime)
            drag.exec_(Qt.MoveAction)
        else:
            super().mousePressEvent(event)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText() and "||" in event.mimeData().text():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()

    def dropEvent(self, event):
        txt = event.mimeData().text()
        if "||" not in txt:
            event.ignore()
            return
        source_full, source_type = txt.split("||",1)
        target_full = f"{self.parent_table_item.table_fullname}.{self.column_name}"
        target_type = self.column_type
        if source_full == target_full:
            QMessageBox.information(None,"Same Column","Cannot join a column onto itself.")
            event.ignore()
            return
        if source_full.startswith(self.parent_table_item.table_fullname + "."):
            QMessageBox.information(None,"Same BFS Table","Join across different BFS items only.")
            event.ignore()
            return

        # single-col wizard
        dlg = ColumnJoinWizardDialog(source_full, source_type, target_full, target_type)
        if dlg.exec_() == QDialog.Accepted:
            jtype, cond = dlg.get_join_data()
            parent_builder = self.parent_table_item.parent_builder
            cv = parent_builder.canvas
            sf_tab = ".".join(source_full.split(".")[:2])
            tf_tab = ".".join(target_full.split(".")[:2])

            source_item = cv.table_items.get(sf_tab, None)
            target_item = cv.table_items.get(tf_tab, None)
            if not source_item or not target_item:
                QMessageBox.warning(None,"Join Error","Could not find BFS items for source/target.")
                event.ignore()
                return
            jl = JoinLine(source_item, target_item, jtype, cond)
            cv.scene_.addItem(jl)
            cv.join_lines.append(jl)
            jl.update_line()
            QMessageBox.information(None,"Join Created",f"{jtype} JOIN line:\n{cond}")
            event.acceptProposedAction()
        else:
            event.ignore()

class CollapsibleTableGraphicsItem(QGraphicsRectItem):
    """ BFS table item => collapsible columns => single-col or multi-condition join """
    def __init__(self, table_fullname, columns, parent_builder, x=0, y=0):
        super().__init__(0,0,220,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(220,220,255)))
        self.setPen(QPen(Qt.darkGray,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.table_fullname = table_fullname
        self.columns = columns
        self.parent_builder = parent_builder
        self.is_collapsed = True
        self.title_height = 20
        self.column_items = []

        self.close_btn = QGraphicsTextItem("[X]", self)
        self.close_btn.setPos(190,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn = QGraphicsTextItem("[+]", self)
        self.toggle_btn.setPos(170,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f = QFont("Arial",9,QFont.Bold)
        self.title_text = QGraphicsTextItem(table_fullname, self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        # mock column types for demonstration
        self.mock_column_types = {}
        for c in columns:
            if c.lower().startswith("id") or c.lower().endswith("id"):
                self.mock_column_types[c] = "INT"
            else:
                self.mock_column_types[c] = "VARCHAR"

        yOff = self.title_height
        for c in columns:
            cRect = QGraphicsRectItem(5,yOff+4,10,10,self)
            cRect.setBrush(QBrush(Qt.white))
            cRect.setPen(QPen(Qt.black,1))
            cText = DraggableColumnTextItem(self, c, self.mock_column_types[c])
            cText.setPos(20,yOff)
            self.column_items.append([cRect,cText,False])
            yOff += 20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,220,self.title_height)
            for (r,t,_) in self.column_items:
                r.setVisible(False)
                t.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded = self.title_height + len(self.column_items)*20
            self.setRect(0,0,220,expanded)
            for (r,t,_) in self.column_items:
                r.setVisible(True)
                t.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

    def mousePressEvent(self, event):
        pos = event.pos()
        close_rect = self.close_btn.mapToParent(self.close_btn.boundingRect())
        if close_rect.boundingRect().contains(pos):
            sc = self.scene()
            if sc:
                self.parent_builder.handle_remove_table(self)
            event.accept()
            return
        toggle_rect = self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if toggle_rect.boundingRect().contains(pos):
            self.is_collapsed = not self.is_collapsed
            self.update_layout()
            event.accept()
            return

        for i,(cRect,cText,checked) in enumerate(self.column_items):
            rRect = cRect.mapToParent(cRect.boundingRect()).boundingRect()
            if rRect.contains(pos):
                self.column_items[i][2] = not checked
                cRect.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def contextMenuEvent(self, event):
        menu = QMenu()
        remove_action = menu.addAction("Remove Table/CTE")
        join_mult = menu.addAction("Multi-Condition Join Wizard")
        chosen = menu.exec_(event.screenPos())
        if chosen == remove_action:
            sc = self.scene()
            if sc:
                self.parent_builder.handle_remove_table(self)
        elif chosen == join_mult:
            # user picks BFS item to join => multi cond
            other_items = [(k,v) for (k,v) in self.parent_builder.canvas.table_items.items() if v!=self]
            if not other_items:
                QMessageBox.information(None,"No other BFS items","Need another BFS item to join.")
                return
            w = MultiConditionJoinWizard()
            if w.exec_() == QDialog.Accepted:
                jtype, cond = w.get_join_data()
                keys = [k for (k,_) in other_items]
                # pick which BFS item to join with
                (chosen_k, ok) = QInputDialog.getItem(None, "Pick BFS item to join",
                                                      "Available BFS items:",
                                                      keys, 0, False)
                if ok and chosen_k:
                    other_itm = self.parent_builder.canvas.table_items.get(chosen_k)
                    jl = JoinLine(self, other_itm, jtype, cond)
                    self.parent_builder.canvas.scene_.addItem(jl)
                    self.parent_builder.canvas.join_lines.append(jl)
                    jl.update_line()

    def get_selected_columns(self):
        sel = []
        for (r,t,chk) in self.column_items:
            if chk:
                colName = t.toPlainText().strip()
                sel.append(f"{self.table_fullname}.{colName}")
        return sel

class CollapsibleBFSGraphicsItem(QGraphicsRectItem):
    """ BFS source item => DML => production-level mapping lines """
    def __init__(self, title, columns, parent_builder, x=100, y=100):
        super().__init__(0,0,240,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(250,250,180)))
        self.setPen(QPen(Qt.red,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.item_title = title
        self.columns = columns
        self.parent_builder = parent_builder
        self.is_collapsed = False
        self.title_height = 20
        self.column_items = []

        self.close_btn = QGraphicsTextItem("[X]", self)
        self.close_btn.setPos(215,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn = QGraphicsTextItem("[-]", self)
        self.toggle_btn.setPos(195,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f = QFont("Arial",9,QFont.Bold)
        self.title_text = QGraphicsTextItem(title, self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        yOff = self.title_height
        for c in columns:
            r = QGraphicsRectItem(5,yOff+4,10,10,self)
            r.setBrush(QBrush(Qt.blue))
            r.setPen(QPen(Qt.black,1))
            t = QGraphicsTextItem(c, self)
            t.setPos(20,yOff)
            self.column_items.append([r,t,True])
            yOff += 20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,240,self.title_height)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(False)
                ct.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded = self.title_height + len(self.column_items)*20
            self.setRect(0,0,240,expanded)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(True)
                ct.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

    def mousePressEvent(self, event):
        pos = event.pos()
        cbr = self.close_btn.mapToParent(self.close_btn.boundingRect())
        if cbr.boundingRect().contains(pos):
            sc = self.scene()
            if sc:
                sc.removeItem(self)
            event.accept()
            return
        tbr = self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if tbr.boundingRect().contains(pos):
            self.is_collapsed = not self.is_collapsed
            self.update_layout()
            event.accept()
            return

        for i,(cb,ct,chk) in enumerate(self.column_items):
            rr = cb.mapToParent(cb.boundingRect()).boundingRect()
            if rr.contains(pos):
                self.column_items[i][2] = not chk
                cb.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder and self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def get_checked_columns(self):
        arr = []
        for (cb,ct,chk) in self.column_items:
            if chk:
                arr.append(ct.toPlainText().strip())
        return arr

###############################################################################
# BFS Canvas => foreign-key autojoin
###############################################################################
class EnhancedCanvasGraphicsView(QGraphicsView):
    def __init__(self, parent_builder, parent=None):
        super().__init__(parent)
        self.parent_builder = parent_builder
        self.setAcceptDrops(True)
        self.scene_ = QGraphicsScene(self)
        self.setScene(self.scene_)

        self.table_items = {}
        self.join_lines = []
        self.mapping_lines = []
        self.operation_red_line = None
        self.collapsible_bfs_item = None
        self.target_table_item = None

        self.validation_timer = QTimer()
        self.validation_timer.setInterval(400)
        self.validation_timer.setSingleShot(True)
        self.validation_timer.timeout.connect(self.parent_builder.validate_sql)

    def dragEnterEvent(self, e):
        if e.mimeData().hasText():
            e.acceptProposedAction()

    def dragMoveEvent(self, e):
        e.acceptProposedAction()

    def dropEvent(self, e):
        txt = e.mimeData().text()
        pos = self.mapToScene(e.pos())
        self.parent_builder.handle_drop(txt, pos)
        e.acceptProposedAction()

    def add_table_item(self, table_key, columns, x, y):
        it = CollapsibleTableGraphicsItem(table_key, columns, self.parent_builder, x, y)
        self.scene_.addItem(it)
        self.table_items[table_key] = it
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()
        self.validation_timer.start()
        # Attempt auto-FK if single Teradata
        self._auto_fk_join(table_key)

    def _auto_fk_join(self, table_key):
        if len(self.parent_builder.connections)==1:
            alias = list(self.parent_builder.connections.keys())[0]
            info = self.parent_builder.connections[alias]
            dbt = info.get("db_type","")
            if "TERADATA" in dbt.upper():
                if not hasattr(self.parent_builder,"_fk_map_cache"):
                    self.parent_builder._fk_map_cache = load_foreign_keys(info["connection"], dbt)
                fk_map = self.parent_builder._fk_map_cache
                item = self.table_items.get(table_key)
                if not item:
                    return
                parts = table_key.split(".")
                if len(parts)==3:
                    # alias.db.tbl
                    dbN = parts[1]
                    tblN = parts[2]
                    # check child->parent
                    for c in item.columns:
                        child_key = f"{dbN}.{tblN}.{c}"
                        if child_key in fk_map:
                            pk = fk_map[child_key]
                            pk_parts = pk.split(".")
                            if len(pk_parts)==3:
                                p_db = pk_parts[0]
                                p_tbl = pk_parts[1]
                                p_key = f"{alias}.{p_db}.{p_tbl}"
                                parent_itm = self.table_items.get(p_key)
                                if parent_itm:
                                    cond = f"{table_key}.{c} = {p_key}.{pk_parts[2]}"
                                    jl = JoinLine(item, parent_itm, "LEFT", cond)
                                    self.scene_.addItem(jl)
                                    self.join_lines.append(jl)
                                    jl.update_line()

                    # check parent->child
                    for ck,pk in fk_map.items():
                        if pk.startswith(f"{dbN}.{tblN}."):
                            cparts = ck.split(".")
                            if len(cparts)==3:
                                c_alias = alias
                                c_db = cparts[0]
                                c_tbl = cparts[1]
                                c_key = f"{alias}.{c_db}.{c_tbl}"
                                child_itm = self.table_items.get(c_key)
                                if child_itm:
                                    cond = f"{ck} = {pk}"
                                    jl = JoinLine(child_itm, item, "LEFT", cond)
                                    self.scene_.addItem(jl)
                                    self.join_lines.append(jl)
                                    jl.update_line()

    def add_target_item(self, table_label, columns, x, y):
        """Used in DML modes for the 'Target' side of BFS mapping lines."""
        from_table = f"Target:{table_label}"
        if from_table in self.table_items:
            # remove old one
            self.remove_table_item(from_table)
        it = CollapsibleTableGraphicsItem(f"Target:{table_label}", columns, self.parent_builder, x, y)
        self.scene_.addItem(it)
        self.table_items[from_table] = it
        self.target_table_item = it

    def remove_table_item(self, table_key):
        if table_key in self.table_items:
            itm = self.table_items[table_key]
            lines_rm = []
            for jl in self.join_lines:
                if jl.start_item==itm or jl.end_item==itm:
                    lines_rm.append(jl)
            for ln in lines_rm:
                self.scene_.removeItem(ln)
                self.join_lines.remove(ln)
            self.scene_.removeItem(itm)
            del self.table_items[table_key]
            self.validation_timer.start()

    def remove_mapping_lines(self):
        for ml in self.mapping_lines:
            self.scene_.removeItem(ml)
        self.mapping_lines.clear()

    def add_vertical_red_line(self, x=450):
        if self.operation_red_line:
            self.scene_.removeItem(self.operation_red_line)
            self.operation_red_line = None
        ln = QGraphicsLineItem(x, 0, x, 3000)
        ln.setPen(QPen(Qt.red,2,Qt.DashDotLine))
        ln.setZValue(-10)
        self.scene_.addItem(ln)
        self.operation_red_line = ln

    def create_mapping_line(self, source_text_item, target_text_item, src_type=None, tgt_type=None):
        ml = MappingLine(source_text_item, target_text_item, self, src_type, tgt_type)
        self.scene_.addItem(ml)
        self.mapping_lines.append(ml)
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()
        self.validation_timer.start()

    def add_subquery_item(self, x, y):
        sq = NestedSubqueryItem(parent_builder=self.parent_builder, x=x, y=y)
        self.scene_.addItem(sq)
        key = f"SubQueryItem_{id(sq)}"
        self.table_items[key] = sq
        self.validation_timer.start()

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        for jl in self.join_lines:
            jl.update_line()
        for ml in self.mapping_lines:
            ml.update_pos()

###############################################################################
# Nested subqueries & BFS
###############################################################################
class NestedVQBDialog(QDialog):
    """ Minimal nested sub-VQB => user can just type a subquery. """
    def __init__(self, existing_sql="", parent_builder=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Nested Sub-VQB")
        self.resize(900,600)
        self.existing_sql = existing_sql
        self.parent_builder = parent_builder
        self.result_sql = ""

        main = QVBoxLayout(self)
        self.txt = QTextEdit()
        self.txt.setPlainText(existing_sql)
        main.addWidget(self.txt)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        raw = self.txt.toPlainText().strip()
        if not raw:
            QMessageBox.warning(self,"No SubQuery","Subquery is empty.")
            return
        self.result_sql = raw
        self.accept()

    def get_subquery_sql(self):
        return self.result_sql

class NestedSubqueryItem(QGraphicsRectItem):
    """ BFS item => nested subquery placeholder. """
    def __init__(self, parent_builder=None, x=0, y=0):
        super().__init__(0,0,220,80)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(200,255,200)))
        self.setPen(QPen(Qt.darkGreen,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.parent_builder = parent_builder
        self.subquery_sql = "-- SubQuery"
        self.label = QGraphicsTextItem("Nested SubQuery\n(double-click)", self)
        self.label.setPos(5,5)
        f = QFont("Arial",9,QFont.Bold)
        self.label.setFont(f)

    def mouseDoubleClickEvent(self, event):
        dlg = NestedVQBDialog(existing_sql=self.subquery_sql, parent_builder=self.parent_builder)
        if dlg.exec_() == QDialog.Accepted:
            new_sql = dlg.get_subquery_sql()
            if new_sql:
                self.subquery_sql = new_sql
                self.label.setPlainText("Nested SubQuery\n(Has SQL)")
        event.accept()

    def contextMenuEvent(self, event):
        menu = QMenu()
        rm = menu.addAction("Remove SubQuery")
        chosen = menu.exec_(event.screenPos())
        if chosen == rm:
            sc = self.scene()
            if sc:
                sc.removeItem(self)

    def get_subquery_sql(self):
        return self.subquery_sql

###############################################################################
# Minimal BFS sub-VQB for "Combine Query" or similar
###############################################################################
class BFSSubVQBMini(QWidget):
    """
    Very simple BFS sub-VQB: user can drag schema items in to build
    a small SELECT. This is used in `SubVQBDialogSimpleBFS`.
    """
    def __init__(self, connections, parent=None):
        super().__init__(parent)
        self.connections = connections or {}
        self.auto_generate = True
        self.table_columns_map = {}
        layout = QVBoxLayout(self)

        self.canvas = EnhancedCanvasGraphicsView(self, parent=self)
        layout.addWidget(self.canvas)

        self.sql_display = QTextEdit()
        layout.addWidget(self.sql_display)
        self.setLayout(layout)

    def handle_drop(self, full_name, pos):
        """
        Accept drag of e.g. alias.db.tbl and add it to the BFS mini-canvas.
        """
        if not self.connections:
            # fallback columns
            if full_name not in self.table_columns_map:
                self.table_columns_map[full_name] = ["id","col1","col2"]
        else:
            parts = full_name.split(".")
            if len(parts) >= 3:
                alias, dbn, tbl = parts[0], parts[1], parts[2]
                info = self.connections.get(alias)
                if info:
                    c = info["connection"]
                    realCols = load_columns_for_table(c, dbn, tbl)
                    if not realCols:
                        realCols = ["id","col1","col2"]
                    self.table_columns_map[full_name] = realCols
            else:
                self.table_columns_map[full_name] = ["id","col1","col2"]

        cols = self.table_columns_map[full_name]
        self.canvas.add_table_item(full_name, cols, pos.x(), pos.y())
        if self.auto_generate:
            self.generate_sql()

    def handle_remove_table(self, table_item):
        for k,v in list(self.canvas.table_items.items()):
            if v == table_item:
                self.canvas.remove_table_item(k)
                break
        if self.auto_generate:
            self.generate_sql()

    def get_selected_columns(self):
        arr = []
        for k,itm in self.canvas.table_items.items():
            if hasattr(itm,"get_selected_columns"):
                arr.extend(itm.get_selected_columns())
        return arr

    def generate_sql(self):
        scols = self.get_selected_columns()
        if not scols:
            scols = ["*"]
        lines = [
            "SELECT "+", ".join(scols),
            "-- BFS sub-VQB"
        ]
        self.sql_display.setPlainText("\n".join(lines))

class SubVQBDialogSimpleBFS(QDialog):
    """ Let user build a mini BFS sub-query, then combine via UNION/INTERSECT/etc. """
    def __init__(self, connections, chosen_alias, parent_builder=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Combine Query (Sub VQB BFS)")
        self.resize(900,600)
        self.operator = "UNION"
        self.second_sql = ""
        self.parent_builder = parent_builder
        self.connections = connections
        self.alias = chosen_alias

        lay = QVBoxLayout(self)
        top = QHBoxLayout()
        top.addWidget(QLabel("Combine Operator:"))
        self.op_cb = QComboBox()
        self.op_cb.addItems(["UNION","UNION ALL","INTERSECT","EXCEPT"])
        top.addWidget(self.op_cb)
        top.addStretch()
        lay.addLayout(top)

        # BFS mini-sub-VQB
        mini_conns = {self.alias: self.connections[self.alias]}
        self.sub_vqb = BFSSubVQBMini(mini_conns)
        lay.addWidget(self.sub_vqb)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        lay.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(lay)

    def on_ok(self):
        op = self.op_cb.currentText()
        built_sql = self.sub_vqb.sql_display.toPlainText().strip()
        if not built_sql:
            QMessageBox.warning(self,"No Query","No BFS sub query built.")
            return
        self.operator = op
        self.second_sql = built_sql
        self.accept()

    def getResult(self):
        return (self.operator, self.second_sql)

###############################################################################
# Panels: Filter, GroupBy, Sort, Pivot, etc.
###############################################################################
class FullSQLParser:
    def __init__(self, sql):
        self.sql = sql
    def parse(self):
        st = sqlparse.parse(self.sql)
        if not st:
            raise ValueError("No valid SQL found.")

class SQLHighlighter(QSyntaxHighlighter):
    def __init__(self, doc):
        super().__init__(doc)
        self.rules = []
        kwfmt = QTextCharFormat()
        kwfmt.setForeground(Qt.darkBlue)
        kwfmt.setFontWeight(QFont.Bold)

        keywords = [
            "SELECT","FROM","WHERE","JOIN","INNER","LEFT","RIGHT","FULL","OUTER",
            "GROUP","BY","HAVING","ORDER","LIMIT","OFFSET","UNION","ALL","INTERSECT",
            "EXCEPT","AS","ON","AND","OR","NOT","IN","IS","NULL","EXISTS","COUNT",
            "SUM","AVG","MIN","MAX","INSERT","UPDATE","DELETE","VALUES","OVER",
            "PARTITION","ROWS","RANGE","CURRENT ROW","ROW_NUMBER","RANK","DENSE_RANK",
            "NTILE","LAG","LEAD","CASE","COALESCE","TRIM","FIRST_VALUE","LAST_VALUE",
            "WITH"
        ]
        for w in keywords:
            pattern = QRegularExpression(r'\b'+w+r'\b',QRegularExpression.CaseInsensitiveOption)
            self.rules.append((pattern, kwfmt))

        strfmt = QTextCharFormat()
        strfmt.setForeground(Qt.darkRed)
        self.rules.append((QRegularExpression(r"'[^']*'"), strfmt))
        self.rules.append((QRegularExpression(r'"[^"]*"'), strfmt))

        cfmt = QTextCharFormat()
        cfmt.setForeground(Qt.green)
        self.rules.append((QRegularExpression(r'--[^\n]*'), cfmt))
        self.rules.append((QRegularExpression(r'/\*.*\*/',QRegularExpression.DotMatchesEverythingOption), cfmt))

    def highlightBlock(self, text):
        for pat,fmt in self.rules:
            matches = pat.globalMatch(text)
            while matches.hasNext():
                m = matches.next()
                st = m.capturedStart()
                ln = m.capturedLength()
                self.setFormat(st, ln, fmt)
        self.setCurrentBlockState(0)

class AddFilterDialog(QDialog):
    def __init__(self, available_columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Filter")
        self.selected_col = None
        self.selected_op = None
        self.selected_val = None

        fl = QFormLayout(self)
        self.col_combo = QComboBox()
        self.col_combo.addItems(available_columns)
        fl.addRow("Column:", self.col_combo)
        self.op_combo = QComboBox()
        self.op_combo.addItems(["=","<>","<",">","<=",">=","IS NULL","IS NOT NULL"])
        fl.addRow("Operator:", self.op_combo)
        self.val_edit = QLineEdit("'ABC'")
        fl.addRow("Value:", self.val_edit)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(fl)

    def on_ok(self):
        c = self.col_combo.currentText()
        if not c:
            QMessageBox.warning(self,"No Column","Pick a column.")
            return
        self.selected_col = c
        self.selected_op = self.op_combo.currentText()
        self.selected_val = self.val_edit.text().strip()
        self.accept()

    def get_filter(self):
        return (self.selected_col, self.selected_op, self.selected_val)

class FilterPanel(QGroupBox):
    def __init__(self, parent_builder, parent=None):
        super().__init__("Filters", parent)
        self.parent_builder = parent_builder
        main = QVBoxLayout(self)
        self.setLayout(main)
        self.tabs = QTabWidget()
        main.addWidget(self.tabs)

        self.where_tab = QWidget()
        self.having_tab = QWidget()
        self.tabs.addTab(self.where_tab, "WHERE")
        self.tabs.addTab(self.having_tab, "HAVING")

        self.where_layout = QVBoxLayout(self.where_tab)
        self.where_table = QTableWidget(0,3)
        self.where_table.setHorizontalHeaderLabels(["Column","Operator","Value"])
        self.where_table.horizontalHeader().setStretchLastSection(True)
        self.where_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.where_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.where_layout.addWidget(self.where_table)

        wh_h = QHBoxLayout()
        add_w = QPushButton("Add WHERE")
        add_w.clicked.connect(lambda:self.add_filter("WHERE"))
        rm_w = QPushButton("Remove WHERE")
        rm_w.clicked.connect(lambda:self.remove_filter("WHERE"))
        wh_h.addWidget(add_w)
        wh_h.addWidget(rm_w)
        self.where_layout.addLayout(wh_h)

        self.having_layout = QVBoxLayout(self.having_tab)
        self.having_table = QTableWidget(0,3)
        self.having_table.setHorizontalHeaderLabels(["Column","Operator","Value"])
        self.having_table.horizontalHeader().setStretchLastSection(True)
        self.having_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.having_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.having_layout.addWidget(self.having_table)

        hv_h = QHBoxLayout()
        add_h = QPushButton("Add HAVING")
        add_h.clicked.connect(lambda:self.add_filter("HAVING"))
        rm_h = QPushButton("Remove HAVING")
        rm_h.clicked.connect(lambda:self.remove_filter("HAVING"))
        hv_h.addWidget(add_h)
        hv_h.addWidget(rm_h)
        self.having_layout.addLayout(hv_h)

    def add_filter(self, clause):
        cols = self.parent_builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No Columns","No columns available.")
            return
        dlg = AddFilterDialog(cols, self)
        if dlg.exec_() == QDialog.Accepted:
            c,o,v = dlg.get_filter()
            tb = self.where_table if clause=="WHERE" else self.having_table
            r = tb.rowCount()
            tb.insertRow(r)
            tb.setItem(r,0,QTableWidgetItem(c))
            tb.setItem(r,1,QTableWidgetItem(o))
            tb.setItem(r,2,QTableWidgetItem(v))
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def remove_filter(self, clause):
        tb = self.where_table if clause=="WHERE" else self.having_table
        rows = sorted([x.row() for x in tb.selectionModel().selectedRows()], reverse=True)
        for rr in rows:
            tb.removeRow(rr)
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()

    def get_filters(self, clause):
        tb = self.where_table if clause=="WHERE" else self.having_table
        out = []
        for r in range(tb.rowCount()):
            col = tb.item(r,0).text()
            op = tb.item(r,1).text()
            val = tb.item(r,2).text()
            out.append((col,op,val))
        return out

class PivotDialog(QDialog):
    def __init__(self, available_cols, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Pivot Wizard (Demo)")
        self.category_col = None
        self.value_col = None
        self.distinct_vals = []
        main = QVBoxLayout(self)

        f = QFormLayout()
        self.cat_combo = QComboBox()
        self.cat_combo.addItems(available_cols)
        f.addRow("Category Column:", self.cat_combo)
        self.val_combo = QComboBox()
        self.val_combo.addItems(available_cols)
        f.addRow("Value Column:", self.val_combo)
        main.addLayout(f)

        self.val_list = QListWidget()
        self.val_list.setSelectionMode(QAbstractItemView.MultiSelection)
        main.addWidget(QLabel("Pick categories (demo)"))
        main.addWidget(self.val_list)

        load_btn = QPushButton("Load Distinct (Demo only)")
        load_btn.clicked.connect(self.on_load_demo)
        main.addWidget(load_btn)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_load_demo(self):
        self.val_list.clear()
        for v in ["Manager","Clerk","Sales","IT","HR"]:
            self.val_list.addItem(v)

    def on_ok(self):
        c = self.cat_combo.currentText()
        v = self.val_combo.currentText()
        if not c or not v:
            QMessageBox.warning(self,"PivotWizard","Must pick cat & value.")
            return
        self.category_col = c
        self.value_col = v
        self.distinct_vals = [it.text() for it in self.val_list.selectedItems()]
        self.accept()

    def build_expressions(self):
        arr = []
        for dv in self.distinct_vals:
            alias = dv.lower().replace(" ","_")+"_val"
            expr = f"SUM(CASE WHEN {self.category_col}='{dv}' THEN {self.value_col} END) AS {alias}"
            arr.append(expr)
        return arr

class GroupByPanel(QGroupBox):
    def __init__(self, parent_builder, parent=None):
        super().__init__("Group By & Aggregates (+Pivot)", parent)
        self.parent_builder = parent_builder
        main = QVBoxLayout(self)
        self.setLayout(main)

        self.gb_table = QTableWidget(0,1)
        self.gb_table.setHorizontalHeaderLabels(["GroupBy Column"])
        self.gb_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.gb_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main.addWidget(self.gb_table)

        gb_h = QHBoxLayout()
        add_g = QPushButton("Add GroupBy")
        add_g.clicked.connect(self.add_group_by)
        rm_g = QPushButton("Remove GroupBy")
        rm_g.clicked.connect(self.remove_group_by)
        gb_h.addWidget(add_g)
        gb_h.addWidget(rm_g)
        main.addLayout(gb_h)

        self.agg_table = QTableWidget(0,3)
        self.agg_table.setHorizontalHeaderLabels(["Function","Column","Alias"])
        self.agg_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.agg_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main.addWidget(self.agg_table)

        agg_h = QHBoxLayout()
        add_agg = QPushButton("Add Agg")
        add_agg.clicked.connect(self.add_agg)
        rm_agg = QPushButton("Remove Agg")
        rm_agg.clicked.connect(self.remove_agg)
        agg_h.addWidget(add_agg)
        agg_h.addWidget(rm_agg)
        main.addLayout(agg_h)

        pivot_btn = QPushButton("Pivot Wizard")
        pivot_btn.clicked.connect(self.launch_pivot)
        main.addWidget(pivot_btn)

    def add_group_by(self):
        cols = self.parent_builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No Columns","No columns available.")
            return
        (c,ok) = QInputDialog.getItem(self,"Add GroupBy","Pick column:", cols, 0, False)
        if ok and c:
            r = self.gb_table.rowCount()
            self.gb_table.insertRow(r)
            self.gb_table.setItem(r,0,QTableWidgetItem(c))
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def remove_group_by(self):
        rows = sorted([x.row() for x in self.gb_table.selectionModel().selectedRows()], reverse=True)
        for rr in rows:
            self.gb_table.removeRow(rr)
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()

    def add_agg(self):
        cols = self.parent_builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        d = QDialog(self.parent_builder)
        d.setWindowTitle("Add Aggregate")
        fl = QFormLayout(d)
        func_cb = QComboBox()
        func_cb.addItems(["COUNT","SUM","AVG","MIN","MAX","CUSTOM"])
        col_cb = QComboBox()
        col_cb.addItems(cols)
        alias_ed = QLineEdit("AggVal")
        fl.addRow("Function:", func_cb)
        fl.addRow("Column:", col_cb)
        fl.addRow("Alias:", alias_ed)
        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(dbb)
        def on_ok():
            if not col_cb.currentText() and func_cb.currentText()!="CUSTOM":
                QMessageBox.warning(d,"Error","Pick a column or use CUSTOM.")
                return
            d.accept()
        dbb.accepted.connect(on_ok)
        dbb.rejected.connect(d.reject)
        d.setLayout(fl)
        if d.exec_() == QDialog.Accepted:
            f = func_cb.currentText()
            c = col_cb.currentText()
            a = alias_ed.text().strip()
            r = self.agg_table.rowCount()
            self.agg_table.insertRow(r)
            self.agg_table.setItem(r,0,QTableWidgetItem(f))
            self.agg_table.setItem(r,1,QTableWidgetItem(c))
            self.agg_table.setItem(r,2,QTableWidgetItem(a))
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def remove_agg(self):
        rows = sorted([x.row() for x in self.agg_table.selectionModel().selectedRows()], reverse=True)
        for rr in rows:
            self.agg_table.removeRow(rr)
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()

    def launch_pivot(self):
        cols = self.parent_builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        dlg = PivotDialog(cols, self)
        if dlg.exec_() == QDialog.Accepted:
            exs = dlg.build_expressions()
            for ex in exs:
                r = self.agg_table.rowCount()
                self.agg_table.insertRow(r)
                self.agg_table.setItem(r,0,QTableWidgetItem("CUSTOM"))
                self.agg_table.setItem(r,1,QTableWidgetItem(ex))
                self.agg_table.setItem(r,2,QTableWidgetItem("PivotVal"))
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def get_group_by(self):
        out = []
        for r in range(self.gb_table.rowCount()):
            it = self.gb_table.item(r,0)
            out.append(it.text())
        return out

    def get_aggregates(self):
        out = []
        for r in range(self.agg_table.rowCount()):
            f = self.agg_table.item(r,0).text()
            c = self.agg_table.item(r,1).text()
            a = self.agg_table.item(r,2).text()
            out.append((f,c,a))
        return out

class SortLimitPanel(QGroupBox):
    def __init__(self, parent_builder, parent=None):
        super().__init__("Sort & Limit", parent)
        self.parent_builder = parent_builder
        main = QVBoxLayout(self)
        self.setLayout(main)

        self.sort_table = QTableWidget(0,2)
        self.sort_table.setHorizontalHeaderLabels(["Column","Direction"])
        self.sort_table.horizontalHeader().setStretchLastSection(True)
        self.sort_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.sort_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main.addWidget(self.sort_table)

        bh = QHBoxLayout()
        add_s = QPushButton("Add Sort")
        add_s.clicked.connect(self.add_sort_dialog)
        rm_s = QPushButton("Remove Sort")
        rm_s.clicked.connect(self.remove_sort)
        bh.addWidget(add_s)
        bh.addWidget(rm_s)
        main.addLayout(bh)

        lo = QHBoxLayout()
        self.limit_spin = QSpinBox()
        self.limit_spin.setRange(0,9999999)
        self.limit_spin.setValue(0)
        self.limit_spin.setSuffix(" (Limit)")
        self.limit_spin.setSpecialValueText("No Limit")
        self.limit_spin.valueChanged.connect(self._maybe_regen)
        lo.addWidget(self.limit_spin)

        self.offset_spin = QSpinBox()
        self.offset_spin.setRange(0,9999999)
        self.offset_spin.setValue(0)
        self.offset_spin.setSuffix(" (Offset)")
        self.offset_spin.setSpecialValueText("No Offset")
        self.offset_spin.valueChanged.connect(self._maybe_regen)
        lo.addWidget(self.offset_spin)
        main.addLayout(lo)

    def _maybe_regen(self):
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()

    def add_sort_dialog(self):
        cols = self.parent_builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        d = QDialog(self)
        d.setWindowTitle("Add Sort")
        fl = QFormLayout(d)
        col_cb = QComboBox()
        col_cb.addItems(cols)
        dir_cb = QComboBox()
        dir_cb.addItems(["ASC","DESC"])
        fl.addRow("Column:", col_cb)
        fl.addRow("Direction:", dir_cb)
        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(dbb)
        def do_ok():
            if not col_cb.currentText():
                QMessageBox.warning(d,"No col","Pick a column.")
                return
            d.accept()
        dbb.accepted.connect(do_ok)
        dbb.rejected.connect(d.reject)
        d.setLayout(fl)
        if d.exec_() == QDialog.Accepted:
            c = col_cb.currentText()
            dd = dir_cb.currentText()
            row = self.sort_table.rowCount()
            self.sort_table.insertRow(row)
            self.sort_table.setItem(row,0,QTableWidgetItem(c))
            self.sort_table.setItem(row,1,QTableWidgetItem(dd))
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def remove_sort(self):
        rows = sorted([x.row() for x in self.sort_table.selectionModel().selectedRows()], reverse=True)
        for rr in rows:
            self.sort_table.removeRow(rr)
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()

    def get_order_bys(self):
        out = []
        for r in range(self.sort_table.rowCount()):
            col = self.sort_table.item(r,0).text()
            dr = self.sort_table.item(r,1).text()
            out.append(f"{col} {dr}")
        return out

    def get_limit(self):
        v = self.limit_spin.value()
        return v if v>0 else None

    def get_offset(self):
        v = self.offset_spin.value()
        return v if v>0 else None

###############################################################################
# For completeness, stubs for advanced expression/win-func
###############################################################################
class AdvancedWindowFunctionDialog(QDialog):
    def __init__(self, columns, parent=None):
        super().__init__(parent)
        self.columns = columns
        self.expr = ""
        self.setWindowTitle("Window Function Wizard (Stub)")

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Imagine a window function builder here..."))
        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(dbb)
        dbb.accepted.connect(self.accept)
        dbb.rejected.connect(self.reject)
        self.setLayout(layout)

    def get_expression(self):
        return "-- Example window function"

class AdvancedExpressionBuilderDialog(QDialog):
    def __init__(self, columns, parent=None):
        super().__init__(parent)
        self.columns = columns
        self.alias = "exprAlias"
        self.expr = ""
        self.setWindowTitle("Expression Builder (Stub)")

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Imagine an expression builder UI here..."))
        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(dbb)
        dbb.accepted.connect(self.accept)
        dbb.rejected.connect(self.reject)
        self.setLayout(layout)

    def get_expression_data(self):
        return (self.alias, "-- Example expression")

###############################################################################
# BFS sub-VQB => CTE
###############################################################################
class SubVQBMiniBFS(QWidget):
    """
    Another minimal BFS sub-VQB  used for building a query to go in a WITH CTE.
    (Similar code to BFSSubVQBMini, but here we keep it separate if you prefer.)
    """
    def __init__(self, connections, parent=None):
        super().__init__(parent)
        self.connections = connections or {}
        self.auto_generate = True
        self.table_columns_map = {}

        layout = QVBoxLayout(self)

        self.canvas = EnhancedCanvasGraphicsView(self, parent=self)
        layout.addWidget(self.canvas)

        self.sql_display = QTextEdit()
        layout.addWidget(self.sql_display)
        self.setLayout(layout)

    def handle_drop(self, full_name, pos):
        if not self.connections:
            if full_name not in self.table_columns_map:
                self.table_columns_map[full_name] = ["id","col1","col2"]
        else:
            parts = full_name.split(".")
            if len(parts)>=3:
                alias, dbn, tbl = parts[0], parts[1], parts[2]
                info = self.connections.get(alias)
                if info:
                    c = info["connection"]
                    realCols = load_columns_for_table(c, dbn, tbl)
                    if not realCols:
                        realCols = ["id","col1","col2"]
                    self.table_columns_map[full_name] = realCols
            else:
                self.table_columns_map[full_name] = ["id","col1","col2"]

        cols = self.table_columns_map[full_name]
        self.canvas.add_table_item(full_name, cols, pos.x(), pos.y())
        if self.auto_generate:
            self.generate_sql()

    def handle_remove_table(self, table_item):
        for k,v in list(self.canvas.table_items.items()):
            if v == table_item:
                self.canvas.remove_table_item(k)
                break
        if self.auto_generate:
            self.generate_sql()

    def get_selected_columns(self):
        arr = []
        for k,itm in self.canvas.table_items.items():
            if hasattr(itm,"get_selected_columns"):
                arr.extend(itm.get_selected_columns())
        return arr

    def generate_sql(self):
        scols = self.get_selected_columns()
        if not scols:
            scols = ["*"]
        lines = [
            "SELECT "+", ".join(scols),
            "-- BFS sub-VQB for CTE or subQuery"
        ]
        self.sql_display.setPlainText("\n".join(lines))

class SubVQBFullDialog(QDialog):
    """ BFS sub-VQB => returns a subquery for a WITH CTE. """
    def __init__(self, connections, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Sub-VQB BFS")
        self.resize(900,600)
        self.connections = connections
        self.result_sql = ""

        main = QVBoxLayout(self)
        self.sub_vqb = SubVQBMiniBFS(self.connections)
        main.addWidget(self.sub_vqb)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        raw = self.sub_vqb.sql_display.toPlainText().strip()
        if not raw:
            QMessageBox.warning(self,"No SubQuery","Subquery BFS is empty.")
            return
        self.result_sql = raw
        self.accept()

    def get_subquery_sql(self):
        return self.result_sql

class CTEDialog(QDialog):
    def __init__(self, parent_builder, existing_name="", existing_sql="", parent=None):
        super().__init__(parent)
        self.setWindowTitle("Define CTE (BFS sub-VQB)")
        self.resize(900,600)
        self.parent_builder = parent_builder
        self.cte_name = existing_name
        self.cte_sql = existing_sql

        main = QVBoxLayout(self)
        fm = QFormLayout()
        self.name_edit = QLineEdit(self.cte_name)
        fm.addRow("CTE Name:", self.name_edit)
        main.addLayout(fm)

        self.sub_vqb = SubVQBFullDialog(self.parent_builder.connections)
        main.addWidget(self.sub_vqb)
        if self.cte_sql.strip():
            self.sub_vqb.sub_vqb.sql_display.setPlainText(self.cte_sql)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"No name","CTE name cannot be empty.")
            return
        raw_sql = self.sub_vqb.get_subquery_sql().strip()
        if not raw_sql:
            QMessageBox.warning(self,"No subquery","CTE BFS subquery is empty.")
            return
        self.cte_name = name
        self.cte_sql = raw_sql
        self.accept()

    def get_cte_data(self):
        return (self.cte_name,self.cte_sql)

class CTEPanel(QGroupBox):
    def __init__(self, parent_builder, parent=None):
        super().__init__("CTEs", parent)
        self.parent_builder = parent_builder
        self.cte_data = []
        main = QVBoxLayout(self)
        self.setLayout(main)

        self.cte_table = QTableWidget(0,3)
        self.cte_table.setHorizontalHeaderLabels(["CTE Name","BFS Sub-VQB","Preview"])
        self.cte_table.horizontalHeader().setSectionResizeMode(0,QHeaderView.ResizeToContents)
        self.cte_table.horizontalHeader().setSectionResizeMode(1,QHeaderView.ResizeToContents)
        self.cte_table.horizontalHeader().setSectionResizeMode(2,QHeaderView.Stretch)
        self.cte_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.cte_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        main.addWidget(self.cte_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add CTE")
        edit_btn = QPushButton("Edit CTE")
        rm_btn = QPushButton("Remove CTE")
        bh.addWidget(add_btn)
        bh.addWidget(edit_btn)
        bh.addWidget(rm_btn)
        bh.addStretch()
        main.addLayout(bh)

        add_btn.clicked.connect(self.on_add_cte)
        edit_btn.clicked.connect(self.on_edit_cte)
        rm_btn.clicked.connect(self.on_remove_cte)

    def on_add_cte(self):
        dlg = CTEDialog(self.parent_builder, "", "", self)
        if dlg.exec_() == QDialog.Accepted:
            name, sql = dlg.get_cte_data()
            self._add_cte_row(name, sql)
            self.parent_builder.show_cte_as_virtual_table(name, ["col1","col2"])
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def on_edit_cte(self):
        rows = self.cte_table.selectionModel().selectedRows()
        if not rows:
            QMessageBox.information(self,"No selection","Select a CTE row to edit.")
            return
        i = rows[0].row()
        nm = self.cte_table.item(i,0).text()
        sq = self.cte_table.item(i,2).text()

        dlg = CTEDialog(self.parent_builder, nm, sq, self)
        if dlg.exec_() == QDialog.Accepted:
            newnm,newsql = dlg.get_cte_data()
            self.cte_table.setItem(i,0,QTableWidgetItem(newnm))
            self.cte_table.setItem(i,2,QTableWidgetItem(newsql))
            self.cte_data[i]['name'] = newnm
            self.cte_data[i]['sql'] = newsql
            if newnm != nm:
                self.parent_builder.remove_virtual_cte_table(nm)
            self.parent_builder.show_cte_as_virtual_table(newnm, ["col1","col2"])
            if self.parent_builder.auto_generate:
                self.parent_builder.generate_sql()

    def on_remove_cte(self):
        rows = sorted([r.row() for r in self.cte_table.selectionModel().selectedRows()], reverse=True)
        for rr in rows:
            nm = self.cte_table.item(rr,0).text()
            self.cte_table.removeRow(rr)
            del self.cte_data[rr]
            self.parent_builder.remove_virtual_cte_table(nm)
        if self.parent_builder.auto_generate:
            self.parent_builder.generate_sql()

    def _add_cte_row(self, cte_name, cte_sql):
        r = self.cte_table.rowCount()
        self.cte_table.insertRow(r)
        self.cte_table.setItem(r,0,QTableWidgetItem(cte_name))
        self.cte_table.setItem(r,1,QTableWidgetItem("BFS Sub-VQB"))
        self.cte_table.setItem(r,2,QTableWidgetItem(cte_sql))
        self.cte_data.append({'name':cte_name,'sql':cte_sql})

    def get_ctes(self):
        out = []
        for r in range(self.cte_table.rowCount()):
            nm = self.cte_table.item(r,0).text()
            sq = self.cte_table.item(r,2).text()
            out.append((nm,sq))
        return out

###############################################################################
# SQL Import => parse with sqlglot => partial BFS
###############################################################################
class SQLImportTab(QWidget):
    def __init__(self, builder=None, parent=None):
        super().__init__(parent)
        self.builder = builder
        main = QVBoxLayout(self)

        instruct = QLabel(
            "Paste or type your SQL, then click 'Import & Rebuild'.\n"
            "We'll parse with sqlglot.parse_one(...) (no 'ansi').\n"
            "Complex queries may partially rebuild BFS."
        )
        main.addWidget(instruct)

        self.sql_edit = QTextEdit()
        main.addWidget(self.sql_edit)

        hb = QHBoxLayout()
        self.import_btn = QPushButton("Import & Rebuild")
        self.import_btn.clicked.connect(self.on_import_rebuild)
        hb.addWidget(self.import_btn)
        main.addLayout(hb)

        self.setLayout(main)

    def on_import_rebuild(self):
        raw_sql = self.sql_edit.toPlainText().strip()
        if not raw_sql:
            QMessageBox.information(self,"Empty SQL","No SQL to parse.")
            return
        try:
            st = sqlparse.parse(raw_sql)
            if not st:
                QMessageBox.warning(self,"No valid SQL","sqlparse found no statements.")
                return
        except Exception as e:
            QMessageBox.warning(self,"Syntax Error",f"sqlparse error:\n{e}")
            return

        try:
            expr = sqlglot.parse_one(raw_sql)
        except Exception as ex:
            QMessageBox.warning(self,"sqlglot Parse Error",f"Could not parse:\n{ex}")
            return

        self.builder.import_and_rebuild_canvas(expr, raw_sql)
        QMessageBox.information(self,"Import OK","Canvas has been rebuilt from the SQL.")

###############################################################################
# ResultDataDialog => show SQL results
###############################################################################
class ResultDataDialog(QDialog):
    def __init__(self, rows, columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("SQL Results")
        self.resize(800,400)
        main = QVBoxLayout(self)

        tbl = QTableWidget(len(rows), len(columns))
        tbl.setHorizontalHeaderLabels(columns)
        for r_idx, row_val in enumerate(rows):
            for c_idx, val in enumerate(row_val):
                it = QTableWidgetItem(str(val))
                tbl.setItem(r_idx, c_idx, it)
        main.addWidget(tbl)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok)
        dbb.accepted.connect(self.accept)
        main.addWidget(dbb)
        self.setLayout(main)

###############################################################################
# The main BFS builder tab
###############################################################################
class VisualQueryBuilderTab(QWidget):
    def __init__(self, connections=None, parent=None):
        super().__init__(parent)
        self.connections = connections if connections else {}
        self.table_columns_map = {}
        self.auto_generate = True
        self.operation_mode = "SELECT"
        self._fk_map_cache = {}
        self.init_ui()

    def init_ui(self):
        main = QVBoxLayout(self)

        # row => connection status
        con_h = QHBoxLayout()
        self.status_light = QFrame()
        self.status_light.setFixedSize(15,15)
        self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
        self.server_label = QLabel("No Connections")
        con_h.addWidget(self.status_light)
        con_h.addWidget(self.server_label)

        self.auto_chk = QCheckBox("Auto-Generate")
        self.auto_chk.setChecked(True)
        self.auto_chk.stateChanged.connect(self.on_auto_gen_changed)
        con_h.addWidget(self.auto_chk)
        con_h.addStretch()
        main.addLayout(con_h)

        top_h = QHBoxLayout()
        subq_btn = QPushButton("Add SubQuery")
        subq_btn.clicked.connect(self.add_subquery_to_canvas)
        top_h.addWidget(subq_btn)

        expr_btn = QPushButton("Expression Builder")
        expr_btn.clicked.connect(self.launch_expr_builder)
        top_h.addWidget(expr_btn)

        wfunc_btn = QPushButton("Window Function Wizard")
        wfunc_btn.clicked.connect(self.launch_window_func)
        top_h.addWidget(wfunc_btn)

        comb_btn = QPushButton("Combine Query (Sub VQB)")
        comb_btn.clicked.connect(self.combine_with_subvqb)
        top_h.addWidget(comb_btn)

        self.op_combo = QComboBox()
        self.op_combo.addItems(["SELECT","INSERT","UPDATE","DELETE"])
        self.op_combo.currentIndexChanged.connect(self.on_op_mode_changed)
        top_h.addWidget(self.op_combo)
        top_h.addStretch()
        main.addLayout(top_h)

        self.tabs = QTabWidget()
        main.addWidget(self.tabs)

        self.schema_tab = QWidget()
        self.config_tab = QWidget()
        self.sql_tab = QWidget()
        self.import_tab = SQLImportTab(builder=self)

        self.tabs.addTab(self.schema_tab, "Schema & Canvas")
        self.tabs.addTab(self.config_tab, "Query Config")
        self.tabs.addTab(self.sql_tab, "SQL Preview")
        self.tabs.addTab(self.import_tab, "SQL Import")

        self.status_bar = QStatusBar()
        main.addWidget(self.status_bar)
        self.setLayout(main)

        self.setup_schema_tab()
        self.setup_config_tab()
        self.setup_sql_tab()

    def set_connections(self, conns):
        self.connections = conns
        if conns:
            self.update_conn_status(True,"Multiple DBs connected")
            self.schema_tree.set_connections(conns)
            self.schema_tree.populate_roots()
            if len(conns)==1:
                alias = list(conns.keys())[0]
                info = conns[alias]
                dbt = info.get("db_type","")
                if "TERADATA" in dbt.upper():
                    self._fk_map_cache = load_foreign_keys(info["connection"], dbt)
        else:
            self.update_conn_status(False,"No Connections")

    def update_conn_status(self, st, info=""):
        if st:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: green;}")
            self.server_label.setText(info)
        else:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
            self.server_label.setText("No Connections")

    def setup_schema_tab(self):
        lay = QVBoxLayout(self.schema_tab)
        self.search_ed = QLineEdit()
        self.search_ed.setPlaceholderText("Filter schema items...")
        self.search_ed.textChanged.connect(self.on_schema_filter)
        lay.addWidget(self.search_ed)

        splitter = QSplitter(Qt.Horizontal)
        self.schema_tree = MultiDBLazySchemaTreeWidget(self.connections, self)
        leftp = QWidget()
        lpl = QVBoxLayout(leftp)
        lpl.addWidget(self.schema_tree)
        splitter.addWidget(leftp)

        self.canvas = EnhancedCanvasGraphicsView(self, parent=self)
        splitter.addWidget(self.canvas)
        splitter.setStretchFactor(0,1)
        splitter.setStretchFactor(1,3)
        lay.addWidget(splitter)

        self.progress = QProgressBar()
        self.progress.setVisible(False)
        lay.addWidget(self.progress)

    def setup_config_tab(self):
        h = QHBoxLayout(self.config_tab)

        self.cte_panel = CTEPanel(self)
        h.addWidget(self.cte_panel, 2)

        self.filter_panel = FilterPanel(self)
        h.addWidget(self.filter_panel, 2)

        self.group_panel = GroupByPanel(self)
        h.addWidget(self.group_panel, 3)

        self.sort_panel = SortLimitPanel(self)
        h.addWidget(self.sort_panel, 2)
        self.config_tab.setLayout(h)

    def setup_sql_tab(self):
        lay = QVBoxLayout(self.sql_tab)
        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Generated SQL:"))
        run_btn = QPushButton("Run SQL")
        run_btn.clicked.connect(self.run_sql)
        top_h.addWidget(run_btn, alignment=Qt.AlignRight)
        lay.addLayout(top_h)

        self.sql_display = QTextEdit()
        self.sql_display.setReadOnly(False)
        self.sql_highlighter = SQLHighlighter(self.sql_display.document())
        lay.addWidget(self.sql_display)

        bar_h = QHBoxLayout()
        self.validation_lbl = QLabel("SQL Status: Unknown")
        bar_h.addWidget(self.validation_lbl)

        profiler_btn = QPushButton("Data Profiler")
        profiler_btn.clicked.connect(self.launch_data_profiler)
        bar_h.addWidget(profiler_btn)

        bar_h.addStretch()
        lay.addLayout(bar_h)

        self.sql_tab.setLayout(lay)

    def launch_data_profiler(self):
        real_tables = []
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns") and not k.startswith("SubQueryItem_") and not k.startswith("BFS") \
               and not k.startswith("Target:") and not k.startswith("CTE."):
                real_tables.append(k)
        if not real_tables:
            QMessageBox.information(self,"No Table","No real BFS table to profile.")
            return
        (chosen,ok) = QInputDialog.getItem(self,"Pick Table",
                                           "Choose BFS table to profile:",
                                           real_tables, 0, False)
        if ok and chosen:
            titem = self.canvas.table_items.get(chosen)
            if not titem or not hasattr(titem,"columns"):
                QMessageBox.information(self,"No columns?","That BFS item has no columns to profile.")
                return
            alias = chosen.split(".")[0]
            info = self.connections.get(alias)
            if not info:
                QMessageBox.warning(self,"No Connection","No DB connection found for BFS item.")
                return
            c = info.get("connection")
            dbt = info.get("db_type","")
            if not c:
                QMessageBox.warning(self,"No ConnectionObj","DB connection invalid.")
                return
            colkeys = []
            for cc in titem.columns:
                colkeys.append(f"{chosen}.{cc}")
            d = DataProfilerDialog(chosen, colkeys, c, dbt, self)
            d.exec_()

    def on_schema_filter(self, txt):
        self.schema_tree.filter_items(txt)

    def on_auto_gen_changed(self, st):
        self.auto_generate = (st == Qt.Checked)

    def on_op_mode_changed(self, idx):
        modes = ["SELECT","INSERT","UPDATE","DELETE"]
        self.operation_mode = modes[idx]
        self.toggle_dml_canvas()
        if self.auto_generate:
            self.generate_sql()

    def toggle_dml_canvas(self):
        if self.operation_mode=="SELECT":
            self.canvas.remove_mapping_lines()
            if self.canvas.operation_red_line:
                self.canvas.scene_.removeItem(self.canvas.operation_red_line)
                self.canvas.operation_red_line = None
            if self.canvas.collapsible_bfs_item:
                self.canvas.scene_.removeItem(self.canvas.collapsible_bfs_item)
                self.canvas.collapsible_bfs_item = None
            if self.canvas.target_table_item:
                self.canvas.scene_.removeItem(self.canvas.target_table_item)
                self.canvas.target_table_item = None
        else:
            # DML -> add BFS source area and a red vertical line
            self.canvas.add_vertical_red_line(450)
            if not self.canvas.collapsible_bfs_item:
                BFScols = ["srcCol1","srcCol2","key"]
                bfs = CollapsibleBFSGraphicsItem("BFS Source", BFScols, self, 50, 100)
                self.canvas.scene_.addItem(bfs)
                self.canvas.collapsible_bfs_item = bfs
            if not self.canvas.target_table_item:
                Tcols = ["colA","colB","key"]
                self.canvas.add_target_item("db.tbl", Tcols, 600, 100)

    def add_subquery_to_canvas(self):
        self.canvas.add_subquery_item(200,200)
        if self.auto_generate:
            self.generate_sql()

    def combine_with_subvqb(self):
        if not self.connections:
            QMessageBox.warning(self,"No Connections","Please add at least one connection.")
            return
        pick = ConnectionPickerDialog(self.connections, self)
        if pick.exec_() != QDialog.Accepted:
            return
        chosen_alias = pick.get_chosen_alias()
        d = SubVQBDialogSimpleBFS(self.connections, chosen_alias, self)
        if d.exec_() == QDialog.Accepted:
            op, second_sql = d.getResult()
            old = self.sql_display.toPlainText().strip()
            if old:
                new_sql = old + f"\n{op}\n(\n{second_sql}\n)"
            else:
                new_sql = f"{op}\n(\n{second_sql}\n)"
            self.sql_display.setPlainText(new_sql)
            self.validate_sql()

    def launch_expr_builder(self):
        cols = self.get_all_possible_columns_for_dialog()
        dlg = AdvancedExpressionBuilderDialog(cols, self)
        if dlg.exec_() == QDialog.Accepted:
            a, ex = dlg.get_expression_data()
            old = self.sql_display.toPlainText()
            self.sql_display.setPlainText(old + f"\n-- Expression {a}\n{ex}")
            self.validate_sql()

    def launch_window_func(self):
        cols = self.get_all_possible_columns_for_dialog()
        dlg = AdvancedWindowFunctionDialog(cols, self)
        if dlg.exec_() == QDialog.Accepted:
            expression = dlg.get_expression()
            old = self.sql_display.toPlainText()
            self.sql_display.setPlainText(old + f"\n-- Window:\n{expression}")
            self.validate_sql()

    def run_sql(self):
        txt = self.sql_display.toPlainText().strip()
        if not txt:
            QMessageBox.information(self,"Empty SQL","No SQL to run.")
            return
        if not self.connections:
            QMessageBox.information(self,"No Connections","No DB connection found.")
            return
        first_alias = list(self.connections.keys())[0]
        conn = self.connections[first_alias]["connection"]
        try:
            cur = conn.cursor()
            cur.execute(txt)
            rows = cur.fetchall()
            cols = [desc[0] for desc in cur.description] if cur.description else []
            dlg = ResultDataDialog(rows, cols, self)
            dlg.exec_()
        except Exception as ex:
            QMessageBox.warning(self,"SQL Error",f"Failed:\n{ex}")

    def get_all_possible_columns_for_dialog(self):
        arr = []
        # All BFS items
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns"):
                for c in v.columns:
                    arr.append(f"{k}.{c}")
        # BFS source side (for DML)
        if self.canvas.collapsible_bfs_item:
            for c in self.canvas.collapsible_bfs_item.columns:
                arr.append(f"BFS.{c}")
        return arr

    def handle_drop(self, full_name, pos):
        if not self.connections:
            if full_name not in self.table_columns_map:
                self.table_columns_map[full_name] = ["id","col1","col2"]
        else:
            parts = full_name.split(".")
            if len(parts)>=3:
                alias, dbn, tbl = parts[0], parts[1], parts[2]
                info = self.connections.get(alias)
                if info:
                    c = info["connection"]
                    realCols = load_columns_for_table(c, dbn, tbl)
                    if not realCols:
                        realCols = ["id","col1","col2"]
                    self.table_columns_map[full_name] = realCols
            else:
                self.table_columns_map[full_name] = ["id","col1","col2"]
        cols = self.table_columns_map[full_name]
        self.canvas.add_table_item(full_name, cols, pos.x(), pos.y())

    def handle_remove_table(self, table_item):
        for k,v in list(self.canvas.table_items.items()):
            if v==table_item:
                self.canvas.remove_table_item(k)
                break

    def show_cte_as_virtual_table(self, cte_name, columns):
        table_key = f"CTE.{cte_name}"
        if table_key in self.canvas.table_items:
            self.canvas.remove_table_item(table_key)
        self.canvas.add_table_item(table_key, columns, 600, 100)

    def remove_virtual_cte_table(self, cte_name):
        table_key = f"CTE.{cte_name}"
        self.canvas.remove_table_item(table_key)

    def generate_sql(self):
        if not self.auto_generate:
            return
        if self.operation_mode == "INSERT":
            body = self._generate_insert()
        elif self.operation_mode == "UPDATE":
            body = self._generate_update()
        elif self.operation_mode == "DELETE":
            body = self._generate_delete()
        else:
            body = self._generate_select()

        ctes = self.cte_panel.get_ctes()
        if ctes:
            cparts = []
            for (n,s) in ctes:
                cparts.append(f"{n} AS (\n{s}\n)")
            cblock = "WITH "+",\n    ".join(cparts)+"\n"
            final_sql = cblock + body
        else:
            final_sql = body

        self.sql_display.setPlainText(final_sql)
        self.validate_sql()

    def validate_sql(self):
        txt = self.sql_display.toPlainText().strip()
        if not txt:
            self.validation_lbl.setText("SQL Status: No SQL.")
            self.validation_lbl.setStyleSheet("color:orange;")
            return
        try:
            parser = FullSQLParser(txt)
            parser.parse()
            self.validation_lbl.setText("SQL Status: Valid.")
            self.validation_lbl.setStyleSheet("color:green;")
        except Exception as ex:
            self.validation_lbl.setText(f"SQL Status: Invalid - {ex}")
            self.validation_lbl.setStyleSheet("color:red;")

    def _build_bfs_from(self):
        invert = {v:k for k,v in self.canvas.table_items.items()}
        adj = {}
        for k in self.canvas.table_items.keys():
            adj[k] = []
        for jl in self.canvas.join_lines:
            s = invert.get(jl.start_item,None)
            e = invert.get(jl.end_item,None)
            if s and e:
                adj[s].append((e,jl))
                adj[e].append((s,jl))
        visited = set()
        blocks = []
        for root in adj:
            if root not in visited:
                queue = [root]
                visited.add(root)
                seg = [root]
                while queue:
                    node = queue.pop(0)
                    for (nbr,ln) in adj[node]:
                        if nbr not in visited:
                            visited.add(nbr)
                            queue.append(nbr)
                            seg.append(f"{ln.join_type} {nbr} ON {ln.condition}")
                block = "\n  ".join(seg)
                if not blocks:
                    blocks.append("FROM "+block)
                else:
                    blocks.append("-- Another subgraph:\nFROM "+block)
        if not blocks:
            return "-- no tables on BFS"
        return "\n".join(blocks)

    def get_selected_columns(self):
        arr = []
        for k,itm in self.canvas.table_items.items():
            if hasattr(itm,"get_selected_columns"):
                arr.extend(itm.get_selected_columns())
        if self.canvas.collapsible_bfs_item:
            bfs_cols = self.canvas.collapsible_bfs_item.get_checked_columns()
            arr.extend([f"BFS.{c}" for c in bfs_cols])
        return arr

    def _generate_select(self):
        scols = self.get_selected_columns()
        if not scols:
            scols = ["*"]
        ags = self.group_panel.get_aggregates()
        final_cols = list(scols)
        for (f,c,a) in ags:
            if f.upper()=="CUSTOM":
                final_cols.append(c)
            else:
                final_cols.append(f"{f}({c}) AS {a}")

        lines = []
        lines.append("SELECT "+", ".join(final_cols))
        lines.append(self._build_bfs_from())

        wfs = self.filter_panel.get_filters("WHERE")
        if wfs:
            conds = [f"{col} {op} {val}" for (col,op,val) in wfs]
            lines.append("WHERE "+ " AND ".join(conds))

        gb = self.group_panel.get_group_by()
        if gb:
            lines.append("GROUP BY "+", ".join(gb))

        hv = self.filter_panel.get_filters("HAVING")
        if hv:
            conds = [f"{col} {op} {val}" for (col,op,val) in hv]
            lines.append("HAVING "+ " AND ".join(conds))

        ob = self.sort_panel.get_order_bys()
        if ob:
            lines.append("ORDER BY "+", ".join(ob))
        lm = self.sort_panel.get_limit()
        if lm is not None:
            lines.append(f"LIMIT {lm}")
        off = self.sort_panel.get_offset()
        if off is not None:
            lines.append(f"OFFSET {off}")
        return "\n".join(lines)

    def _generate_select_sql_only(self):
        scols = self.get_selected_columns()
        if not scols:
            scols = ["*"]
        lines = []
        lines.append("SELECT "+", ".join(scols))
        lines.append(self._build_bfs_from())
        wfs = self.filter_panel.get_filters("WHERE")
        if wfs:
            conds = [f"{col} {op} {val}" for (col,op,val) in wfs]
            lines.append("WHERE "+" AND ".join(conds))
        return "\n".join(lines)

    def _parse_target_info(self):
        if not self.canvas.target_table_item:
            return (None,None)
        tText = self.canvas.target_table_item.title_text.toPlainText()
        if tText.startswith("Target:"):
            raw = tText.replace("Target:","").strip()
            if "." in raw:
                parts = raw.split(".",1)
                return (parts[0].strip(), parts[1].strip())
        return (None,None)

    def _parse_mapped_columns(self):
        arr = []
        for ml in self.canvas.mapping_lines:
            arr.append((ml.source_col, ml.target_col))
        return arr

    def _generate_insert(self):
        dbName,tName = self._parse_target_info()
        if not dbName or not tName:
            return "-- No target => no INSERT"
        mapped = self._parse_mapped_columns()
        if not mapped:
            return "-- No column mapping => no INSERT"
        sub = self._generate_select_sql_only()
        target_cols = [m[1] for m in mapped]
        lines = [
            f"INSERT INTO {dbName}.{tName} ({', '.join(target_cols)})",
            sub
        ]
        return "\n".join(lines)

    def _generate_update(self):
        dbName,tName = self._parse_target_info()
        if not dbName or not tName:
            return "-- No target => no UPDATE"
        mapped = self._parse_mapped_columns()
        if not mapped:
            return "-- No column mapping => no UPDATE"
        sub = self._generate_select_sql_only()
        key_col = "key"
        sets = []
        for (src,tgt) in mapped:
            if tgt.lower()!=key_col:
                sets.append(f"{tgt}=src.{src}")
        lines = [
            f"UPDATE {dbName}.{tName}",
            f"SET {', '.join(sets)}",
            "FROM (",
            sub,
            ") AS src",
            f"WHERE {dbName}.{tName}.{key_col}=src.{key_col}"
        ]
        return "\n".join(lines)

    def _generate_delete(self):
        dbName,tName = self._parse_target_info()
        if not dbName or not tName:
            return "-- No target => no DELETE"
        sub = self._generate_select_sql_only()
        key_col = "key"
        lines = [
            f"DELETE FROM {dbName}.{tName}",
            f"WHERE {key_col} IN (",
            sub,
            ")"
        ]
        return "\n".join(lines)

    def import_and_rebuild_canvas(self, root_expr, full_sql):
        # Clear BFS
        for k in list(self.canvas.table_items.keys()):
            self.canvas.remove_table_item(k)
        self.canvas.remove_mapping_lines()

        # Clear filters
        while self.filter_panel.where_table.rowCount()>0:
            self.filter_panel.where_table.removeRow(0)
        while self.filter_panel.having_table.rowCount()>0:
            self.filter_panel.having_table.removeRow(0)

        # Clear group
        while self.group_panel.gb_table.rowCount()>0:
            self.group_panel.gb_table.removeRow(0)
        while self.group_panel.agg_table.rowCount()>0:
            self.group_panel.agg_table.removeRow(0)

        # Clear sort
        while self.sort_panel.sort_table.rowCount()>0:
            self.sort_panel.sort_table.removeRow(0)
        self.sort_panel.limit_spin.setValue(0)
        self.sort_panel.offset_spin.setValue(0)

        # Clear CTE
        while self.cte_panel.cte_table.rowCount()>0:
            self.cte_panel.cte_table.removeRow(0)
        self.cte_panel.cte_data.clear()

        main_expr = root_expr
        if root_expr.key == "WITH":
            cte_exps = root_expr.args.get("expressions") or []
            for cexp in cte_exps:
                cName = cexp.alias
                cSelect = cexp.this
                cSQL = cSelect.sql()
                self.cte_panel._add_cte_row(cName,cSQL)
            main_expr = root_expr.this

        # For now, if its a SELECT, we just show the SQL. BFS partial rebuild is non-trivial.
        self.sql_display.setPlainText(full_sql)
        self.validate_sql()

###############################################################################
# The main window => merges everything
###############################################################################
class MainVQBWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("All-Features VQB - BFS, No Pan/Zoom, Profiler, FKs, Subqueries")
        self.resize(1200,800)
        self.connections = {}
        self.builder_tab = VisualQueryBuilderTab(self.connections)
        self.setCentralWidget(self.builder_tab)

        tb = self.addToolBar("Main Toolbar")
        conn_act = QAction("Connections", self)
        conn_act.triggered.connect(self.on_manage_connections)
        tb.addAction(conn_act)

        fit_act = QAction("Fit to View", self)
        fit_act.triggered.connect(self.on_fit_view)
        tb.addAction(fit_act)

        layout_act = QAction("Auto-Layout", self)
        layout_act.triggered.connect(self.on_auto_layout)
        tb.addAction(layout_act)

    def on_manage_connections(self):
        dlg = MultiODBCConnectDialog(self.connections, self)
        if dlg.exec_() == QDialog.Accepted:
            self.connections = dlg.get_connections()
            self.builder_tab.set_connections(self.connections)

    def on_fit_view(self):
        sc = self.builder_tab.canvas.scene_
        self.builder_tab.canvas.fitInView(sc.itemsBoundingRect(), Qt.KeepAspectRatio)

    def on_auto_layout(self):
        items = list(self.builder_tab.canvas.table_items.values())
        col_count = 3
        xsp = 250
        ysp = 180
        for i,itm in enumerate(items):
            row = i // col_count
            col = i % col_count
            itm.setPos(col*xsp, row*ysp)
        for jl in self.builder_tab.canvas.join_lines:
            jl.update_line()

###############################################################################
# main entry
###############################################################################
def main():
    app = QApplication(sys.argv)
    apply_fusion_style()
    w = MainVQBWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()