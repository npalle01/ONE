def load_approvals(self):
    """
    Loads pending approval records for the current user.
    Retrieves the lock owner from BRM_RULE_LOCKS via a LEFT JOIN.
    Filters the approvals to display only those for which the approval stage
    is the minimum for each rule.
    """
    self.approvals_table.setRowCount(0)
    c = self.connection.cursor()
    try:
        query = """
            SELECT 
                A.RULE_ID, 
                A.GROUP_NAME, 
                R.RULE_NAME, 
                A.APPROVAL_STAGE, 
                A.APPROVED_FLAG,
                ISNULL(L.LOCKED_BY, 'Unlocked') AS LOCKED_BY
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
            LEFT JOIN BRM_RULE_LOCKS L 
                ON R.RULE_ID = L.RULE_ID AND L.ACTIVE_LOCK = 1
            WHERE A.USERNAME = ? AND A.APPROVED_FLAG = 0
            ORDER BY A.RULE_ID
        """
        c.execute(query, (self.logged_in_username,))
        rows = c.fetchall()

        # Helper to fetch the current minimum approval stage for a given rule.
        def get_min_stage(rule_id):
            cur = self.connection.cursor()
            cur.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID = ? AND APPROVED_FLAG = 0
            """, (rule_id,))
            res = cur.fetchone()
            return res[0] if res and res[0] is not None else None

        # Filter rows: Only include rows where the approval stage equals the minimum stage.
        filtered = [row for row in rows if row[3] == get_min_stage(row[0])]

        self.approvals_table.setRowCount(len(filtered))
        for i, row in enumerate(filtered):
            rule_id, group_name, rule_name, stage, approved_flag, locked_by = row
            self.approvals_table.setItem(i, 0, QTableWidgetItem(str(rule_id)))
            self.approvals_table.setItem(i, 1, QTableWidgetItem(str(group_name)))
            self.approvals_table.setItem(i, 2, QTableWidgetItem(str(rule_name)))
            self.approvals_table.setItem(i, 3, QTableWidgetItem(str(stage)))
            self.approvals_table.setItem(i, 4, QTableWidgetItem(str(approved_flag)))
            # Approve button
            approve_btn = QPushButton("Approve")
            # Capture current row index using default argument to avoid late binding.
            approve_btn.clicked.connect(lambda _, idx=i: self.do_approve(idx))
            self.approvals_table.setCellWidget(i, 5, approve_btn)
            # Reject button
            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, idx=i: self.do_reject(idx))
            self.approvals_table.setCellWidget(i, 6, reject_btn)
            # Display lock status from BRM_RULE_LOCKS
            self.approvals_table.setItem(i, 7, QTableWidgetItem(str(locked_by)))
            # Force Unlock button (enabled only for admin users)
            force_btn = QPushButton("ForceUnlock")
            force_btn.setEnabled(self.user_group == "Admin")
            force_btn.clicked.connect(lambda _, idx=i: self.do_forceunlock(idx))
            self.approvals_table.setCellWidget(i, 8, force_btn)
    except Exception as ex:
        QMessageBox.critical(self, "Approval Load Error", str(ex))