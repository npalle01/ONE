# ------------------------------------------------------
# CHECK IF RULE IS LOCKED (Prevents Editing If Locked)
# ------------------------------------------------------
def check_rule_lock(conn, rule_id, user_id):
    """
    Checks if a rule is locked by another user.
    Returns True if the rule is locked by someone else, False if editable.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row and row[0] and row[0] != user_id:
        return True  # Rule is locked by another user
    return False  # Editable

# ------------------------------------------------------
# ADD AUDIT LOG ENTRY
# ------------------------------------------------------
def add_audit_log(conn, action, table_name, record_id, user, old_data, new_data):
    """
    Logs all actions performed on BRM tables.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (action, table_name, record_id, user, json.dumps(old_data), json.dumps(new_data)))
    conn.commit()
# ------------------------------------------------------
# CHECK IF USER HAS TABLE-LEVEL PERMISSIONS
# ------------------------------------------------------
def check_table_permissions(conn, user_group, table_list):
    """
    Ensures that the user's group has access to all tables used in a rule.
    """
    c = conn.cursor()
    c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (user_group,))
    allowed_tables = {row[0] for row in c.fetchall()}

    for table in table_list:
        if table not in allowed_tables:
            raise PermissionError(f"Access Denied: {user_group} does not have permission for {table}.")
# ------------------------------------------------------
# EXECUTE RULE SQL (Supports Dry-Run & Real Execution)
# ------------------------------------------------------
def execute_rule(conn, rule_id, is_dry_run=False):
    """
    Executes the rule SQL and returns pass/fail.
    If is_dry_run=True, the transaction is rolled back.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = c.fetchone()
    if not row:
        return False, "Rule not found."

    sql = row[0]
    try:
        c.execute("BEGIN TRANSACTION")
        c.execute(sql)
        rows = c.fetchall()
        result = rows[0][0] if rows else 0
        if is_dry_run:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
        return result == 1, f"Executed successfully, returned: {result}"
    except Exception as ex:
        c.execute("ROLLBACK")
        return False, str(ex)

# ------------------------------------------------------
# CHAIN SIMULATION DIALOG
# ------------------------------------------------------
class ChainSimulationDialog(QDialog):
    """
    Runs a chain of rules starting from a selected rule.
    Uses BFS to execute all dependent rules in sequence.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Rule Chain")
        self.resize(500, 300)
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.parent_rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for rid, rname in rows:
            self.parent_rule_combo.addItem(f"{rid} - {rname}", rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)
        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_chain(self):
        pid = self.parent_rule_combo.currentData()
        ex, sk = self.run_chain_simulation(pid)
        txt = f"Executed: {ex}\nSkipped: {sk}"
        self.result_text.setPlainText(txt)

    def run_chain_simulation(self, start_rule):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rows = c.fetchall()
        rule_map = {}
        children_map = {}

        for rid, pid, sql in rows:
            rule_map[rid] = sql
            if pid:
                children_map.setdefault(pid, []).append(rid)

        executed = []
        skipped = set()
        queue = [start_rule]

        while queue:
            rid = queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_map:
                skipped.add(rid)
                continue
            sql = rule_map[rid]
            ok, msg = execute_rule(self.connection, rid, is_dry_run=True)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    queue.extend(children_map[rid])
            else:
                skipped.add(rid)

        return executed, skipped
