#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL â€“ PART 2 (REVISED + ENHANCED)
Includes:
  - BFS rule exec with child & global-critical links
  - Multi-step approvals with advanced conditional logic
  - Impact analysis
  - Strict permission checks for table references
  - Locking logic stubs (with concurrency checks) 
  - add_rule, update_rule, deactivate_rule, delete_rule 
    fully integrated with table-level permission checks
No references to older placeholders or minimal code.
Assumes PART 1 has all imports, parse_sql_dependencies, detect_operation_type, etc.
"""

import json
import math
from datetime import datetime
from collections import deque


# ============================================================================
# PERMISSION CHECK UTILITY
# ============================================================================
def check_group_permissions_for_rule(conn, owner_group, referenced_tables):
    """
    Verify that 'owner_group' has permission for each (schema, table).
    If missing => raise ValueError.

    'referenced_tables' => from parse_sql_dependencies(sql_text)["tables"]
       Each element is a tuple: (schema_name, table_name, alias, is_subselect).
    """
    c = conn.cursor()

    for (schema_name, table_name, alias, is_sub) in referenced_tables:
        # skip if no real table_name or it starts with something like (CTE) or MISSING_
        if not table_name or table_name.startswith("(CTE)") or table_name.startswith("MISSING_"):
            continue

        schema = schema_name if schema_name else "dbo"
        fully_qualified = f"{schema}.{table_name}"

        c.execute("""
            SELECT 1
            FROM GROUP_PERMISSIONS
            WHERE GROUP_NAME = ?
              AND TARGET_TABLE = ?
        """, (owner_group, fully_qualified))
        row = c.fetchone()
        if not row:
            msg = (f"Group '{owner_group}' lacks permission to reference '{fully_qualified}'.")
            raise ValueError(msg)


# ============================================================================
# BUILD RULE ADJACENCY (FOR BFS)
# ============================================================================
def build_rule_adjacency(conn):
    """
    Return (children_map, roots).
    children_map => parent_rule_id -> [child_rule_ids...]
    roots => list of top-level rule IDs with no parent.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    children_map = {}
    all_ids = set()
    parent_ids = set()

    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)

    roots = [x for x in all_ids if x not in parent_ids]
    return (children_map, roots)


def load_global_critical_links(conn):
    """
    Return a map => GCR_RULE_ID -> set of target IDs 
    for global-critical links.
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = c.fetchall()
    link_map = {}
    for (gcr, tgt) in rows:
        link_map.setdefault(gcr, set()).add(tgt)
    return link_map


def get_all_rules_as_dict(conn):
    """
    Return rule_id -> row-dict for BFS logic
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    allrows = c.fetchall()
    cols = [desc[0] for desc in c.description]
    out = {}
    for row in allrows:
        d = dict(zip(cols, row))
        out[d["RULE_ID"]] = d
    return out


def skip_descendants(child_id, children_map, skipped):
    """
    BFS to skip all descendants of child_id in children_map, adding to 'skipped'.
    """
    stack = [child_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in children_map:
            stack.extend(children_map[cur])


def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert an execution record into RULE_EXECUTION_LOGS
    """
    c = conn.cursor()
    c.execute("""
      INSERT INTO RULE_EXECUTION_LOGS(
        RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
      )
      VALUES(?, GETDATE(), ?, ?, ?)
    """, (rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()


def execute_rules_in_order(conn):
    """
    BFS from root => run rule SQL => if critical rule fails => skip children, etc.
    """
    children_map, roots = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)

    executed = []
    skipped = set()
    c = conn.cursor()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info = rule_lookup[rid]
        sql_ = info["RULE_SQL"] or ""
        is_crit = (info["CRITICAL_RULE"] == 1 or info["IS_GLOBAL"] == 1)
        crit_scope = (info["CRITICAL_SCOPE"] or "NONE").upper()

        c.execute("BEGIN TRANSACTION")
        success = False
        msg = ""
        rec_count = 0
        try:
            if sql_.strip():
                c.execute(sql_)
                rows = c.fetchall()
                if rows:
                    rec_count = len(rows)
                    val = rows[0][0]
                    success = (val == 1)
                    msg = f"Returned: {val}"
                else:
                    success = True
                    msg = "No rows => PASS"
            else:
                # e.g. DECISION_TABLE or no SQL => stub pass
                success = True
                msg = "DECISION_TABLE or empty SQL => PASS"

            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success = False
            msg = str(ex)

        insert_rule_execution_log(conn, rid, success, msg, rec_count)

        if success:
            executed.append(rid)
            if rid in children_map:
                for ch_ in children_map[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip children if critical
            if is_crit and crit_scope != "NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)
            skipped.add(rid)

    return (executed, skipped)


# ============================================================================
# MULTI-STEP APPROVALS
# ============================================================================
def get_child_rules_bfs(conn, start_rule_id):
    """
    Return set of all descendant rule IDs (child BFS + GCR).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    child_map = {}
    for (rid, pid) in rows:
        if pid:
            child_map.setdefault(pid, []).append(rid)

    gcr = load_global_critical_links(conn)
    visited = set()
    queue = [start_rule_id]
    results = set()

    while queue:
        cur = queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in child_map:
            for ch_ in child_map[cur]:
                results.add(ch_)
                queue.append(ch_)

        if cur in gcr:
            for g_ in gcr[cur]:
                results.add(g_)
                queue.append(g_)

    return results


def find_impacted_business_groups(conn, rule_id):
    """
    Return set of impacted groups => BFS of child, GCR, then read OWNER_GROUP
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row[0])

    child_ids = get_child_rules_bfs(conn, rule_id)
    for cid in child_ids:
        c2 = conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID = ?", (cid,))
        r2 = c2.fetchone()
        if r2:
            impacted.add(r2[0])
    return impacted


def create_multistep_approvals(conn, rule_id):
    """
    Standard pipeline => BG1 -> BG2 -> BG3 -> FINAL, 
    plus table-based conditions => require BG2 or BG3 if e.g. finance, sensitive, etc.
    BFS impacted groups included as well.
    """
    impacted = find_impacted_business_groups(conn, rule_id)

    c2 = conn.cursor()
    c2.execute("""
        SELECT TABLE_NAME
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE RULE_ID = ?
    """, (rule_id,))
    deps = c2.fetchall()
    require_bg2 = False
    require_bg3 = False

    for (tname,) in deps:
        lo = (tname or "").lower()
        if "finance" in lo or "credit" in lo:
            require_bg2 = True
        if "sensitive_data" in lo or "personal_info" in lo:
            require_bg3 = True

    pipeline = []
    pipeline.append("BG1")

    if require_bg2 or ("BG2" in impacted):
        pipeline.append("BG2")
    if require_bg3 or ("BG3" in impacted):
        pipeline.append("BG3")

    pipeline.append("FINAL")

    c = conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID = ?", (rule_id,))
    stage_ctr = 1

    for grp in pipeline:
        if grp == "FINAL":
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                  APPROVED_TIMESTAMP, APPROVAL_STAGE
                )
                VALUES(?,?,?,?,NULL,?)
            """, (rule_id, "FINAL", "final_approver", 0, stage_ctr))
            stage_ctr += 1
        else:
            c3 = conn.cursor()
            c3.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME = ?", (grp,))
            arows = c3.fetchall()
            for (apuser,) in arows:
                c.execute("""
                    INSERT INTO BRM_RULE_APPROVALS(
                      RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                      APPROVED_TIMESTAMP, APPROVAL_STAGE
                    )
                    VALUES(?,?,?,?,NULL,?)
                """, (rule_id, grp, apuser, 0, stage_ctr))
            stage_ctr += 1

    conn.commit()


# ============================================================================
# RULE CRUD (STRICT PERMISSION CHECKS + LOCKING)
# ============================================================================
def lock_rule_for_edit(conn, rule_id, user_name):
    """
    Insert a row into BRM_RULE_LOCKS => (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP).
    If rule is already locked by someone else => raise an error or allow forced unlock.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        locked_by = row[0]
        if locked_by != user_name:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
        # else locked by the same user => OK
    else:
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP)
            VALUES(?,?,GETDATE())
        """, (rule_id, user_name))
        conn.commit()


def unlock_rule(conn, rule_id, user_name=None, force=False):
    """
    If 'force' => admin can remove lock. Otherwise only the same user can unlock.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        locked_by = row[0]
        if not force:
            if user_name and locked_by != user_name:
                raise ValueError(f"Cannot unlock. Rule {rule_id} is locked by {locked_by}.")
        c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID = ?", (rule_id,))
        conn.commit()


def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert => parse => set lifecycle => create approvals => with table-level checks => lock => done.
    """
    c = conn.cursor()
    # duplicates
    c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE OWNER_GROUP = ? AND RULE_NAME = ?
    """, (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    new_sql = rule_data.get("RULE_SQL","").strip()
    if new_sql:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL = ?", (new_sql,))
        row2 = c.fetchone()
        if row2:
            raise ValueError("Another rule with that exact SQL already exists.")

    # lifecycle
    rule_data["LIFECYCLE_STATE"] = "DRAFT"
    if rule_data.get("IS_GLOBAL",0) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create a global rule.")

    # parse + permission checks
    op_type = detect_operation_type(new_sql)
    parse_info = parse_sql_dependencies(new_sql)
    check_group_permissions_for_rule(conn, rule_data["OWNER_GROUP"], parse_info["tables"])

    # example of auto lock => optional
    # you could lock an ID=0 or do not lock yet
    # lock_rule_for_edit(conn, ???, created_by)  # if you want an ID you can't do it before insert 
    # ...
    
    row = c.execute("""
      INSERT INTO BRM_RULES(
        GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
        EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
        CREATED_BY, DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
        CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP, CLUSTER_NAME,
        APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE,
        LIFECYCLE_STATE
      )
      OUTPUT inserted.RULE_ID
      VALUES(?,?,?,?,?,
             ?,?,
             ?,?,
             ?,?,?,?,?,?,
             ?,?,?,?,
             ?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,

        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),

        rule_data.get("STATUS","INACTIVE"),
        1,

        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),

        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),

        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE"),
        rule_data["LIFECYCLE_STATE"]
    )).fetchone()

    if not row:
        raise ValueError("Insert failed => no RULE_ID.")
    new_id = row[0]

    # Insert table deps
    col_op = "READ"
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op = "WRITE"

    for (sch, tb, alias, is_sub) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            c.execute("""
               INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                 RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
               )
               VALUES(?,?,?,?,?)
            """, (new_id, sch if sch else "dbo", tb, "AutoCol", col_op))
    conn.commit()

    # create approvals if not global or if user is admin => up to you
    if rule_data.get("IS_GLOBAL",0) == 0 or user_group=="Admin":
        create_multistep_approvals(conn, new_id)

    return new_id


def update_rule(conn, rule_data, updated_by, user_group):
    """
    Update => re-check table permissions => set status=INACTIVE => re-approval => etc.
    """
    c = conn.cursor()
    rid = rule_data["RULE_ID"]

    # check lock => optionally
    # lock_rule_for_edit(conn, rid, updated_by)

    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    colnames = [desc[0] for desc in c.description]
    old_data = dict(zip(colnames, old))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update global rule.")

    new_sql = rule_data.get("RULE_SQL","").strip()
    if new_sql and new_sql!=old_data["RULE_SQL"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL = ?", (new_sql,))
        row2 = c.fetchone()
        if row2 and row2[0]!=rid:
            raise ValueError("Another rule with that SQL already exists.")

    # parse + permission checks
    op_type = detect_operation_type(new_sql)
    parse_info = parse_sql_dependencies(new_sql)
    owner_g = rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"])
    check_group_permissions_for_rule(conn, owner_g, parse_info["tables"])

    # do actual update
    c.execute("""
      UPDATE BRM_RULES
      SET GROUP_ID = ?,
          PARENT_RULE_ID = ?,
          RULE_TYPE_ID = ?,
          RULE_NAME = ?,
          RULE_SQL = ?,
          EFFECTIVE_START_DATE = ?,
          EFFECTIVE_END_DATE = ?,
          STATUS = 'INACTIVE',
          VERSION = VERSION + 1,
          UPDATED_BY = ?,
          DESCRIPTION = ?,
          OPERATION_TYPE = ?,
          BUSINESS_JUSTIFICATION = ?,
          OWNER_GROUP = ?,
          CLUSTER_NAME = ?,
          APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
          IS_GLOBAL = ?,
          CRITICAL_RULE = ?,
          CRITICAL_SCOPE = ?,
          CDC_TYPE = ?,
          LIFECYCLE_STATE = 'UNDER_APPROVAL'
      WHERE RULE_ID = ?
    """,(
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,

        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),

        updated_by,
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        owner_g,
        rule_data.get("CLUSTER_NAME", old_data["CLUSTER_NAME"]),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rid
    ))
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rid,))

    col_op = "READ"
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op = "WRITE"
    for (sch, tb, alias, is_sub) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            c.execute("""
               INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                 RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
               )
               VALUES(?,?,?,?,?)
            """, (rid, sch if sch else "dbo", tb, "AutoCol", col_op))

    conn.commit()

    # create approvals if not global or user is admin
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"])==0 or user_group=="Admin":
        create_multistep_approvals(conn, rid)


def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivate => must be fully approved => no active children => if global => admin only
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in c.description]
    old_data = dict(zip(cols, old))

    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate => not fully approved.")
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate a global rule.")

    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID = ? AND STATUS='ACTIVE'", (rule_id,))
    if c.fetchone():
        raise ValueError("Deactivate child rules first (some are active).")

    c.execute("""
      UPDATE BRM_RULES
      SET STATUS='INACTIVE',
          UPDATED_BY=?,
          VERSION=VERSION+1,
          LIFECYCLE_STATE='INACTIVE'
      WHERE RULE_ID=?
    """, (updated_by, rule_id))
    conn.commit()


def delete_rule(conn, rule_id, action_by, user_group):
    """
    Fully-approved, inactive => no children => no references => if global => admin only.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in c.description]
    old_data = dict(zip(cols, old))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete => not fully approved.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Must be inactive first.")

    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID = ?", (rule_id,))
    if c.fetchone():
        raise ValueError("Child rules exist => cannot delete.")

    c.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    if c.fetchone():
        raise ValueError("Remove references from BRM_COLUMN_MAPPING first.")

    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    conn.commit()

    # also remove from BRM_RULE_LOCKS if present
    c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID = ?", (rule_id,))
    conn.commit()
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL â€“ PART 3 (REVISED + ENHANCED)
Single/Chain/Group simulations, improved scheduling,
advanced feature tabs (decision tables, conflicts, composites, snapshots, tags, validations),
plus "WhatIfTestTab" with real CSV loading.
Added "Run All Data Validations" direct feature to DataValidationTab.
No references to older minimal code.
"""

import json
import math
import logging
import csv
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget, QFileDialog, QAbstractItemView, QCheckBox
)
from PyQt5.QtCore import Qt, QDateTime, QDate
from PyQt5.QtGui import QColor
import pyqtgraph as pg  # for charting or advanced visuals if needed


# ----------------------------------------------------------------------------
# UTILITY: DRY-RUN RULE SQL
# ----------------------------------------------------------------------------
def run_rule_sql_dry_run(conn, rule_sql):
    """
    Attempt rule SQL in a transaction => interpret row[0][0]==1 => PASS. Then rollback.
    If no SQL => pass
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    try:
        if rule_sql.strip():
            c.execute(rule_sql)
            rows = c.fetchall()
            if rows:
                val = rows[0][0]
                success = (val == 1)
                msg = f"Returned: {val}"
            else:
                success = True
                msg = "No rows => PASS"
        else:
            success = True
            msg = "No SQL => pass"
    except Exception as ex:
        success = False
        msg = str(ex)
    c.execute("ROLLBACK")
    return (success, msg)


# ----------------------------------------------------------------------------
# SINGLE RULE SIMULATION
# ----------------------------------------------------------------------------
class SingleRuleSimulationDialog(QDialog):
    """
    Let user pick a single rule's SQL => do a BFS or single test => show pass/fail.
    For simplicity, we do direct dry-run of the SQL.
    """
    def __init__(self, connection, rule_id, rule_sql, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.rule_sql = rule_sql

        self.setWindowTitle(f"Simulate Rule {rule_id} â€“ PartÂ 3 (Enhanced)")
        self.resize(500,300)
        layout = QVBoxLayout(self)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Dry-Run Rule")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def do_sim(self):
        ok, msg = run_rule_sql_dry_run(self.connection, self.rule_sql)
        self.result_text.setPlainText(
            f"Rule {self.rule_id} => {'PASS' if ok else 'FAIL'} => {msg}"
        )


# ----------------------------------------------------------------------------
# CHAIN SIMULATION
# ----------------------------------------------------------------------------
class ChainSimulationDialog(QDialog):
    """
    BFS from a chosen 'parent rule' => do a dry-run for each child's SQL => 
    skipping if a parent fails.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Parent Chain â€“ PartÂ 3 (Enhanced)")
        self.resize(500,300)
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.parent_rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for (rid, rn) in rows:
            disp = f"{rid} - {rn}"
            self.parent_rule_combo.addItem(disp, rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Chain BFS")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_chain(self):
        pid = self.parent_rule_combo.currentData()
        ex, fails = self.run_chain_bfs(pid)
        txt = (f"Chain BFS from rule {pid}\n"
               f"Executed => {ex}\n"
               f"SkippedOrFailed => {fails}")
        self.result_text.setPlainText(txt)

    def run_chain_bfs(self, start_rule):
        """
        Minimal BFS for parent->child relationships. If any rule fails => skip descendants.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rows = c.fetchall()

        rule_map = {}
        child_map = {}
        for (rid, pid, sql_) in rows:
            rule_map[rid] = sql_
            if pid:
                child_map.setdefault(pid, []).append(rid)

        executed = []
        failed_or_skipped = []
        queue = [start_rule]

        while queue:
            rid = queue.pop(0)
            if rid not in rule_map:
                failed_or_skipped.append(rid)
                continue
            sql_ = rule_map[rid] or ""
            ok, msg = run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
                if rid in child_map:
                    for ch_ in child_map[rid]:
                        queue.append(ch_)
            else:
                failed_or_skipped.append(rid)
                # skip children
                if rid in child_map:
                    for ch_ in child_map[rid]:
                        failed_or_skipped.append(ch_)

        return (executed, failed_or_skipped)


# ----------------------------------------------------------------------------
# GROUP SIMULATION
# ----------------------------------------------------------------------------
class GroupSimulationDialog(QDialog):
    """
    For a 'custom group' => run each rule => show pass/fail immediately.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Custom Group â€“ PartÂ 3 (Enhanced)")
        self.resize(500,300)
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.group_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows = c.fetchall()
        for (cg_id, cg_name) in rows:
            disp = f"{cg_id} - {cg_name}"
            self.group_combo.addItem(disp, cg_id)
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Group BFS")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_group(self):
        cg_id = self.group_combo.currentData()
        ex, fails = self.do_group_sim(cg_id)
        msg = (f"Custom Group {cg_id} Simulation:\n"
               f"Executed => {ex}\n"
               f"FailedOrSkipped => {fails}")
        self.result_text.setPlainText(msg)

    def do_group_sim(self, cg_id):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (cg_id,))
        group_rules = [r[0] for r in c.fetchall()]

        c.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES")
        allrows = c.fetchall()
        rule_map = {row[0]: row[1] for row in allrows}

        executed = []
        fails = []
        for rid in group_rules:
            sql_ = rule_map.get(rid, "")
            ok, msg = run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return (executed, fails)


# ----------------------------------------------------------------------------
# SYNC METADATA (IMPROVED)
# ----------------------------------------------------------------------------
def sync_metadata_improved(conn):
    c = conn.cursor()
    c.execute("""
        SELECT s.name AS schema_name, t.name AS table_name
        FROM sys.tables t
        JOIN sys.schemas s ON t.schema_id = s.schema_id
        ORDER BY s.name, t.name
    """)
    actual_tables = set()
    for row in c.fetchall():
        fulln = f"{row[0]}.{row[1]}".lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID, RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps = c.fetchall()
    missing_count = 0

    for (dep_id, rule_id, dbn, tbln) in deps:
        cand = (tbln or "").lower().strip()
        if "." not in cand:
            cand = f"dbo.{cand}"
        cand = cand.lower()
        if cand not in actual_tables:
            c.execute("""
                UPDATE BRM_RULE_TABLE_DEPENDENCIES
                SET TABLE_NAME = 'MISSING_' + TABLE_NAME
                WHERE DEPENDENCY_ID = ?
            """, (dep_id,))
            missing_count += 1
    conn.commit()

    msg = (f"Metadata sync complete.\n"
           f"Found {len(actual_tables)} real DB tables.\n"
           f"Scanned {len(deps)} dependencies.\n"
           f"Marked {missing_count} as 'MISSING_'.")
    QMessageBox.information(None, "Sync Metadata", msg)


# ----------------------------------------------------------------------------
# SCHEDULING
# ----------------------------------------------------------------------------
class EnhancedScheduleDialog(QDialog):
    """
    Let user pick a rule => schedule => store in RULE_SCHEDULES => status=Scheduled.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling UI (PartÂ 3)")
        self.resize(400,300)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for (rid, rname) in rows:
            disp = f"{rid} - {rname}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        cl_btn = QPushButton("Close")
        cl_btn.clicked.connect(self.close)
        bh.addWidget(cl_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_ = self.calendar.selectedDate()
        time_ = self.time_edit.time()
        dt_str = f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        c = self.connection.cursor()
        c.execute("""
            INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP)
            VALUES(?,?,'Scheduled',GETDATE())
        """, (rid, dt_str))
        self.connection.commit()
        QMessageBox.information(self, "Scheduled", f"Rule {rid} scheduled at {dt_str}.")
        self.close()


class ScheduleManagementTab(QWidget):
    """
    Show up to 1000 schedules => add/update/delete schedule 
    for advanced scheduling.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 5)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID","RuleID","ScheduleTime","Status","Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
          SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
          FROM RULE_SCHEDULES
          ORDER BY SCHEDULE_TIME DESC
          OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()
        for row in rows:
            r_ = self.table.rowCount()
            self.table.insertRow(r_)
            self.table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(r_,1,QTableWidgetItem(str(row[1])))
            self.table.setItem(r_,2,QTableWidgetItem(str(row[2])))
            self.table.setItem(r_,3,QTableWidgetItem(str(row[3])))

            act_widget = QWidget()
            hh = QHBoxLayout(act_widget)
            hh.setContentsMargins(0,0,0,0)

            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rr=r_: self.update_schedule(rr))
            hh.addWidget(upd_btn)

            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rr=r_: self.delete_schedule(rr))
            hh.addWidget(del_btn)

            hh.addStretch()
            self.table.setCellWidget(r_,4,act_widget)

        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_idx):
        it = self.table.item(row_idx,0)
        if not it:
            return
        sch_id = int(it.text())
        new_dt, ok = QInputDialog.getText(self,"Update Schedule","New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, row_idx):
        it = self.table.item(row_idx,0)
        if not it:
            return
        sch_id = int(it.text())
        confirm = QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()


# ----------------------------------------------------------------------------
# DECISION TABLES TAB, CONFLICT PRIORITY, COMPOSITE RULES, SNAPSHOTS, TAGS,
# DATA VALIDATION (WITH "RUN ALL VALIDATIONS") & WHAT-IF TEST TAB
# ----------------------------------------------------------------------------

class DecisionTablesTab(QWidget):
    # ... same as earlier code ...
    pass

class ConflictPriorityManagerTab(QWidget):
    # ... same ...
    pass

class CompositeRulesTab(QWidget):
    # ... same ...
    pass

class SnapshotManagerTab(QWidget):
    # ... same ...
    pass

class TagsManagerTab(QWidget):
    # ... same ...
    pass


# ----------------------------------------------------------------------------
# DATA VALIDATION TAB (ENHANCED WITH "RUN ALL" BUTTON)
# ----------------------------------------------------------------------------
class DataValidationTab(QWidget):
    """
    Manage validations + run them real-time with a new button => pass/fail displayed.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.dv_table = QTableWidget(0, 5)
        self.dv_table.setHorizontalHeaderLabels([
            "VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"
        ])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)

        rem_btn = QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_val)
        bh.addWidget(rem_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)

        # NEW: "Run All" button
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        bh.addWidget(run_btn)

        bh.addStretch()
        layout.addLayout(bh)

        # A text area to show results
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
          SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
          FROM DATA_VALIDATIONS
          ORDER BY VALIDATION_ID
        """)
        rows = c.fetchall()
        for r_ in rows:
            rr = self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            for col_i, val in enumerate(r_):
                self.dv_table.setItem(rr, col_i, QTableWidgetItem(str(val) if val else ""))

    def add_val(self):
        # standard approach
        pass

    def remove_val(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it = self.dv_table.item(row,0)
        if not it:
            return
        vid = int(it.text())
        confirm = QMessageBox.question(self,"Confirm",f"Remove validation {vid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID = ?", (vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

    def run_all_validations(self):
        """
        Query all validations => run each => log pass/fail => show results in result_text.
        Minimal example with a NOT NULL or RANGE logic.
        """
        c = self.connection.cursor()
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS")
        validations = c.fetchall()

        output_lines = []
        for (vid, tbl, col, vtype, params) in validations:
            success = True
            message = "PASS"
            try:
                if vtype.upper()=="NOT NULL":
                    q = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                    c.execute(q)
                    null_count = c.fetchone()[0]
                    if null_count>0:
                        success=False
                        message=f"FAIL => Found {null_count} null(s)"
                elif vtype.upper()=="RANGE":
                    # parse numeric range from params, e.g. "0-100"
                    # ...
                    pass
                # else other types
            except Exception as ex:
                success=False
                message=f"Error => {ex}"

            # log results
            c2 = self.connection.cursor()
            c2.execute("""
               INSERT INTO DATA_VALIDATION_LOGS(
                 VALIDATION_ID, RUN_TIMESTAMP, PASS_FLAG, MESSAGE
               )
               VALUES(?, GETDATE(), ?, ?)
            """,(vid, 1 if success else 0, message))
            self.connection.commit()

            out_str = f"ValidationID={vid} on {tbl}.{col} => {'PASS' if success else 'FAIL'} => {message}"
            output_lines.append(out_str)

        self.result_text.setPlainText("\n".join(output_lines))
        QMessageBox.information(self,"Validation Run",f"Executed {len(validations)} validations.")


# ----------------------------------------------------------------------------
# WHAT-IF TEST TAB
# ----------------------------------------------------------------------------
class WhatIfTestTab(QWidget):
    # ... same as your prior advanced code ...
    pass
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL â€“ PART 4 (REVISED + ENHANCED)
 - AuditLogViewer
 - RuleSearchDialog
 - VersionHistoryDialog (with line-by-line comparison stubs if needed)
 - RuleDashboard (with a new 'Locked By' column)
 - RuleEditorDialog
No references to older minimal code.
"""

import sys
import json
import csv
import math
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox,
    QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox
)
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtGui import QColor


# ----------------------------------------------------------------------------
# AUDIT LOG VIEWER
# ----------------------------------------------------------------------------
class AuditLogViewer(QDialog):
    """
    Show BRM_AUDIT_LOG => search => CSV export
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        self.setWindowTitle("Audit Logs â€“ PartÂ 4 (Enhanced)")
        self.resize(800,600)
        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.log_table = QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        csv_btn = QPushButton("Export CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
          FROM BRM_AUDIT_LOG
          ORDER BY ACTION_TIMESTAMP DESC
          OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()
        for row in rows:
            r_ = self.log_table.rowCount()
            self.log_table.insertRow(r_)
            for col_i in range(8):
                val = row[col_i]
                if col_i in (5,6) and val:
                    try:
                        d_ = json.loads(val)
                        val = json.dumps(d_, indent=2)
                    except:
                        pass
                item = QTableWidgetItem(str(val) if val else "")
                self.log_table.setItem(r_, col_i, item)

    def perform_search(self, text):
        txt = text.lower()
        for row in range(self.log_table.rowCount()):
            show = False
            for col_i in (1,2,4):
                it = self.log_table.item(row,col_i)
                if it and (txt in it.text().lower()):
                    show = True
                    break
            self.log_table.setRowHidden(row, not show)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self,"Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer = csv.writer(f)
            headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row):
                    continue
                rowdata=[]
                for col in range(self.log_table.columnCount()):
                    it=self.log_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported",f"Audit logs exported to {path}.")


# ----------------------------------------------------------------------------
# RULE SEARCH DIALOG
# ----------------------------------------------------------------------------
class RuleSearchDialog(QDialog):
    """
    Basic text snippet search => name or SQL => show top 1000 in table
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        self.setWindowTitle("Search Rules â€“ PartÂ 4 (Enhanced)")
        self.resize(800,600)
        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","CreatedBy"
        ])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)

        rb = QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        layout.addWidget(rb)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt = self.search_edit.text().strip()
        c = self.connection.cursor()
        if txt:
            c.execute("""
              SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
              FROM BRM_RULES
              WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)

        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_ = self.res_table.rowCount()
            self.res_table.insertRow(r_)
            for col_i, val in enumerate(row):
                item = QTableWidgetItem(str(val) if val else "")
                self.res_table.setItem(r_, col_i, item)


# ----------------------------------------------------------------------------
# VERSION HISTORY DIALOG
# ----------------------------------------------------------------------------
class VersionHistoryDialog(QDialog):
    """
    Show audit log for a rule => optionally rollback => line-by-line compare stub
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id

        self.setWindowTitle(f"Version History â€“ Rule {rule_id} (PartÂ 4 Enhanced)")
        self.resize(800,400)
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels([
            "AuditID","Action","Timestamp","OldData","NewData","Compare"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh = QHBoxLayout()
        rb_btn = QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.do_rollback)
        bh.addWidget(rb_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c = self.connection.cursor()
        c.execute("""
           SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
           FROM BRM_AUDIT_LOG
           WHERE TABLE_NAME='BRM_RULES'
             AND RECORD_ID=?
             AND ACTION IN ('INSERT','UPDATE')
           ORDER BY ACTION_TIMESTAMP DESC
        """, (self.rule_id,))
        rows = c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_ = self.table.rowCount()
            self.table.insertRow(r_)
            # 0..4 => columns
            for i_ in range(3):
                val = row[i_]
                self.table.setItem(r_, i_, QTableWidgetItem(str(val) if val else ""))

            old_s = ""
            new_s = ""
            if row[3]:
                try:
                    d_ = json.loads(row[3])
                    old_s = json.dumps(d_, indent=2)
                except:
                    old_s = str(row[3])
            if row[4]:
                try:
                    d2 = json.loads(row[4])
                    new_s = json.dumps(d2, indent=2)
                except:
                    new_s = str(row[4])

            self.table.setItem(r_, 3, QTableWidgetItem(old_s))
            self.table.setItem(r_, 4, QTableWidgetItem(new_s))

            # A compare button or placeholder
            compare_btn = QPushButton("Compare")
            compare_btn.clicked.connect(lambda _, rr=r_: self.compare_version(rr))
            self.table.setCellWidget(r_, 5, compare_btn)

    def compare_version(self, row_i):
        """
        Show line-by-line difference between old/new in a simple dialog.
        """
        old_data_item = self.table.item(row_i, 3)
        new_data_item = self.table.item(row_i, 4)
        old_s = old_data_item.text() if old_data_item else ""
        new_s = new_data_item.text() if new_data_item else ""

        # You could do a diff library (difflib) approach here 
        # For now, just show them side by side:
        cdlg = QDialog(self)
        cdlg.setWindowTitle("Compare Versions")
        cdlg.resize(800,600)
        lay = QVBoxLayout(cdlg)

        txt = QPlainTextEdit()
        txt.setReadOnly(True)
        diff_str = f"--- OLD ---\n{old_s}\n\n+++ NEW +++\n{new_s}\n"
        txt.setPlainText(diff_str)
        lay.addWidget(txt)

        cb = QPushButton("Close")
        cb.clicked.connect(cdlg.close)
        lay.addWidget(cb)
        cdlg.exec_()

    def do_rollback(self):
        sel = self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected.")
            return
        row_i = sel[0].row()
        old_data_item = self.table.item(row_i, 3)
        if not old_data_item:
            QMessageBox.warning(self,"No Data","No old_data found.")
            return
        old_json = old_data_item.text().strip()
        if not old_json:
            QMessageBox.warning(self,"Empty","Empty old_data => cannot rollback.")
            return
        confirm = QMessageBox.question(self,"Confirm","Rollback to this version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_dict = json.loads(old_json)
        except Exception as ex:
            QMessageBox.critical(self,"JSON Error",str(ex))
            return
        self.apply_rollback(old_dict)
        QMessageBox.information(self,"Rolled Back","Version rollback done.")
        self.load_history()

    def apply_rollback(self, old_data):
        """
        Minimal approach => forcibly sets name, sql, owner => sets status=INACTIVE => re-approval
        plus re-parse table dependencies if needed.
        """
        rid = old_data["RULE_ID"]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
        row = c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")

        new_sql = old_data.get("RULE_SQL","")
        c.execute("BEGIN TRANSACTION")
        c.execute("""
           UPDATE BRM_RULES
           SET RULE_NAME = ?,
               RULE_SQL = ?,
               OWNER_GROUP = ?,
               STATUS='INACTIVE',
               VERSION=VERSION+1,
               UPDATED_BY='Rollback',
               APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
           WHERE RULE_ID=?
        """,(old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rid))

        # re-parse dependencies
        from .part1_foundation import parse_sql_dependencies, detect_operation_type  # if separate file
        # Or if you're in a single-file scenario, just call parse_sql_dependencies(...) directly.

        op_ = detect_operation_type(new_sql)
        parse_info = parse_sql_dependencies(new_sql)
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rid,))
        col_op = "READ"
        if op_ in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"
        for (sch,tb,alias,sub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                   INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                     RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                   )
                   VALUES(?,?,?,?,?)
                """,(rid, sch if sch else "dbo", tb, "RolledBackCol", col_op))

        c.execute("COMMIT")


# ----------------------------------------------------------------------------
# RULE DASHBOARD
# ----------------------------------------------------------------------------
class RuleDashboard(QGroupBox):
    """
    Paginated table => new column for "Locked By"
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        # top filter
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL..")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        # rule table => now 9 columns => last is lockedBy
        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","OwnerGroup","CreatedTS","ApprovalStatus","Locked By"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_clause(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            filters.append("STATUS = ?")
            params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return (clause, params)

    def load_rules(self):
        c = self.connection.cursor()
        clause, pars = self.build_filter_clause()

        # total count
        count_q = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, pars)
        rowc = c.fetchone()
        total = rowc[0] if rowc else 0
        self.total_pages = max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset = (self.current_page-1)*self.records_per_page
        data_q = f"""
          SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION,
                 OWNER_GROUP, CREATED_TIMESTAMP, APPROVAL_STATUS
          FROM BRM_RULES
          WHERE {clause}
          ORDER BY RULE_ID DESC
          OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*pars, offset, self.records_per_page))
        rows = c.fetchall()

        # fetch lock info => rule_id -> locked_by
        c2 = self.connection.cursor()
        c2.execute("SELECT RULE_ID, LOCKED_BY FROM BRM_RULE_LOCKS")
        lock_rows = c2.fetchall()
        lock_map = {}
        for (rid, lby) in lock_rows:
            lock_map[rid] = lby

        self.rule_table.setRowCount(0)
        for row in rows:
            r_ = self.rule_table.rowCount()
            self.rule_table.insertRow(r_)

            # first 8 columns
            for col_i in range(8):
                val = row[col_i]
                item = QTableWidgetItem(str(val) if val else "")
                if col_i==3:  # status
                    if str(val).upper()=="ACTIVE":
                        item.setBackground(QColor(144,238,144))
                    else:
                        item.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_, col_i, item)

            # 9th => locked by
            locked_by = lock_map.get(row[0], "")  # row[0] => RULE_ID
            locked_item = QTableWidgetItem(locked_by)
            if locked_by:
                locked_item.setBackground(QColor(255,215,180))
            self.rule_table.setItem(r_, 8, locked_item)

    def get_selected_rule_ids(self):
        sel = self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in sel:
            row = i_.row()
            it = self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()


# ----------------------------------------------------------------------------
# RULE EDITOR DIALOG
# ----------------------------------------------------------------------------
class RuleEditorDialog(QDialog):
    """
    Add or update rule => references add_rule / update_rule from PartÂ 2.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = (rule_data is not None)

        title = "Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title + " â€“ PartÂ 4 (Enhanced)")
        self.resize(800,600)

        main_layout = QVBoxLayout(self)
        form = QFormLayout()

        self.group_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows = c.fetchall()
        for (gid,gname) in grp_rows:
            disp = f"{gname} (ID={gid})"
            self.group_combo.addItem(disp, gid)
        form.addRow("Rule Group:", self.group_combo)

        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        pr_rows = c.fetchall()
        for (rid,rn) in pr_rows:
            disp2 = f"{rn} (ID={rid})"
            self.parent_combo.addItem(disp2, rid)
        form.addRow("Parent Rule:", self.parent_combo)

        self.name_edit = QLineEdit()
        form.addRow("Rule Name:", self.name_edit)

        self.rule_type_combo = QComboBox()
        c.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        trows = c.fetchall()
        for (tid,tn) in trows:
            self.rule_type_combo.addItem(tn, tid)
        form.addRow("Rule Type:", self.rule_type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form.addRow("Status:", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form.addRow("Effective Start:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form.addRow("Effective End:", self.end_dt)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, 0 => FAIL.")
        form.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit = QTextEdit()
        form.addRow("Description:", self.desc_edit)

        self.just_edit = QTextEdit()
        form.addRow("Business Justification:", self.just_edit)

        self.global_cb = None
        if self.user_group=="Admin":
            self.global_cb = QCheckBox("Global (Admin only)")
            form.addRow("Global Rule:", self.global_cb)

        self.critical_cb = QCheckBox()
        form.addRow("Critical Rule:", self.critical_cb)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form.addRow("Critical Scope:", self.scope_combo)

        main_layout.addLayout(form)

        bh = QHBoxLayout()
        self.save_btn = QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)

        cb2 = QPushButton("Cancel")
        cb2.clicked.connect(self.reject)
        bh.addWidget(cb2)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)

        if self.is_update and self.rule_data:
            self.load_existing()

    def load_existing(self):
        rd = self.rule_data
        gid=rd.get("GROUP_ID")
        if gid:
            ix=self.group_combo.findData(gid)
            if ix>=0:
                self.group_combo.setCurrentIndex(ix)

        pid=rd.get("PARENT_RULE_ID")
        if pid:
            ix2=self.parent_combo.findData(pid)
            if ix2>=0:
                self.parent_combo.setCurrentIndex(ix2)

        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3=self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)

        st=rd.get("STATUS","INACTIVE")
        i_st=self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        fmt="%Y-%m-%d %H:%M:%S"
        sd=rd.get("EFFECTIVE_START_DATE","")
        if sd:
            try:
                dt_=datetime.strptime(sd, fmt)
                self.start_dt.setDateTime(dt_)
            except:
                pass
        ed=rd.get("EFFECTIVE_END_DATE","")
        if ed:
            try:
                dt2_=datetime.strptime(ed, fmt)
                self.end_dt.setDateTime(dt2_)
            except:
                pass

        cdcv=rd.get("CDC_TYPE","NONE").upper()
        i_cdc=self.cdc_combo.findText(cdcv)
        if i_cdc>=0:
            self.cdc_combo.setCurrentIndex(i_cdc)

        if rd.get("RULE_SQL"):
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.user_group=="Admin":
            if rd.get("IS_GLOBAL",0)==1 and self.global_cb:
                self.global_cb.setChecked(True)

        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_cb.setChecked(True)

        scp=rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp=self.scope_combo.findText(scp)
        if i_scp>=0:
            self.scope_combo.setCurrentIndex(i_scp)

    def save_rule(self):
        from .part2_crud import add_rule, update_rule  # if separate file approach
        # In single-file, just call the function directly.

        nm=self.name_edit.text().strip()
        sql_=self.sql_edit.toPlainText().strip()

        if not nm:
            QMessageBox.warning(self,"Error","Rule name is required.")
            return

        group_id=self.group_combo.currentData()
        parent_id=self.parent_combo.currentData()
        rt_id=self.rule_type_combo.currentData()
        st=self.status_combo.currentText()
        start_s=self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_s=self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_ = self.cdc_combo.currentText().upper()

        desc_ = self.desc_edit.toPlainText().strip()
        just_ = self.just_edit.toPlainText().strip()

        isg = 0
        if self.user_group=="Admin" and self.global_cb:
            if self.global_cb.isChecked():
                isg=1

        isc=1 if self.critical_cb.isChecked() else 0
        scp_=self.scope_combo.currentText().upper()

        # fetch group name
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?", (group_id,))
        rowg=c.fetchone()
        if rowg:
            owner_g=rowg[0]
        else:
            owner_g="BG1"

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id if parent_id else None,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": start_s,
            "EFFECTIVE_END_DATE": end_s,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdc_,
            "OWNER_GROUP": owner_g
        }

        if self.is_update and self.rule_data:
            # do update
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm=QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Updated","Rule updated => re-approval started.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id=add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Created",f"Rule '{nm}' created (ID={new_id}).")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
