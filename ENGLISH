from flask import Flask, request, render_template_string
import sqlglot
from sqlglot import exp
import json

app = Flask(__name__)

###############################################################################
# DOMAIN MAP (Replace with your actual table/column mappings)
###############################################################################
DOMAIN_MAP = {
    "tables": {
        "financial_risk_table": "the Financial Risk data store"
    },
    "columns": {
        "customer_id": "Customer Identifier",
        "exposure_amount": "Exposure Amount (USD)",
        "rating": "Credit Rating"
    }
}

###############################################################################
# HELPER FUNCTIONS
###############################################################################
def get_domain_name(identifier: str, domain_map: dict, is_table=False) -> str:
    """
    Map raw identifier -> business-friendly name if present in domain_map.
    """
    if not identifier:
        return identifier
    key = identifier.lower().strip()
    if is_table:
        return domain_map["tables"].get(key, identifier)
    else:
        return domain_map["columns"].get(key, identifier)


def explain_expression(expr, domain_map):
    """
    Convert a sqlglot Expression node into a user-friendly string,
    applying domain_map for columns/tables if relevant.
    """
    if isinstance(expr, exp.Column):
        return get_domain_name(expr.name, domain_map, is_table=False)
    elif isinstance(expr, exp.Func):
        # E.g. SUM(...), COUNT(...), etc.
        func_name = expr.name.upper()
        args = expr.args.get("expressions", [])
        return f"{func_name}({', '.join(explain_expression(a, domain_map) for a in args)})"
    elif isinstance(expr, exp.Literal):
        # E.g. 'BBB' or 10
        return str(expr.value).strip("'")
    elif isinstance(expr, exp.Alias):
        # e.g. "SUM(exposure_amount) AS total_exposure"
        alias_name = expr.alias
        child = expr.this
        return f"{explain_expression(child, domain_map)} AS {alias_name}"
    return str(expr)


def parse_and_explain(sql_query: str) -> (str, str):
    """
    1. Parse the SQL with sqlglot
    2. Build a basic English explanation
    3. Return (explanation_text, ast_json)
    """
    try:
        ast = sqlglot.parse_one(sql_query, read='ansi')
    except Exception as e:
        return (f"Error parsing SQL: {e}", "{}")

    if not isinstance(ast, exp.Select):
        return ("Not a valid SELECT statement or unrecognized query.", "{}")

    explanation_parts = []

    # FROM
    from_expr = ast.args.get("from")
    if from_expr and isinstance(from_expr, exp.Table):
        table_name = get_domain_name(from_expr.name, DOMAIN_MAP, is_table=True)
        explanation_parts.append(f"This query retrieves data from **{table_name}**.")

    # SELECT
    select_expressions = ast.select_expressions
    if select_expressions:
        columns = []
        for s in select_expressions:
            columns.append(explain_expression(s, DOMAIN_MAP))
        explanation_parts.append("It selects: " + ", ".join(columns) + ".")

    # WHERE
    if ast.args.get("where"):
        where_condition = ast.args["where"].this
        explanation_parts.append(f"It is filtered by **{explain_expression(where_condition, DOMAIN_MAP)}**.")

    # GROUP BY
    if ast.args.get("group"):
        group_expressions = ast.args["group"].args.get("expressions", [])
        group_cols = [explain_expression(g, DOMAIN_MAP) for g in group_expressions]
        explanation_parts.append("Results are grouped by **" + ", ".join(group_cols) + "**.")

    # ORDER BY
    if ast.args.get("order"):
        order_expressions = ast.args["order"].args.get("expressions", [])
        order_list = []
        for o in order_expressions:
            col_text = explain_expression(o.this, DOMAIN_MAP)
            desc_flag = o.args.get("desc", False)
            direction = "DESC" if desc_flag else "ASC"
            order_list.append(f"{col_text} {direction}")
        explanation_parts.append("It is then sorted by **" + ", ".join(order_list) + "**.")

    # LIMIT
    if ast.args.get("limit"):
        limit_expr = ast.args["limit"].args.get("expression")
        if limit_expr:
            explanation_parts.append(f"Finally, it returns only the first **{limit_expr}** rows.")

    if not explanation_parts:
        return ("No explanation found; the query might be empty or too complex.", "{}")

    explanation_text = " ".join(explanation_parts)
    # Also produce AST JSON for debugging
    ast_json = ast.to_json()
    return (explanation_text, ast_json)


###############################################################################
# BASIC HTML TEMPLATE
###############################################################################
HTML_TEMPLATE = """
<!doctype html>
<html>
<head>
    <title>SQL-to-English (Flask Demo)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 1.5rem; }
        h1, h2 { color: #333; }
        textarea { width: 100%; height: 150px; }
        .result { background: #f8f8f8; padding: 1rem; border: 1px solid #ddd; margin-top: 1rem; }
        pre { background: #f0f0f0; padding: 0.5rem; overflow: auto; }
    </style>
</head>
<body>
    <h1>SQL-to-English (Flask + sqlglot)</h1>
    <form method="POST">
        <label for="sql_query"><strong>Enter SQL Query:</strong></label><br>
        <textarea id="sql_query" name="sql_query">{{ sql_query }}</textarea><br><br>
        <button type="submit">Translate</button>
    </form>

    {% if explanation %}
    <div class="result">
        <h2>Explanation</h2>
        <div style="white-space: pre-wrap;">
            {{ explanation | safe }}
        </div>
        <br>
        <h2>AST (JSON)</h2>
        <pre>{{ ast_json }}</pre>
    </div>
    {% endif %}
</body>
</html>
"""

###############################################################################
# FLASK ROUTE
###############################################################################
@app.route("/", methods=["GET", "POST"])
def index():
    sql_query = ""
    explanation = None
    ast_json = None

    if request.method == "POST":
        sql_query = request.form.get("sql_query", "").strip()
        explanation, ast_json = parse_and_explain(sql_query)

    return render_template_string(
        HTML_TEMPLATE, 
        sql_query=sql_query,
        explanation=explanation,
        ast_json=ast_json
    )


if __name__ == "__main__":
    # Run Flask in debug mode for local development
    app.run(debug=True)