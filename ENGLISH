import sqlparse
import re

###############################################################################
# 1) DOMAIN MAP
###############################################################################
# Customize these mappings for your environment:
DOMAIN_MAP = {
    "tables": {
        "financial_risk_table": "the Financial Risk data store",
        "customer_info": "the Customer Information table"
    },
    "columns": {
        "customer_id": "Customer Identifier",
        "exposure_amount": "Exposure Amount (USD)",
        "rating": "Credit Rating",
        "cusip_id": "CUSIP Identifier",
        "customer_name": "Customer Name",
        "total_exposure": "Total Exposure (USD)"
    }
}

def get_domain_table_name(raw: str) -> str:
    """
    Map a raw table name to a domain-friendly name if found in DOMAIN_MAP.
    Otherwise, return the raw name.
    """
    return DOMAIN_MAP["tables"].get(raw.lower().strip(), raw)

def get_domain_column_name(raw: str) -> str:
    """
    Map a raw column name to a domain-friendly name if found in DOMAIN_MAP.
    Otherwise, return the raw name.
    """
    return DOMAIN_MAP["columns"].get(raw.lower().strip(), raw)

###############################################################################
# 2) PARSING LOGIC
###############################################################################
def parse_sql_to_dict(sql_query: str) -> dict:
    """
    Use sqlparse to extract:
      - SELECT columns
      - FROM (table or subquery)
      - JOIN(s)
      - WHERE
      - GROUP BY
      - ORDER BY
      - LIMIT
    Recursively handle subqueries.
    Returns a dict describing the query.
    """
    parsed = sqlparse.parse(sql_query)
    if not parsed:
        return {}

    # We'll parse only the first statement
    statement = parsed[0]

    result = {
        "columns": [],
        "from": None,
        "joins": [],
        "where": None,
        "group_by": [],
        "order_by": [],
        "limit": None
    }

    tokens = [t for t in statement.tokens if not t.is_whitespace]
    current_clause = None
    buffer = []

    def flush_clause(clause_name, buf):
        if clause_name == "SELECT":
            result["columns"] = parse_select_list(buf)
        elif clause_name == "FROM":
            result["from"] = parse_from_clause(buf)
        elif clause_name == "JOIN":
            jinfo = parse_join_clause(buf)
            if jinfo:
                result["joins"].append(jinfo)
        elif clause_name == "WHERE":
            result["where"] = parse_condition_clause(buf)
        elif clause_name == "GROUP BY":
            result["group_by"] = parse_comma_list(buf)
        elif clause_name == "ORDER BY":
            result["order_by"] = parse_comma_list(buf)
        elif clause_name == "LIMIT":
            result["limit"] = parse_limit_clause(buf)
        buf.clear()

    i = 0
    while i < len(tokens):
        t = tokens[i]
        val_up = t.value.upper()

        # Detect start of SELECT clause
        if t.ttype == sqlparse.tokens.DML and val_up == "SELECT":
            if current_clause and buffer:
                flush_clause(current_clause, buffer)
            current_clause = "SELECT"
            buffer.clear()

        elif t.is_keyword:
            # Check for major clauses
            if val_up == "FROM":
                if current_clause and buffer:
                    flush_clause(current_clause, buffer)
                current_clause = "FROM"
                buffer.clear()

            elif val_up in ("LEFT", "RIGHT", "FULL", "CROSS", "INNER"):
                # join type prefix
                buffer.append(t)

            elif val_up == "JOIN":
                # finalize previous
                if current_clause and buffer:
                    flush_clause(current_clause, buffer)
                current_clause = "JOIN"
                buffer.clear()
                buffer.append(t)

            elif val_up == "WHERE":
                if current_clause and buffer:
                    flush_clause(current_clause, buffer)
                current_clause = "WHERE"
                buffer.clear()

            elif val_up == "GROUP":
                # possibly GROUP BY
                if i+1 < len(tokens) and tokens[i+1].value.upper() == "BY":
                    if current_clause and buffer:
                        flush_clause(current_clause, buffer)
                    current_clause = "GROUP BY"
                    i += 1  # skip the "BY"
                    buffer.clear()
                else:
                    buffer.append(t)

            elif val_up == "ORDER":
                # possibly ORDER BY
                if i+1 < len(tokens) and tokens[i+1].value.upper() == "BY":
                    if current_clause and buffer:
                        flush_clause(current_clause, buffer)
                    current_clause = "ORDER BY"
                    i += 1
                    buffer.clear()
                else:
                    buffer.append(t)

            elif val_up == "LIMIT":
                if current_clause and buffer:
                    flush_clause(current_clause, buffer)
                current_clause = "LIMIT"
                buffer.clear()
            else:
                buffer.append(t)
        else:
            buffer.append(t)

        i += 1

    # flush leftover tokens
    if current_clause and buffer:
        flush_clause(current_clause, buffer)

    return result

###############################################################################
# 2B) HELPER PARSERS FOR CLAUSES
###############################################################################
def tokens_to_str(token_list) -> str:
    return "".join(t.value for t in token_list).strip()

def parse_select_list(token_list) -> list:
    raw = tokens_to_str(token_list)
    return split_top_level_csv(raw)

def parse_from_clause(token_list) -> str:
    raw = tokens_to_str(token_list)
    return detect_subquery(raw)

def parse_join_clause(token_list) -> dict:
    raw = tokens_to_str(token_list)
    info = {"type": "JOIN", "table": "", "on": ""}
    # split on "ON"
    parts = re.split(r"\bON\b", raw, flags=re.IGNORECASE)
    left_side = parts[0].strip()
    on_side = parts[1].strip() if len(parts) > 1 else ""

    # find join type
    m = re.match(r"^\s*((LEFT|RIGHT|FULL|CROSS|INNER)\s*(OUTER)?\s+JOIN)(.*)$", left_side, re.IGNORECASE)
    if m:
        info["type"] = m.group(1).upper()  # e.g. "LEFT JOIN"
        remainder = m.group(4).strip()
        info["table"] = detect_subquery(remainder)
    else:
        info["table"] = detect_subquery(left_side)

    info["on"] = detect_subqueries_in_condition(on_side)
    return info

def parse_condition_clause(token_list) -> str:
    raw = tokens_to_str(token_list)
    return detect_subqueries_in_condition(raw)

def parse_comma_list(token_list) -> list:
    raw = tokens_to_str(token_list)
    return split_top_level_csv(raw)

def parse_limit_clause(token_list) -> str:
    return tokens_to_str(token_list)

def split_top_level_csv(text: str) -> list:
    """
    Split by commas not within parentheses
    """
    items = []
    buf = []
    level = 0
    for ch in text:
        if ch == '(':
            level += 1
            buf.append(ch)
        elif ch == ')':
            level -= 1
            buf.append(ch)
        elif ch == ',' and level == 0:
            items.append("".join(buf).strip())
            buf.clear()
        else:
            buf.append(ch)
    if buf:
        items.append("".join(buf).strip())
    return items

###############################################################################
# 3) SUBQUERY DETECTION & RECURSION
###############################################################################
SUBQ_REGEX = re.compile(r"\(\s*SELECT\s+([\s\S]*?)\)", re.IGNORECASE)

def detect_subquery(raw: str) -> str:
    match = re.search(SUBQ_REGEX, raw)
    if match:
        # parse subquery
        sub_sql = match.group(1).strip()
        sub_dict = parse_sql_to_dict(sub_sql)
        sub_expl = build_business_explanation(sub_dict)
        # replace the entire (SELECT...) block with SUBQUERY{explanation}
        replaced = re.sub(SUBQ_REGEX, f"SUBQUERY{{{sub_expl}}}", raw, 1, flags=re.IGNORECASE)
        return replaced
    return raw

def detect_subqueries_in_condition(cond: str) -> str:
    new_text = cond
    while True:
        match = re.search(SUBQ_REGEX, new_text)
        if not match:
            break
        sub_sql = match.group(1).strip()
        sub_dict = parse_sql_to_dict(sub_sql)
        sub_expl = build_business_explanation(sub_dict)
        new_text = re.sub(SUBQ_REGEX, f"SUBQUERY{{{sub_expl}}}", new_text, 1, flags=re.IGNORECASE)
    return new_text

###############################################################################
# 4) BUILD A BUSINESS-ORIENTED EXPLANATION
###############################################################################
def build_business_explanation(qdict: dict) -> str:
    """
    Construct a short business-friendly explanation in paragraph style.
    Subqueries are replaced with SUBQUERY{...} which also uses this function recursively.
    """
    segments = []

    # FROM
    frm = qdict.get("from")
    if frm:
        from_desc = describe_table_or_subquery(frm)
        segments.append(f"This analysis originates from {from_desc}.")

    # JOINS
    for j in qdict.get("joins", []):
        jtype = j["type"].title()  # e.g. "Left Join"
        jtable = describe_table_or_subquery(j["table"])
        jcond = domain_replace(j["on"])
        if jcond:
            segments.append(
                f"It then merges with {jtable} via a {jtype}, focusing on ({jcond})."
            )
        else:
            segments.append(
                f"It then merges with {jtable} via a {jtype}."
            )

    # SELECT columns
    columns = qdict.get("columns", [])
    if columns:
        col_texts = [domain_replace(c) for c in columns]
        joined_cols = ", ".join(col_texts)
        segments.append(
            f"The analysis captures these key measures or fields: {joined_cols}."
        )

    # WHERE
    wh = qdict.get("where")
    if wh:
        wh_str = domain_replace(wh)
        segments.append(
            f"Only records meeting ({wh_str}) are considered."
        )

    # GROUP BY
    gb = qdict.get("group_by", [])
    if gb:
        mapped_gb = [domain_replace(g) for g in gb]
        segments.append(
            f"For aggregation, data is grouped by {', '.join(mapped_gb)}."
        )

    # ORDER BY
    ob = qdict.get("order_by", [])
    if ob:
        mapped_ob = [domain_replace(o) for o in ob]
        segments.append(
            f"The output is prioritized by sorting on {', '.join(mapped_ob)}."
        )

    # LIMIT
    lim = qdict.get("limit")
    if lim:
        segments.append(
            f"Finally, results are capped at the top {lim} entries."
        )

    if not any(qdict.values()):
        return "a minimal or empty query"

    paragraph = " ".join(segments)
    return paragraph

def describe_table_or_subquery(txt: str) -> str:
    """
    If txt is a SUBQUERY, embed that explanation.
    Otherwise map the table name from domain map.
    """
    if txt.startswith("SUBQUERY{") and txt.endswith("}"):
        inside = txt[len("SUBQUERY{"):-1].strip()
        return f"a sub-analysis: ({inside})"
    else:
        splitted = txt.split(None, 1)
        tbl = splitted[0]
        remainder = ""
        if len(splitted) > 1:
            remainder = " " + splitted[1]
        mapped_tbl = get_domain_table_name(tbl)
        return f"{mapped_tbl}{remainder}"

def domain_replace(raw_text: str) -> str:
    """
    Naive approach: replace recognized table/column names in raw_text,
    skipping SUBQUERY{...} placeholders.
    """
    tokens = re.split(r'(\W+)', raw_text)
    out = []
    for t in tokens:
        if t.startswith("SUBQUERY{"):
            out.append(t)
            continue
        if "." in t:
            parts = t.split(".")
            if len(parts) == 2:
                alias, col = parts
                out.append(f"{alias}.{get_domain_column_name(col)}")
            else:
                out.append(t)
        else:
            # single token => maybe table or column
            out.append(get_domain_column_name(get_domain_table_name(t)))
    return "".join(out)

###############################################################################
# 5) STANDALONE MAIN
###############################################################################
def main():
    print("Business-Oriented SQL-to-English (sqlparse-based). Enter 'exit' to quit.\n")
    while True:
        user_input = input("Enter a SELECT query:\n> ").strip()
        if user_input.lower() in ("exit", "quit"):
            print("Goodbye!")
            break
        if not user_input:
            continue

        qdict = parse_sql_to_dict(user_input)
        explanation = build_business_explanation(qdict)
        print("\n--- Explanation ---")
        print(explanation)
        print("-------------------\n")

if __name__ == "__main__":
    main()


SELECT
    frt.customer_id,
    SUM(frt.exposure_amount) AS total_exposure
FROM financial_risk_table frt
WHERE frt.rating < 'BBB'
GROUP BY frt.customer_id
ORDER BY total_exposure DESC
LIMIT 5