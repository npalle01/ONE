import streamlit as st
import sqlglot
from sqlglot import exp
import json

################################################################################
# 1) DEFINE A SIMPLE DOMAIN MAP
################################################################################
# In a real system, you might load these from a database table (as shown in earlier demos).
DOMAIN_MAP = {
    "tables": {
        "financial_risk_table": "the Financial Risk data store"
    },
    "columns": {
        "customer_id": "Customer Identifier",
        "exposure_amount": "Exposure Amount (USD)",
        "rating": "Credit Rating",
        "total_exposure": "Total Exposure (USD)"
    }
}


################################################################################
# 2) HELPER FUNCTIONS FOR DOMAIN NAME LOOKUP
################################################################################
def get_domain_name(identifier: str, domain_map: dict, is_table=False) -> str:
    """
    Lookup an identifier in the domain map. If is_table=True, look in 'tables';
    otherwise, look in 'columns'.
    """
    if not identifier:
        return identifier
    key = identifier.lower().strip()
    if is_table:
        return domain_map["tables"].get(key, identifier)
    else:
        return domain_map["columns"].get(key, identifier)


################################################################################
# 3) EXPLAINING THE SQL PARTS
################################################################################

def explain_select_clause(select_expressions, domain_map):
    """
    Takes a list of Expression objects from sqlglot for the SELECT clause.
    Returns a comma-separated string describing them in business-friendly terms.
    """
    parts = []
    for expr in select_expressions:
        # Each expr might be a Column, an Alias, a Function, etc.
        if isinstance(expr, exp.Alias):
            # E.g., SUM(exposure_amount) AS total_exposure
            alias_name = expr.alias
            child = expr.this  # The underlying expression
            child_text = explain_expression(child, domain_map)
            parts.append(f"{child_text} AS **{alias_name}**")
        else:
            parts.append(explain_expression(expr, domain_map))
    return ", ".join(parts)


def explain_expression(expression, domain_map):
    """
    Convert a single Expression node into a human-friendly string,
    applying the domain map for columns/tables if relevant.
    """
    if isinstance(expression, exp.Column):
        # A Column node typically has .table and .name
        col_name = expression.name
        return get_domain_name(col_name, domain_map, is_table=False)

    elif isinstance(expression, exp.Identifier):
        # Could be a reference to a table or column
        return expression.name

    elif isinstance(expression, exp.Func):
        # e.g. SUM(...), COUNT(...), etc.
        func_name = expression.name.upper()
        args = expression.args.get("expressions", [])
        arg_texts = [explain_expression(arg, domain_map) for arg in args]
        arg_str = ", ".join(arg_texts)
        return f"{func_name}({arg_str})"

    elif isinstance(expression, exp.Literal):
        # A literal value, e.g. 'BBB' or 10
        return str(expression.value).strip("'")

    elif isinstance(expression, exp.Alias):
        # E.g. (some expression) AS alias
        return explain_expression(expression.this, domain_map)

    else:
        # Fallback for unhandled expression types
        return str(expression)


def explain_from_clause(ast, domain_map):
    """
    Identify the FROM table(s). This demonstration handles a single-table scenario
    or a basic reference. For multi-table joins or subqueries, you'd need a more
    thorough traversal.
    """
    table_expr = ast.args.get("from")
    if not table_expr:
        return ""
    # table_expr might be a Table, a Join, or a Subquery, etc.
    # For simplicity, let's assume a single table reference:
    if isinstance(table_expr, exp.Table):
        table_name = table_expr.name
        return get_domain_name(table_name, domain_map, is_table=True)
    else:
        # Possibly a join or subquery. We can do a short fallback.
        return "multiple sources or a subquery"


def explain_where_clause(ast, domain_map):
    """
    Return a string describing the WHERE condition if present.
    We recursively handle AND, OR, basic operators, etc.
    """
    where_expr = ast.args.get("where")
    if not where_expr:
        return ""
    condition = where_expr.this  # The actual condition expression
    return explain_condition(condition, domain_map)


def explain_condition(expr_node, domain_map):
    """
    Recursively explain a condition expression (AND, OR, =, <, etc.).
    """
    if isinstance(expr_node, exp.Binary):
        # A binary operation: expr_node.op in ("=", "<", ">", "<=", ">=", "<>", "!=")
        left_text = explain_condition(expr_node.left, domain_map)
        right_text = explain_condition(expr_node.right, domain_map)
        return f"{left_text} {expr_node.op} {right_text}"

    elif isinstance(expr_node, exp.And):
        left_text = explain_condition(expr_node.left, domain_map)
        right_text = explain_condition(expr_node.right, domain_map)
        return f"({left_text} AND {right_text})"

    elif isinstance(expr_node, exp.Or):
        left_text = explain_condition(expr_node.left, domain_map)
        right_text = explain_condition(expr_node.right, domain_map)
        return f"({left_text} OR {right_text})"

    elif isinstance(expr_node, exp.Column):
        return get_domain_name(expr_node.name, domain_map, is_table=False)

    elif isinstance(expr_node, exp.Literal):
        return str(expr_node.value).strip("'")

    # For function calls or other expressions in the WHERE
    elif isinstance(expr_node, exp.Func):
        func_name = expr_node.name.upper()
        args = expr_node.args.get("expressions", [])
        arg_texts = [explain_condition(a, domain_map) for a in args]
        return f"{func_name}({', '.join(arg_texts)})"

    # Fallback
    return str(expr_node)


def explain_groupby_clause(ast, domain_map):
    group_expr = ast.args.get("group")
    if not group_expr:
        return ""
    # group_expr is typically a Group node containing expressions
    columns = [explain_expression(c, domain_map) for c in group_expr.args.get("expressions", [])]
    return ", ".join(columns)


def explain_orderby_clause(ast, domain_map):
    order_expr = ast.args.get("order")
    if not order_expr:
        return ""
    # order_expr is typically an Order node. Each child is an OrderItem, which has .this (the expression) and .args['desc'] = True/False
    items = []
    for item in order_expr.args.get("expressions", []):
        col_text = explain_expression(item.this, domain_map)
        desc_flag = item.args.get("desc", False)
        direction = "DESC" if desc_flag else "ASC"
        items.append(f"{col_text} {direction}")
    return ", ".join(items)


def explain_limit_clause(ast):
    limit_expr = ast.args.get("limit")
    if not limit_expr:
        return ""
    # limit_expr might be an expression or integer
    # If it's e.g. LIMIT 10, you'll see an expression with .this = '10'
    if limit_expr.args.get("expression"):
        return str(limit_expr.args["expression"])
    return ""


def build_explanation(ast, domain_map):
    """
    Main function: gather SELECT, FROM, WHERE, GROUP, ORDER, LIMIT,
    and produce a cohesive English explanation.
    """
    if not ast or not isinstance(ast, exp.Select):
        return "Not a SELECT query or unrecognized format."

    explanation_parts = []

    # FROM
    table_text = explain_from_clause(ast, domain_map)
    if table_text:
        explanation_parts.append(f"This query retrieves data from **{table_text}**.")

    # SELECT
    select_expressions = ast.select_expressions
    if select_expressions:
        sel_text = explain_select_clause(select_expressions, domain_map)
        explanation_parts.append(f"It selects: {sel_text}.")

    # WHERE
    where_text = explain_where_clause(ast, domain_map)
    if where_text:
        explanation_parts.append(f"It is filtered to rows where **{where_text}**.")

    # GROUP BY
    group_text = explain_groupby_clause(ast, domain_map)
    if group_text:
        explanation_parts.append(f"Results are grouped by **{group_text}**.")

    # ORDER BY
    order_text = explain_orderby_clause(ast, domain_map)
    if order_text:
        explanation_parts.append(f"It is then sorted by **{order_text}**.")

    # LIMIT
    limit_text = explain_limit_clause(ast)
    if limit_text:
        explanation_parts.append(f"Finally, it returns only the first **{limit_text}** row(s).")

    if not explanation_parts:
        return "No explanation found (query may be empty or too complex)."

    return " ".join(explanation_parts)


def translate_sql_to_english(sql_query: str, domain_map: dict) -> (str, str):
    """
    - Parse the SQL with sqlglot.
    - Build an English explanation from the AST.
    - Return (explanation, ast_json_string)
    """
    sql_query = sql_query.strip()
    if not sql_query:
        return ("Please provide a valid SQL query.", "")

    # Attempt parse
    try:
        # parse_one returns the AST for the first statement
        ast = sqlglot.parse_one(sql_query, read='ansi')
    except Exception as e:
        return (f"Error parsing SQL: {e}", "")

    # Build the explanation
    explanation = build_explanation(ast, domain_map)

    # Also provide a JSON-like representation of the AST (for debugging)
    ast_json = ast.to_json()
    return (explanation, ast_json)


################################################################################
# 4) STREAMLIT UI
################################################################################
def main():
    st.title("SQL-to-English using sqlglot")

    st.markdown("""
    This demo **parses** your SQL with [sqlglot](https://github.com/tobymao/sqlglot),
    walks the resulting **abstract syntax tree (AST)**, and produces a simplified,
    **business-friendly** explanation.
    
    **Domain Map**: We replace known tables and columns with more user-friendly names.
    """)

    # Provide a default example
    default_sql = """
SELECT
    customer_id,
    SUM(exposure_amount) AS total_exposure
FROM financial_risk_table
WHERE rating < 'BBB'
GROUP BY customer_id
ORDER BY total_exposure DESC
LIMIT 10
"""

    user_sql = st.text_area("Enter your SQL:", default_sql, height=200)

    if st.button("Translate"):
        explanation, ast_json = translate_sql_to_english(user_sql, DOMAIN_MAP)
        st.subheader("Explanation")
        st.markdown(explanation)

        with st.expander("View AST JSON"):
            st.json(json.loads(ast_json))
    else:
        st.info("Awaiting query...")

if __name__ == "__main__":
    main()