import sqlglot
from sqlglot import exp

###############################################################################
# 1) DOMAIN MAP
###############################################################################
# You can update these mappings based on your actual environment.
DOMAIN_MAP = {
    "tables": {
        "financial_risk_table": "the Financial Risk data store"
    },
    "columns": {
        "customer_id": "Customer Identifier",
        "exposure_amount": "Exposure Amount (USD)",
        "rating": "Credit Rating",
        "total_exposure": "Total Exposure (USD)"
    }
}

###############################################################################
# 2) HELPER FUNCTIONS
###############################################################################
def get_domain_name(identifier: str, domain_map: dict, is_table=False) -> str:
    """
    Convert a raw table or column identifier into a more business-friendly name 
    if available in the DOMAIN_MAP.
    """
    if not identifier:
        return identifier
    key = identifier.lower().strip()
    if is_table:
        return domain_map["tables"].get(key, identifier)
    else:
        return domain_map["columns"].get(key, identifier)


def explain_expression(expr, domain_map):
    """
    Recursively interpret a sqlglot Expression node into a user-friendly string,
    applying domain map replacements for known columns/tables.
    """
    if isinstance(expr, exp.Column):
        # e.g. table.column or just column
        return get_domain_name(expr.name, domain_map, is_table=False)

    elif isinstance(expr, exp.Func):
        # e.g. SUM(...), COUNT(...), etc.
        func_name = expr.name.upper()
        arg_exprs = expr.args.get("expressions", [])
        arg_texts = [explain_expression(a, domain_map) for a in arg_exprs]
        return f"{func_name}({', '.join(arg_texts)})"

    elif isinstance(expr, exp.Literal):
        # e.g. 'BBB' or 10
        return str(expr.value).strip("'")

    elif isinstance(expr, exp.Alias):
        # e.g. SUM(exposure_amount) AS total_exposure
        alias_name = expr.alias
        child_expr = expr.this
        return f"{explain_expression(child_expr, domain_map)} AS {alias_name}"

    # Fallback for unhandled expression types
    return str(expr)


def parse_and_explain(sql_query: str):
    """
    1. Parse the SQL with sqlglot using 'generic' dialect.
    2. Build a basic English explanation referencing the domain map.
    3. Return the explanation as a string.
    """
    # Trim leading/trailing whitespace
    sql_query = sql_query.strip()
    if not sql_query:
        return "No query entered."

    try:
        # Use 'generic' to avoid unknown dialect errors
        ast = sqlglot.parse_one(sql_query, read="generic")
    except Exception as e:
        return f"Error parsing SQL: {e}"

    # We only handle simple SELECT queries in this demo
    if not isinstance(ast, exp.Select):
        return "Not a valid SELECT statement or unsupported query type."

    explanation_parts = []

    # FROM
    from_expr = ast.args.get("from")
    if from_expr and isinstance(from_expr, exp.Table):
        table_name = get_domain_name(from_expr.name, DOMAIN_MAP, is_table=True)
        explanation_parts.append(f"This query retrieves data from {table_name}.")

    # SELECT
    select_expressions = ast.select_expressions
    if select_expressions:
        columns = [explain_expression(col, DOMAIN_MAP) for col in select_expressions]
        explanation_parts.append("It selects: " + ", ".join(columns) + ".")

    # WHERE
    where_expr = ast.args.get("where")
    if where_expr:
        where_condition = where_expr.this
        explanation_parts.append(f"It is filtered by {explain_expression(where_condition, DOMAIN_MAP)}.")

    # GROUP BY
    group_expr = ast.args.get("group")
    if group_expr:
        group_items = group_expr.args.get("expressions", [])
        group_texts = [explain_expression(g, DOMAIN_MAP) for g in group_items]
        if group_texts:
            explanation_parts.append("Results are grouped by " + ", ".join(group_texts) + ".")

    # ORDER BY
    order_expr = ast.args.get("order")
    if order_expr:
        order_items = order_expr.args.get("expressions", [])
        order_texts = []
        for o in order_items:
            col_text = explain_expression(o.this, DOMAIN_MAP)
            desc_flag = o.args.get("desc", False)
            direction = "DESC" if desc_flag else "ASC"
            order_texts.append(f"{col_text} {direction}")
        if order_texts:
            explanation_parts.append("It is then sorted by " + ", ".join(order_texts) + ".")

    # LIMIT
    limit_expr = ast.args.get("limit")
    if limit_expr:
        limit_val = limit_expr.args.get("expression")
        if limit_val:
            explanation_parts.append(f"Finally, it returns only the first {limit_val} rows.")

    if not explanation_parts:
        return "No explanation could be formed. The query may be empty or too complex."

    # Join them into one paragraph
    return " ".join(explanation_parts)


###############################################################################
# 3) MAIN ENTRY POINT (STANDALONE CONSOLE APP)
###############################################################################
def main():
    print("Welcome to the standalone SQL-to-English tool (sqlglot + generic dialect).")
    print("Type/paste your SQL below. Type 'exit' or 'quit' to end.\n")

    while True:
        user_input = input("Enter SQL> ").strip()
        if user_input.lower() in ["exit", "quit"]:
            print("Goodbye!")
            break

        explanation = parse_and_explain(user_input)
        print("\n--- EXPLANATION ---")
        print(explanation)
        print("-------------------\n")

# Run the console-based app if we execute this script
if __name__ == "__main__":
    main()