#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8
Comprehensive Business Rules Management Tool (BRM), fully implemented in 8 parts.
No references to old code; everything is integrated from scratch.

Part 1 covers:
 - Imports for all 8 parts
 - Logging
 - Email Config & Sender
 - Database Connection (Dialog)
 - Basic DB helpers (fetch, auditing)
 - Login (Dialog)
 - Operation Type Detection (support DECISION_TABLE)
 - Advanced SQL Parsing
 - Rule Lifecycle States
 - Onboarding Wizard (optional new-user flow)

The BFS logic, multi-step approvals, rule CRUD, and more advanced features
will appear in subsequent parts (2–8).
"""

# =========================
#           IMPORTS
# =========================

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re

from datetime import datetime, date, time, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 (GUI)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate, QMimeData
from PyQt5.QtGui import QColor, QDrag, QPainter, QBrush, QPen
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog,
    QCalendarWidget, QAbstractItemView
)
import pyqtgraph as pg
from sqlparse.sql import (
    Identifier, IdentifierList, Parenthesis, Token
)
from sqlparse.tokens import Keyword, DML

# =========================
#        LOGGING
# =========================
logging.basicConfig(
    filename='brm_tool_advanced.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)


# =========================
#       EMAIL CONFIG
# =========================
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_user",
    "smtp_password": "your_smtp_pass",
    "sender_email": "noreply@example.com"
}


def send_email_notification(subject: str, body: str, recipients: list):
    """
    Fully implemented SMTP-based email sending, using the config above.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email successfully sent to {', '.join(recipients)}")
    except Exception as ex:
        logger.error(f"Error sending email to {recipients}: {ex}")


# =========================
#   DATABASE CONNECTION
# =========================
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Choose an ODBC DSN or type a custom connection string for SQL Server.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400, 200)

        layout = QVBoxLayout(self)
        lbl = QLabel("Select an ODBC DSN or provide a custom connection string:")
        layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        layout.addWidget(self.conn_str_edit)

        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cancel_btn)
        layout.addLayout(bh)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None


# =========================
#       DB HELPERS
# =========================
def fetch_all_dict(cursor):
    """
    Grab .fetchall() => list of dict if description is present.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        return [dict(zip(colnames, row)) for row in rows]
    return rows


def fetch_one_dict(cursor):
    """
    Grab single row => dict if available.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None


def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    """
    Insert a record into BRM_AUDIT_LOG with JSON-serialized old/new data.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG (
        ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (
        action,
        table_name,
        str(record_id) if record_id else None,
        actor,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()


# =========================
#          LOGIN
# =========================
class LoginDialog(QtWidgets.QDialog):
    """
    Minimal username/password login. Looks up in a USERS table in the DB.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – Part 1")
        self.resize(300,150)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.attempt_login)
        layout.addWidget(login_btn)

        self.setLayout(layout)

    def attempt_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter both username and password.")
            return

        c = self.connection.cursor()
        c.execute("""
        SELECT USER_ID, USER_GROUP
        FROM USERS
        WHERE USERNAME=? AND PASSWORD=?
        """,(usern, passw))
        row = fetch_one_dict(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Failed", "Invalid credentials.")


# =========================
# DETECT OPERATION TYPE
# =========================
def detect_operation_type(rule_sql: str, decision_table_id=None) -> str:
    """
    Return INSERT/UPDATE/DELETE/SELECT/DECISION_TABLE/OTHER based on content.
    If rule_sql is empty but we have decision_table_id, => DECISION_TABLE.
    Otherwise check first keyword of SQL. If none matched => 'OTHER'.
    """
    if (not rule_sql) and decision_table_id:
        return "DECISION_TABLE"

    txt = rule_sql.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"


# =========================
#   ADVANCED SQL PARSER
# =========================
def parse_sql_dependencies(sql_text: str):
    """
    Return dict with 'tables', 'cte_tables', 'alias_map', 'columns'.
    Uses sqlparse logic to detect references in the query for table dependencies.
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    column_list = []

    for stmt in statements:
        ctes = _extract_with_clauses(stmt)
        for cName, refs in ctes.items():
            cte_info.append((cName, refs))

        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs = _extract_columns(stmt)
        column_list.extend(col_refs)

    # Deduplicate tables
    unique_tables = list({x for x in all_tables})

    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": column_list
    }


def _extract_with_clauses(statement):
    cte_map={}
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper()=="WITH":
            i+=1
            i=_parse_cte_block(tokens,i,cte_map)
            continue
        i+=1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    while i<len(tokens):
        tk=tokens[i]
        if isinstance(tk, Identifier):
            cte_name=tk.get_real_name()
            i+=1
            i=_parse_cte_as_clause(tokens,i,cte_name,cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i+=1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i<len(tokens):
        tk=tokens[i]
        val=tk.value.upper() if tk.ttype else ""
        if val=="AS":
            i+=1
            if i<len(tokens):
                sub=tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs=_extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name]=sub_refs
                    i+=1
                    return i
        else:
            i+=1
    return i

def _extract_subselect_tokens(tokens):
    results=[]
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident,set())
                    st=(st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st=_parse_identifier(tk,set())
                st=(st[0], st[1], st[2], True)
                results.append(st)
        i+=1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper()=="SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    results=[]
    alias_map={}
    tokens=list(tokenlist)
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, known_cte_names)
                    results.append(st)
                    al=st[2]
                    if al:
                        alias_map[al]=(st[0], st[1])
            elif isinstance(tk, Identifier):
                st=_parse_identifier(tk, known_cte_names)
                results.append(st)
                al=st[2]
                if al:
                    alias_map[al]=(st[0], st[1])
        i+=1
    return (results, alias_map)

def _parse_identifier(ident, known_cte_names):
    alias=ident.get_alias()
    real_name=ident.get_real_name()
    schema_name=ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    results=[]
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is DML:
            word=tk.value.upper()
            if word=="SELECT":
                cols=_parse_select_list(tokens,i+1)
                for c_ in cols:
                    results.append((c_,False,True))
            elif word in ("INSERT","UPDATE"):
                colRefs=_parse_dml_columns(tokens,i,word)
                for c_ in colRefs:
                    results.append((c_,True,False))
        i+=1
    return results

def _parse_select_list(tokens, start_idx):
    columns=[]
    i=start_idx
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                nm=ident.get_name()
                if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(nm)
        elif isinstance(tk, Identifier):
            nm=tk.get_name()
            if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(nm)
        i+=1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    columns=[]
    if dml_word=="INSERT":
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                for subToken in tk.tokens:
                    if isinstance(subToken, IdentifierList):
                        for ident in subToken.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(subToken, Identifier):
                        columns.append(subToken.get_name())
                return columns
            i+=1
    elif dml_word=="UPDATE":
        found_set=False
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.ttype is Keyword and tk.value.upper()=="SET":
                found_set=True
                i+=1
                columns.extend(_parse_update_set_list(tokens,i))
                break
            i+=1
    return columns

def _parse_update_set_list(tokens, start_i):
    columns=[]
    i=start_i
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, Identifier):
            columns.append(tk.get_name())
        i+=1
    return columns


# =========================
# RULE LIFECYCLE STATES
# =========================
RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]


# =========================
#   ONBOARDING WIZARD
# =========================
class OnboardingWizard(QDialog):
    """
    Optional new-user wizard => helps them do 3 steps:
      1) Create a group
      2) Create a rule
      3) Schedule that rule
    Then done.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Welcome Wizard – Part 1")
        self.resize(400,300)

        main_layout=QVBoxLayout(self)
        self.steps_label=QLabel("Welcome to the advanced BRM Tool!\nThis wizard guides new users.")
        main_layout.addWidget(self.steps_label)

        self.current_step=0
        nav_btn=QPushButton("Next")
        nav_btn.clicked.connect(self.advance_step)
        main_layout.addWidget(nav_btn)
        self.setLayout(main_layout)

    def advance_step(self):
        self.current_step+=1
        if self.current_step==1:
            self.steps_label.setText("Step 1: Go to 'Group Management' => 'Add Group'.")
        elif self.current_step==2:
            self.steps_label.setText("Step 2: Go to 'Business Rules' => 'Add Rule'.")
        elif self.current_step==3:
            self.steps_label.setText("Step 3: Go to 'Scheduling' => 'Add New Schedule'.")
        else:
            self.steps_label.setText("All done. Enjoy the BRM Tool.")
            self.accept()
"""
BRM TOOL – PART 2 of 8 (Enhanced with Advanced Impact Analysis)
BFS rule execution, multi-step approvals, advanced CRUD with lifecycle states,
plus advanced impact analysis that checks child rules, GCR links, conflicts, composites, etc.

Assumes presence of Part 1 in the same file/namespace:
 - Logging
 - DB helpers (fetch_one_dict, insert_audit_log, etc.)
 - detect_operation_type, parse_sql_dependencies
 - RULE_LIFECYCLE_STATES
 - (Optional) references to Part 1 classes for GUI or OnboardingWizard
"""

import json
from datetime import datetime
from collections import deque

# =========================
#   BFS RULE EXECUTION
# =========================

def build_rule_adjacency(conn):
    """
    Construct parent->children map from BRM_RULES (PARENT_RULE_ID).
    Return (children_map, roots_list).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    children_map = {}
    all_ids = set()
    parent_ids = set()

    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)

    roots = [x for x in all_ids if x not in parent_ids]
    return children_map, roots


def load_global_critical_links(conn):
    """
    Return dict => GCR_RULE_ID -> set of TARGET_RULE_ID, 
    used if a global/critical rule fails => skip these targets too.
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = c.fetchall()
    link_map = {}
    for (gcr, tgt) in rows:
        link_map.setdefault(gcr, set()).add(tgt)
    return link_map


def get_all_rules_as_dict(conn):
    """
    Return {rule_id: {col:val,...}} for BFS lookup of OPERATION_TYPE, RULE_SQL, etc.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    out = {}
    for row in rows:
        d = dict(zip(colnames, row))
        out[d["RULE_ID"]] = d
    return out


def skip_descendants(child_id, children_map, skipped):
    """
    If a critical rule fails, skip all its descendants in BFS 
    by adding them to 'skipped'.
    """
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])


def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert a BFS or scheduled run result into RULE_EXECUTION_LOGS.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS (
      RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
    )
    VALUES(?, GETDATE(), ?, ?, ?)
    """,(rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()


def run_sql_rule_transaction(conn, rule_sql):
    """
    Execute rule_sql in a transaction => if row[0][0]==1 => pass => commit, else rollback => fail.
    Return (success, message, row_count).
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(rule_sql)
        rows = c.fetchall()
        if rows:
            rec_count = len(rows)
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        if success:
            c.execute("COMMIT")
        else:
            c.execute("ROLLBACK")
    except Exception as ex:
        c.execute("ROLLBACK")
        success = False
        msg = str(ex)
    return (success, msg, rec_count)


def run_decision_table_rule_bfs(conn, rule_info):
    """
    If OPERATION_TYPE='DECISION_TABLE', we might read DECISION_TABLE_ID and run real logic.
    Here, we do a placeholder that always passes, with rec_count=1.
    """
    dt_id = rule_info.get("DECISION_TABLE_ID")
    success = True
    msg = f"Decision Table {dt_id} => PASS (stub logic)"
    rec_count = 1
    return (success, msg, rec_count)


def execute_rules_in_bfs(conn):
    """
    BFS from each root => run rule => if a critical rule fails => skip children + gcr links.
    Return (executed_list, skipped_set).
    """
    children_map, roots = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)

    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info = rule_lookup[rid]
        op_type = info["OPERATION_TYPE"] or "OTHER"
        is_crit = (info["CRITICAL_RULE"]==1 or info["IS_GLOBAL"]==1)
        scope = (info["CRITICAL_SCOPE"] or "NONE").upper()

        if op_type=="DECISION_TABLE":
            (ok, msg, rec_count) = run_decision_table_rule_bfs(conn, info)
        else:
            rule_sql = info["RULE_SQL"] or ""
            (ok, msg, rec_count) = run_sql_rule_transaction(conn, rule_sql)

        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            # If critical => skip children + GCR links
            if is_crit and scope!="NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for linked_id in gcr_links[rid]:
                        skip_descendants(linked_id, children_map, skipped)

    return (executed, skipped)


# =========================
# MULTI-STEP APPROVALS
# =========================
def create_multistep_approvals(conn, rule_id):
    """
    Insert multi-step approval records in BRM_RULE_APPROVALS:
      - BG1
      - BG2 or BG3 if we see 'finance' or 'sensitive_data' references or BFS group impacted
      - FINAL stage
    """
    impacted = advanced_find_impacted_groups(conn, rule_id)  # we'll call advanced version here

    # Check table references
    c2 = conn.cursor()
    c2.execute("""
    SELECT TABLE_NAME
    FROM BRM_RULE_TABLE_DEPENDENCIES
    WHERE RULE_ID=?
    """,(rule_id,))
    deps = c2.fetchall()
    require_bg2 = False
    require_bg3 = False
    for (tname,) in deps:
        lo = (tname or "").lower()
        if "finance" in lo or "credit" in lo:
            require_bg2 = True
        if "sensitive_data" in lo or "personal_info" in lo:
            require_bg3 = True

    pipeline = []
    pipeline.append("BG1")

    if require_bg2 or "BG2" in impacted:
        pipeline.append("BG2")
    if require_bg3 or "BG3" in impacted:
        pipeline.append("BG3")

    pipeline.append("FINAL")

    c = conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    stage = 1

    for grp in pipeline:
        if grp=="FINAL":
            # single final_approver
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE
            )
            VALUES(?,?,?,?,NULL,?)
            """,(rule_id,"FINAL","final_approver",0, stage))
            stage+=1
        else:
            c3 = conn.cursor()
            c3.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
            apprs=c3.fetchall()
            for (apuser,) in apprs:
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE
                )
                VALUES(?,?,?,?,NULL,?)
                """,(rule_id, grp, apuser, 0, stage))
            stage+=1

    conn.commit()


# =========================
# ADVANCED IMPACT ANALYSIS
# =========================

def advanced_find_impacted_groups(conn, rule_id):
    """
    Like a BFS approach to find groups from child rules, but also checks:
     - global-critical links
     - potential conflicts from RULE_CONFLICTS
     - references from composite rules (COMPOSITE_RULES)
     - optional references from DECISION_TABLES or RULE_TAGS if desired
    Return set of group names possibly impacted.
    """
    impacted = set()

    # 1) get the main rule's group
    c=conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if row:
        impacted.add(row[0])

    # 2) BFS child + GCR to find all descendant rule IDs
    all_related = advanced_get_related_rules(conn, rule_id)
    # gather those groups
    for rid in all_related:
        c2=conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        r2=c2.fetchone()
        if r2:
            impacted.add(r2[0])
    return impacted


def advanced_get_related_rules(conn, start_rule_id):
    """
    Return a set of rule IDs that might be impacted by changes to start_rule_id,
    considering:
      - normal BFS for child rules (via PARENT_RULE_ID)
      - global-critical links in BRM_GLOBAL_CRITICAL_LINKS
      - conflict references in RULE_CONFLICTS (if a conflict is relevant)
      - references from COMPOSITE_RULES that mention start_rule_id in logic
      - decision table references (if relevant)
    """
    queue=[start_rule_id]
    visited=set([start_rule_id])

    # building adjacency from parent->child
    # plus GCR
    child_map, _ = build_rule_adjacency(conn)
    gcr = load_global_critical_links(conn)

    # conflict adjacency
    conf_map = build_conflict_adjacency(conn)

    # composite adjacency
    comp_map = build_composite_adjacency(conn)

    while queue:
        cur = queue.pop(0)

        # child BFS
        if cur in child_map:
            for child_id in child_map[cur]:
                if child_id not in visited:
                    visited.add(child_id)
                    queue.append(child_id)

        # GCR BFS
        if cur in gcr:
            for linked_id in gcr[cur]:
                if linked_id not in visited:
                    visited.add(linked_id)
                    queue.append(linked_id)

        # conflict BFS => if there's a conflict between cur and X => consider X impacted
        if cur in conf_map:
            for c_ in conf_map[cur]:
                if c_ not in visited:
                    visited.add(c_)
                    queue.append(c_)

        # composite BFS => if a composite references cur => the composite rule's ID is impacted
        if cur in comp_map:
            for c_ in comp_map[cur]:
                if c_ not in visited:
                    visited.add(c_)
                    queue.append(c_)

        # Optionally: decision table adjacency if you store such references
        # ... if (start_rule_id is used by a dt)...

    return visited


def build_conflict_adjacency(conn):
    """
    Return dict => rule_id => set of conflicting rule_ids
    from RULE_CONFLICTS(RULE_ID1,RULE_ID2).
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID1,RULE_ID2 FROM RULE_CONFLICTS")
    rows=c.fetchall()
    conf_map={}
    for (r1,r2) in rows:
        conf_map.setdefault(r1,set()).add(r2)
        conf_map.setdefault(r2,set()).add(r1)
    return conf_map


def build_composite_adjacency(conn):
    """
    Return a dict => rule_id => set of composite_rule_ids or other rules 
    if your composite logic references them. 
    For simplicity, let's parse 'LOGIC_EXPR' for 'RuleX' mentions. 
    """
    c=conn.cursor()
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    rows=c.fetchall()
    comp_map={}
    # We'll do a simple pattern: Rule(\d+)
    pat=re.compile(r"Rule(\d+)")

    # Suppose each 'RuleX' mention => adjacency from X->composite_rule_id
    for (crid, expr) in rows:
        if not expr:
            continue
        matches=pat.findall(expr)
        for m_ in matches:
            try:
                ridx=int(m_)
                comp_map.setdefault(ridx,set()).add(crid)
            except:
                pass
    return comp_map


def advanced_analyze_rule_impact(conn, rule_id):
    """
    Return a dict with:
       'downstream_rules' => all BFS, GCR, conflict, composite links,
       'impacted_groups'  => set of group names from advanced_find_impacted_groups
       Possibly more fields if needed.
    """
    all_rel = advanced_get_related_rules(conn, rule_id)
    impacted_g = advanced_find_impacted_groups(conn, rule_id)
    return {
        "downstream_rules": all_rel,
        "impacted_groups": impacted_g
    }


# =========================
# ADVANCED RULE CRUD
# =========================

def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert new BRM_RULES row => parse SQL => approvals => audit => advanced references.
    """
    c = conn.cursor()

    # check duplicates in same group
    c.execute("""
    SELECT RULE_ID FROM BRM_RULES
    WHERE OWNER_GROUP=? AND RULE_NAME=?
    """,(rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("A rule with that name already exists in this group.")

    # check identical SQL
    new_sql=rule_data.get("RULE_SQL","").strip()
    if new_sql:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        row2=c.fetchone()
        if row2:
            raise ValueError("Another rule with this same SQL already exists.")

    # forcibly set lifecycle => DRAFT
    rule_data["LIFECYCLE_STATE"]="DRAFT"

    if rule_data.get("IS_GLOBAL",0)==1 and user_group!="Admin":
        raise ValueError("Only Admin can create a global rule.")

    from_part_1_op=detect_operation_type(new_sql, rule_data.get("DECISION_TABLE_ID"))
    rule_data["OPERATION_TYPE"]=from_part_1_op

    parse_info={}
    col_op="READ"
    if from_part_1_op not in ("DECISION_TABLE","OTHER") and new_sql:
        parse_info=parse_sql_dependencies(new_sql)
        if from_part_1_op in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"

    nowstr=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    row = c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,
      RULE_NAME,RULE_SQL,
      EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,
      STATUS,VERSION,
      CREATED_BY,DESCRIPTION,OPERATION_TYPE,
      BUSINESS_JUSTIFICATION,CREATED_TIMESTAMP,
      UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,
      APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,
      CRITICAL_SCOPE,CDC_TYPE,LIFECYCLE_STATE,
      DECISION_TABLE_ID
    )
    OUTPUT inserted.RULE_ID
    VALUES(?,?,?,?,?,
           ?,?,
           ?,?,
           ?,?,?,?,?,?,
           ?,?,?,?,
           ?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],

        rule_data["RULE_NAME"].strip(),
        new_sql,

        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),

        rule_data.get("STATUS","INACTIVE"),
        1,

        created_by,
        rule_data.get("DESCRIPTION",""),
        from_part_1_op,

        rule_data.get("BUSINESS_JUSTIFICATION",""),
        nowstr,

        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),

        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),

        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE"),
        rule_data["LIFECYCLE_STATE"],

        rule_data.get("DECISION_TABLE_ID", None)
    )).fetchone()

    if not row:
        raise ValueError("Failed to insert rule; no RULE_ID returned.")
    new_id = row[0]

    if from_part_1_op not in ("DECISION_TABLE","OTHER") and new_sql:
        for (sch, tb, alias, issub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,
                  COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(new_id, sch if sch else "N/A", tb, "AutoCol", col_op))

    insert_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # create approvals if not global or user is Admin
    if rule_data.get("IS_GLOBAL",0)==0 or user_group=="Admin":
        create_multistep_approvals(conn, new_id)

    return new_id


def update_rule(conn, rule_data, updated_by, user_group):
    """
    Update existing rule => re-approval => parse new SQL => bump version => advanced references.
    """
    c=conn.cursor()
    rid=rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    colnames=[d[0] for d in c.description]
    old_data=dict(zip(colnames, old))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update a global rule.")

    new_sql=rule_data.get("RULE_SQL","").strip()
    if new_sql and new_sql!=old_data["RULE_SQL"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        row2=c.fetchone()
        if row2 and row2[0]!=rid:
            raise ValueError("A rule with that SQL already exists.")

    final_op=detect_operation_type(new_sql, rule_data.get("DECISION_TABLE_ID"))
    rule_data["OPERATION_TYPE"]=final_op

    parse_info={}
    col_op="READ"
    if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
        parse_info=parse_sql_dependencies(new_sql)
        if final_op in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"

    c.execute("""
    UPDATE BRM_RULES
    SET GROUP_ID=?,
        PARENT_RULE_ID=?,
        RULE_TYPE_ID=?,
        RULE_NAME=?,
        RULE_SQL=?,
        EFFECTIVE_START_DATE=?,
        EFFECTIVE_END_DATE=?,
        STATUS='INACTIVE',
        VERSION=VERSION+1,
        UPDATED_BY=?,
        DESCRIPTION=?,
        OPERATION_TYPE=?,
        BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?,
        CLUSTER_NAME=?,
        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?,
        CRITICAL_RULE=?,
        CRITICAL_SCOPE=?,
        CDC_TYPE=?,
        LIFECYCLE_STATE='UNDER_APPROVAL',
        DECISION_TABLE_ID=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        final_op,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
        rule_data.get("CLUSTER_NAME", old_data["CLUSTER_NAME"]),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rule_data.get("DECISION_TABLE_ID", old_data["DECISION_TABLE_ID"]),
        rid
    ))

    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
        for (sch,tb,alias,issub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,
                  COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid, sch if sch else "N/A", tb,"AutoCol", col_op))

    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"]=old_data["VERSION"]+1

    insert_audit_log(conn,"UPDATE","BRM_RULES",rid,updated_by,old_data,new_data)
    conn.commit()

    # if not global or user is admin => re-create approvals
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"])==0 or user_group=="Admin":
        create_multistep_approvals(conn, rid)


def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivate a fully-approved rule => must have no ACTIVE children.
    If global => only admin.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old))

    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate unless fully APPROVED.")
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")

    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    if c.fetchone():
        raise ValueError("Deactivate child rules first (some are ACTIVE).")

    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',
        UPDATED_BY=?,
        VERSION=VERSION+1,
        LIFECYCLE_STATE='INACTIVE'
    WHERE RULE_ID=?
    """,(updated_by, rule_id))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["LIFECYCLE_STATE"]="INACTIVE"

    insert_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()


def delete_rule(conn, rule_id, action_by, user_group):
    """
    Delete a fully-approved, inactive rule => no children, references. 
    If global => only Admin can do so.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    cols=[desc[0] for desc in c.description]
    old_data=dict(zip(cols,old))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Must be INACTIVE first.")

    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    if c.fetchone():
        raise ValueError("Child rules exist; cannot delete.")

    c.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    if c.fetchone():
        raise ValueError("Remove references from BRM_COLUMN_MAPPING first.")

    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    insert_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)
    conn.commit()
"""
BRM TOOL – PART 3 of 8
Single/Chain/Group simulations, improved metadata sync,
scheduling, advanced feature tabs (decision tables, conflicts, composites, snapshots, tags, validations),
plus a WhatIfTestTab for user-provided data.

All BFS logic (including advanced references) is assumed present from Part 2 in the same namespace.
No references to external old code.
"""

import json
import math
import logging
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget, QFileDialog
)
from PyQt5.QtCore import Qt, QDateTime, QDate
import pyqtgraph as pg


# =========================
#  DRY-RUN UTILITY + SIMS
# =========================

def dry_run_sql_rule(conn, sql_text):
    """
    Attempt rule's SQL in a transaction => interpret row[0][0] as pass==1 => then ROLLBACK always.
    Return (bool passFlag, str message).
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    try:
        c.execute(sql_text)
        rows=c.fetchall()
        if rows:
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
    except Exception as ex:
        success=False
        msg=str(ex)
    c.execute("ROLLBACK")
    return (success, msg)


class SingleRuleSimulationDialog(QDialog):
    """
    Allows a quick pass/fail "dry-run" for a single rule's SQL or DECISION_TABLE.
    If DECISION_TABLE => minimal pass stub or extended logic if needed.
    """
    def __init__(self, connection, rule_id, rule_sql, op_type, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.rule_sql=rule_sql
        self.op_type=op_type
        self.setWindowTitle(f"Simulate Rule {rule_id} (Part 3)")
        self.resize(500,300)

        layout=QVBoxLayout(self)
        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        run_btn=QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_sim(self):
        if self.op_type=="DECISION_TABLE":
            # placeholder => always pass
            self.result_text.setPlainText(f"DECISION_TABLE => PASS (stub).")
            return
        # otherwise do normal SQL
        ok,msg=dry_run_sql_rule(self.connection, self.rule_sql)
        outcome="PASS" if ok else "FAIL"
        self.result_text.setPlainText(f"{outcome} => {msg}")


class ChainSimulationDialog(QDialog):
    """
    BFS chain simulation => pick a parent rule => run them in a simulated BFS (dry-run).
    If DECISION_TABLE => pass stub. Otherwise => do dry_run_sql_rule.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Simulate Rule Chain (Part 3)")
        self.resize(500,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()
        self.parent_rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.parent_rule_combo.addItem(disp, rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_chain(self):
        pid=self.parent_rule_combo.currentData()
        ex,sk=self.run_chain(pid)
        txt=f"BFS chain from parent={pid}\nExecuted => {ex}\nSkipped => {sk}"
        self.result_text.setPlainText(txt)

    def run_chain(self, start_id):
        """
        BFS chain in memory => ignoring advanced skipping if fails, but showing pass/fail for each child node.
        """
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,PARENT_RULE_ID,RULE_SQL,OPERATION_TYPE FROM BRM_RULES")
        rows=c.fetchall()
        rule_map={}
        children_map={}
        for (rid, pid, rsql, op_) in rows:
            rule_map[rid]=(rsql, op_)
            if pid:
                children_map.setdefault(pid,[]).append(rid)

        executed=[]
        skipped=set()
        queue=[start_id]

        while queue:
            rid=queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_map:
                skipped.add(rid)
                continue
            (rsql,op_) = rule_map[rid]
            if op_=="DECISION_TABLE":
                ok=True
                msg="DECISION_TABLE => PASS"
            else:
                (ok,msg)=dry_run_sql_rule(self.connection, rsql)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch in children_map[rid]:
                        if ch not in skipped:
                            queue.append(ch)
            else:
                skipped.add(rid)
        return (executed, skipped)


class GroupSimulationDialog(QDialog):
    """
    Dry-run all rules in a chosen custom group. If DECISION_TABLE => pass stub, else dry_run_sql_rule.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Simulate Custom Group (Part 3)")
        self.resize(500,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()
        self.group_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows=c.fetchall()
        for (cg_id, cg_name) in rows:
            disp=f"{cg_id} - {cg_name}"
            self.group_combo.addItem(disp, cg_id)
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_group(self):
        cg_id=self.group_combo.currentData()
        ex,fails=self.simulate_custom_group(cg_id)
        msg=f"Group ID={cg_id}\nExecuted => {ex}\nFailed => {fails}"
        self.result_text.setPlainText(msg)

    def simulate_custom_group(self, custom_group_id):
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        rows=c.fetchall()
        group_rules=[r[0] for r in rows]

        # get map: rule_id => (sql, op_type)
        c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE FROM BRM_RULES")
        allrows=c.fetchall()
        rule_map={}
        for (rid, rsql, op_) in allrows:
            rule_map[rid]=(rsql, op_)

        executed=[]
        fails=[]
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            (rsql, op_) = rule_map[rid]
            if op_=="DECISION_TABLE":
                # stub => pass
                executed.append(rid)
            else:
                (ok, msg)=dry_run_sql_rule(self.connection, rsql or "")
                if ok:
                    executed.append(rid)
                else:
                    fails.append(rid)
        return (executed, fails)


# =========================
# SYNC METADATA (IMPROVED)
# =========================
def sync_metadata_improved(conn):
    """
    Compare real DB tables (sys.tables + sys.schemas) vs. BRM_RULE_TABLE_DEPENDENCIES => 
    Mark references that do not exist => 'MISSING_' prefix.
    """
    c=conn.cursor()
    c.execute("""
    SELECT s.name as schema_name, t.name as table_name
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id=s.schema_id
    ORDER BY s.name, t.name
    """)
    actual_tables=set()
    for row in c.fetchall():
        fulln=(f"{row[0]}.{row[1]}").lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps=c.fetchall()
    missing=[]
    updated=0
    for d_ in deps:
        dep_id=d_[0]
        t_name=(d_[3] or "").strip()
        if "." not in t_name:
            candidate=(f"dbo.{t_name}").lower()
        else:
            candidate=t_name.lower()
        if candidate not in actual_tables:
            missing.append(dep_id)
    for mid in missing:
        c.execute("""
        UPDATE BRM_RULE_TABLE_DEPENDENCIES
        SET TABLE_NAME='MISSING_' + TABLE_NAME
        WHERE DEPENDENCY_ID=?
        """,(mid,))
        updated+=1

    conn.commit()
    msg=(
        f"Metadata Sync completed.\n"
        f"Found {len(actual_tables)} real tables in DB.\n"
        f"Scanned {len(deps)} dependencies.\n"
        f"Marked {updated} references as MISSING.\n"
    )
    QMessageBox.information(None, "Sync Metadata", msg)


# =========================
#    SCHEDULING
# =========================

class EnhancedScheduleDialog(QDialog):
    """
    Simple dialog => pick a rule => pick date/time => insert into RULE_SCHEDULES with 'Scheduled' status.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Enhanced Scheduling UI (Part 3)")
        self.resize(400,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        date_=self.calendar.selectedDate()
        time_=self.time_edit.time()
        dt_str=f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP)
        VALUES(?,?,'Scheduled',GETDATE())
        """,(rid, dt_str))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} scheduled at {dt_str}.")
        self.close()


class ScheduleManagementTab(QWidget):
    """
    Show the list of RULE_SCHEDULES => up to 1000 rows => allow user to add, update, delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.schedule_table=QTableWidget(0,5)
        self.schedule_table.setHorizontalHeaderLabels([
            "Schedule ID","Rule ID","Schedule Time","Status","Actions"
        ])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn=QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            self.schedule_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(r_i,2,QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(r_i,3,QTableWidgetItem(str(row[3])))

            act_widget=QWidget()
            hh=QHBoxLayout(act_widget)
            hh.setContentsMargins(0,0,0,0)
            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _, ridx=r_i: self.update_schedule(ridx))
            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _, ridx=r_i: self.delete_schedule(ridx))
            hh.addWidget(upd_btn)
            hh.addWidget(del_btn)
            hh.addStretch()
            self.schedule_table.setCellWidget(r_i,4,act_widget)

        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, rowidx):
        sch_id_item=self.schedule_table.item(rowidx,0)
        if not sch_id_item:
            return
        sch_id=int(sch_id_item.text())
        new_dt,ok=QInputDialog.getText(self,"Update Schedule","Enter new date/time (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, rowidx):
        sch_id_item=self.schedule_table.item(rowidx,0)
        if not sch_id_item:
            return
        sch_id=int(sch_id_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule ID={sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()


# =========================
# ADVANCED FEATURE TABS
# =========================

class DecisionTablesTab(QWidget):
    """
    Minimal manager for DECISION_TABLES. Real logic is handled in BFS or "run_dt" methods.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.dt_table=QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels([
            "Decision Table ID","Table Name","Description"
        ])
        layout.addWidget(self.dt_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete DT")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        run_btn=QPushButton("Run DT (Stub)")
        run_btn.clicked.connect(self.run_dt)
        bh.addWidget(run_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            self.dt_table.setItem(r_i,0,QTableWidgetItem(str(r_[0])))
            self.dt_table.setItem(r_i,1,QTableWidgetItem(r_[1]))
            self.dt_table.setItem(r_i,2,QTableWidgetItem(r_[2] if r_[2] else ""))

    def add_dt(self):
        nm,ok=QInputDialog.getText(self,"Add Decision Table","Name (TABLE_NAME):")
        if not ok or not nm.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(nm.strip(),desc.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Decision table created.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No DT selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","DT removed.")
        self.load_dt()

    def run_dt(self):
        """
        Stub => just informs user it's a placeholder.
        Real logic would read condition rows from DECISION_TABLE_RULES, etc.
        """
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No DT selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        QMessageBox.information(self,"Run DT",f"Decision Table {dt_id} => PASS (stub).")


class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY).
    No BFS logic here, but BFS can skip or unify based on these conflicts.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels([
            "Conflict ID","Rule1","Rule2","Priority"
        ])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        set_btn=QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        bh.addWidget(set_btn)

        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY
        FROM RULE_CONFLICTS
        ORDER BY CONFLICT_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            self.cf_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.cf_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.cf_table.setItem(r_i,2,QTableWidgetItem(str(row[2])))
            self.cf_table.setItem(r_i,3,QTableWidgetItem(str(row[3])))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule ID1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule ID2:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Conflict Priority (int):")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pri))
        self.connection.commit()
        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        if not cfid_item:
            return
        cf_id=int(cfid_item.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp, cf_id))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Conflict priority updated.")
        self.load_conflicts()

    def del_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        cf_id=int(cfid_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()


class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES => logic expr references multiple rules => BFS can handle them or not.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CompositeRule ID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_crule)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_crule)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_crules)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_crules()

    def load_crules(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS
        FROM COMPOSITE_RULES
        ORDER BY COMPOSITE_RULE_ID
        """)
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.cr_table.rowCount()
            self.cr_table.insertRow(r_i)
            for idx in range(4):
                val=r_[idx] if r_[idx] else ""
                self.cr_table.setItem(r_i,idx,QTableWidgetItem(str(val)))

    def add_crule(self):
        nm,ok=QInputDialog.getText(self,"New Composite Rule","CRULE_NAME:")
        if not ok or not nm.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expr","(e.g. 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","(Optional) e.g. 'SendEmail'")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
        VALUES(?,?,?)
        """,(nm.strip(), expr.strip(), act.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","Composite rule created.")
        self.load_crules()

    def del_crule(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        crid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {crid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(crid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_crules()


class SnapshotManagerTab(QWidget):
    """
    Let user 'take snapshot' of BRM_RULES => store in RULE_SNAPSHOTS,
    or remove existing snapshots.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["SNAPSHOT_ID","SNAPSHOT_NAME","CREATED_BY","CREATED_TIMESTAMP","SNAPSHOT_JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.ss_table.rowCount()
            self.ss_table.insertRow(r_i)
            for idx in range(5):
                val=r_[idx] if r_[idx] else ""
                self.ss_table.setItem(r_i, idx, QTableWidgetItem(str(val)))

    def take_snapshot(self):
        nm,ok=QInputDialog.getText(self,"Snapshot","Enter snapshot name:")
        if not ok or not nm.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        allrows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        rules_list=[]
        for row in allrows:
            rules_list.append(dict(zip(colnames,row)))
        snap_json=json.dumps(rules_list, indent=2)

        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(nm.strip(),"SnapshotUser",snap_json))
        self.connection.commit()
        QMessageBox.information(self,"Snapshot","Snapshot created.")
        self.load_snapshots()

    def delete_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        it=self.ss_table.item(row,0)
        sid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Snapshot removed.")
        self.load_snapshots()


class TagsManagerTab(QWidget):
    """
    Manage RULE_TAGS => add or remove textual tags from rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rm_btn=QPushButton("Remove Tag")
        rm_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rm_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.tags_table.rowCount()
            self.tags_table.insertRow(r_i)
            for idx in range(3):
                val=r_[idx] if r_[idx] else ""
                self.tags_table.setItem(r_i, idx, QTableWidgetItem(str(val)))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Enter rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        if not it:
            return
        tag_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tag_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()


class DataValidationTab(QWidget):
    """
    Manage data validations in DATA_VALIDATIONS => e.g. 'NOT NULL', 'RANGE', etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Validation")
        addb.clicked.connect(self.add_validation)
        bh.addWidget(addb)

        delb=QPushButton("Remove Validation")
        delb.clicked.connect(self.remove_validation)
        bh.addWidget(delb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_validations)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
        FROM DATA_VALIDATIONS
        ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.dv_table.rowCount()
            self.dv_table.insertRow(r_i)
            for idx in range(5):
                val=r_[idx] if r_[idx] else ""
                self.dv_table.setItem(r_i,idx,QTableWidgetItem(str(val)))

    def add_validation(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name (e.g. 'dbo.Customer'):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'NOT NULL','RANGE'):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional) param string:")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(
          TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
        )
        VALUES(?,?,?,?)
        """,(tbl.strip(), col.strip(), vtype.strip(), pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Data validation added.")
        self.load_validations()

    def remove_validation(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation ID={vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Data validation removed.")
        self.load_validations()


# =========================
#   WHAT-IF TESTING TAB
# =========================
def whatif_dry_run_decision_table(conn, dt_id):
    """
    A hypothetical function to run a DecisionTable. For now, return pass=1.
    """
    return (True,"DT Stub => PASS")

def whatif_dry_run_sql(conn, sql_):
    """
    Attempt the SQL in a transaction => interpret row[0][0]==1 => PASS => rollback.
    """
    return dry_run_sql_rule(conn, sql_)


class WhatIfTestTab(QWidget):
    """
    Let user pick a rule => optionally upload CSV => do a dry-run. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME,OPERATION_TYPE,RULE_SQL,DECISION_TABLE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rname,op_,sql_,dt_id) in rows:
            disp=f"{rid} - {rname}"
            self.rule_combo.addItem(disp,(rid,op_,sql_,dt_id))
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        csv_btn=QPushButton("Upload CSV")
        csv_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(csv_btn)

        run_btn=QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if not path:
            return
        QMessageBox.information(self,"Uploaded",f"CSV {path} chosen.\n(Stub) Not actually loaded yet.")

    def run_test(self):
        data=self.rule_combo.currentData()
        if not data:
            QMessageBox.warning(self,"No Rule","No rule selected.")
            return
        (rid, op_type, sql_, dt_id)=data
        if op_type=="DECISION_TABLE":
            (ok,msg)=whatif_dry_run_decision_table(self.connection, dt_id)
        else:
            (ok,msg)=whatif_dry_run_sql(self.connection, sql_ or "")
        outcome="PASS" if ok else "FAIL"
        self.result_text.setPlainText(f"Rule {rid} => {outcome} => {msg}")
"""
BRM TOOL – PART 4 of 8
AuditLogViewer, RuleSearchDialog, VersionHistoryDialog,
RuleDashboard (paginated + filters), RuleEditorDialog (with real-time validation stub).
No references to old code outside these eight parts.
"""

import sys
import json
import csv
import math
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox, QCheckBox,
    QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox
)
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtGui import QColor


# =========================
#   AUDIT LOG VIEWER
# =========================

class AuditLogViewer(QDialog):
    """
    Display entries from BRM_AUDIT_LOG with search + CSV export.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs (Part 4)")
        self.resize(800,600)

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor..")
        self.search_edit.textChanged.connect(self.do_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.log_table=QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.log_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        csv_btn=QPushButton("Export to CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)
        bh.addStretch()
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                if col_i in (5,6) and val:
                    # old_data/new_data => try JSON
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.log_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def do_search(self, text):
        txt=text.lower()
        for row in range(self.log_table.rowCount()):
            show=False
            for col_i in (1,2,4):  # Action, Table, ActionBy
                it=self.log_table.item(row,col_i)
                if it and txt in it.text().lower():
                    show=True
                    break
            self.log_table.setRowHidden(row, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row):
                    continue
                rowdata=[]
                for col in range(self.log_table.columnCount()):
                    it=self.log_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported",f"Audit logs exported to {path}.")


# =========================
#   RULE SEARCH DIALOG
# =========================
class RuleSearchDialog(QDialog):
    """
    Search BRM_RULES by name or SQL snippet => show top 1000 results.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules (Part 4)")
        self.resize(800,600)

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","CreatedBy"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.res_table)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        main_layout.addWidget(ref_btn)

        self.setLayout(main_layout)
        self.load_results()

    def load_results(self):
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_i=self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for idx,val in enumerate(row):
                self.res_table.setItem(r_i, idx, QTableWidgetItem(str(val) if val else ""))


# =========================
#   VERSION HISTORY
# =========================
class VersionHistoryDialog(QDialog):
    """
    Show audit log entries for a single rule => can rollback to old_data if needed.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(800,400)

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels([
            "AuditID","Action","Timestamp","OldData","NewData"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb_btn=QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.rollback_to_selected)
        bh.addWidget(rb_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,ACTION_TIMESTAMP,OLD_DATA,NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES'
          AND RECORD_ID=?
          AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            self.table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.table.setItem(r_i,2,QTableWidgetItem(str(row[2])))

            odtxt=""
            if row[3]:
                try:
                    d_=json.loads(row[3])
                    odtxt=json.dumps(d_,indent=2)
                except:
                    odtxt=str(row[3])
            self.table.setItem(r_i,3,QTableWidgetItem(odtxt))

            ndtxt=""
            if row[4]:
                try:
                    d2=json.loads(row[4])
                    ndtxt=json.dumps(d2,indent=2)
                except:
                    ndtxt=str(row[4])
            self.table.setItem(r_i,4,QTableWidgetItem(ndtxt))

    def rollback_to_selected(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected.")
            return
        row_i=sel[0].row()
        old_data_item=self.table.item(row_i,3)
        if not old_data_item:
            QMessageBox.warning(self,"None","No old_data present.")
            return
        old_data_str=old_data_item.text().strip()
        if not old_data_str:
            QMessageBox.warning(self,"Empty","Empty old_data => cannot rollback.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to this version?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            old_data=json.loads(old_data_str)
        except Exception as ex:
            QMessageBox.critical(self,"JSON Error",str(ex))
            return
        self.apply_rollback(old_data)
        QMessageBox.information(self,"Rolled Back","Version rollback done.")
        self.load_history()

    def apply_rollback(self, old_data):
        """
        Minimal approach => forcibly sets rule name, sql, owner group to old_data's fields,
        sets status=INACTIVE => re-approval. You can adapt to revert more fields if needed.
        """
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")

        new_sql=old_data.get("RULE_SQL","")
        c.execute("BEGIN TRANSACTION")
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(
            old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rid
        ))

        # re-parse dependencies if needed
        from_part1 = globals().get("parse_sql_dependencies", None)
        detect_op = globals().get("detect_operation_type", None)
        if from_part1 and detect_op:
            op_ = detect_op(new_sql, old_data.get("DECISION_TABLE_ID"))
            parse_info = from_part1(new_sql)
            c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
            col_op="READ" if op_=="SELECT" else "WRITE"
            for (sch,tb,alias,_) in parse_info["tables"]:
                if tb and not tb.startswith("(CTE)"):
                    c.execute("""
                    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                      RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                    )
                    VALUES(?,?,?,?,?)
                    """,(rid, sch if sch else "N/A", tb, "RolledBack", col_op))

        c.execute("COMMIT")


# =========================
#   RULE DASHBOARD
# =========================
class RuleDashboard(QGroupBox):
    """
    Paginated + filterable table of BRM_RULES => user can select multiple => 
    get_selected_rule_ids() returns them for actions (update, delete, etc.).
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.selected_rule_id=None

        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL..")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","OwnerGroup","CreatedTS","ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_id)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_clause(self):
        filters=[]
        params=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%",f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        if filters:
            clause=" AND ".join(filters)
        else:
            clause="1=1"
        return (clause, params)

    def load_rules(self):
        c=self.connection.cursor()
        clause,params=self.build_filter_clause()
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, params)
        rowc=c.fetchone()
        total=rowc[0] if rowc else 0
        self.total_pages=max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page
        data_q=f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*params, offset, self.records_per_page))
        rows=c.fetchall()

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i in range(8):
                val=str(rd[col_i]) if rd[col_i] else ""
                it=QTableWidgetItem(val)
                if col_i==3:  # status
                    if val.lower()=="active":
                        it.setBackground(QColor(144,238,144))
                    else:
                        it.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_i, col_i, it)

    def update_selected_id(self):
        sel=self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.rule_table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for idx in idxs:
            row=idx.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()


# =========================
#  RULE EDITOR DIALOG
# =========================
class RuleEditorDialog(QDialog):
    """
    Adding or Updating a rule. 
    - Real-time validation stub
    - DECISION_TABLE_ID field for linking
    - If user is admin => can set global
    - On save => calls add_rule or update_rule from BFS logic
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)

        title="Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title+" (Part 4)")
        self.resize(800,600)

        main_l=QVBoxLayout(self)
        form_l=QFormLayout()

        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows=c.fetchall()
        for (gid,gname) in grp_rows:
            disp=f"{gname} (ID={gid})"
            self.group_combo.addItem(disp,gid)
        form_l.addRow("Rule Group:", self.group_combo)

        self.parent_rule_combo=QComboBox()
        self.parent_rule_combo.addItem("(No Parent)",None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        p_rows=c.fetchall()
        for (rid,rn) in p_rows:
            disp2=f"{rn} (ID={rid})"
            self.parent_rule_combo.addItem(disp2, rid)
        form_l.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit=QLineEdit()
        form_l.addRow("Rule Name:", self.name_edit)

        self.rule_type_combo=QComboBox()
        c.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        type_rows=c.fetchall()
        for (tid,tn) in type_rows:
            self.rule_type_combo.addItem(tn,tid)
        form_l.addRow("Rule Type:", self.rule_type_combo)

        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_l.addRow("Status:", self.status_combo)

        self.start_dt=QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_l.addRow("Effective Start:", self.start_dt)

        self.end_dt=QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_l.addRow("Effective End:", self.end_dt)

        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_l.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit=QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL that returns 1 => PASS, 0 => FAIL.\n(Leave blank if DECISION_TABLE.)")
        self.sql_edit.textChanged.connect(self.live_validate_sql)
        form_l.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit=QTextEdit()
        form_l.addRow("Description:", self.desc_edit)

        self.just_edit=QTextEdit()
        form_l.addRow("Justification:", self.just_edit)

        self.global_cb=None
        if self.user_group=="Admin":
            self.global_cb=QCheckBox("Global Rule (Admin only)")
            form_l.addRow("Global:", self.global_cb)

        self.critical_cb=QCheckBox()
        form_l.addRow("Critical Rule:", self.critical_cb)

        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_l.addRow("Critical Scope:", self.scope_combo)

        self.dt_id_edit=QLineEdit()
        self.dt_id_edit.setPlaceholderText("(Optional) DECISION_TABLE_ID")
        form_l.addRow("Decision Table ID:", self.dt_id_edit)

        main_l.addLayout(form_l)

        bh=QHBoxLayout()
        self.save_btn=QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)

        cb=QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(cb)
        main_l.addLayout(bh)

        self.setLayout(main_l)

        if self.is_update and self.rule_data:
            self.load_existing_data()

    def load_existing_data(self):
        rd=self.rule_data

        gid=rd["GROUP_ID"]
        ix=self.group_combo.findData(gid)
        if ix>=0:
            self.group_combo.setCurrentIndex(ix)

        pid=rd["PARENT_RULE_ID"]
        if pid:
            ix2=self.parent_rule_combo.findData(pid)
            if ix2>=0:
                self.parent_rule_combo.setCurrentIndex(ix2)
        else:
            self.parent_rule_combo.setCurrentIndex(0)

        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3=self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)

        st=rd.get("STATUS","INACTIVE")
        idx_st=self.status_combo.findText(st)
        if idx_st>=0:
            self.status_combo.setCurrentIndex(idx_st)

        fmt="%Y-%m-%d %H:%M:%S"
        sd=rd.get("EFFECTIVE_START_DATE","")
        if sd:
            try:
                dt_=datetime.strptime(sd,fmt)
                self.start_dt.setDateTime(dt_)
            except:
                pass
        ed=rd.get("EFFECTIVE_END_DATE","")
        if ed:
            try:
                dt2_=datetime.strptime(ed,fmt)
                self.end_dt.setDateTime(dt2_)
            except:
                pass

        cdcv=rd.get("CDC_TYPE","NONE").upper()
        idx_cdc=self.cdc_combo.findText(cdcv)
        if idx_cdc>=0:
            self.cdc_combo.setCurrentIndex(idx_cdc)

        if rd.get("RULE_SQL"):
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.user_group=="Admin" and "IS_GLOBAL" in rd:
            if rd["IS_GLOBAL"]==1 and self.global_cb:
                self.global_cb.setChecked(True)

        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_cb.setChecked(True)

        sc=rd.get("CRITICAL_SCOPE","NONE").upper()
        idx_sc=self.scope_combo.findText(sc)
        if idx_sc>=0:
            self.scope_combo.setCurrentIndex(idx_sc)

        if rd.get("DECISION_TABLE_ID"):
            self.dt_id_edit.setText(str(rd["DECISION_TABLE_ID"]))

    def live_validate_sql(self):
        # stub => user typed => we do minimal checks
        txt=self.sql_edit.toPlainText().strip()
        # you can parse or do partial run checks

    def save_rule(self):
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","Rule name required.")
            return
        sql_=self.sql_edit.toPlainText().strip()
        group_id=self.group_combo.currentData()
        parent_id=self.parent_rule_combo.currentData()
        rt_id=self.rule_type_combo.currentData()
        st=self.status_combo.currentText()
        start_dt_str=self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_dt_str=self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_val=self.cdc_combo.currentText().upper()

        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()

        isg=0
        if self.user_group=="Admin" and self.global_cb:
            if self.global_cb.isChecked():
                isg=1
        isc=1 if self.critical_cb.isChecked() else 0
        scp=self.scope_combo.currentText().upper()

        dt_id=None
        if self.dt_id_edit.text().strip():
            try:
                dt_id=int(self.dt_id_edit.text().strip())
            except:
                dt_id=None

        # fetch group name
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?",(group_id,))
        g_r=c.fetchone()
        if g_r:
            gname=g_r[0]
        else:
            gname="BG1"

        rule_dict={
            "GROUP_ID":group_id,
            "PARENT_RULE_ID": parent_id if parent_id else None,
            "RULE_TYPE_ID":rt_id,
            "RULE_NAME":nm,
            "RULE_SQL":sql_,
            "EFFECTIVE_START_DATE":start_dt_str,
            "EFFECTIVE_END_DATE":end_dt_str,
            "STATUS":st,
            "DESCRIPTION":desc_,
            "BUSINESS_JUSTIFICATION":just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp,
            "CDC_TYPE": cdc_val,
            "OWNER_GROUP": gname,
            "DECISION_TABLE_ID": dt_id
        }

        if self.is_update and self.rule_data:
            rid=self.rule_data["RULE_ID"]
            rule_dict["RULE_ID"]=rid
            confirm=QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                from_part2_update=globals().get("update_rule")
                if not from_part2_update:
                    raise ValueError("update_rule not found in global scope.")
                from_part2_update(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Success",f"Rule {rid} updated => re-approval started.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                from_part2_add=globals().get("add_rule")
                if not from_part2_add:
                    raise ValueError("add_rule not found in global scope.")
                new_id=from_part2_add(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Created",f"Rule '{nm}' created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
"""
BRM TOOL – PART 5 of 8
MultiStepApprovalTab, GlobalCriticalAdminTab, Hierarchy with drag-and-drop stub,
Enhanced Lineage Graph.

All references to BFS, advanced CRUD, scheduling, etc. from Parts 1–4 are assumed 
to be in the same file/namespace.
"""

import sys
import json
import math
import logging
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QCheckBox, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu, QFileDialog,
    QInputDialog, QGraphicsView, QGraphicsScene, QGraphicsLineItem,
    QGraphicsRectItem, QGraphicsEllipseItem
)
from PyQt5.QtCore import Qt, QPoint
from PyQt5.QtGui import QColor, QPen, QBrush


# =========================
# APPROVALS (MultiStepApprovalTab)
# =========================
class MultiStepApprovalTab(QWidget):
    """
    Show any pending approvals for the current user => Approve/Reject if it's their stage.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.approval_table=QTableWidget(0,7)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","GroupName","RuleName","Stage","Approved?","Approve","Reject"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        self.approval_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.approval_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.approval_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        """
        We only want rows for the current user => APPROVED_FLAG=0 => must be minimal stage.
        """
        self.approval_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG,
               A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()

        def get_current_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            return ro[0] if ro else None

        # Only show if it's the minimal stage => user can Approve/Reject
        minimal=[]
        for row in rows:
            rid=row[0]
            st=row[4]
            cur_st=get_current_stage(rid)
            if cur_st==st:
                minimal.append(row)

        self.approval_table.setRowCount(0)
        for row_data in minimal:
            r_i=self.approval_table.rowCount()
            self.approval_table.insertRow(r_i)
            self.approval_table.setItem(r_i,0,QTableWidgetItem(str(row_data[0])))
            self.approval_table.setItem(r_i,1,QTableWidgetItem(str(row_data[1])))
            self.approval_table.setItem(r_i,2,QTableWidgetItem(str(row_data[5])))
            self.approval_table.setItem(r_i,3,QTableWidgetItem(str(row_data[4])))
            self.approval_table.setItem(r_i,4,QTableWidgetItem(str(row_data[3])))

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rindex=r_i: self.do_approve(rindex))
            self.approval_table.setCellWidget(r_i,5,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rindex=r_i: self.do_reject(rindex))
            self.approval_table.setCellWidget(r_i,6,reject_btn)

    def do_approve(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=str(grp_item.text())

        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))

        # check if any further approvals needed
        def get_current_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            return ro[0] if ro else None

        nxt_stage=get_current_stage(rid)
        if nxt_stage is None:
            # all approvals => set rule to APPROVED => ACTIVE
            c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
            WHERE RULE_ID=?
            """,(rid,))
        else:
            # still need more
            c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
            WHERE RULE_ID=?
            """,(rid,))

        # audit
        insert_audit=globals().get("insert_audit_log")
        if insert_audit:
            old_data={"APPROVED_FLAG":0}
            new_data={"APPROVED_FLAG":1}
            insert_audit(self.connection,"UPDATE","BRM_RULE_APPROVALS",rid,self.logged_in_username,old_data,new_data)

        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} => Approved.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=str(grp_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))
        c.execute("""
        UPDATE BRM_RULES
        SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
        WHERE RULE_ID=?
        """,(rid,))
        insert_audit=globals().get("insert_audit_log")
        if insert_audit:
            insert_audit(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"rejected":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} => Rejected.")
        self.load_approvals()


# =========================
# GLOBAL/CRITICAL ADMIN
# =========================
class GlobalCriticalAdminTab(QWidget):
    """
    If user is admin => can set is_global, critical_rule, scope, plus manage GCR links.
    """
    def __init__(self, main_window, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_window=main_window
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_h=QHBoxLayout()
        self.show_only_gcr=QCheckBox("Show only GCR (global/critical) rules")
        self.show_only_gcr.setChecked(True)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(self.show_only_gcr)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IS_GLOBAL","CRITICAL_RULE","CRITICAL_SCOPE","STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        # global/critical scope
        scope_h=QHBoxLayout()
        self.global_cb=QCheckBox("Set Global?")
        scope_h.addWidget(self.global_cb)

        self.critical_cb=QCheckBox("Set Critical?")
        scope_h.addWidget(self.critical_cb)

        scope_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        scope_h.addWidget(self.scope_combo)

        apply_btn=QPushButton("Apply to Selected")
        apply_btn.clicked.connect(self.apply_gcs)
        scope_h.addWidget(apply_btn)
        scope_h.addStretch()
        layout.addLayout(scope_h)

        # Link management
        link_h=QHBoxLayout()
        self.gcr_parent_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_parent_combo)

        self.gcr_child_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.gcr_child_combo)

        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(link_btn)
        link_h.addWidget(unlink_btn)

        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all_btn=QPushButton("Refresh All")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.rule_table.setItem(r_i,col_i,QTableWidgetItem(str(val)))

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.gcr_parent_combo.addItem(disp, rid)

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.gcr_child_combo.addItem(disp, rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT GCR_RULE_ID,TARGET_RULE_ID
        FROM BRM_GLOBAL_CRITICAL_LINKS
        ORDER BY GCR_RULE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def get_selected_rules(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for idx in idxs:
            r_i=idx.row()
            it=self.rule_table.item(r_i,0)
            if it:
                out.append(int(it.text()))
        return out

    def apply_gcs(self):
        rids=self.get_selected_rules()
        if not rids:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        isg=1 if self.global_cb.isChecked() else 0
        isc=1 if self.critical_cb.isChecked() else 0
        scp=self.scope_combo.currentText().upper()
        confirm=QMessageBox.question(
            self, "Confirm", 
            f"Set IS_GLOBAL={isg}, CRITICAL_RULE={isc}, SCOPE={scp} for {len(rids)} rule(s)?"
        )
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        for rid in rids:
            c.execute("""
            UPDATE BRM_RULES
            SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
            WHERE RULE_ID=?
            """,(isg,isc,scp,rid))
        self.connection.commit()
        QMessageBox.information(self,"Done",f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No Parent","Pick a parent GCR rule first.")
            return
        if not cid:
            QMessageBox.warning(self,"No Child","Pick a child rule.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        ins_audit=globals().get("insert_audit_log")
        c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(pid,cid))
        if ins_audit:
            ins_audit(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"parent":pid,"child":cid})
        self.connection.commit()
        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        ins_audit=globals().get("insert_audit_log")
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
        if ins_audit:
            ins_audit(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",{"parent":pid,"child":cid},None)
        self.connection.commit()
        QMessageBox.information(self,"Unlinked",f"Child {cid} from {pid}")
        self.load_link_view()


# =========================
# HIERARCHY VIEW
# =========================
class HierarchyViewTab(QTreeWidget):
    """
    Show group->rule tree => user can drag rule => re-parent stub.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule (Part 5)"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grps=c.fetchall()
        grp_map={}
        for (gid,gname) in grps:
            top=QTreeWidgetItem([f"{gname} (ID={gid})"])
            top.setData(0, Qt.UserRole, ("group",gid))
            self.addTopLevelItem(top)
            grp_map[gid]=top

        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID FROM BRM_RULES ORDER BY RULE_ID")
        rws=c.fetchall()
        for (rid,rn,gid) in rws:
            if gid in grp_map:
                parent_it=grp_map[gid]
                child=QTreeWidgetItem([f"Rule {rid}: {rn}"])
                child.setData(0, Qt.UserRole, ("rule",rid))
                parent_it.addChild(child)
        self.expandAll()

    def dropEvent(self, event):
        """
        Stub => parse target => update DB if re-parenting => For now just show a message.
        """
        source_item=self.currentItem()
        super().dropEvent(event)
        QMessageBox.information(self,"Drag/Drop","Re-parenting stub => you'd parse new structure => update DB.")


# =========================
# ENHANCED LINEAGE GRAPH
# =========================
class EnhancedLineageGraphWidget(QGraphicsView):
    """
    Visual graph => each rule is a node => edges for parent->child & table dependencies
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.children_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()

        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        if not rows:
            self.scene.addText("No rules found.")
            return

        all_ids=set()
        parent_map={}
        for row in rows:
            rid=row[0]
            pid=row[2]
            all_ids.add(rid)
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                parent_map[rid]=pid

        from collections import deque
        child_ids=set(parent_map.keys())
        roots=[x for x in all_ids if x not in child_ids]

        # store for BFS
        rule_lookup={}
        for row in rows:
            d={
                "RULE_ID": row[0],
                "RULE_NAME": row[1],
                "PARENT_RULE_ID": row[2],
                "STATUS": row[3],
                "RULE_TYPE_ID": row[4],
                "CLUSTER_NAME": row[5],
                "IS_GLOBAL": row[6],
                "CRITICAL_RULE": row[7]
            }
            rule_lookup[row[0]]=d

        queue=deque()
        level_map={}
        visited=set()
        for rt in roots:
            queue.append((rt,0))

        while queue:
            (rid, depth)=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info=rule_lookup[rid]
            rowcount=level_map.get(depth,0)
            level_map[depth]=rowcount+1
            x=depth*250
            y=rowcount*120

            node_item=self.make_rule_node(info)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid]=node_item

            if rid in self.children_map:
                for ch_ in self.children_map[rid]:
                    queue.append((ch_, depth+1))

        # draw edges
        for row in rows:
            rid=row[0]
            pid=row[2]
            if pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # add table dependencies
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps=c.fetchall()
        tbl_map={}
        idx=0
        for (drid, dbn, tbl, coln, op_) in deps:
            key=(dbn+"."+tbl).lower().strip(".")
            if key not in tbl_map:
                ellipse=TableEllipseItem(key)
                ellipse.setPos(800, idx*60)
                self.scene.addItem(ellipse)
                tbl_map[key]=ellipse
                idx+=1
            if drid in self.node_map:
                color=QColor("blue") if op_=="READ" else QColor("red")
                self.draw_edge(self.node_map[drid], tbl_map[key], color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def make_rule_node(self, info):
        """
        Return a QGraphicsItem => rectangle or ellipse based on RULE_TYPE_ID,
        color for active/inactive or cluster, pen if critical.
        """
        rt_id=info["RULE_TYPE_ID"]
        if rt_id==1:
            node=QGraphicsRectItem(0,0,140,60)
        else:
            node=QGraphicsEllipseItem(0,0,140,60)

        status=info["STATUS"]
        if status.lower()=="active":
            basecol=QColor("lightgreen")
        else:
            basecol=QColor("tomato")

        cluster=info["CLUSTER_NAME"] or ""
        if cluster:
            hv=abs(hash(cluster))%360
            basecol=QColor.fromHsv(hv,128,255)

        node.setBrush(QBrush(basecol))
        pen=QPen(Qt.black,2)
        if info["CRITICAL_RULE"]==1:
            pen=QPen(QColor("red"),3)
        node.setPen(pen)

        disp=info["RULE_NAME"]
        if info["IS_GLOBAL"]==1:
            disp=f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self, item1, item2, color=QColor("darkblue")):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=QGraphicsLineItem(p1.x(), p1.y(), p2.x(), p2.y())
        line.setPen(QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene:
            br=self.scene.itemsBoundingRect()
            if br.isValid():
                self.fitInView(br, Qt.KeepAspectRatio)


class TableEllipseItem(QGraphicsEllipseItem):
    """
    A small ellipse representing a DB table in the lineage graph.
    """
    def __init__(self, table_name):
        super().__init__(0,0,120,50)
        self.table_name=table_name
        self.setBrush(QBrush(QColor("lightblue")))
        self.setToolTip(f"Table: {table_name}")
"""
BRM TOOL – PART 6 of 8
MetricsDashboardTab, CtrlTablesTab, GroupManagementTab, UserManagementTab.

This completes the major admin features, building on BFS and advanced logic from Parts 1–5.
No references to external old code.
"""

import math
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget
)
from PyQt5.QtCore import Qt
import pyqtgraph as pg

# =========================
#  METRICS DASHBOARD
# =========================
class MetricsDashboardTab(QWidget):
    """
    Show a bar chart => rule counts by status from BRM_RULES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.chart=pg.PlotWidget(title="Rule Counts by Status (Part 6)")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        ref_btn=QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS,COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()
        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]

        self.chart.clear()
        if statuses:
            xvals=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(xvals), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(xvals, statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True,y=True)

# =========================
#  CONTROL TABLES TAB
# =========================
class CtrlTablesTab(QWidget):
    """
    Simple viewer => pick from known admin tables => load up to 1000 rows => display in a QTableWidget.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS"
        ]
        self.tbl_combo=QComboBox()
        for t_ in self.table_list:
            self.tbl_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        self.load_btn=QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def on_load_data(self):
        tbl=self.tbl_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[d[0] for d in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error fetching columns: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving data: {ex}")
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)

        for row in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for j,val in enumerate(row):
                self.data_table.setItem(r_i,j,QTableWidgetItem(str(val)))


# =========================
# GROUP MANAGEMENT TAB
# =========================
class GroupManagementTab(QWidget):
    """
    Manage business groups, membership, group permissions, group approvers.
    If user not admin => hide.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # Groups & membership
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_box_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_box_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.delete_group)
        grp_btns.addWidget(del_grp_btn)

        grp_btns.addStretch()
        grp_box_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        memb_box=QGroupBox("Membership")
        memb_layout=QVBoxLayout(memb_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        memb_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.add_user_to_group)
        memb_btns.addWidget(add_usr_btn)

        rm_usr_btn=QPushButton("Remove User from Group")
        rm_usr_btn.clicked.connect(self.remove_user_from_group)
        memb_btns.addWidget(rm_usr_btn)

        memb_btns.addStretch()
        memb_layout.addLayout(memb_btns)
        gm_layout.addWidget(memb_box)

        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # Permissions
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)

        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)

        top_h=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(QLabel("Select Group:"))
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["TargetTable"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.add_permission)
        ph.addWidget(addp_btn)
        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.remove_permission)
        ph.addWidget(remp_btn)
        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # Approvers
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(QLabel("Group:"))
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.add_approver)
        appr_btns.addWidget(add_appr_btn)

        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.remove_approver)
        appr_btns.addWidget(del_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)

        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        # Refresh
        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.populate_perm_groups()
        self.populate_appr_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.groups_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.users_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            return None
        it=self.groups_table.item(row,0)
        if not it:
            return None
        return it.text()

    def add_group(self):
        gname,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not gname.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("""
        INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
        VALUES(?,?,?)
        """,(gname.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for '{grp}':")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(), grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(), grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group '{grp}' removed.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def get_selected_user(self):
        row=self.users_table.currentRow()
        if row<0:
            return None
        it=self.users_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Enter group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        row=c.fetchone()
        if row and row[0]==grp.strip():
            QMessageBox.warning(self,"Error","User is already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user => move to BG1?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def populate_perm_groups(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.perm_group_combo.clear()
        for (gn,) in rows:
            self.perm_group_combo.addItem(gn, gn)

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(str(row[0]) if row[0] else ""))

    def add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Pick a group first.")
            return
        tbl,ok=QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.MyTable'):")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE)
        VALUES(?,?)
        """,(grp.strip(), tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        row=self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        tbl=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{tbl}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(),tbl))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"Permission removed.")
        self.load_permissions()

    def populate_appr_groups(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.appr_group_combo.clear()
        for (gn,) in rows:
            self.appr_group_combo.addItem(gn, gn)

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        self.appr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT APPROVER_ID,USERNAME
        FROM BUSINESS_GROUP_APPROVERS
        WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.appr_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"None","Pick a group.")
            return
        usern,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME)
        VALUES(?,?)
        """,(grp.strip(), usern.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver '{usern}' added to group '{grp}'.")
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        appr_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver ID={appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()


# =========================
# USER MANAGEMENT TAB
# =========================
class UserManagementTab(QWidget):
    """
    Admin-only => manage USERS table => add, delete, change password. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        bh.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.user_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_userid(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Enter password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("""
        INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP)
        VALUES(?,?,?)
        """,(uname.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","User created.")
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"User ID={uid} removed.")
        self.load_users()

    def change_password(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"New Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Changed","Password updated.")
        self.load_users()
"""
BRM TOOL – PART 7 of 8
CustomRuleGroupEnhancedTab (for advanced custom group mgmt),
AlertsAndDashboardsTab (showing old approvals + upcoming schedules).

Builds on BFS logic, advanced CRUD, scheduling, etc. from Parts 1–6.
No references to any external/old code beyond this 8-part file.
"""

import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem, 
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox, 
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QMenu
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor, QDrag


# =========================
# CUSTOM RULE GROUP (Enhanced)
# =========================
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manage custom rule groups:
      - Create/rename/delete
      - Backup/restore
      - Assign rules => BFS or normal approach
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_grp_edit=QLineEdit()
        self.new_grp_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_grp_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        right_layout=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search rules to add..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)

        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for (cg_id, cg_name, owner) in groups:
            disp=f"{cg_name} (Owner={owner})"
            g_it=QTreeWidgetItem([disp])
            g_it.setData(0,Qt.UserRole,cg_id)
            g_it.setBackground(0, QBrush(QColor("lightgray")))
            self.tree.addTopLevelItem(g_it)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for (rid,rn,isg,isc) in assigned:
                txt=f"Rule {rid}: {rn}"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0, Qt.UserRole, rid)
                if isg==1:
                    rr_item.setBackground(0, QBrush(QColor("lightblue")))
                if isc==1:
                    rr_item.setBackground(0, QBrush(QColor("lightcoral")))
                g_it.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        rows=c.fetchall()

        # get assigned
        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set([r[0] for r in c2.fetchall()])

        for (rid,rn,og) in rows:
            if rid in assigned:
                # skip already assigned
                continue
            disp=f"Rule {rid}: {rn} (Owner={og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole, rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # child => rule => allow "remove rule from group"
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id, rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group.")
                self.refresh_all()

    def create_group(self):
        name=self.new_grp_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name specified.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(
          CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP
        )
        VALUES(?,?,?,GETDATE())
        """,(name, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_grp_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        parent=it.parent()
        if parent:
            # selected a rule => go up to the group
            it=parent
        cg_id=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (cg_id,disp)

    def rename_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[r[0] for r in c.fetchall()]
        backup_data={"group_name":grpname,"members":assigned}

        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1

        snap=json.dumps(backup_data)
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,snap))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {r[0]} (ts={r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:", items, 0,False)
        if not ok or not sel:
            return
        m=re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver=int(m.group(1))

        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return

        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found.")
            return
        try:
            data=json.loads(backup_json)
            new_gname=data["group_name"]
            members=data["members"]
            c.execute("BEGIN TRANSACTION")
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_gname,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel_items=self.tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self,"None","No group selected in the tree.")
            return
        g_item=sel_items[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        selected_rules=self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return
        c=self.connection.cursor()
        count=0
        for it in selected_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()


# =========================
# ALERTS & DASHBOARDS
# =========================
class AlertsAndDashboardsTab(QWidget):
    """
    Show old approvals (>3 days) + upcoming schedules (within next 24 hours).
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # old approvals
        c.execute("""
        SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
               DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP), GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(
              SELECT MIN(APPROVAL_STAGE)
              FROM BRM_RULE_APPROVALS
              WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
          )
          AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP), GETDATE())>3
        """)
        old_approvals=c.fetchall()
        if old_approvals:
            lines.append("Approvals older than 3 days:")
            for (rid,stg,rn,age) in old_approvals:
                lines.append(f" - Rule {rid}, stage={stg}, age={age} days => {rn}")
        else:
            lines.append("No old approvals found (>3 days).")

        lines.append("")

        # upcoming schedules
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upcoming=c.fetchall()
        if upcoming:
            lines.append("Upcoming schedules (next 24h):")
            for (sid,rid,ts) in upcoming:
                lines.append(f" - ID={sid}, rule={rid}, time={ts}")
        else:
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))
"""
BRM TOOL – PART 8 of 8
Final QMainWindow (BRMTool) that integrates all parts: BFS logic, advanced CRUD, scheduling, 
and advanced features. Also includes the 'main' launcher function.
No references to external old code outside these eight parts.
"""

import sys
import json
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QComboBox,
    QPushButton, QLabel, QMessageBox, QDialog, QLineEdit
)
from PyQt5.QtCore import QTimer

# We assume that:
#  - Part 1 defines DatabaseConnectionDialog, LoginDialog, OnboardingWizard, plus basic DB helpers, etc.
#  - Parts 2–7 define BFS logic, multi-step approvals, advanced CRUD, scheduling, advanced features, etc.
#  - Everything is in the same file or properly imported.


class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Integration")
        self.resize(1300,850)
        self.connection=None
        self.user_id=None
        self.logged_in_username=None
        self.user_group=None

        # Step 1: DatabaseConnectionDialog (Part 1)
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection=dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Step 2: LoginDialog (Part 1)
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group
        # also get username from DB if needed
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="UnknownUser"

        # Optional: Show Onboarding Wizard (Part 1) if you want
        # wiz=OnboardingWizard(self.connection)
        # wiz.exec_()

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        # Sync Metadata
        syncAct=QtWidgets.QAction("Sync Metadata",self)
        syncAct.triggered.connect(self.sync_metadata_trigger)
        fileMenu.addAction(syncAct)

        # Metrics Dashboard
        metricsAct=QtWidgets.QAction("View Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        # Schedules
        schedAct=QtWidgets.QAction("New Schedule (Dialog)",self)
        schedAct.triggered.connect(self.launch_enh_sched)
        fileMenu.addAction(schedAct)

        # Chain Sim
        chainAct=QtWidgets.QAction("Simulate Rule Chain",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        # Group Sim
        grpAct=QtWidgets.QAction("Simulate Custom Group",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        # Help Menu
        helpMenu=menubar.addMenu("Help")
        usageAct=QtWidgets.QAction("Show Tips", self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        # Tools menu => from Part 4
        toolsMenu=menubar.addMenu("Tools")
        alAct=QtWidgets.QAction("View Audit Logs",self)
        alAct.triggered.connect(self.open_audit_log)
        toolsMenu.addAction(alAct)

        srAct=QtWidgets.QAction("Search Rules",self)
        srAct.triggered.connect(self.open_rule_search)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (Enter Rule ID)",self)
        verAct.triggered.connect(self.open_version_history)
        toolsMenu.addAction(verAct)

        # Advanced => from Part 3
        advMenu=menubar.addMenu("Advanced")
        self.decision_tab=DecisionTablesTab(self.connection)
        self.conflict_tab=ConflictPriorityManagerTab(self.connection)
        self.composite_tab=CompositeRulesTab(self.connection)
        self.snap_tab=SnapshotManagerTab(self.connection)
        self.tags_tab=TagsManagerTab(self.connection)
        self.dv_tab=DataValidationTab(self.connection)
        self.whatif_tab=WhatIfTestTab(self.connection)

        advMenu.addAction("Open Decision Tables", lambda: self.tabs.addTab(self.decision_tab, "Decision Tables"))
        advMenu.addAction("Open Conflict Priority", lambda: self.tabs.addTab(self.conflict_tab, "Conflict Priority"))
        advMenu.addAction("Open Composite Rules", lambda: self.tabs.addTab(self.composite_tab, "Composite Rules"))
        advMenu.addAction("Open Snapshot Manager", lambda: self.tabs.addTab(self.snap_tab, "Snapshots"))
        advMenu.addAction("Open Tags Manager", lambda: self.tabs.addTab(self.tags_tab, "Tags Manager"))
        advMenu.addAction("Open Data Validation", lambda: self.tabs.addTab(self.dv_tab, "Data Validation"))
        advMenu.addAction("Open What-If Testing", lambda: self.tabs.addTab(self.whatif_tab, "WhatIf Testing"))

        cw=QWidget()
        layout=QVBoxLayout(cw)

        # If admin => allow impersonation UI
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.user_switch_combo=QComboBox()
            self.user_switch_btn=QPushButton("Switch User")
            self.user_switch_btn.clicked.connect(self.do_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.user_switch_combo)
            top_h.addWidget(self.user_switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.load_user_switch_combo()

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # Business Rules tab => includes BFS references
        brw=QWidget()
        br_lay=QVBoxLayout(brw)
        top_btns=QHBoxLayout()

        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule_flow)
        top_btns.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.update_rule_flow)
        top_btns.addWidget(upd_btn)

        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.deactivate_rule_flow)
        top_btns.addWidget(deact_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.delete_rule_flow)
        top_btns.addWidget(del_btn)

        run_btn=QPushButton("Run ETL BFS")
        run_btn.clicked.connect(self.run_bfs_etl)
        top_btns.addWidget(run_btn)

        sim_btn=QPushButton("Simulate Single Rule")
        sim_btn.clicked.connect(self.sim_single_rule)
        top_btns.addWidget(sim_btn)

        top_btns.addStretch()
        br_lay.addLayout(top_btns)

        self.brm_dashboard=RuleDashboard(self.connection, self.user_id, self.user_group)
        br_lay.addWidget(self.brm_dashboard)
        brw.setLayout(br_lay)
        self.tabs.addTab(brw, "Business Rules")

        # Approvals tab => Part 5
        self.appr_tab=MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.appr_tab, "Approvals")

        # GCR Admin => if admin
        if self.user_group=="Admin":
            self.gcr_tab=GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # Hierarchy => Part 5
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # Enhanced Lineage => Part 5
        lw=QWidget()
        lw_l=QVBoxLayout(lw)
        heading=QLabel("Lineage Visualization")
        heading.setStyleSheet("font-weight:bold;")
        lw_l.addWidget(heading)
        self.lineage_view=EnhancedLineageGraphWidget(self.connection)
        lw_l.addWidget(self.lineage_view)
        # optional controls
        bottom_h=QHBoxLayout()
        ref_graph_btn=QPushButton("Refresh Graph")
        ref_graph_btn.clicked.connect(self.lineage_view.populate_graph)
        bottom_h.addWidget(ref_graph_btn)
        reset_btn=QPushButton("Reset View")
        reset_btn.clicked.connect(self.lineage_view.resetView)
        bottom_h.addWidget(reset_btn)
        bottom_h.addStretch()
        lw_l.addLayout(bottom_h)
        lw.setLayout(lw_l)
        self.tabs.addTab(lw,"Lineage")

        # Custom Groups => Part 7
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # Scheduling => Part 3
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # Control Tables => Part 6
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # Metrics => Part 6
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # Alerts => Part 7
        self.alerts_tab=AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.alerts_tab,"Alerts & Dashboards")

        # Group Mgmt => Part 6
        self.grp_mgmt_tab=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # User Mgmt => if admin
        if self.user_group=="Admin":
            self.user_mgmt_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # Timers
        self.approval_timer=QTimer(self)
        self.approval_timer.timeout.connect(self.appr_tab.load_approvals)
        self.approval_timer.start(5000) # e.g. 5s

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules_due)
        self.schedule_timer.start(60000) # 60s

        self.show()

    def sync_metadata_trigger(self):
        fn=globals().get("sync_metadata_improved")
        if fn:
            fn(self.connection)

    def show_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800,600)
        dv_l=QVBoxLayout(dlg)
        chart_tab=MetricsDashboardTab(self.connection)
        dv_l.addWidget(chart_tab)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        dv_l.addWidget(close_btn)
        dlg.exec_()

    def launch_enh_sched(self):
        sch_dlg=EnhancedScheduleDialog(self.connection, self)
        sch_dlg.exec_()

    def launch_chain_sim(self):
        dlg=ChainSimulationDialog(self.connection, self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=GroupSimulationDialog(self.connection, self)
        dlg.exec_()

    def show_help(self):
        QMessageBox.information(self,"Help/Tips",
            "BRM Tool – fully advanced version.\nUse the tabs to manage rules, approvals, etc.")

    def open_audit_log(self):
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def open_rule_search(self):
        dlg=RuleSearchDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def open_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Rule ID","Enter a rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection, rid, self)
        dlg.exec_()

    def do_switch_user(self):
        data=self.user_switch_combo.currentData()
        if not data:
            return
        (new_uid,new_grp)=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        QMessageBox.information(self,"Switched",f"Impersonating user {new_uid} => group {new_grp}.")

    def load_user_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for (uid,uname,ugrp) in rows:
            disp=f"{uname} ({ugrp})"
            self.user_switch_combo.addItem(disp,(uid,ugrp))

    def add_rule_flow(self):
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def update_rule_flow(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No rule with ID={rid}.")
            return
        cols=[d[0] for d in c.description]
        rule_data=dict(zip(cols,row))
        dlg=RuleEditorDialog(self.connection,self.user_group,rule_data,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def deactivate_rule_flow(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                from_part2_deact=globals().get("deactivate_rule")
                from_part2_deact(self.connection, rid, "CurrentUser", self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivation => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def delete_rule_flow(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                from_part2_del=globals().get("delete_rule")
                from_part2_del(self.connection, rid, "CurrentUser", self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Delete => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_bfs_etl(self):
        from_part2_bfs=globals().get("execute_rules_in_bfs")
        if not from_part2_bfs:
            QMessageBox.warning(self,"Missing","No BFS function found in global scope.")
            return
        executed,skipped=from_part2_bfs(self.connection)
        msg=f"BFS => executed={executed}, skipped={list(skipped)}"
        QMessageBox.information(self,"Run BFS",msg)
        self.brm_dashboard.load_rules()

    def sim_single_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL,OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","Rule not found or missing data.")
            return
        rsql=row[0]
        op=row[1]
        dlg=SingleRuleSimulationDialog(self.connection,rid,rsql or "",op or "OTHER",self)
        dlg.exec_()

    def check_schedules_due(self):
        """
        Every minute => check RULE_SCHEDULES => if SCHEDULE_TIME<=now => run rule logic in a transaction => update status.
        """
        c=self.connection.cursor()
        now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
        """,(now,))
        due=c.fetchall()
        for row in due:
            (sch_id,rid,ts)=row
            c2=self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL,OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                r_=c2.fetchone()
                if r_:
                    (sql_,op_)=r_
                    if op_=="DECISION_TABLE":
                        # placeholder => pass
                        pass_success=True
                        msg="DECISION_TABLE => PASS"
                    else:
                        try:
                            c2.execute(sql_)
                            rows2=c2.fetchall()
                            if rows2:
                                val=rows2[0][0]
                                pass_success=(val==1)
                                msg=f"Returned: {val}"
                            else:
                                pass_success=True
                                msg="No rows => PASS"
                        except Exception as ex:
                            pass_success=False
                            msg=str(ex)
                        if pass_success:
                            c2.execute("COMMIT")
                        else:
                            c2.execute("ROLLBACK")

                    if pass_success:
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
                    else:
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                self.connection.commit()
            except Exception as ex:
                logging.error(f"Scheduled exec error => {ex}")
                c2.execute("ROLLBACK")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                self.connection.commit()
        self.sch_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()


def main():
    """
    Standard entry point => merges all parts => runs the final BRMTool UI.
    """
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())
