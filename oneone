#!/usr/bin/env python
"""
BRM TOOL – SINGLE FILE, FULLY INTEGRATED WITH DML SUPPORT

Features:
  • Database Connection & Login (USERS table)
  • Rule CRUD, BFS-based Execution (skipping child rules if global/critical fails)
  • Multi-step Approvals (Approve/Reject)
  • Insert/Update/Delete detection => OPERATION_TYPE = 'INSERT','UPDATE','DELETE','SELECT'
  • Column-level ("acupuncture") lineage: DML columns stored with COLUMN_OP='WRITE'
  • Dry-run (simulate) for single rule, entire chain, custom group
  • Global/Critical Admin, Custom Rule Groups, Scheduling, Control Tables, Audit Logs, etc.
  • Advanced: Decision Tables, Conflict Priority, Composite Rules, Snapshot Manager, Tags, Data Validation
  • Transaction per DML rule in BFS: commit on success, rollback on fail
  • Comprehensive code – no references to old code or brevity placeholders
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
from datetime import datetime
from collections import deque
from email.mime.text import MIMEText

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog,
    QCalendarWidget
)
import pyqtgraph as pg
from sqlparse.sql import IdentifierList, Identifier
from sqlparse.tokens import Keyword, DML

###############################################################################
# LOGGING
###############################################################################
logging.basicConfig(
    filename='brm_tool_fully_integrated_dml.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# EMAIL CONFIG
###############################################################################
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",  
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – DML Enhanced")
        self.resize(400,200)
        layout = QVBoxLayout(self)

        lbl = QLabel("Select a SQL Server ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom connection string (optional)")
        layout.addWidget(self.conn_str_edit)

        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cb = QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cb)
        layout.addLayout(bh)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self,"Error","No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self,"Connection Error",str(ex))
            return None

###############################################################################
# DB HELPERS
###############################################################################
def get_cursor_rows(cursor):
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    return rows

def get_cursor_one(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return None

def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    import json
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """,(action, table_name, str(record_id), action_by,
         json.dumps(old_data) if old_data else None,
         json.dumps(new_data) if new_data else None))
    conn.commit()

###############################################################################
# LOGIN
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – Full DML")
        self.resize(300,150)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self,"Error","Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(usern,passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")

###############################################################################
# ADVANCED SQL PARSE
###############################################################################
import sqlparse
from sqlparse.sql import IdentifierList, Identifier
from sqlparse.tokens import Keyword, DML

def parse_identifier(identifier):
    raw = str(identifier).strip("[] ")
    parts = raw.split(".")
    if len(parts)==3:
        return (parts[0].strip("[] "), parts[1].strip("[] "), parts[2].strip("[] "))
    elif len(parts)==2:
        return ("", parts[0].strip("[] "), parts[1].strip("[] "))
    else:
        return ("","", raw.strip("[] "))

def advanced_extract_tables(sql_text:str):
    parsed = sqlparse.parse(sql_text)
    found = []
    for statement in parsed:
        from_seen=False
        for token in statement.tokens:
            if token.ttype is Keyword and token.value.upper()=="FROM":
                from_seen=True
                continue
            if from_seen:
                if token.ttype is Keyword:
                    break
                if isinstance(token,IdentifierList):
                    for ident in token.get_identifiers():
                        db,sch,tbl = parse_identifier(ident)
                        if tbl:
                            found.append((db,sch,tbl))
                elif isinstance(token,Identifier):
                    db,sch,tbl = parse_identifier(token)
                    if tbl:
                        found.append((db,sch,tbl))
    unique=[]
    for x in found:
        if x not in unique:
            unique.append(x)
    return unique

###############################################################################
# DML DETECT & COLUMN PARSE
###############################################################################
def detect_operation_type(sql_text:str) -> str:
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def extract_write_columns_for_update(sql_text:str):
    up = sql_text.upper()
    idx = up.find(" SET ")
    if idx<0:
        return []
    sub = sql_text[idx+4:]
    wh = sub.upper().find(" WHERE ")
    if wh>=0:
        sub=sub[:wh]
    columns=[]
    parts=sub.split(",")
    for part in parts:
        eqPos=part.find("=")
        if eqPos>0:
            col=part[:eqPos].strip("[] \n")
            columns.append(col)
    return columns

def extract_write_columns_for_insert(sql_text:str):
    up=sql_text.upper()
    idx=up.find("INSERT INTO ")
    if idx<0:
        return []
    tail=sql_text[idx+11:].strip()
    # find '('
    op=tail.find("(")
    if op<0:
        return []
    cp=tail.find(")",op)
    if cp<0:
        return []
    sub=tail[op+1:cp]
    columns=[]
    for col in sub.split(","):
        columns.append(col.strip("[] \n"))
    return columns

###############################################################################
# BFS RULE EXECUTION (PER-RULE TRANSACTION FOR DML)
###############################################################################
def build_rule_adjacency(conn):
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows=get_cursor_rows(c)
    children_map={}
    all_ids=set()
    parent_ids=set()
    for r_ in rows:
        rid=r_["RULE_ID"]
        pid=r_["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid,[]).append(rid)
    roots=[x for x in all_ids if x not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    c=conn.cursor()
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows=get_cursor_rows(c)
    link_map={}
    for r_ in rows:
        link_map.setdefault(r_["GCR_RULE_ID"],set()).add(r_["TARGET_RULE_ID"])
    return link_map

def get_all_rules_as_dict(conn):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rr=get_cursor_rows(c)
    return {x["RULE_ID"]:x for x in rr}

def skip_descendants(child_id, children_map, skipped):
    stack=[child_id]
    while stack:
        curr=stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def execute_rules_in_order(conn):
    children_map, roots=build_rule_adjacency(conn)
    gcr_links=load_global_critical_links(conn)
    rule_lookup=get_all_rules_as_dict(conn)
    executed=[]
    skipped=set()
    c=conn.cursor()
    queue=list(roots)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning(f"Rule {rid} not found in dictionary.")
            continue
        rinfo=rule_lookup[rid]
        sql_=rinfo["RULE_SQL"]
        is_crit=(rinfo["CRITICAL_RULE"]==1 or rinfo["IS_GLOBAL"]==1)
        crit_scope=(rinfo["CRITICAL_SCOPE"] or "NONE").upper()

        c.execute("BEGIN TRANSACTION")
        success=False
        msg=""
        try:
            c.execute(sql_)
            row=get_cursor_one(c)
            if row:
                val=list(row.values())[0]
                success=(val==1)
                msg=f"Returned: {val}"
            else:
                success=True
                msg="No rows => PASS"
        except Exception as ex:
            success=False
            msg=str(ex)

        if success:
            c.execute("COMMIT")
            logger.info(f"Rule {rid} => PASS. {msg}")
            executed.append(rid)
            if rid in children_map:
                for ch_ in children_map[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            c.execute("ROLLBACK")
            logger.warning(f"Rule {rid} => FAIL. {msg}")
            if is_crit and crit_scope!="NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    return executed, skipped

###############################################################################
# RULE CRUD WITH DML-SUPPORTING LOGIC
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    c=conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")
    if rule_data.get("IS_GLOBAL",0)==1 and user_group!="Admin":
        raise ValueError("Only Admin can create global rule.")

    op_type=detect_operation_type(rule_data["RULE_SQL"])
    rule_data["OPERATION_TYPE"]=op_type

    c.execute("""
    INSERT INTO BRM_RULES(
        GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
        EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,CREATED_BY,
        DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,CREATED_TIMESTAMP,
        UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,APPROVAL_STATUS,
        IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
    )
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS","INACTIVE"),
        1,
        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),
        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE")
    ))
    new_id=c.execute("SELECT SCOPE_IDENTITY()").fetchone()[0]

    # parse dependencies
    if op_type in ["INSERT","UPDATE","DELETE"]:
        target_table="N/A"
        up = rule_data["RULE_SQL"].upper()

        if op_type=="INSERT":
            idx=up.find("INSERT INTO ")
            if idx>=0:
                tail=rule_data["RULE_SQL"][idx+11:].strip()
                spacePos=tail.find(" ")
                if spacePos>0:
                    target_table=tail[:spacePos]
                else:
                    brPos=tail.find("(")
                    if brPos>0:
                        target_table=tail[:brPos]
            target_table=target_table.strip("[] ")

            cols=extract_write_columns_for_insert(rule_data["RULE_SQL"])
            if not cols:
                cols=["N/A"]
            for col in cols:
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(new_id,"N/A",target_table,col,"WRITE"))

        elif op_type=="UPDATE":
            idx=up.find("UPDATE ")
            if idx>=0:
                tail=rule_data["RULE_SQL"][idx+7:].strip()
                spacePos=tail.find(" ")
                if spacePos>0:
                    target_table=tail[:spacePos]
            target_table=target_table.strip("[] ")

            cols=extract_write_columns_for_update(rule_data["RULE_SQL"])
            if not cols:
                cols=["N/A"]
            for col in cols:
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(new_id,"N/A",target_table,col,"WRITE"))

        elif op_type=="DELETE":
            idx=up.find("DELETE FROM ")
            if idx>=0:
                tail=rule_data["RULE_SQL"][idx+11:].strip()
                spacePos=tail.find(" ")
                if spacePos>0:
                    target_table=tail[:spacePos]
                else:
                    target_table=tail
            target_table=target_table.strip("[] ")

            # no columns, just 'N/A'
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(new_id,"N/A",target_table,"N/A","WRITE"))

    else:
        # read
        fromPart=advanced_extract_tables(rule_data["RULE_SQL"])
        for (dbn,sch,tbn) in fromPart:
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(new_id,dbn if dbn else "N/A",tbn if tbn else sch,"DerivedCol","READ"))

    add_audit_log(conn,"INSERT","BRM_RULES",new_id,created_by,None,rule_data)
    conn.commit()
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c=conn.cursor()
    rid=rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data=dict(old)

    new_owner=rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_name=rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()
    if (new_owner!=old["OWNER_GROUP"] or new_name!=old["RULE_NAME"]):
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",(new_owner,new_name))
        du=c.fetchone()
        if du and du[0]!=rid:
            raise ValueError(f"Duplicate rule '{new_name}' in group '{new_owner}'")

    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"])==1 and user_group!="Admin":
        raise ValueError("Only Admin can set is_global=1.")

    op_type=detect_operation_type(rule_data["RULE_SQL"])
    rule_data["OPERATION_TYPE"]=op_type

    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID=?,
      PARENT_RULE_ID=?,
      RULE_TYPE_ID=?,
      RULE_NAME=?,
      RULE_SQL=?,
      EFFECTIVE_START_DATE=?,
      EFFECTIVE_END_DATE=?,
      STATUS='INACTIVE',
      VERSION=VERSION+1,
      UPDATED_BY=?,
      DESCRIPTION=?,
      OPERATION_TYPE=?,
      BUSINESS_JUSTIFICATION=?,
      OWNER_GROUP=?,
      CLUSTER_NAME=?,
      APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
      IS_GLOBAL=?,
      CRITICAL_RULE=?,
      CRITICAL_SCOPE=?,
      CDC_TYPE=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_name,
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old["BUSINESS_JUSTIFICATION"]),
        new_owner,
        rule_data.get("CLUSTER_NAME", old.get("CLUSTER_NAME","")),
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rid
    ))

    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))

    if op_type in ["INSERT","UPDATE","DELETE"]:
        target_table="N/A"
        up=rule_data["RULE_SQL"].upper()
        if op_type=="INSERT":
            idx=up.find("INSERT INTO ")
            if idx>=0:
                tail=rule_data["RULE_SQL"][idx+11:].strip()
                spacePos=tail.find(" ")
                if spacePos>0:
                    target_table=tail[:spacePos]
                else:
                    brPos=tail.find("(")
                    if brPos>0:
                        target_table=tail[:brPos]
            target_table=target_table.strip("[] ")
            cols=extract_write_columns_for_insert(rule_data["RULE_SQL"])
            if not cols:
                cols=["N/A"]
            for col in cols:
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid,"N/A",target_table,col,"WRITE"))

        elif op_type=="UPDATE":
            idx=up.find("UPDATE ")
            if idx>=0:
                tail=rule_data["RULE_SQL"][idx+7:].strip()
                spacePos=tail.find(" ")
                if spacePos>0:
                    target_table=tail[:spacePos]
            target_table=target_table.strip("[] ")
            cols=extract_write_columns_for_update(rule_data["RULE_SQL"])
            if not cols:
                cols=["N/A"]
            for col in cols:
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid,"N/A",target_table,col,"WRITE"))
        elif op_type=="DELETE":
            idx=up.find("DELETE FROM ")
            if idx>=0:
                tail=rule_data["RULE_SQL"][idx+11:].strip()
                spacePos=tail.find(" ")
                if spacePos>0:
                    target_table=tail[:spacePos]
                else:
                    target_table=tail
            target_table=target_table.strip("[] ")
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(rid,"N/A",target_table,"N/A","WRITE"))
    else:
        fromPart=advanced_extract_tables(rule_data["RULE_SQL"])
        for (dbn,sch,tbn) in fromPart:
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(rid,dbn if dbn else "N/A",tbn if tbn else sch,"DerivedCol","READ"))

    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"]=old_data["VERSION"]+1
    add_audit_log(conn,"UPDATE","BRM_RULES",rid,updated_by,old_data,new_data)
    conn.commit()

###############################################################################
# DEACTIVATE/DELETE RULE
###############################################################################
def deactivate_rule(conn, rule_id, updated_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids=get_cursor_rows(c)
    if kids:
        raise ValueError("Deactivate child rules first.")
    old_data=dict(old)
    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',UPDATED_BY=?,VERSION=VERSION+1
    WHERE RULE_ID=?
    """,(updated_by, rule_id))
    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    add_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids=get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist, cannot delete.")
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    leftover=get_cursor_rows(c)
    if leftover:
        raise ValueError("Re-map or remove column references first.")
    old_data=dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)
    conn.commit()

###############################################################################
# SIMULATION HELPERS (TRANSACTION+ROLLBACK FOR DML)
###############################################################################
def run_rule_sql_dry_run(conn, rule_sql):
    c=conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    try:
        c.execute(rule_sql)
        row=get_cursor_one(c)
        if row:
            val=list(row.values())[0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
    except Exception as ex:
        success=False
        msg=str(ex)
    c.execute("ROLLBACK")  # always rollback in simulation
    return success,msg

###############################################################################
# SINGLE RULE SIMULATION
###############################################################################
class SingleRuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.sql_text=sql_text
        self.setWindowTitle(f"Simulate Rule ID={rule_id}")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        run_btn=QPushButton("Run Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)
        cls_btn=QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        bh.addWidget(cls_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        ok,msg=run_rule_sql_dry_run(self.connection,self.sql_text)
        out=f"{'PASS' if ok else 'FAIL'} => {msg}"
        self.result_text.setPlainText(out)

###############################################################################
# (ChainSimulationDialog, GroupSimulationDialog, etc.) 
# The rest of the UI classes follow, including advanced tabs:
# DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab, SnapshotManagerTab,
# TagsManagerTab, DataValidationTab, plus GroupManagementTab, UserManagementTab,
# CustomRuleGroupEnhancedTab, MultiStepApprovalTab, GlobalCriticalAdminTab,
# HierarchyViewTab, EnhancedLineageGraphWidget, MetricsDashboardTab,
# CtrlTablesTab, AuditLogViewer, SearchRuleDialog, VersionHistoryDialog, 
# AlertsAndDashboardsTab, ScheduleManagementTab, 
# plus the main window that orchestrates everything.

# Below is the complete integrated code with no references to old code.

###############################################################################
# CHAIN SIM
###############################################################################
class ChainSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Simulate Rule Chain - Dry-run")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.parent_rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=get_cursor_rows(c)
        for r_ in rows:
            disp=f"{r_['RULE_ID']} - {r_['RULE_NAME']}"
            self.parent_rule_combo.addItem(disp, r_["RULE_ID"])
        form.addRow("Parent Rule:",self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def sim_chain(self):
        pid=self.parent_rule_combo.currentData()
        executed,skipped=self.do_chain_sim(pid)
        txt=f"Chain from rule {pid}\nExecuted => {executed}\nSkipped => {list(skipped)}"
        self.result_text.setPlainText(txt)

    def do_chain_sim(self, parent_rule_id):
        # We'll do BFS but each rule is run in a short transaction => rollback
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,PARENT_RULE_ID,RULE_SQL FROM BRM_RULES")
        rows=get_cursor_rows(c)
        children_map={}
        rule_dict={}
        for r_ in rows:
            rid=r_["RULE_ID"]
            pid=r_["PARENT_RULE_ID"]
            rule_dict[rid]=r_
            if pid:
                children_map.setdefault(pid,[]).append(rid)
        executed=[]
        skipped=set()
        queue=[parent_rule_id]
        while queue:
            rid=queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_dict:
                continue
            sql_=rule_dict[rid]["RULE_SQL"]
            ok,msg=run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch_ in children_map[rid]:
                        if ch_ not in skipped:
                            queue.append(ch_)
            else:
                skipped.add(rid)
        return executed,skipped

###############################################################################
# GROUP SIM
###############################################################################
class GroupSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Simulate Custom Group - Dry-run")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.group_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows=get_cursor_rows(c)
        for g_ in rows:
            disp=f"{g_['CUSTOM_GROUP_ID']} - {g_['CUSTOM_GROUP_NAME']}"
            self.group_combo.addItem(disp, g_["CUSTOM_GROUP_ID"])
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_group(self):
        gid=self.group_combo.currentData()
        ex,fails=self.do_sim(gid)
        msg=f"Group {gid}\nExecuted => {ex}\nFails => {fails}"
        self.result_text.setPlainText(msg)

    def do_sim(self, custom_group_id):
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        group_rules=get_cursor_rows(c)
        rids=[x["RULE_ID"] for x in group_rules]

        c.execute("SELECT RULE_ID,RULE_SQL FROM BRM_RULES")
        allrules=get_cursor_rows(c)
        rule_lookup={r_["RULE_ID"]:r_ for r_ in allrules}
        executed=[]
        fails=[]
        for rid in rids:
            if rid not in rule_lookup:
                fails.append(rid)
                continue
            sql_=rule_lookup[rid]["RULE_SQL"]
            ok,msg=run_rule_sql_dry_run(self.connection,sql_)
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return executed,fails

###############################################################################
# COMMENTS (BRM_RULE_COMMENTS)
###############################################################################
class CommentsDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Comments - Rule {rule_id}")
        self.resize(500,400)
        layout=QVBoxLayout(self)

        self.comment_table=QTableWidget(0,3)
        self.comment_table.setHorizontalHeaderLabels(["Comment ID","Username","Comment"])
        self.comment_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.comment_table)

        add_h=QHBoxLayout()
        self.comment_edit=QLineEdit()
        self.comment_edit.setPlaceholderText("Write a comment..")
        add_h.addWidget(self.comment_edit)
        add_btn=QPushButton("Add")
        add_btn.clicked.connect(self.add_comment)
        add_h.addWidget(add_btn)
        layout.addLayout(add_h)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_comments)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_comments()

    def load_comments(self):
        self.comment_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT COMMENT_ID,USERNAME,COMMENT_TEXT
        FROM BRM_RULE_COMMENTS
        WHERE RULE_ID=?
        ORDER BY COMMENT_ID DESC
        """,(self.rule_id,))
        rows=get_cursor_rows(c)
        for r_ in rows:
            r_i=self.comment_table.rowCount()
            self.comment_table.insertRow(r_i)
            self.comment_table.setItem(r_i,0,QTableWidgetItem(str(r_["COMMENT_ID"])))
            self.comment_table.setItem(r_i,1,QTableWidgetItem(r_["USERNAME"]))
            self.comment_table.setItem(r_i,2,QTableWidgetItem(r_["COMMENT_TEXT"]))

    def add_comment(self):
        txt=self.comment_edit.text().strip()
        if not txt:
            return
        usern="CurrentUser"  
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_RULE_COMMENTS(RULE_ID,USERNAME,COMMENT_TEXT,CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(self.rule_id,usern,txt))
        self.connection.commit()
        self.comment_edit.clear()
        self.load_comments()

###############################################################################
# ALERTS & DASHBOARDS
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
               DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(SELECT MIN(APPROVAL_STAGE) FROM BRM_RULE_APPROVALS WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0)
          AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        old_ap=get_cursor_rows(c)
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for ap in old_ap:
                lines.append(f" - Rule {ap['RULE_ID']} (stage={ap['APPROVAL_STAGE']}, age={ap['age']}) => {ap['RULE_NAME']}")
        else:
            lines.append("No old approvals found.")

        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
          AND SCHEDULE_TIME>=GETDATE()
        ORDER BY SCHEDULE_TIME
        """)
        upcoming=get_cursor_rows(c)
        if upcoming:
            lines.append("")
            lines.append("Upcoming Schedules next 24h:")
            for up in upcoming:
                lines.append(f" - ID={up['SCHEDULE_ID']} => rule {up['RULE_ID']} @ {up['SCHEDULE_TIME']}")
        else:
            lines.append("")
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))

###############################################################################
# ENHANCED SCHEDULE DIALOG
###############################################################################
class EnhancedScheduleDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Enhanced Scheduling UI")
        self.resize(400,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rr=get_cursor_rows(c)
        for r_ in rr:
            disp=f"{r_['RULE_ID']} - {r_['RULE_NAME']}"
            self.rule_combo.addItem(disp, r_["RULE_ID"])
        form.addRow("Select Rule:",self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:",self.calendar)

        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)
        cls_btn=QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        bh.addWidget(cls_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        date_=self.calendar.selectedDate()
        time_=self.time_edit.time()
        dt_str=f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP)
        VALUES(?,?,'Scheduled',GETDATE())
        """,(rid,dt_str))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} scheduled at {dt_str}.")
        self.close()

###############################################################################
# VERSION HISTORY
###############################################################################
class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History - Rule {rule_id}")
        self.resize(800,400)
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["Audit ID","Action","Timestamp","Old Data","New Data"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb=QPushButton("Rollback Selected")
        rb.clicked.connect(self.do_rollback)
        bh.addWidget(rb)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,ACTION_TIMESTAMP,OLD_DATA,NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES'
          AND RECORD_ID=?
          AND ACTION IN('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=get_cursor_rows(c)
        self.table.setRowCount(0)
        for r_ in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            self.table.setItem(r_i,0,QTableWidgetItem(str(r_["AUDIT_ID"])))
            self.table.setItem(r_i,1,QTableWidgetItem(r_["ACTION"]))
            self.table.setItem(r_i,2,QTableWidgetItem(str(r_["ACTION_TIMESTAMP"])))
            self.table.setItem(r_i,3,QTableWidgetItem(r_["OLD_DATA"] or ""))
            self.table.setItem(r_i,4,QTableWidgetItem(r_["NEW_DATA"] or ""))

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected for rollback.")
            return
        row=sel[0].row()
        old_data_item=self.table.item(row,3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self,"No Old Data","No old_data found.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to selected version?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            import json
            old_data=json.loads(old_data_item.text())
            self.apply_rollback(old_data)
            QMessageBox.information(self,"Rolled Back","Rule rollback done.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def apply_rollback(self, old_data):
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=get_cursor_one(c)
        if not row:
            raise ValueError("Rule not found for rollback.")
        # minimal rollback example
        c.execute("BEGIN TRANSACTION")
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(old_data["RULE_NAME"],old_data["RULE_SQL"],old_data["OWNER_GROUP"],rid))
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP)
        VALUES(?,?,?,?,?)
        """,(rid,"RollbackDB","RollbackTable","RollbackCol","READ"))
        c.execute("COMMIT")

###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard",parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.selected_rule_id=None
        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL snippet...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_combo=QComboBox()
        self.status_combo.addItem("All",None)
        self.status_combo.addItem("ACTIVE","ACTIVE")
        self.status_combo.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_combo)
        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Name","SQL","Status","Version","Owner Group","Created TS","Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.rule_table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_combo.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.load_rules()

    def build_filter_query(self):
        filters=[]
        params=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%",f"%{txt}%"])
        st=self.status_combo.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause=" AND ".join(filters) if filters else "1=1"
        return clause,params

    def load_rules(self):
        c=self.connection.cursor()
        clause,params=self.build_filter_query()

        count_q=f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}"
        c.execute(count_q,params)
        rowc=get_cursor_one(c)
        total=rowc["ccount"] if rowc else 0
        self.total_pages=max(1,math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset=(self.current_page-1)*self.records_per_page

        data_q=f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q,(*params,offset,self.records_per_page))
        rows=get_cursor_rows(c)

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_=self.rule_table.rowCount()
            self.rule_table.insertRow(r_)
            self.rule_table.setItem(r_,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r_,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r_,2,QTableWidgetItem(rd["RULE_SQL"]))
            self.rule_table.setItem(r_,3,QTableWidgetItem(rd["STATUS"]))
            self.rule_table.setItem(r_,4,QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r_,5,QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r_,6,QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r_,7,QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel=self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.rule_table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i in idxs:
            r_=i.row()
            it=self.rule_table.item(r_,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

###############################################################################
# MULTI-STEP APPROVAL
###############################################################################
class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(5)
        stages=["BG1","BG2","BG3","FINAL"]
        for st in stages:
            circle=QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status=stage_status_map.get(st,"NotStarted")
            if status=="Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status=="Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status=="Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.appr_table=QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID","Group Name","Rule Name","Stage","Approved?","Approve","Reject"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.appr_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        c=self.connection.cursor()
        q="""
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """
        c.execute(q,(self.logged_in_username,))
        rows=get_cursor_rows(c)

        def get_current_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) as stage
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            rowx=get_cursor_one(c2)
            if rowx and rowx["stage"]:
                return rowx["stage"]
            return None

        minimal=[]
        for rd in rows:
            rid=rd["RULE_ID"]
            st=rd["APPROVAL_STAGE"]
            if get_current_stage(rid)==st:
                minimal.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal:
            r_=self.appr_table.rowCount()
            self.appr_table.insertRow(r_)
            self.appr_table.setItem(r_,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r_,1,QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r_,2,QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r_,3,QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r_,4,QTableWidgetItem(str(rd["APPROVED_FLAG"])))

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_i=r_: self.do_approve(row_i))
            self.appr_table.setCellWidget(r_,5,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, row_i=r_: self.do_reject(row_i))
            self.appr_table.setCellWidget(r_,6,reject_btn)

    def do_approve(self, row_i):
        rid_item=self.appr_table.item(row_i,0)
        grp_item=self.appr_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=grp_item.text()
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1,APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))

        def get_current_stage(rid_):
            c3=self.connection.cursor()
            c3.execute("""
            SELECT MIN(APPROVAL_STAGE) as stage
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            row3=get_cursor_one(c3)
            if row3 and row3["stage"]:
                return row3["stage"]
            return None

        nxt=get_current_stage(rid)
        if nxt is None:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED',STATUS='ACTIVE' WHERE RULE_ID=?",(rid,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS',STATUS='INACTIVE' WHERE RULE_ID=?",(rid,))

        add_audit_log(self.connection,"UPDATE","BRM_RULE_APPROVALS",rid,self.logged_in_username,{"APPROVED_FLAG":0},{"APPROVED_FLAG":1})
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} approved.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.appr_table.item(row_i,0)
        if not rid_item:
            return
        rid=int(rid_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2,APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,self.logged_in_username))
        c.execute("""
        UPDATE BRM_RULES
        SET APPROVAL_STATUS='REJECTED',STATUS='INACTIVE'
        WHERE RULE_ID=?
        """,(rid,))
        add_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"REJECTED":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} rejected.")
        self.load_approvals()

###############################################################################
# GLOBAL/CRITICAL ADMIN
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app=main_app
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return

        top_h=QHBoxLayout()
        self.show_only_gcr=QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        ref_btn=QPushButton("Refresh Rule List")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(self.show_only_gcr)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Rule Name","Owner Group","IS_GLOBAL","CRITICAL_RULE",
            "CRITICAL_SCOPE","STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.rule_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.rule_table)

        gcs_h=QHBoxLayout()
        self.global_cb=QCheckBox("Set Global?")
        gcs_h.addWidget(self.global_cb)
        self.critical_cb=QCheckBox("Set Critical?")
        gcs_h.addWidget(self.critical_cb)
        gcs_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        gcs_h.addWidget(self.scope_combo)
        apply_btn=QPushButton("Apply Flags/Scope")
        apply_btn.clicked.connect(self.apply_gcs_to_selected)
        gcs_h.addWidget(apply_btn)
        gcs_h.addStretch()
        layout.addLayout(gcs_h)

        link_h=QHBoxLayout()
        self.gcr_rule_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_rule_combo)
        self.child_rule_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.child_rule_combo)
        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_h.addWidget(link_btn)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(unlink_btn)
        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all=QPushButton("Refresh Everything")
        ref_all.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        self.rule_table.setRowCount(0)
        for r_ in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(r_):
                self.rule_table.setItem(r_i,col_i,QTableWidgetItem(str(val)))

    def populate_gcr_rule_combo(self):
        self.gcr_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        for row in c.fetchall():
            disp=f"ID:{row[0]} - {row[1]}"
            self.gcr_rule_combo.addItem(disp,row[0])

    def populate_child_rule_combo(self):
        self.child_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            disp=f"ID:{row[0]} - {row[1]}"
            self.child_rule_combo.addItem(disp,row[0])

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(r_[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(r_[1])))

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i in idxs:
            row=i.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def apply_gcs_to_selected(self):
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No Selection","Select rule(s) first.")
            return
        is_g=1 if self.global_cb.isChecked() else 0
        is_c=1 if self.critical_cb.isChecked() else 0
        scope_val=self.scope_combo.currentText().upper()
        confirm=QMessageBox.question(self,"Confirm",f"Set IS_GLOBAL={is_g}, CRITICAL_RULE={is_c}, scope={scope_val} for {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        for rid in rids:
            c.execute("UPDATE BRM_RULES SET IS_GLOBAL=?,CRITICAL_RULE=?,CRITICAL_SCOPE=? WHERE RULE_ID=?",
                      (is_g,is_c,scope_val,rid))
        self.connection.commit()
        QMessageBox.information(self,"Updated",f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No GCR","Pick a parent GCR rule.")
            return
        cid=self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self,"No Child","Pick a child rule.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(pid,cid))
        self.connection.commit()
        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_rule_combo.currentData()
        if not pid:
            return
        cid=self.child_rule_combo.currentData()
        if not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
        self.connection.commit()
        QMessageBox.information(self,"Unlinked",f"Child {cid} from parent {pid}")
        self.load_link_view()

###############################################################################
# HIERARCHY
###############################################################################
class HierarchyViewTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Group / Rule"])
        layout.addWidget(self.tree)
        ref_btn=QPushButton("Refresh Hierarchy")
        ref_btn.clicked.connect(self.load_hierarchy)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        groups=get_cursor_rows(c)
        grp_map={}
        for g_ in groups:
            it=QTreeWidgetItem([f"{g_['GROUP_NAME']} (ID={g_['GROUP_ID']})"])
            self.tree.addTopLevelItem(it)
            grp_map[g_["GROUP_ID"]]=it
        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID FROM BRM_RULES ORDER BY RULE_ID")
        rr=get_cursor_rows(c)
        for r_ in rr:
            gid=r_["GROUP_ID"]
            if gid in grp_map:
                parent=grp_map[gid]
                ch=QTreeWidgetItem([f"Rule {r_['RULE_ID']}: {r_['RULE_NAME']}"])
                parent.addChild(ch)

###############################################################################
# ENHANCED LINEAGE GRAPH
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.children_map={}
        self.parents_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,
               IS_GLOBAL,CRITICAL_RULE
        FROM BRM_RULES ORDER BY RULE_ID
        """)
        rules=get_cursor_rows(c)
        if not rules:
            txt_item=QtWidgets.QGraphicsTextItem("No rules found in BRM_RULES.")
            self.scene.addItem(txt_item)
            return

        for r_ in rules:
            rid=r_["RULE_ID"]
            pid=r_["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                self.parents_map[rid]=pid

        from collections import deque
        all_ids=set(x["RULE_ID"] for x in rules)
        child_ids=set(self.parents_map.keys())
        roots=list(all_ids - child_ids)
        rule_lookup={x["RULE_ID"]:x for x in rules}

        queue=deque()
        level_map={}
        visited=set()
        for rt in roots:
            queue.append((rt,0))

        while queue:
            rid,depth=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info=rule_lookup[rid]
            count_at_level=level_map.get(depth,0)
            level_map[depth]=count_at_level+1
            x=depth*220
            y=count_at_level*120
            node_item=self.create_node(info)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid]=node_item
            if rid in self.children_map:
                for ch_ in self.children_map[rid]:
                    queue.append((ch_,depth+1))

        for r_ in rules:
            pid=r_["PARENT_RULE_ID"]
            rid=r_["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # table deps
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps=get_cursor_rows(c)
        tbl_map={}
        idx=0
        for d_ in deps:
            key=f"{d_['DATABASE_NAME']}.{d_['TABLE_NAME']}".strip(".")
            if key not in tbl_map:
                t_item=QtWidgets.QGraphicsEllipseItem(0,0,100,40)
                basecol=QtGui.QColor("lightblue")
                t_item.setBrush(QtGui.QBrush(basecol))
                t_item.setToolTip(f"Table: {key}")
                t_item.setPos(900,idx*60)
                self.scene.addItem(t_item)
                tbl_map[key]=t_item
                idx+=1
            rid_dep=d_["RULE_ID"]
            if rid_dep in self.node_map:
                color=QtGui.QColor("darkblue")
                if d_["COLUMN_OP"]=="WRITE":
                    color=QtGui.QColor("darkred")
                self.draw_edge(self.node_map[rid_dep], tbl_map[key], color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, info):
        rtype=info["RULE_TYPE_ID"]
        status=info["STATUS"]
        cluster=(info.get("CLUSTER_NAME","") or "")
        is_g=info["IS_GLOBAL"]
        is_c=info["CRITICAL_RULE"]

        if rtype==1:
            node=QtWidgets.QGraphicsRectItem(0,0,120,50)
        else:
            node=QtWidgets.QGraphicsEllipseItem(0,0,120,50)

        if status.lower()=="active":
            basecol=QtGui.QColor("lightgreen")
        else:
            basecol=QtGui.QColor("tomato")
        if cluster:
            hv=abs(hash(cluster))%360
            basecol=QtGui.QColor.fromHsv(hv,128,255)
        node.setBrush(QtGui.QBrush(basecol))

        pen=QtGui.QPen(QtCore.Qt.black,2)
        if is_c==1:
            pen=QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)
        disp=info["RULE_NAME"]
        if is_g==1:
            disp=f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=QtWidgets.QGraphicsLineItem(p1.x(),p1.y(),p2.x(),p2.y())
        line.setPen(QtGui.QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button()==QtCore.Qt.LeftButton:
            item=self.itemAt(event.pos())
            if isinstance(item,(QtWidgets.QGraphicsRectItem,QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self,"Rule Details",item.toolTip())
        super().mousePressEvent(event)

    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setPen(QtGui.QPen(QtCore.Qt.black,2))

    def search_nodes(self, query):
        self.clear_highlights()
        ql=query.lower()
        c=self.connection.cursor()
        found=set()

        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE LOWER(RULE_NAME) LIKE ?
           OR LOWER(RULE_SQL) LIKE ?
           OR LOWER(DESCRIPTION) LIKE ?
           OR LOWER(BUSINESS_JUSTIFICATION) LIKE ?
           OR CAST(RULE_ID AS VARCHAR(50)) LIKE ?
        """,(f"%{ql}%",f"%{ql}%",f"%{ql}%",f"%{ql}%",f"%{ql}%"))
        for x in get_cursor_rows(c):
            found.add(x["RULE_ID"])

        c.execute("""
        SELECT RULE_ID
        FROM BRM_COLUMN_MAPPING
        WHERE LOWER(SOURCE_COLUMN_NAME) LIKE ? OR LOWER(TARGET_COLUMN_NAME) LIKE ?
        """,(f"%{ql}%",f"%{ql}%"))
        for x in get_cursor_rows(c):
            found.add(x["RULE_ID"])

        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE LOWER(DATABASE_NAME) LIKE ? OR LOWER(TABLE_NAME) LIKE ?
        """,(f"%{ql}%",f"%{ql}%"))
        for x in get_cursor_rows(c):
            found.add(x["RULE_ID"])

        if not found:
            QMessageBox.information(self,"No Match",f"No match for '{query}'")
            return

        def highlight_ancestors(rid):
            cur=rid
            while cur in self.parents_map:
                if cur in self.node_map:
                    self.node_map[cur].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                par=self.parents_map[cur]
                if par in self.node_map:
                    self.node_map[par].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                cur=par

        def highlight_descendants(rid):
            st=[rid]
            visited=set()
            while st:
                cc=st.pop()
                if cc in visited:
                    continue
                visited.add(cc)
                if cc in self.node_map:
                    self.node_map[cc].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                if cc in self.children_map:
                    st.extend(self.children_map[cc])

        for rid in found:
            if rid in self.node_map:
                self.node_map[rid].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                highlight_ancestors(rid)
                highlight_descendants(rid)

###############################################################################
# METRICS
###############################################################################
class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.chart=pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        ref_btn=QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS,COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        rows=get_cursor_rows(c)
        statuses=[r_["STATUS"] for r_ in rows]
        counts=[r_["sc"] for r_ in rows]
        self.chart.clear()
        if statuses:
            x=range(len(statuses))
            bar_item=pg.BarGraphItem(x=x,height=counts,width=0.6,brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(x,statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True,y=True)

###############################################################################
# CONTROL TABLES
###############################################################################
class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES","BRM_RULE_GROUPS","BRM_RULES",
            "BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG","BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS",
            "BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS","BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS",
            "BRM_RULE_APPROVALS","BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES","RULE_SNAPSHOTS",
            "RULE_TAGS","DATA_VALIDATIONS"
        ]

        self.table_combo=QComboBox()
        for t_ in self.table_list:
            self.table_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn=QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.data_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def on_load_data(self):
        tbl=self.table_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error","Failed to get columns: "+str(ex))
            return

        try:
            c.execute(f"SELECT * FROM {tbl}")
            rows=get_cursor_rows(c)
        except Exception as ex:
            QMessageBox.critical(self,"Error","Failed to get data: "+str(ex))
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)

        for rd in rows:
            r_=self.data_table.rowCount()
            self.data_table.insertRow(r_)
            for j,cn in enumerate(colnames):
                val=rd.get(cn,"")
                self.data_table.setItem(r_,j,QTableWidgetItem(str(val)))

###############################################################################
# GROUP MANAGEMENT (Admin)
###############################################################################
class GroupManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)

        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        grp_btns.addWidget(del_grp_btn)

        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        membership_box=QGroupBox("Membership Management")
        membership_layout=QVBoxLayout(membership_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btns.addWidget(add_usr_btn)
        rem_usr_btn=QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btns.addWidget(rem_usr_btn)
        memb_btns.addStretch()
        membership_layout.addLayout(memb_btns)
        gm_layout.addWidget(membership_box)
        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # Permissions
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)
        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)

        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.on_add_permission)
        ph.addWidget(addp_btn)
        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.on_remove_permission)
        ph.addWidget(remp_btn)
        ph.addStretch()
        perm_box_layout.addLayout(ph)
        perm_tab.setLayout(perm_layout)
        perm_layout.addWidget(perm_box)
        self.tabs.addTab(perm_tab,"Permissions")

        # Approvers
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btns.addWidget(add_appr_btn)
        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btns.addWidget(del_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        self.groups_table.setRowCount(0)
        for r_ in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            self.groups_table.setItem(r_i,0,QTableWidgetItem(r_["GROUP_NAME"]))
            self.groups_table.setItem(r_i,1,QTableWidgetItem(r_.get("DESCRIPTION","")))
            self.groups_table.setItem(r_i,2,QTableWidgetItem(r_.get("EMAIL","")))

    def get_selected_group(self):
        i=self.groups_table.currentRow()
        if i<0:
            return None
        it=self.groups_table.item(i,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",
                  (name.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def on_rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def on_delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group removed.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=get_cursor_rows(c)
        for r_ in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            self.users_table.setItem(r_i,0,QTableWidgetItem(str(r_["USER_ID"])))
            self.users_table.setItem(r_i,1,QTableWidgetItem(r_["USERNAME"]))
            self.users_table.setItem(r_i,2,QTableWidgetItem(r_["USER_GROUP"]))

    def get_selected_user(self):
        i=self.users_table.currentRow()
        if i<0:
            return None
        it=self.users_table.item(i,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group does not exist.")
            return
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        rowu=get_cursor_one(c)
        if not rowu:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if rowu["USER_GROUP"]==grp.strip():
            QMessageBox.warning(self,"Error","User is already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user from group => user moves to BG1.")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def load_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        self.perm_group_combo.clear()
        for r_ in rows:
            self.perm_group_combo.addItem(r_["GROUP_NAME"],r_["GROUP_NAME"])

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=get_cursor_rows(c)
        self.perm_table.setRowCount(0)
        for r_ in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(r_["TARGET_TABLE"]))

    def on_add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        table,ok=QInputDialog.getText(self,"Add Permission","Table name:")
        if not ok or not table.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),table.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def on_remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","No group selected.")
            return
        row=self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        table_name=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{table_name}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(),table_name))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    def load_appr_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        self.appr_group_combo.clear()
        for r_ in rows:
            self.appr_group_combo.addItem(r_["GROUP_NAME"],r_["GROUP_NAME"])

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=get_cursor_rows(c)
        self.appr_table.setRowCount(0)
        for r_ in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(r_["APPROVER_ID"])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(r_["USERNAME"]))

    def on_add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        usern,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(),usern.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver '{usern}' added to {grp}.")
        self.load_approvers()

    def on_remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        app_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver ID={app_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(app_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

###############################################################################
# USER MANAGEMENT
###############################################################################
class UserManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["User ID","Username","Password","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.on_add_user)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.on_delete_user)
        bh.addWidget(del_btn)
        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.on_change_password)
        bh.addWidget(pass_btn)
        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)
        self.setLayout(layout)

        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=get_cursor_rows(c)
        for r_ in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            self.user_table.setItem(r_i,0,QTableWidgetItem(str(r_["USER_ID"])))
            self.user_table.setItem(r_i,1,QTableWidgetItem(r_["USERNAME"]))
            self.user_table.setItem(r_i,2,QTableWidgetItem(r_["PASSWORD"]))
            self.user_table.setItem(r_i,3,QTableWidgetItem(r_["USER_GROUP"]))

    def get_selected_user_id(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user(self):
        name,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not name.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(name.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","User added.")
        self.load_users()

    def on_delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","User removed.")
        self.load_users()

    def on_change_password(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Password changed.")
        self.load_users()

###############################################################################
# CUSTOM RULE GROUPS
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Custom Group / Rule"])
        self.tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=get_cursor_rows(c)
        for g_ in groups:
            disp=f"{g_['CUSTOM_GROUP_NAME']} ({g_['OWNER_BUSINESS_GROUP']})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0,Qt.UserRole,g_["CUSTOM_GROUP_ID"])
            g_item.setBackground(0,QtGui.QBrush(QtGui.QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(g_["CUSTOM_GROUP_ID"],))
            assigned=get_cursor_rows(c2)
            for rr in assigned:
                txt=f"Rule {rr['RULE_ID']}: {rr['RULE_NAME']}"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0,Qt.UserRole, rr["RULE_ID"])
                if rr["IS_GLOBAL"]==1:
                    rr_item.setBackground(0,QtGui.QBrush(QtGui.QColor("lightblue")))
                if rr["CRITICAL_RULE"]==1:
                    rr_item.setBackground(0,QtGui.QBrush(QtGui.QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        rows=get_cursor_rows(c)

        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set(x["RULE_ID"] for x in get_cursor_rows(c2))

        for r_ in rows:
            if r_["RULE_ID"] in assigned:
                continue
            disp=f"Rule {r_['RULE_ID']}: {r_['RULE_NAME']} (Owner {r_['OWNER_GROUP']})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,r_["RULE_ID"])
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent_item=item.parent()
        if parent_item:
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent_item.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id,rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} from group {group_id}.")
                self.refresh_all()

    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name entered.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return None,None
        item=sel[0]
        par=item.parent()
        if par:
            item=par
        gid=item.data(0,Qt.UserRole)
        disp=item.text(0)
        return gid,disp

    def rename_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        rowg=get_cursor_one(c)
        if not rowg:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname=rowg["CUSTOM_GROUP_NAME"]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[x["RULE_ID"] for x in get_cursor_rows(c)]
        backup_data={"group_name":grpname,"members":assigned}
        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 AS new_ver
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1
        import json
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON)
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=get_cursor_rows(c)
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {x['BACKUP_VERSION']} (ts {x['BACKUP_TIMESTAMP']})" for x in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return
        import re
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        ver=int(m.group(1))
        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return
        backup_json=None
        for r_ in rows:
            if r_["BACKUP_VERSION"]==ver:
                backup_json=r_["BACKUP_JSON"]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found.")
            return
        import json
        backup_data=json.loads(backup_json)
        new_name=backup_data["group_name"]
        members=backup_data["members"]
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_name,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected in the tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return
        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()

###############################################################################
# DECISION TABLES
###############################################################################
class DecisionTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["ID","Table Name","Description"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
            rows=get_cursor_rows(c)
            for r_ in rows:
                r_i=self.table.rowCount()
                self.table.insertRow(r_i)
                self.table.setItem(r_i,0,QTableWidgetItem(str(r_["DECISION_TABLE_ID"])))
                self.table.setItem(r_i,1,QTableWidgetItem(r_["TABLE_NAME"]))
                self.table.setItem(r_i,2,QTableWidgetItem(r_["DESCRIPTION"] or ""))
        except Exception as ex:
            logger.error("Load DT: "+str(ex))

    def add_dt(self):
        name,ok=QInputDialog.getText(self,"New Decision Table","Enter table name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(name.strip(),desc.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Decision table created.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def del_dt(self):
        row=self.table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No selection.")
            return
        it=self.table.item(row,0)
        if not it:
            return
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table ID={dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Decision table removed.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# CONFLICT PRIORITY
###############################################################################
class ConflictPriorityManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.conflict_table=QTableWidget(0,4)
        self.conflict_table.setHorizontalHeaderLabels(["Conflict ID","Rule1","Rule2","Priority"])
        self.conflict_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.conflict_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Conflicts")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)
        fix_btn=QPushButton("Set Priority")
        fix_btn.clicked.connect(self.set_priority)
        bh.addWidget(fix_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.conflict_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows=get_cursor_rows(c)
            for r_ in rows:
                r_i=self.conflict_table.rowCount()
                self.conflict_table.insertRow(r_i)
                self.conflict_table.setItem(r_i,0,QTableWidgetItem(str(r_["CONFLICT_ID"])))
                self.conflict_table.setItem(r_i,1,QTableWidgetItem(str(r_["RULE_ID1"])))
                self.conflict_table.setItem(r_i,2,QTableWidgetItem(str(r_["RULE_ID2"])))
                self.conflict_table.setItem(r_i,3,QTableWidgetItem(str(r_["PRIORITY"])))
        except Exception as ex:
            logger.error("Load Conflicts: "+str(ex))

    def set_priority(self):
        row=self.conflict_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        it=self.conflict_table.item(row,0)
        if not it:
            return
        c_id=int(it.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority","Priority (lower=stronger)?",1,1,1000)
        if not ok:
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,c_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated","Priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# COMPOSITE RULES
###############################################################################
class CompositeRulesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CompositeRule ID","Name","Logic","ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_composite)
        bh.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_composites)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
            rows=get_cursor_rows(c)
            for r_ in rows:
                r_i=self.cr_table.rowCount()
                self.cr_table.insertRow(r_i)
                self.cr_table.setItem(r_i,0,QTableWidgetItem(str(r_["COMPOSITE_RULE_ID"])))
                self.cr_table.setItem(r_i,1,QTableWidgetItem(r_["CRULE_NAME"]))
                self.cr_table.setItem(r_i,2,QTableWidgetItem(r_["LOGIC_EXPR"]))
                self.cr_table.setItem(r_i,3,QTableWidgetItem(r_["ACTION_ON_PASS"] or ""))
        except Exception as ex:
            logger.error("Load Composite Rules: "+str(ex))

    def add_composite(self):
        name,ok=QInputDialog.getText(self,"New Composite","Name:")
        if not ok or not name.strip():
            return
        logic,ok2=QInputDialog.getText(self,"Logic Expression","e.g. Rule(101) AND Rule(102)")
        if not ok2:
            logic=""
        action,ok3=QInputDialog.getText(self,"Action on Pass","e.g. 'SendEmail' or 'ChainNext'")
        if not ok3:
            action=""
        c=self.connection.cursor()
        try:
            c.execute("""
            INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
            VALUES(?,?,?)
            """,(name.strip(),logic.strip(),action.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Composite rule created.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def del_composite(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        if not it:
            return
        cid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Composite rule removed.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# SNAPSHOT MANAGER
###############################################################################
class SnapshotManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.snap_table=QTableWidget(0,4)
        self.snap_table.setHorizontalHeaderLabels(["Snapshot ID","Snapshot Name","Created By","Timestamp"])
        self.snap_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.snap_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)
        cmp_btn=QPushButton("Compare Snapshots")
        cmp_btn.clicked.connect(self.compare_snapshots)
        bh.addWidget(cmp_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snaps)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_snaps()

    def load_snaps(self):
        self.snap_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
            rows=get_cursor_rows(c)
            for r_ in rows:
                r_i=self.snap_table.rowCount()
                self.snap_table.insertRow(r_i)
                self.snap_table.setItem(r_i,0,QTableWidgetItem(str(r_["SNAPSHOT_ID"])))
                self.snap_table.setItem(r_i,1,QTableWidgetItem(r_["SNAPSHOT_NAME"]))
                self.snap_table.setItem(r_i,2,QTableWidgetItem(r_["CREATED_BY"]))
                self.snap_table.setItem(r_i,3,QTableWidgetItem(str(r_["CREATED_TIMESTAMP"])))
        except Exception as ex:
            logger.error("Load Snapshots: "+str(ex))

    def take_snapshot(self):
        name,ok=QInputDialog.getText(self,"Snapshot Name","Enter name:")
        if not ok or not name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES")
            rows=get_cursor_rows(c)
            import json
            snap_json=json.dumps(rows)
            user="SnapshotTaker"
            c.execute("""
            INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON)
            VALUES(?,?,GETDATE(),?)
            """,(name.strip(), user, snap_json))
            self.connection.commit()
            QMessageBox.information(self,"Snapshot","Snapshot created.")
            self.load_snaps()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def compare_snapshots(self):
        idxs=self.snap_table.selectionModel().selectedRows()
        if len(idxs)!=2:
            QMessageBox.warning(self,"Need 2","Select exactly two snapshots.")
            return
        c=self.connection.cursor()
        row_ids=[]
        for i in idxs:
            row=i.row()
            it=self.snap_table.item(row,0)
            row_ids.append(int(it.text()))

        def get_json(snap_id):
            c2=self.connection.cursor()
            c2.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(snap_id,))
            ro=get_cursor_one(c2)
            if ro:
                return ro["SNAPSHOT_JSON"]
            return None

        snap1=get_json(row_ids[0])
        snap2=get_json(row_ids[1])
        if not snap1 or not snap2:
            QMessageBox.warning(self,"Missing Data","One snapshot missing JSON.")
            return
        import json
        data1=json.loads(snap1)
        data2=json.loads(snap2)
        c1=len(data1)
        c2=len(data2)
        msg=f"Snapshot {row_ids[0]} has {c1} records.\nSnapshot {row_ids[1]} has {c2} records."
        QMessageBox.information(self,"Compare",msg)

###############################################################################
# TAGS MANAGER
###############################################################################
class TagsManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["Tag ID","Rule ID","Tag"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)
        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
            rows=get_cursor_rows(c)
            for r_ in rows:
                r_i=self.tags_table.rowCount()
                self.tags_table.insertRow(r_i)
                self.tags_table.setItem(r_i,0,QTableWidgetItem(str(r_["TAG_ID"])))
                self.tags_table.setItem(r_i,1,QTableWidgetItem(str(r_["RULE_ID"])))
                self.tags_table.setItem(r_i,2,QTableWidgetItem(r_["TAG_NAME"]))
        except Exception as ex:
            logger.error("Load Tags: "+str(ex))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID?")
        if not ok:
            return
        tg,ok2=QInputDialog.getText(self,"Tag Name","(e.g. 'Credit','Market')")
        if not ok2 or not tg.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tg.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Tag assigned.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        if not it:
            return
        t_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {t_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(t_id,))
            self.connection.commit()
            QMessageBox.information(self,"Removed","Tag removed.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# DATA VALIDATION
###############################################################################
class DataValidationTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["Validation ID","Table","Column","Type","Params"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Delete Validation")
        del_btn.clicked.connect(self.del_val)
        bh.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("""
            SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
            FROM DATA_VALIDATIONS
            ORDER BY VALIDATION_ID
            """)
            rows=get_cursor_rows(c)
            for r_ in rows:
                r_i=self.dv_table.rowCount()
                self.dv_table.insertRow(r_i)
                self.dv_table.setItem(r_i,0,QTableWidgetItem(str(r_["VALIDATION_ID"])))
                self.dv_table.setItem(r_i,1,QTableWidgetItem(r_["TABLE_NAME"]))
                self.dv_table.setItem(r_i,2,QTableWidgetItem(r_["COLUMN_NAME"]))
                self.dv_table.setItem(r_i,3,QTableWidgetItem(r_["VALIDATION_TYPE"]))
                self.dv_table.setItem(r_i,4,QTableWidgetItem(r_["PARAMS"] or ""))
        except Exception as ex:
            logger.error("Load Data Validations: "+str(ex))

    def add_val(self):
        t_name,ok=QInputDialog.getText(self,"New Validation","Table name:")
        if not ok or not t_name.strip():
            return
        c_name,ok2=QInputDialog.getText(self,"Column name","Enter column:")
        if not ok2 or not c_name.strip():
            return
        vtype,ok3=QInputDialog.getItem(self,"Validation Type","Pick type:",["Range","Regex","NotNull","Enum"],0,False)
        if not ok3:
            return
        params,ok4=QInputDialog.getText(self,"Params","(Could be JSON or param list):")
        if not ok4:
            params=""
        c=self.connection.cursor()
        try:
            c.execute("""
            INSERT INTO DATA_VALIDATIONS(TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS)
            VALUES(?,?,?,?)
            """,(t_name.strip(),c_name.strip(),vtype,params.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Validation rule added.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def del_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        v_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete validation {v_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(v_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Validation removed.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# SCHEDULE MANAGEMENT
###############################################################################
class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.schedule_table=QTableWidget(0,4)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID","Rule ID","Schedule Time","Status"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=get_cursor_rows(c)
        self.schedule_table.setRowCount(0)
        for r_ in rows:
            r_i=self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            self.schedule_table.setItem(r_i,0,QTableWidgetItem(str(r_["SCHEDULE_ID"])))
            self.schedule_table.setItem(r_i,1,QTableWidgetItem(str(r_["RULE_ID"])))
            self.schedule_table.setItem(r_i,2,QTableWidgetItem(str(r_["SCHEDULE_TIME"])))
            self.schedule_table.setItem(r_i,3,QTableWidgetItem(r_["STATUS"]))

###############################################################################
# AUDIT LOG VIEWER & RULE SEARCH
###############################################################################
class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs - Full DML")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search action/table/actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table=QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels([
            "Audit ID","Action","Table","Record ID","Action By","Old Data","New Data","Timestamp"
        ])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.audit_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.audit_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)
        exp_btn=QPushButton("Export to CSV")
        exp_btn.clicked.connect(self.export_csv)
        bh.addWidget(exp_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=get_cursor_rows(c)
        self.audit_table.setRowCount(0)
        for row in rows:
            r_=self.audit_table.rowCount()
            self.audit_table.insertRow(r_)
            self.audit_table.setItem(r_,0,QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r_,1,QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r_,2,QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r_,3,QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r_,4,QTableWidgetItem(row["ACTION_BY"]))
            oldtxt=""
            if row["OLD_DATA"]:
                try:
                    p=json.loads(row["OLD_DATA"])
                    oldtxt=json.dumps(p,indent=2)
                except:
                    oldtxt=row["OLD_DATA"]
            self.audit_table.setItem(r_,5,QTableWidgetItem(oldtxt))
            newtxt=""
            if row["NEW_DATA"]:
                try:
                    p2=json.loads(row["NEW_DATA"])
                    newtxt=json.dumps(p2,indent=2)
                except:
                    newtxt=row["NEW_DATA"]
            self.audit_table.setItem(r_,6,QTableWidgetItem(newtxt))
            self.audit_table.setItem(r_,7,QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))

    def perform_search(self, text):
        txt_l=text.lower()
        for row in range(self.audit_table.rowCount()):
            show=False
            for col in (1,2,4):
                it=self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    show=True
                    break
            self.audit_table.setRowHidden(row, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Save CSV","","CSV Files (*.csv)")
        if not path:
            return
        import csv
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row):
                    continue
                rowdata=[]
                for col in range(self.audit_table.columnCount()):
                    it=self.audit_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported","Audit logs exported.")

class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules - Full DML")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.res_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.res_table)

        rb=QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        layout.addWidget(rb)
        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        c=self.connection.cursor()
        txt=self.search_edit.text().strip()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r_=self.res_table.rowCount()
            self.res_table.insertRow(r_)
            self.res_table.setItem(r_,0,QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r_,1,QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r_,2,QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r_,3,QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r_,4,QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r_,5,QTableWidgetItem(row["CREATED_BY"]))

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Fully Integrated with DML")
        self.resize(1300,850)
        self.connection=None

        # DB Connection
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection=dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Login
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        c=self.connection.cursor()
        c.execute("SELECT USERNAME,USER_GROUP FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if not row:
            sys.exit(0)
        self.logged_in_username=row[0]
        self.user_group=row[1]

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        syncAct=QtWidgets.QAction("Sync Metadata",self)
        syncAct.triggered.connect(self.sync_metadata_stub)
        fileMenu.addAction(syncAct)

        metricsAct=QtWidgets.QAction("View Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        schedAct=QtWidgets.QAction("Enhanced Scheduling",self)
        schedAct.triggered.connect(self.launch_enh_sched)
        fileMenu.addAction(schedAct)

        chainAct=QtWidgets.QAction("Simulate Rule Chain",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        grpAct=QtWidgets.QAction("Simulate Custom Group",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        helpMenu=menubar.addMenu("Help")
        usageAct=QtWidgets.QAction("Show Tips",self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        cw=QWidget()
        layout=QVBoxLayout(cw)

        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # Business Rules Tab
        brw=QWidget()
        br_lay=QVBoxLayout(brw)

        cr_h=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        cr_h.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        cr_h.addWidget(upd_btn)

        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.on_deactivate_rule)
        cr_h.addWidget(deact_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.on_delete_rule)
        cr_h.addWidget(del_btn)

        etl_btn=QPushButton("Run ETL (BFS)")
        etl_btn.clicked.connect(self.run_etl_bfs)
        cr_h.addWidget(etl_btn)

        sim_btn=QPushButton("Simulate Rule")
        sim_btn.clicked.connect(self.simulate_single_rule)
        cr_h.addWidget(sim_btn)

        cr_h.addStretch()
        br_lay.addLayout(cr_h)

        self.brm_dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_lay.addWidget(self.brm_dashboard)
        brw.setLayout(br_lay)
        self.tabs.addTab(brw,"Business Rules")

        # Approvals
        self.approv_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # Global/Critical Admin
        if self.user_group=="Admin":
            self.gcr_tab=GlobalCriticalAdminTab(self,self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # Hierarchy
        self.hierarchy=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy,"Hierarchy")

        # Lineage
        lin_w=QWidget()
        lin_l=QVBoxLayout(lin_w)
        lb=QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lin_l.addWidget(lb)
        self.lineage_tab=EnhancedLineageGraphWidget(self.connection)
        lin_l.addWidget(self.lineage_tab)
        line_h=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table..")
        sbtn=QPushButton("Search")
        sbtn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rb=QPushButton("Reset View")
        rb.clicked.connect(self.lineage_tab.resetView)
        refb=QPushButton("Refresh Graph")
        refb.clicked.connect(self.lineage_tab.populate_graph)
        line_h.addWidget(self.lineage_search)
        line_h.addWidget(sbtn)
        line_h.addWidget(rb)
        line_h.addWidget(refb)
        line_h.addStretch()
        lin_l.addLayout(line_h)
        lin_w.setLayout(lin_l)
        self.tabs.addTab(lin_w,"Lineage")

        # Custom Groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # Scheduling
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # Control Tables
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # Metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # Alerts & Dashboards
        self.alert_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Dashboards")

        # Group mgmt
        self.grp_mgmt=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt,"Group Management")

        # User mgmt
        if self.user_group=="Admin":
            self.user_mgmt=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt,"User Management")

        # Tools menu
        toolsMenu=menubar.addMenu("Tools")
        alAct=QtWidgets.QAction("View Audit Logs",self)
        alAct.triggered.connect(self.launch_audit_log)
        toolsMenu.addAction(alAct)

        srAct=QtWidgets.QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_search)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (Enter Rule ID)",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        # Advanced menu
        advMenu=menubar.addMenu("Advanced")
        self.decision_tab=DecisionTablesTab(self.connection)
        self.conflict_tab=ConflictPriorityManagerTab(self.connection)
        self.composite_tab=CompositeRulesTab(self.connection)
        self.snap_tab=SnapshotManagerTab(self.connection)
        self.tags_tab=TagsManagerTab(self.connection)
        self.dv_tab=DataValidationTab(self.connection)

        advMenu.addAction("Open Decision Tables",lambda: self.tabs.addTab(self.decision_tab,"Decision Tables"))
        advMenu.addAction("Open Conflict Priority",lambda: self.tabs.addTab(self.conflict_tab,"Conflict Priority"))
        advMenu.addAction("Open Composite Rules",lambda: self.tabs.addTab(self.composite_tab,"Composite Rules"))
        advMenu.addAction("Open Snapshot Manager",lambda: self.tabs.addTab(self.snap_tab,"Snapshots"))
        advMenu.addAction("Open Tags Manager",lambda: self.tabs.addTab(self.tags_tab,"Tags Manager"))
        advMenu.addAction("Open Data Validation",lambda: self.tabs.addTab(self.dv_tab,"Data Validation"))

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

        self.show()

    def sync_metadata_stub(self):
        QMessageBox.information(self,"Sync","Metadata sync stub invoked.")

    def show_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800,600)
        lay=QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection)
        lay.addWidget(chart)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        lay.addWidget(cb)
        dlg.exec_()

    def launch_enh_sched(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()

    def launch_chain_sim(self):
        dlg=ChainSimulationDialog(self.connection,self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=GroupSimulationDialog(self.connection,self)
        dlg.exec_()

    def show_help(self):
        msg=(
            "All functionalities integrated, including BFS for DML with per-rule transactions.\n"
            "Insert/Update/Delete rules store OPERATION_TYPE + 'WRITE' columns. Dry-run uses ROLLBACK.\n"
            "Check out tabs for Approvals, GC Admin, Custom Groups, Scheduling, etc.\n"
            "Advanced has Decision Tables, Conflicts, Composite, Snapshots, Tags, Data Validation.\n"
        )
        QMessageBox.information(self,"Help/Tips",msg)

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        new_uid,new_grp=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        QMessageBox.information(self,"Switched",f"Impersonating user {new_uid}, group={new_grp}.")

    def populate_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for r_ in rows:
            disp=f"{r_[1]} ({r_[2]})"
            self.switch_combo.addItem(disp,(r_[0],r_[2]))

    def on_add_rule(self):
        QMessageBox.information(self,"Add Rule","Implement your Add Rule UI; call add_rule() under the hood.")
        self.brm_dashboard.load_rules()

    def on_update_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid=rids[0]
        QMessageBox.information(self,"Update Rule",f"Implement your Update Rule UI for rule {rid}, then call update_rule().")
        self.brm_dashboard.load_rules()

    def on_deactivate_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rr in rids:
            try:
                deactivate_rule(self.connection,rr,self.user_group,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivation done. success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def on_delete_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                delete_rule(self.connection,rid,self.user_group,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deletion done. success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_etl_bfs(self):
        executed,skipped=execute_rules_in_order(self.connection)
        msg=f"Run ETL BFS => executed={executed}, skipped={list(skipped)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def simulate_single_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly one rule to simulate.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","No rule found.")
            return
        sql_=row[0]
        dlg=SingleRuleSimulationDialog(self.connection,rid,sql_,self)
        dlg.exec_()

    def launch_audit_log(self):
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_search(self):
        dlg=SearchRuleDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection,rid,self)
        dlg.exec_()

    def check_due_schedules(self):
        c=self.connection.cursor()
        now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
        """,(now,))
        due=get_cursor_rows(c)
        for item in due:
            rid=item["RULE_ID"]
            c2=self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute(f"{' '.join(item['SCHEDULE_TIME'].split())}")  # Not real. Example only?
                # Actually we'd do: c2.execute the rule SQL from BRM_RULES
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                row=c2.fetchone()
                if row:
                    try:
                        c2.execute(row[0])
                    except Exception as ex:
                        logger.error(f"Scheduled rule {rid} => FAIL: {ex}")
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(item["SCHEDULE_ID"],))
                        continue
                c2.execute("COMMIT")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(item["SCHEDULE_ID"],))
            except Exception as ex:
                logger.error("Scheduled exec error: "+str(ex))
            self.connection.commit()
        self.sch_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# MAIN
###############################################################################
def main():
    app=QApplication(sys.argv)
    app.setStyle("Fusion")
    w=BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()