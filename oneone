#!/usr/bin/env python
"""
BRM TOOL – ENHANCED PART 1
Core imports, logging, email config, DB connection, login, advanced SQL + column parsing, etc.
No placeholders or references to “old code.” Fully supports column extraction for BRM_COLUMN_MAPPING.
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
from datetime import datetime
from collections import deque
from email.mime.text import MIMEText

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog
)

###############################################################################
# LOGGING
###############################################################################
logging.basicConfig(
    filename='brm_tool_enhanced.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# EMAIL CONFIG
###############################################################################
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Sends an email via SMTP to 'recipients' using EMAIL_CONFIG.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Allows the user to pick an ODBC DSN (SQL Server) or enter a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection - Enhanced Part 1")
        self.resize(400, 200)
        
        layout = QVBoxLayout(self)
        lbl = QLabel("Select a SQL Server ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)
        
        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)
        
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        layout.addWidget(self.conn_str_edit)
        
        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cb = QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cb)
        layout.addLayout(bh)

    def get_connection(self):
        """
        Returns a pyodbc connection or None if there's an error or no selection.
        """
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

###############################################################################
# DB HELPERS
###############################################################################
def get_cursor_rows(cursor):
    """
    Safely fetches all rows from a cursor, returning a list of dicts if column info is present.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    return rows

def get_cursor_one(cursor):
    """
    Fetches one row from a cursor, returning a dict if column info is present.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return None

def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Inserts an audit record into BRM_AUDIT_LOG.
    """
    import json
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG (
        ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """,
    (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# LOGIN
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Simple username/password prompt with minimal validation.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        
        self.setWindowTitle("Login - Enhanced Part 1")
        self.resize(300, 150)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        """
        Performs the login check with the USERS table.
        """
        username = self.user_edit.text().strip()
        password = self.pass_edit.text().strip()
        if not username or not password:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (username, password))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Failed", "Invalid credentials.")

###############################################################################
# DETECT OPERATION TYPE
###############################################################################
def detect_operation_type(sql_text: str) -> str:
    """
    Returns one of "INSERT", "UPDATE", "DELETE", "SELECT", or "OTHER" 
    based on the first word in the SQL text.
    """
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

###############################################################################
# ADVANCED SQL PARSER (TABLE + COLUMN EXTRACTION)
###############################################################################
def enhanced_advanced_extract_tables(sql_text: str):
    """
    Parses the SQL text and returns a dict with:
      "tables":     list of (schema, table, alias, is_subselect)
      "cte_tables": list of (cte_name, list_of_references)
      "alias_map":  mapping from alias -> (schema, table)
      "columns":    list of (col_name, is_dml_target, in_select_list)

    This is a fairly advanced parser using sqlparse. 
    It attempts to identify:
     - Regular table references (with optional schema)
     - CTE references
     - Columns used in SELECT or DML statements
    """
    statements = sqlparse.parse(sql_text)
    final_tables = []
    cte_info = []
    alias_map = {}
    column_list = []  # (column_name, is_dml_target, in_select_list)

    for stmt in statements:
        # Check WITH clauses
        cte_dict = _extract_with_clauses(stmt)
        for cte_name, refs in cte_dict.items():
            cte_info.append((cte_name, refs))

        # Identify main FROM references
        main_refs, main_alias = _extract_main_from(stmt.tokens, set(cte_dict.keys()))
        final_tables.extend(main_refs)
        alias_map.update(main_alias)

        # Attempt to parse columns (from SELECT or DML)
        col_refs = _extract_columns(stmt)
        column_list.extend(col_refs)

    final_tables = list({x for x in final_tables})  # ensure uniqueness
    return {
        "tables": final_tables,
        "cte_tables": list(cte_info),
        "alias_map": alias_map,
        "columns": column_list
    }

def _extract_with_clauses(statement):
    """
    Gathers all WITH cte_name => subselect references.
    Returns a dict mapping cte_name -> list_of_table_refs.
    """
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    """
    Parses something like WITH cte1 AS (SELECT ...), cte2 AS (SELECT ...).
    """
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, sqlparse.sql.Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        val = tk.value.upper() if tk.ttype else ""
        if val == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, sqlparse.sql.Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens(tokens):
    """
    Recursively finds table references within subselects (FROM/JOIN).
    """
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2 = _extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is sqlparse.tokens.Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False

        if from_seen:
            if isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, set())
                    st = (st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, sqlparse.sql.Identifier):
                st = _parse_identifier(tk, set())
                st = (st[0], st[1], st[2], True)
                results.append(st)
        i += 1
    return results

def _is_subselect(token):
    """
    Returns True if the token is a group that contains a SELECT DML.
    """
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is sqlparse.tokens.DML and sub.value.upper() == "SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    """
    Finds table references after FROM/JOIN keywords in the main statement.
    """
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2 = _extract_subselect_tokens(tk.tokens)
            results.extend(sub2)

        if tk.ttype is sqlparse.tokens.Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False

        if from_seen:
            if isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, known_cte_names)
                    results.append(st)
                    al = st[2]
                    if al:
                        alias_map[al] = (st[0], st[1])
            elif isinstance(tk, sqlparse.sql.Identifier):
                st = _parse_identifier(tk, known_cte_names)
                results.append(st)
                al = st[2]
                if al:
                    alias_map[al] = (st[0], st[1])
        i += 1
    return (results, alias_map)

def _parse_identifier(ident, known_cte_names):
    """
    Parse an identifier => (schema, real_name, alias, is_subselect).
    If real_name is in known_cte_names => it's a CTE reference.
    """
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema_name = ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    """
    Attempts to extract columns from:
      - SELECT list
      - DML target columns (INSERT or UPDATE)
    Returns a list of (column_name, is_dml_target:bool, in_select_list:bool).
    """
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.DML:
            dml_word = tk.value.upper()
            if dml_word == "SELECT":
                # parse next tokens for SELECT columns until FROM or other keyword
                col_refs = _parse_select_list(tokens, i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif dml_word in ("INSERT","UPDATE"):
                col_refs2 = _parse_dml_columns(tokens, i, dml_word)
                for c_ in col_refs2:
                    results.append((c_, True, False))
        i += 1
    return results

def _parse_select_list(tokens, start_idx):
    """
    Gathers column names from SELECT list until we hit FROM or another major keyword.
    """
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, sqlparse.sql.IdentifierList):
            for ident in tk.get_identifiers():
                colnm = ident.get_name()
                if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(colnm)
        elif isinstance(tk, sqlparse.sql.Identifier):
            colnm = tk.get_name()
            if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(colnm)
        i += 1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    """
    For INSERT: columns in parentheses after the table name
      e.g. INSERT INTO table (col1, col2) ...
    For UPDATE: columns in the SET clause
    """
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, sqlparse.sql.Parenthesis):
                for subtoken in tk.tokens:
                    if isinstance(subtoken, sqlparse.sql.IdentifierList):
                        for ident in subtoken.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(subtoken, sqlparse.sql.Identifier):
                        columns.append(subtoken.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return columns

def _parse_update_set_list(tokens, start_i):
    """
    After 'SET col1=..., col2=..., ...', gather column names.
    """
    columns = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, sqlparse.sql.Identifier):
            columns.append(tk.get_name())
        i += 1
    return columns

# End of Enhanced Part 1
#!/usr/bin/env python
"""
BRM TOOL – PART 2 of 5
BFS rule execution, multi-step approvals, advanced update logic,
and BFS child owners => re-approval triggers.
Fully implemented with no placeholders or references to old code.
"""

import json
from datetime import datetime
from collections import deque

# We assume Part 1 (part1.py) provides these functions:
#   enhanced_advanced_extract_tables(sql_text)
#   detect_operation_type(sql_text)
#   add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data)
from part1 import enhanced_advanced_extract_tables, detect_operation_type, add_audit_log

###############################################################################
# BFS RULE EXEC + STATS
###############################################################################
def build_rule_adjacency(conn):
    """
    Builds an adjacency map for rules by reading (RULE_ID, PARENT_RULE_ID) from BRM_RULES.
    Returns:
      children_map => dict of parent_rule_id -> list of child_rule_ids
      roots        => list of rule_ids that have no parent
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    children_map = {}
    all_ids = set()
    parent_ids = set()

    for row in rows:
        rule_id = row[0]
        parent_id = row[1]
        all_ids.add(rule_id)
        if parent_id:
            parent_ids.add(parent_id)
            children_map.setdefault(parent_id, []).append(rule_id)

    roots = [x for x in all_ids if x not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    """
    Loads the global/critical link edges from BRM_GLOBAL_CRITICAL_LINKS.
    Returns a dict: gcr_rule_id -> set of target_rule_ids
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = c.fetchall()
    link_map = {}
    for row in rows:
        parent_gcr = row[0]
        child = row[1]
        link_map.setdefault(parent_gcr, set()).add(child)
    return link_map

def get_all_rules_as_dict(conn):
    """
    Returns all rules from BRM_RULES as a dict of rule_id -> rule_record (as a dict).
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    cols = [desc[0] for desc in c.description]
    result = {}
    for r in rows:
        d = dict(zip(cols, r))
        result[d["RULE_ID"]] = d
    return result

def skip_descendants(child_id, children_map, skipped):
    """
    BFS skipping: used to mark all descendants (children, children-of-children, etc.)
    so they won't get executed when a critical rule fails.
    """
    stack = [child_id]
    while stack:
        current = stack.pop()
        if current in skipped:
            continue
        skipped.add(current)
        if current in children_map:
            stack.extend(children_map[current])

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Inserts a record into RULE_EXECUTION_LOGS to track the outcome of a BFS rule execution pass.
    """
    c = conn.cursor()
    c.execute("""
        INSERT INTO RULE_EXECUTION_LOGS(
            RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
        ) VALUES (?, GETDATE(), ?, ?, ?)
    """, (rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()

def execute_rules_in_order(conn):
    """
    Performs BFS-based rule execution:
      - If a rule is CRITICAL or GLOBAL and fails, skip all its descendants.
      - Logs each rule outcome in RULE_EXECUTION_LOGS.
    Returns (list_of_executed_ids, set_of_skipped_ids).
    """
    children_map, roots = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)

    executed = []
    skipped = set()
    c = conn.cursor()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            continue

        rule_info = rule_lookup[rid]
        sql_ = rule_info["RULE_SQL"]
        is_crit = (rule_info["CRITICAL_RULE"] == 1 or rule_info["IS_GLOBAL"] == 1)
        crit_scope = (rule_info["CRITICAL_SCOPE"] or "NONE").upper()

        c.execute("BEGIN TRANSACTION")
        success = False
        msg = ""
        record_count = 0
        try:
            c.execute(sql_)
            rows = c.fetchall()
            if rows:
                record_count = len(rows)
                # We assume the first row, first col => 1 means pass
                val = rows[0][0]
                success = (val == 1)
                msg = f"Returned: {val}"
            else:
                success = True
                msg = "No rows => PASS"
            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success = False
            msg = str(ex)

        insert_rule_execution_log(conn, rid, success, msg, record_count)

        if success:
            executed.append(rid)
            if rid in children_map:
                for ch_ in children_map[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # If it's critical => skip BFS children
            if is_crit and crit_scope != "NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                # Also skip GCR-linked children
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    return executed, skipped

###############################################################################
# BFS FOR CHILD RULES
###############################################################################
def get_child_rules_bfs(conn, start_rule_id):
    """
    Returns all child (descendant) rule IDs via BFS, including global-critical links.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    allrows = c.fetchall()

    children_map = {}
    for row in allrows:
        rid, pid = row
        if pid:
            children_map.setdefault(pid, []).append(rid)

    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    glinks = c.fetchall()
    gl_map = {}
    for row in glinks:
        gcr, child_ = row
        gl_map.setdefault(gcr, []).append(child_)

    visited = set()
    queue = [start_rule_id]
    results = set()
    while queue:
        cur = queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in children_map:
            for ch in children_map[cur]:
                results.add(ch)
                queue.append(ch)
        if cur in gl_map:
            for ch2 in gl_map[cur]:
                results.add(ch2)
                queue.append(ch2)
    return results

###############################################################################
# MULTI-STEP APPROVAL CREATION
###############################################################################
def create_multistep_approvals(conn, rule_id):
    """
    Creates multi-step approvals for a rule. 
    The approach: 
      1) find impacted groups (the rule's own + BFS children owners).
      2) build pipeline from a base_order = ["BG1","BG2","BG3","FINAL"], but only 
         keep the BGs that are actually impacted. "FINAL" is always included.
      3) Insert rows into BRM_RULE_APPROVALS for each stage.
    """
    impacted = find_impacted_business_groups(conn, rule_id)
    base_order = ["BG1", "BG2", "BG3", "FINAL"]

    c = conn.cursor()
    # Remove old approvals if any
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID = ?", (rule_id,))

    stage_counter = 1
    pipeline = []

    # Build final pipeline 
    for stage_group in base_order:
        if stage_group == "FINAL":
            pipeline.append(stage_group)
        else:
            if stage_group in impacted:
                pipeline.append(stage_group)

    # Insert approvals in order
    for grp_ in pipeline:
        if grp_ == "FINAL":
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                  APPROVED_TIMESTAMP, APPROVAL_STAGE, ACTION_TYPE
                )
                VALUES(?,?,?,?,NULL,?, 'CREATE_OR_UPDATE')
            """, (rule_id, "FINAL", "final_approver", 0, stage_counter))
            stage_counter += 1
        else:
            # Insert for each group approver
            c2 = conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME = ?", (grp_,))
            approvers = c2.fetchall()
            for row in approvers:
                usern = row[0]
                c.execute("""
                    INSERT INTO BRM_RULE_APPROVALS(
                      RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                      APPROVED_TIMESTAMP, APPROVAL_STAGE, ACTION_TYPE
                    ) VALUES(?,?,?,?,NULL,?, 'CREATE_OR_UPDATE')
                """, (rule_id, grp_, usern, 0, stage_counter))
            stage_counter += 1

    conn.commit()

###############################################################################
# FIND IMPACTED BUSINESS GROUPS
###############################################################################
def find_impacted_business_groups(conn, rule_id):
    """
    Gathers the set of business groups impacted by a rule:
      1) The rule's own owner group
      2) The BFS child rules => their owner groups
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row[0])

    child_ids = get_child_rules_bfs(conn, rule_id)
    for cid in child_ids:
        c2 = conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID = ?", (cid,))
        row2 = c2.fetchone()
        if row2:
            impacted.add(row2[0])
    return impacted

###############################################################################
# RULE CRUD with Group Permissions + BFS Approvals
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    """
    Adds a new rule to BRM_RULES with advanced logic:
      - Checks for duplicates (same group + name)
      - Checks for same SQL in an existing rule
      - If is_global=1 => must be Admin
      - Runs advanced parser => ensures group has permission for each table
      - Inserts row => sets approval_status='APPROVAL_IN_PROGRESS'
      - If not global => create multi-step approvals
      - Audit log the insert
    """
    c = conn.cursor()
    # check duplicates
    c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE OWNER_GROUP = ? AND RULE_NAME = ?
    """, (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    new_sql = rule_data["RULE_SQL"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL = ?", (new_sql,))
    if c.fetchone():
        raise ValueError("Another rule with the same SQL exists. Not allowed.")

    # If rule is global => only admin can create
    if rule_data.get("IS_GLOBAL", 0) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create global rule.")

    # Determine operation type from the SQL
    op_type = detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"] = op_type

    # Enforce group permissions => parse the SQL for table references
    owner_grp = rule_data["OWNER_GROUP"]
    c.execute("""
        SELECT TARGET_TABLE
        FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME = ?
    """, (owner_grp,))
    perm_rows = c.fetchall()
    allowed_tables = set(x[0].lower() for x in perm_rows)

    parse_info = enhanced_advanced_extract_tables(new_sql)
    for (schema, tbl, alias, _) in parse_info["tables"]:
        if tbl:
            schema_part = schema if schema else "dbo"
            full_name = (f"{schema_part}.{tbl}").lower()
            if full_name not in allowed_tables:
                raise ValueError(f"Group '{owner_grp}' does not have permission for table '{full_name}'")

    # Insert rule
    row = c.execute("""
        INSERT INTO BRM_RULES(
          GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
          EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
          CREATED_BY, DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
          CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP, CLUSTER_NAME,
          APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE,
          DECISION_TABLE_ID
        )
        OUTPUT inserted.RULE_ID
        VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS","INACTIVE"),
        1,
        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),
        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE"),
        rule_data.get("DECISION_TABLE_ID")
    )).fetchone()

    if not row:
        raise ValueError("Insert failed, no RULE_ID returned.")
    new_id = row[0]

    # Insert table dependencies => for read or write
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op = "WRITE"
    else:
        col_op = "READ"

    for (sch, tb, alias, _) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES(?,?,?,?,?)
            """, (new_id, sch if sch else "N/A", tb, "DerivedCol", col_op))

    # Write audit log
    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # If not global => create multi-step approvals
    if rule_data.get("IS_GLOBAL", 0) == 0:
        create_multistep_approvals(conn, new_id)

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    """
    Updates an existing rule with BFS re-approval triggers.
      - If old rule is global => only admin can update
      - If new rule_data has IS_GLOBAL=1 => only admin can set that
      - Re-check group permissions for new SQL
      - Re-init approvals => 'APPROVAL_IN_PROGRESS' + multi-step
      - Audit log
    """
    c = conn.cursor()
    rid = rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)

    # Check duplicates if group+name changed
    new_owner = rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_name = rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()
    if (new_owner != old["OWNER_GROUP"] or new_name != old["RULE_NAME"]):
        c.execute("""
            SELECT RULE_ID 
            FROM BRM_RULES
            WHERE OWNER_GROUP=? AND RULE_NAME=?
        """, (new_owner, new_name))
        du = c.fetchone()
        if du and du[0] != rid:
            raise ValueError(f"Duplicate rule '{new_name}' in group '{new_owner}'.")

    new_sql = rule_data["RULE_SQL"].strip()
    if new_sql != old["RULE_SQL"].strip():
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL = ?", (new_sql,))
        rowx = c.fetchone()
        if rowx and rowx[0] != rid:
            raise ValueError("Another rule with that SQL exists. Not allowed.")

    # If old rule is global => only admin can update
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update global rule.")

    # If new rule_data sets is_global=1 => only admin
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set is_global=1.")

    # Operation type from the new SQL
    op_type = detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"] = op_type

    # Enforce group permissions => parse
    c.execute("""
        SELECT TARGET_TABLE
        FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME = ?
    """, (new_owner,))
    perm_rows = c.fetchall()
    allowed_tables = set(x[0].lower() for x in perm_rows)

    parse_info = enhanced_advanced_extract_tables(new_sql)
    for (schema, tbl, alias, _) in parse_info["tables"]:
        if tbl:
            schema_part = schema if schema else "dbo"
            full_name = (f"{schema_part}.{tbl}").lower()
            if full_name not in allowed_tables:
                raise ValueError(f"Group '{new_owner}' not permitted for table '{full_name}'")

    # Perform update
    c.execute("""
        UPDATE BRM_RULES
        SET
          GROUP_ID=?,
          PARENT_RULE_ID=?,
          RULE_TYPE_ID=?,
          RULE_NAME=?,
          RULE_SQL=?,
          EFFECTIVE_START_DATE=?,
          EFFECTIVE_END_DATE=?,
          STATUS='INACTIVE',
          VERSION=VERSION+1,
          UPDATED_BY=?,
          DESCRIPTION=?,
          OPERATION_TYPE=?,
          BUSINESS_JUSTIFICATION=?,
          OWNER_GROUP=?,
          CLUSTER_NAME=?,
          APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
          IS_GLOBAL=?,
          CRITICAL_RULE=?,
          CRITICAL_SCOPE=?,
          CDC_TYPE=?,
          DECISION_TABLE_ID=?
        WHERE RULE_ID=?
    """, (
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_name,
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old["BUSINESS_JUSTIFICATION"]),
        new_owner,
        rule_data.get("CLUSTER_NAME", old.get("CLUSTER_NAME","")),
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rule_data.get("DECISION_TABLE_ID", old.get("DECISION_TABLE_ID")),
        rid
    ))

    # Refresh table dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rid,))
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op = "WRITE"
    else:
        col_op = "READ"

    for (sch, tb, alias, _) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                ) VALUES(?,?,?,?,?)
            """, (rid, sch if sch else "N/A", tb, "DerivedCol", col_op))

    # Combine old/new data for audit
    new_data = dict(old_data)
    for k, v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old_data["VERSION"] + 1

    add_audit_log(conn, "UPDATE", "BRM_RULES", rid, updated_by, old_data, new_data)
    conn.commit()

    # BFS re-init approvals => incorporate BFS child owners
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 0:
        create_multistep_approvals(conn, rid)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivates a rule => sets STATUS='INACTIVE', version++, re‐approval approach:
      - rule must be fully APPROVED
      - if global => only admin can deactivate
      - no active children
      - updates & logs
      - triggers a new round of approvals for the "deactivate" action
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate a global rule.")

    # Check if any children are active
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID = ? AND STATUS='ACTIVE'", (rule_id,))
    kids = c.fetchall()
    if kids:
        raise ValueError("Deactivate child rules first.")

    old_data = dict(old)
    # Set status to inactive
    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE', UPDATED_BY=?, VERSION=VERSION+1, APPROVAL_STATUS='DEACTIVATE_IN_PROGRESS'
        WHERE RULE_ID=?
    """, (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old_data["VERSION"] + 1
    new_data["APPROVAL_STATUS"] = "DEACTIVATE_IN_PROGRESS"
    add_audit_log(conn, "DEACTIVATE_REQUEST", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

    # Create multi-step approvals for "deactivate" => insert new approvals with ACTION_TYPE='DEACTIVATE'
    # Reuse BFS child owners logic
    impacted = find_impacted_business_groups(conn, rule_id)
    base_order = ["BG1", "BG2", "BG3", "FINAL"]
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND ACTION_TYPE='DEACTIVATE'", (rule_id,))

    stage_ctr = 1
    pipeline = []
    for stg in base_order:
        if stg == "FINAL":
            pipeline.append(stg)
        else:
            if stg in impacted:
                pipeline.append(stg)

    for st_ in pipeline:
        if st_ == "FINAL":
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                  APPROVED_TIMESTAMP, APPROVAL_STAGE, ACTION_TYPE
                )
                VALUES(?,?,?,?,NULL,?, 'DEACTIVATE')
            """, (rule_id, "FINAL", "final_approver", 0, stage_ctr))
            stage_ctr += 1
        else:
            c2 = conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (st_,))
            ap_rows = c2.fetchall()
            for row_ in ap_rows:
                c.execute("""
                    INSERT INTO BRM_RULE_APPROVALS(
                      RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                      APPROVED_TIMESTAMP, APPROVAL_STAGE, ACTION_TYPE
                    )
                    VALUES(?,?,?,?,NULL,?, 'DEACTIVATE')
                """, (rule_id, st_, row_[0], 0, stage_ctr))
            stage_ctr += 1

    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Deletes a rule => physically removes it from BRM_RULES if fully approved & inactive.
      - If global => only admin can delete
      - Must be fully APPROVED, must be STATUS='INACTIVE'
      - No children
      - No references in BRM_COLUMN_MAPPING
      - Logs via audit
      - Also check if there's a 'DELETE' action_type approval in progress => if you want to 
        require the multi-step approval for deletion as well, you can do so.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")

    # Check children
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    kids = c.fetchall()
    if kids:
        raise ValueError("Child rules exist; cannot delete.")

    # Check if columns in BRM_COLUMN_MAPPING
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    leftover = c.fetchall()
    if leftover:
        raise ValueError("Re-map or remove column references first.")

    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

# End of Part 2
#!/usr/bin/env python
"""
BRM TOOL – PART 3 of 5
Single rule/chain/group simulation, improved sync_metadata, scheduling,
plus advanced feature tabs:
  • Decision tables
  • Conflict priority
  • Composite rules
  • Snapshots
  • Tags
  • Data validations

Fully implemented, no placeholders or references to old code.
"""

import json
import math
import pyodbc
import sqlparse

from datetime import datetime
from collections import deque

# PyQt5
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget, QTimeEdit
)
from PyQt5.QtCore import Qt, QDateTime, QDate, QTime
from PyQt5.QtGui import QFont

###############################################################################
# DRY-RUN
###############################################################################
def run_rule_sql_dry_run(conn, rule_sql):
    """
    Executes the given rule_sql in a transaction, then rolls back 
    so no changes are actually committed.
    Returns (success:bool, message:str)
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    try:
        c.execute(rule_sql)
        rows = c.fetchall()
        if rows:
            # We assume the first row's first col => 1 means pass
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            # If no rows => we treat it as a pass
            success = True
            msg = "No rows => PASS"
    except Exception as ex:
        success = False
        msg = str(ex)
    c.execute("ROLLBACK")
    return success, msg

###############################################################################
# SINGLE RULE SIM
###############################################################################
class SingleRuleSimulationDialog(QDialog):
    """
    Allows the user to quickly simulate a single rule's SQL 
    by performing a dry-run (1 => pass, else => fail).
    """
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.sql_text = sql_text
        self.setWindowTitle(f"Simulate Rule {rule_id}")
        self.resize(500, 300)

        layout = QVBoxLayout(self)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_sim(self):
        success, msg = run_rule_sql_dry_run(self.connection, self.sql_text)
        self.result_text.setPlainText(f"{'PASS' if success else 'FAIL'} => {msg}")

###############################################################################
# CHAIN SIM
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    Lets the user pick a parent rule from a combo box and do a BFS chain dry-run 
    (similar to the BFS used in part2, but done in memory).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Rule Chain - Dry-run")
        self.resize(500, 300)

        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.parent_rule_combo = QComboBox()

        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for row in rows:
            rid = row[0]
            rname = row[1]
            disp = f"{rid} - {rname}"
            self.parent_rule_combo.addItem(disp, rid)

        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_chain(self):
        pid = self.parent_rule_combo.currentData()
        executed, skipped = self.do_chain_sim(pid)
        txt = f"Chain from rule {pid}\nExecuted => {executed}\nSkipped => {skipped}"
        self.result_text.setPlainText(txt)

    def do_chain_sim(self, start_rule):
        """
        This does a BFS-like dry-run for the chain from 'start_rule'.
        If any rule fails => we skip its children.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rows = c.fetchall()

        rule_dict = {}
        children_map = {}
        for row in rows:
            rid = row[0]
            pid = row[1]
            sql_ = row[2]
            rule_dict[rid] = {
                "RULE_ID": rid,
                "PARENT_RULE_ID": pid,
                "RULE_SQL": sql_
            }
            if pid:
                children_map.setdefault(pid, []).append(rid)

        executed = []
        skipped = set()
        queue = [start_rule]

        while queue:
            rid = queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_dict:
                skipped.add(rid)
                continue
            sql_ = rule_dict[rid]["RULE_SQL"]
            ok, msg = run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch_ in children_map[rid]:
                        if ch_ not in skipped:
                            queue.append(ch_)
            else:
                skipped.add(rid)

        return executed, skipped

###############################################################################
# GROUP SIM
###############################################################################
class GroupSimulationDialog(QDialog):
    """
    Lets the user pick a custom group from BRM_CUSTOM_RULE_GROUPS,
    then dry-run each member rule in that group.
    If a rule fails => it's just listed as fail (we do not BFS skip).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Custom Group - Dry-run")
        self.resize(500, 300)

        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.group_combo = QComboBox()

        c = connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows = c.fetchall()
        for row in rows:
            cg_id = row[0]
            cg_name = row[1]
            disp = f"{cg_id} - {cg_name}"
            self.group_combo.addItem(disp, cg_id)

        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def sim_group(self):
        cg_id = self.group_combo.currentData()
        executed, fails = self.do_sim(cg_id)
        msg = f"Group {cg_id}\nExecuted => {executed}\nFails => {fails}"
        self.result_text.setPlainText(msg)

    def do_sim(self, custom_group_id):
        """
        For each rule in the custom group, do a dry-run. 
        If pass => add to 'executed', else => add to 'fails'.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_RULE_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
        rows = c.fetchall()
        group_rules = [x[0] for x in rows]

        c2 = self.connection.cursor()
        c2.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES")
        all_ = c2.fetchall()
        rule_map = {}
        for r_ in all_:
            rid = r_[0]
            rsql = r_[1]
            rule_map[rid] = rsql

        executed = []
        fails = []
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            sql_ = rule_map[rid]
            ok, msg = run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return executed, fails

###############################################################################
# SYNC METADATA (IMPROVED)
###############################################################################
def sync_metadata_improved(conn):
    """
    Checks sys.tables for actual schema+table pairs, 
    then scans BRM_RULE_TABLE_DEPENDENCIES => if any 'TABLE_NAME' not found => 
    prefix it with 'MISSING_'
    """
    c = conn.cursor()

    # get actual tables
    c.execute("""
        SELECT s.name AS schema_name, t.name AS table_name
        FROM sys.tables t
        JOIN sys.schemas s ON t.schema_id = s.schema_id
        ORDER BY s.name, t.name
    """)
    actual_tables = set()
    for row in c.fetchall():
        fulln = f"{row[0]}.{row[1]}".lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID, RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps = c.fetchall()
    missing = []
    updated_count = 0

    for d_ in deps:
        dep_id = d_[0]
        tbl = (d_[3] or "").strip()
        if "." not in tbl:
            candidate = f"dbo.{tbl}".lower()
        else:
            candidate = tbl.lower()

        if candidate not in actual_tables:
            missing.append(dep_id)

    for dep_id in missing:
        c.execute("""
            UPDATE BRM_RULE_TABLE_DEPENDENCIES
            SET TABLE_NAME='MISSING_' + TABLE_NAME
            WHERE DEPENDENCY_ID=?
        """, (dep_id,))
        updated_count += 1

    conn.commit()
    msg = (
        f"Metadata Sync completed.\n"
        f"Found {len(actual_tables)} real tables.\n"
        f"Scanned {len(deps)} dependencies.\n"
        f"Marked {updated_count} references as MISSING.\n"
    )
    QMessageBox.information(None, "Sync Metadata", msg)

###############################################################################
# SCHEDULING (ADD/UPDATE/DELETE)
###############################################################################
class EnhancedScheduleDialog(QDialog):
    """
    Dialog to create a new schedule (picks a rule, date, time).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling UI - Create")
        self.resize(400, 300)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for row in rows:
            rid = row[0]
            rname = row[1]
            disp = f"{rid} - {rname}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QTimeEdit(QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)
        bh = QHBoxLayout()

        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        cls_btn = QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        bh.addWidget(cls_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_ = self.calendar.selectedDate()
        time_ = self.time_edit.time()
        dt_str = f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP)
                VALUES(?, ?, 'Scheduled', GETDATE())
            """, (rid, dt_str))
            self.connection.commit()
            QMessageBox.information(self, "Scheduled", f"Rule {rid} scheduled at {dt_str}.")
            self.close()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class ScheduleManagementTab(QWidget):
    """
    A tab that shows the existing schedules in a table with Update/Delete actions,
    plus a button to create a new schedule with EnhancedScheduleDialog.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 5)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID","Rule ID","Schedule Time","Status","Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
            FROM RULE_SCHEDULES
            ORDER BY SCHEDULE_TIME DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            self.schedule_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(r_i, 2, QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(r_i, 3, QTableWidgetItem(row[3]))

            # Actions cell
            act_widget = QWidget()
            h = QHBoxLayout(act_widget)
            h.setContentsMargins(0,0,0,0)

            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rowidx=r_i: self.update_schedule(rowidx))

            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rowidx=r_i: self.delete_schedule(rowidx))

            h.addWidget(upd_btn)
            h.addWidget(del_btn)
            h.addStretch()
            self.schedule_table.setCellWidget(r_i, 4, act_widget)

        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, rowidx):
        sch_id_item = self.schedule_table.item(rowidx, 0)
        if not sch_id_item:
            return
        sch_id = int(sch_id_item.text())

        new_dt, ok = QInputDialog.getText(
            self, "Update Schedule", 
            "Enter new datetime (YYYY-MM-DD HH:mm:ss):"
        )
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME = ? WHERE SCHEDULE_ID = ?", (new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, rowidx):
        sch_id_item = self.schedule_table.item(rowidx, 0)
        if not sch_id_item:
            return
        sch_id = int(sch_id_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {sch_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sch_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Schedule {sch_id} removed.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()

###############################################################################
# ADVANCED FEATURES TABS
###############################################################################
class DecisionTablesTab(QWidget):
    """
    Simple tab to show decision tables in a QTableWidget, plus add/delete/refresh.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["Decision Table ID","Table Name","Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn = QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows = c.fetchall()
        for r_ in rows:
            rr = self.dt_table.rowCount()
            self.dt_table.insertRow(rr)
            self.dt_table.setItem(rr, 0, QTableWidgetItem(str(r_[0])))
            self.dt_table.setItem(rr, 1, QTableWidgetItem(r_[1]))
            self.dt_table.setItem(rr, 2, QTableWidgetItem(r_[2] if r_[2] else ""))

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional desc:")
        if not ok2:
            desc = ""
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES(?, ?)", (name.strip(), desc.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision table created.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def del_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        it = self.dt_table.item(row, 0)
        if not it:
            return
        dt_id = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete decision table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision table removed.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class ConflictPriorityManagerTab(QWidget):
    """
    Manages RULE_CONFLICTS table: each record has conflict_id, rule1, rule2, priority.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["Conflict ID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        setp_btn = QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        rows = c.fetchall()
        for row in rows:
            rr = self.cf_table.rowCount()
            self.cf_table.insertRow(rr)
            self.cf_table.setItem(rr, 0, QTableWidgetItem(str(row[0])))
            self.cf_table.setItem(rr, 1, QTableWidgetItem(str(row[1])))
            self.cf_table.setItem(rr, 2, QTableWidgetItem(str(row[2])))
            self.cf_table.setItem(rr, 3, QTableWidgetItem(str(row[3])))

    def add_conflict(self):
        r1, ok = QInputDialog.getInt(self, "Add Conflict", "Rule ID1:")
        if not ok:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Rule ID2:")
        if not ok2:
            return
        pri, ok3 = QInputDialog.getInt(self, "Priority", "Enter priority (int):")
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, pri))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict inserted.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cfid_item = self.cf_table.item(row, 0)
        if not cfid_item:
            return
        cf_id = int(cfid_item.text())
        newp, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (newp, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority changed.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def del_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cfid_item = self.cf_table.item(row, 0)
        if not cfid_item:
            return
        cf_id = int(cfid_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Conflict removed.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class CompositeRulesTab(QWidget):
    """
    Manages COMPOSITE_RULES table => each has an ID, name, logic_expr, action_on_pass, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["Composite Rule ID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_crule)
        bh.addWidget(add_btn)

        del_btn = QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_crule)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_crules)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_crules()

    def load_crules(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS 
            FROM COMPOSITE_RULES
            ORDER BY COMPOSITE_RULE_ID
        """)
        rows = c.fetchall()
        for r_ in rows:
            rr = self.cr_table.rowCount()
            self.cr_table.insertRow(rr)
            self.cr_table.setItem(rr, 0, QTableWidgetItem(str(r_[0])))
            self.cr_table.setItem(rr, 1, QTableWidgetItem(r_[1]))
            self.cr_table.setItem(rr, 2, QTableWidgetItem(r_[2] if r_[2] else ""))
            self.cr_table.setItem(rr, 3, QTableWidgetItem(r_[3] if r_[3] else ""))

    def add_crule(self):
        name, ok = QInputDialog.getText(self, "New Composite Rule", "Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getText(self, "Logic Expr", "(e.g. 'Rule1==PASS AND Rule2==PASS'):")
        if not ok2:
            expr = ""
        act, ok3 = QInputDialog.getText(self, "Action On Pass", "(Optional) Action:")
        if not ok3:
            act = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
                VALUES(?,?,?)
            """, (name.strip(), expr.strip(), act.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Created", "Composite rule created.")
            self.load_crules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def del_crule(self):
        row = self.cr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No composite rule selected.")
            return
        it = self.cr_table.item(row, 0)
        if not it:
            return
        cid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {cid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (cid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Composite rule removed.")
            self.load_crules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class SnapshotManagerTab(QWidget):
    """
    Manages RULE_SNAPSHOTS => user can take a snapshot of all current BRM_RULES, 
    or delete an existing snapshot.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["Snapshot ID","SNAPSHOT_NAME","CREATED_BY","CREATED_TIMESTAMP","SNAPSHOT_JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snapshot)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
            FROM RULE_SNAPSHOTS
            ORDER BY SNAPSHOT_ID DESC
        """)
        rows = c.fetchall()
        for r_ in rows:
            rr = self.ss_table.rowCount()
            self.ss_table.insertRow(rr)
            self.ss_table.setItem(rr, 0, QTableWidgetItem(str(r_[0])))
            self.ss_table.setItem(rr, 1, QTableWidgetItem(r_[1]))
            self.ss_table.setItem(rr, 2, QTableWidgetItem(r_[2]))
            self.ss_table.setItem(rr, 3, QTableWidgetItem(str(r_[3])))
            self.ss_table.setItem(rr, 4, QTableWidgetItem(r_[4] if r_[4] else ""))

    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows = c.fetchall()
        colnames = [desc[0] for desc in c.description]
        rules_list = []
        for row in rows:
            rules_list.append(dict(zip(colnames, row)))
        import json
        snapshot_json = json.dumps(rules_list)
        try:
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
                VALUES(?,?,?)
            """, (name.strip(), "SnapshotUser", snapshot_json))
            self.connection.commit()
            QMessageBox.information(self, "Snapshot", "Snapshot created.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def del_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        it = self.ss_table.item(row, 0)
        if not it:
            return
        ssid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {ssid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (ssid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Snapshot removed.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class TagsManagerTab(QWidget):
    """
    Manages RULE_TAGS => each record references a rule_id + a tag_name.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rem_btn = QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows = c.fetchall()
        for r_ in rows:
            rr = self.tags_table.rowCount()
            self.tags_table.insertRow(rr)
            self.tags_table.setItem(rr, 0, QTableWidgetItem(str(r_[0])))
            self.tags_table.setItem(rr, 1, QTableWidgetItem(str(r_[1])))
            self.tags_table.setItem(rr, 2, QTableWidgetItem(r_[2]))

    def add_tag(self):
        rid, ok = QInputDialog.getInt(self, "Add Tag", "Rule ID:")
        if not ok:
            return
        tag, ok2 = QInputDialog.getText(self, "Tag", "Tag name:")
        if not ok2 or not tag.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?,?)", (rid, tag.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Tag assigned.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        it = self.tags_table.item(row, 0)
        if not it:
            return
        tag_id = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Tag removed.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class DataValidationTab(QWidget):
    """
    Manages DATA_VALIDATIONS => each record references a table, column, validation_type, 
    plus optional params.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dv_table = QTableWidget(0, 5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)

        del_btn = QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_val)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
            ORDER BY VALIDATION_ID
        """)
        rows = c.fetchall()
        for r_ in rows:
            rr = self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            self.dv_table.setItem(rr, 0, QTableWidgetItem(str(r_[0])))
            self.dv_table.setItem(rr, 1, QTableWidgetItem(r_[1]))
            self.dv_table.setItem(rr, 2, QTableWidgetItem(r_[2]))
            self.dv_table.setItem(rr, 3, QTableWidgetItem(r_[3]))
            self.dv_table.setItem(rr, 4, QTableWidgetItem(r_[4] if r_[4] else ""))

    def add_val(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Table name:")
        if not ok or not tbl.strip():
            return
        col, ok2 = QInputDialog.getText(self, "Column", "Column name:")
        if not ok2 or not col.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "(e.g. 'RANGE','NOT NULL'):")
        if not ok3 or not vtype.strip():
            return
        pars, ok4 = QInputDialog.getText(self, "Params", "(optional) param string:")
        if not ok4:
            pars = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(
                  TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
                ) VALUES(?,?,?,?)
            """, (tbl.strip(), col.strip(), vtype.strip(), pars.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Validation rule added.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_val(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        it = self.dv_table.item(row, 0)
        if not it:
            return
        vid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove data validation {vid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Validation removed.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# End of Part 3
#!/usr/bin/env python
"""
BRM TOOL – PART 4 of 5
Fully expanded main window, multi-step approvals with reject,
global/critical administration, hierarchy, lineage, user/group management, 
custom groups with backup/restore, control tables, analytics, advanced rule dashboard/editor, etc.
No placeholders or references to old code.
"""

import json
import math
import logging
from datetime import datetime

# PyQt5
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTabWidget, QLineEdit, QMessageBox, QAbstractItemView, QComboBox,
    QTableWidget, QTableWidgetItem, QPlainTextEdit, QFormLayout, QCheckBox,
    QDialog, QTreeWidget, QTreeWidgetItem, QListWidget, QListWidgetItem,
    QFileDialog, QInputDialog, QTextEdit, QGroupBox, QAction
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QColor
import pyodbc
import pyqtgraph as pg

logger = logging.getLogger(__name__)

###############################################################################
# APPROVAL TAB
###############################################################################
class MultiStepApprovalTab(QWidget):
    """
    Tab that shows multi-step approvals (including rejections).
    Only displays items where the logged_in_username is the approver.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)

        self.appr_table = QTableWidget(0, 7)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID", "Group Name", "Rule Name", "Stage", "Approved?", "Approve", "Reject"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        """
        Loads approvals where the current user is an approver AND not yet approved_flag=1 or 2.
        Then, only shows those at the minimal stage for each action_type.
        """
        c = self.connection.cursor()
        query = """
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, A.APPROVAL_STAGE,
               R.RULE_NAME, R.APPROVAL_STATUS, A.ACTION_TYPE
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """
        c.execute(query, (self.logged_in_username,))
        rows = c.fetchall()

        def get_current_stage(rid_, action_type_):
            c2 = self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) 
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND ACTION_TYPE=? AND APPROVED_FLAG=0
            """, (rid_, action_type_))
            ro = c2.fetchone()
            if ro and ro[0]:
                return ro[0]
            return None

        # Filter rows => only show if the action_type's min stage == current stage
        filtered_rows = []
        for rd in rows:
            rule_id = rd[0]
            stage = rd[4]
            action_type = rd[7]
            cur_st = get_current_stage(rule_id, action_type)
            if cur_st == stage:
                filtered_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rowdata in filtered_rows:
            r_i = self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)

            # RULE_ID
            self.appr_table.setItem(r_i, 0, QTableWidgetItem(str(rowdata[0])))
            # GROUP_NAME
            self.appr_table.setItem(r_i, 1, QTableWidgetItem(rowdata[1]))
            # RULE_NAME
            self.appr_table.setItem(r_i, 2, QTableWidgetItem(rowdata[5]))
            # STAGE
            self.appr_table.setItem(r_i, 3, QTableWidgetItem(str(rowdata[4])))
            # APPROVED?
            self.appr_table.setItem(r_i, 4, QTableWidgetItem(str(rowdata[3])))

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rowidx=r_i: self.do_approve(rowidx))
            self.appr_table.setCellWidget(r_i, 5, approve_btn)

            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rowidx=r_i: self.do_reject(rowidx))
            self.appr_table.setCellWidget(r_i, 6, reject_btn)

    def do_approve(self, row_i):
        """
        Sets APPROVED_FLAG=1 for that row, then checks if we should move to next stage or 
        finalize the rule status.
        """
        rid_item = self.appr_table.item(row_i, 0)
        grp_item = self.appr_table.item(row_i, 1)
        if not rid_item or not grp_item:
            return
        rid = int(rid_item.text())
        grp = grp_item.text()

        c = self.connection.cursor()

        # find ACTION_TYPE
        c.execute("""
        SELECT ACTION_TYPE 
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rid, grp, self.logged_in_username))
        row = c.fetchone()
        if not row:
            return
        action_type = row[0]

        # Approve
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rid, grp, self.logged_in_username))

        # check next stage
        c.execute("""
        SELECT MIN(APPROVAL_STAGE)
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=? AND ACTION_TYPE=? AND APPROVED_FLAG=0
        """, (rid, action_type))
        nxt = c.fetchone()
        if nxt and nxt[0] is not None:
            # still some pending => update rule status accordingly
            if action_type == "CREATE_OR_UPDATE":
                c.execute("""
                    UPDATE BRM_RULES 
                    SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                    WHERE RULE_ID=?
                """, (rid,))
            elif action_type == "DEACTIVATE":
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='DEACTIVATE_IN_PROGRESS'
                    WHERE RULE_ID=?
                """, (rid,))
            elif action_type == "DELETE":
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='DELETE_IN_PROGRESS'
                    WHERE RULE_ID=?
                """, (rid,))
        else:
            # no more pending approvals => final
            if action_type == "CREATE_OR_UPDATE":
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE'
                    WHERE RULE_ID=?
                """, (rid,))
            elif action_type == "DEACTIVATE":
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='INACTIVE'
                    WHERE RULE_ID=?
                """, (rid,))
            elif action_type == "DELETE":
                # physically delete the rule
                c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rid,))
                c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
                c.execute("DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID=? OR SOURCE_RULE_ID=?", (rid, rid))

        # audit
        from part1 import add_audit_log
        old_data = {"APPROVED_FLAG": 0}
        new_data = {"APPROVED_FLAG": 1, "ACTION_TYPE": action_type}
        add_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rid, self.logged_in_username, old_data, new_data)

        self.connection.commit()
        QMessageBox.information(self, "Approved", f"Rule {rid} approved at current stage.")
        self.load_approvals()

    def do_reject(self, row_i):
        """
        If the user rejects => set APPROVED_FLAG=2 => update rule status 
        (REJECTED => inactive or active, depending on action_type).
        """
        rid_item = self.appr_table.item(row_i, 0)
        grp_item = self.appr_table.item(row_i, 1)
        if not rid_item or not grp_item:
            return
        rid = int(rid_item.text())
        grp = grp_item.text()

        confirm = QMessageBox.question(self, "Confirm", f"Reject rule {rid}?")
        if confirm != QMessageBox.Yes:
            return

        c = self.connection.cursor()
        # find action_type
        c.execute("""
        SELECT ACTION_TYPE 
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rid, grp, self.logged_in_username))
        row = c.fetchone()
        if not row:
            return
        action_type = row[0]

        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rid, grp, self.logged_in_username))

        if action_type == "CREATE_OR_UPDATE":
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?", (rid,))
        elif action_type == "DEACTIVATE":
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='ACTIVE' WHERE RULE_ID=?", (rid,))
        elif action_type == "DELETE":
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?", (rid,))

        from part1 import add_audit_log
        add_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rid, self.logged_in_username, None, {"REJECTED": True, "ACTION_TYPE": action_type})
        self.connection.commit()
        QMessageBox.information(self, "Rejected", f"Rule {rid} rejected.")
        self.load_approvals()

###############################################################################
# GLOBAL / CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    Allows Admin to set is_global, critical_rule, critical_scope, plus manage global-critical links.
    """
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)

        if user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return

        # Filter
        filter_h = QHBoxLayout()
        self.show_only_gcr = QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        filter_h.addWidget(self.show_only_gcr)
        filter_h.addWidget(ref_btn)
        filter_h.addStretch()
        layout.addLayout(filter_h)

        # table of rules
        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Rule Name","Owner Group","IS_GLOBAL","CRITICAL_RULE","CRITICAL_SCOPE","STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        # Set flags
        gcs_h = QHBoxLayout()
        self.global_cb = QCheckBox("Set Global?")
        gcs_h.addWidget(self.global_cb)
        self.critical_cb = QCheckBox("Set Critical?")
        gcs_h.addWidget(self.critical_cb)
        gcs_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        gcs_h.addWidget(self.scope_combo)

        apply_btn = QPushButton("Apply Flags/Scope to Selected")
        apply_btn.clicked.connect(self.apply_gcs_to_selected)
        gcs_h.addWidget(apply_btn)
        gcs_h.addStretch()
        layout.addLayout(gcs_h)

        # link management
        link_box = QHBoxLayout()
        self.gcr_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Parent GCR Rule:"))
        link_box.addWidget(self.gcr_rule_combo)

        self.child_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Child Rule:"))
        link_box.addWidget(self.child_rule_combo)

        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_box.addWidget(link_btn)

        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_box.addWidget(unlink_btn)
        link_box.addStretch()
        layout.addLayout(link_box)

        # Link view
        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all_btn = QPushButton("Refresh Everything")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.rule_table.setItem(r_i, col_i, QTableWidgetItem(str(val)))
        self.rule_table.resizeColumnsToContents()

    def populate_gcr_rule_combo(self):
        self.gcr_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows = c.fetchall()
        for row in rows:
            rid, rname = row[0], row[1]
            disp = f"ID:{rid} - {rname}"
            self.gcr_rule_combo.addItem(disp, rid)

    def populate_child_rule_combo(self):
        self.child_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for row in rows:
            rid, rname = row[0], row[1]
            disp = f"ID:{rid} - {rname}"
            self.child_rule_combo.addItem(disp, rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows = c.fetchall()
        for row in rows:
            r_i = self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
        self.link_view.resizeColumnsToContents()

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                rids.append(int(it.text()))
        return rids

    def apply_gcs_to_selected(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "No Selection", "Select rule(s) first.")
            return
        is_global = 1 if self.global_cb.isChecked() else 0
        is_crit = 1 if self.critical_cb.isChecked() else 0
        scope_val = self.scope_combo.currentText().upper()

        confirm = QMessageBox.question(self, "Confirm",
            f"Set IS_GLOBAL={is_global}, CRITICAL_RULE={is_crit}, SCOPE={scope_val} for {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return

        c = self.connection.cursor()
        for rid in rids:
            c.execute("""
            UPDATE BRM_RULES
            SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
            WHERE RULE_ID=?
            """, (is_global, is_crit, scope_val, rid))
        self.connection.commit()
        QMessageBox.information(self, "Done", f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid = self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self, "No Parent GCR", "Select a parent GCR rule.")
            return
        cid = self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self, "No Child", "Select a child rule.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Link child {cid} => parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()

        from part1 import add_audit_log
        c.execute("""
        INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID)
        VALUES(?, ?)
        """, (pid, cid))
        add_audit_log(self.connection, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{pid}->{cid}", "Admin", None, {"parent": pid, "child": cid})
        self.connection.commit()
        QMessageBox.information(self, "Linked", f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid = self.gcr_rule_combo.currentData()
        cid = self.child_rule_combo.currentData()
        if not pid or not cid:
            return
        confirm = QMessageBox.question(self, "Confirm", f"Unlink child {cid} from parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        from part1 import add_audit_log
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?", (pid, cid))
        add_audit_log(self.connection, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{pid}->{cid}", "Admin", {"parent": pid, "child": cid}, None)
        self.connection.commit()
        QMessageBox.information(self, "Unlinked", f"Child {cid} from {pid}")
        self.load_link_view()

###############################################################################
# HIERARCHY VIEW TAB
###############################################################################
class HierarchyViewTab(QWidget):
    """
    Shows a tree of BRM_RULE_GROUPS => child BRM_RULES in that group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tree = QTreeWidget()
        self.tree.setHeaderLabels(["Group / Rule"])
        layout.addWidget(self.tree)

        ref_btn = QPushButton("Refresh Hierarchy")
        ref_btn.clicked.connect(self.load_hierarchy)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.tree.clear()

        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows = c.fetchall()
        grp_map = {}
        for g in grp_rows:
            gid = g[0]
            gname = g[1]
            it = QTreeWidgetItem([f"{gname} (ID={gid})"])
            self.tree.addTopLevelItem(it)
            grp_map[gid] = it

        c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID FROM BRM_RULES ORDER BY RULE_ID")
        rule_rows = c.fetchall()
        for rr in rule_rows:
            rid, rnm, g_id = rr
            if g_id in grp_map:
                parent_it = grp_map[g_id]
                child = QTreeWidgetItem([f"Rule {rid}: {rnm}"])
                parent_it.addChild(child)

        self.tree.expandAll()

###############################################################################
# ENHANCED LINEAGE GRAPH
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    QGraphicsView that draws a node/edge graph of the rule hierarchy,
    plus table dependencies on the side.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.node_map = {}
        self.children_map = {}
        self.parents_map = {}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, RULE_TYPE_ID, CLUSTER_NAME, IS_GLOBAL, CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rows = c.fetchall()
        if not rows:
            txt_item = QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(txt_item)
            return

        # Build adjacency
        all_ids = set()
        for row in rows:
            rid = row[0]
            pid = row[2]
            all_ids.add(rid)
            if pid:
                self.children_map.setdefault(pid, []).append(rid)
                self.parents_map[rid] = pid

        from collections import deque
        child_ids = set(self.parents_map.keys())
        roots = list(all_ids - child_ids)

        # store for later
        rule_lookup = {}
        for row in rows:
            d_ = {
                "RULE_ID": row[0],
                "RULE_NAME": row[1],
                "PARENT_RULE_ID": row[2],
                "STATUS": row[3],
                "RULE_TYPE_ID": row[4],
                "CLUSTER_NAME": row[5],
                "IS_GLOBAL": row[6],
                "CRITICAL_RULE": row[7]
            }
            rule_lookup[row[0]] = d_

        queue = deque()
        level_map = {}
        visited = set()
        for rt in roots:
            queue.append((rt, 0))

        while queue:
            rid, depth = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info = rule_lookup[rid]
            count_at_level = level_map.get(depth, 0)
            level_map[depth] = count_at_level + 1
            x = depth * 220
            y = count_at_level * 120

            node_item = self.create_node(info)
            node_item.setPos(x, y)
            self.scene.addItem(node_item)
            self.node_map[rid] = node_item

            # push children
            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch, depth+1))

        # draw edges
        for row in rows:
            rid = row[0]
            pid = row[2]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # now also show table deps
        c.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps = c.fetchall()
        tbl_map = {}
        idx = 0
        for d_ in deps:
            drid, dbn, tbn, coln, cop = d_
            key = f"{dbn}.{tbn}".lower().strip(".")
            if key not in tbl_map:
                t_item = QtWidgets.QGraphicsEllipseItem(0,0,100,40)
                t_item.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
                t_item.setToolTip(f"Table: {key}")
                t_item.setPos(800, idx*60)
                self.scene.addItem(t_item)
                tbl_map[key] = t_item
                idx += 1

            if drid in self.node_map:
                color = QtGui.QColor("darkblue") if cop=="READ" else QtGui.QColor("darkred")
                self.draw_edge(self.node_map[drid], tbl_map[key], color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, info):
        """
        Creates a QGraphicsItem for the rule node.
        If RULE_TYPE_ID=1 => rectangle, else => ellipse.
        If rule is CRITICAL => thicker red pen.
        If global => prepend name with (G).
        """
        rtype = info["RULE_TYPE_ID"]
        status = info["STATUS"]
        cluster = info["CLUSTER_NAME"] or ""
        is_g = info["IS_GLOBAL"]
        is_c = info["CRITICAL_RULE"]

        if rtype == 1:
            node = QtWidgets.QGraphicsRectItem(0,0,120,50)
        else:
            node = QtWidgets.QGraphicsEllipseItem(0,0,120,50)

        if status.lower() == "active":
            basecol = QtGui.QColor("lightgreen")
        else:
            basecol = QtGui.QColor("tomato")

        if cluster:
            hv = abs(hash(cluster)) % 360
            basecol = QtGui.QColor.fromHsv(hv,128,255)

        node.setBrush(QtGui.QBrush(basecol))

        pen = QtGui.QPen(QtCore.Qt.black, 2)
        if is_c == 1:
            pen = QtGui.QPen(QtGui.QColor("red"), 3)
        node.setPen(pen)

        disp = info["RULE_NAME"]
        if is_g == 1:
            disp = f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1 = item1.sceneBoundingRect()
        r2 = item2.sceneBoundingRect()
        p1 = r1.center()
        p2 = r2.center()
        line = QtWidgets.QGraphicsLineItem(p1.x(), p1.y(), p2.x(), p2.y())
        line.setPen(QtGui.QPen(color, 2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item, (QtWidgets.QGraphicsRectItem, QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self, "Rule Details", item.toolTip())
        super().mousePressEvent(event)

    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setPen(QtGui.QPen(QtCore.Qt.black,2))

    def search_nodes(self, query):
        """
        Highlights the chain (ancestors + descendants) of nodes matching the query.
        Query can match rule_name, rule_sql, or table_name in the dependencies, etc.
        """
        self.clear_highlights()
        ql = query.lower()
        c = self.connection.cursor()
        found = set()

        # search in rules
        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE LOWER(RULE_NAME) LIKE ?
           OR LOWER(RULE_SQL) LIKE ?
           OR LOWER(DESCRIPTION) LIKE ?
           OR LOWER(BUSINESS_JUSTIFICATION) LIKE ?
           OR CAST(RULE_ID AS VARCHAR(50)) LIKE ?
        """, (f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%"))
        for row in c.fetchall():
            found.add(row[0])

        # search in table deps
        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE LOWER(DATABASE_NAME) LIKE ?
           OR LOWER(TABLE_NAME) LIKE ?
        """, (f"%{ql}%", f"%{ql}%"))
        for row in c.fetchall():
            found.add(row[0])

        if not found:
            QMessageBox.information(self, "No Match", f"No match for '{query}'")
            return

        def highlight_ancestors(rid):
            cur = rid
            while cur in self.parents_map:
                if cur in self.node_map:
                    self.node_map[cur].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                par = self.parents_map[cur]
                if par in self.node_map:
                    self.node_map[par].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                cur = par

        def highlight_descendants(rid):
            stack = [rid]
            visited = set()
            while stack:
                c_ = stack.pop()
                if c_ in visited:
                    continue
                visited.add(c_)
                if c_ in self.node_map:
                    self.node_map[c_].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                if c_ in self.children_map:
                    stack.extend(self.children_map[c_])

        for rid in found:
            if rid in self.node_map:
                self.node_map[rid].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                highlight_ancestors(rid)
                highlight_descendants(rid)

###############################################################################
# METRICS
###############################################################################
class MetricsDashboardTab(QWidget):
    """
    A simple bar chart (pyqtgraph) showing rule counts by STATUS.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.chart = pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        ref_btn = QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        rows = c.fetchall()
        statuses = [r[0] for r in rows]
        counts = [r[1] for r in rows]

        self.chart.clear()
        if statuses:
            x = range(len(statuses))
            bar_item = pg.BarGraphItem(x=list(x), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(x, statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True, y=True)

###############################################################################
# CONTROL TABLES TAB
###############################################################################
class CtrlTablesTab(QWidget):
    """
    Shows data from various control tables in a QTableWidget for read-only browsing.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table_list = [
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS"
        ]

        self.table_combo = QComboBox()
        for t_ in self.table_list:
            self.table_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.data_table = QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def on_load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error getting columns",str(ex))
            return

        try:
            c.execute(f"SELECT * FROM {tbl}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error retrieving data",str(ex))
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)

        for row in rows:
            r_ = self.data_table.rowCount()
            self.data_table.insertRow(r_)
            for j, val in enumerate(row):
                self.data_table.setItem(r_, j, QTableWidgetItem(str(val)))

###############################################################################
# GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTab(QWidget):
    """
    Admin-only tab for managing BUSINESS_GROUPS, group permissions, and group approvers.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)

        if user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Groups & membership
        gm_tab = QWidget()
        gm_layout = QVBoxLayout(gm_tab)

        grp_box = QGroupBox("Group Details")
        grp_layout = QVBoxLayout(grp_box)
        self.groups_table = QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        grp_btns = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        grp_btns.addWidget(del_grp_btn)

        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        membership_box = QGroupBox("Membership Management")
        membership_layout = QVBoxLayout(membership_box)
        self.users_table = QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btns = QHBoxLayout()
        add_usr_btn = QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btns.addWidget(add_usr_btn)
        rem_usr_btn = QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btns.addWidget(rem_usr_btn)
        memb_btns.addStretch()
        membership_layout.addLayout(memb_btns)
        gm_layout.addWidget(membership_box)
        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab, "Groups & Membership")

        # Permissions
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        perm_box = QGroupBox("Group Permissions")
        perm_box_layout = QVBoxLayout(perm_box)

        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo = QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table = QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph = QHBoxLayout()
        addp_btn = QPushButton("Add Permission")
        addp_btn.clicked.connect(self.on_add_permission)
        ph.addWidget(addp_btn)

        remp_btn = QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.on_remove_permission)
        ph.addWidget(remp_btn)
        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # Approvers
        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        ah = QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo = QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table = QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btns.addWidget(add_appr_btn)

        del_appr_btn = QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btns.addWidget(del_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_btn = QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.groups_table.setRowCount(0)
        for row in rows:
            r_i = self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            self.groups_table.setItem(r_i,0,QTableWidgetItem(row[0]))
            self.groups_table.setItem(r_i,1,QTableWidgetItem(row[1] if row[1] else ""))
            self.groups_table.setItem(r_i,2,QTableWidgetItem(row[2] if row[2] else ""))

    def load_users(self):
        self.users_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = c.fetchall()
        for row in rows:
            r_i = self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            self.users_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.users_table.setItem(r_i,1,QTableWidgetItem(row[1]))
            self.users_table.setItem(r_i,2,QTableWidgetItem(row[2]))

    def load_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.perm_group_combo.clear()
        for row in rows:
            self.perm_group_combo.addItem(row[0], row[0])

    def load_appr_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.appr_group_combo.clear()
        for row in rows:
            self.appr_group_combo.addItem(row[0], row[0])

    def on_add_group(self):
        name,ok = QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc,ok2 = QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc = ""
        em,ok3 = QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em = ""
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (name.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error","Group already exists.")
                return
            c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",(name.strip(),desc.strip(),em.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Group created.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def on_rename_group(self):
        i = self.groups_table.currentRow()
        if i<0:
            QMessageBox.warning(self,"None","No group selected.")
            return
        it = self.groups_table.item(i,0)
        if not it:
            return
        grp = it.text().strip()
        new_name,ok = QInputDialog.getText(self,"Rename Group",f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def on_delete_group(self):
        i = self.groups_table.currentRow()
        if i<0:
            QMessageBox.warning(self,"None","No group selected.")
            return
        it = self.groups_table.item(i,0)
        if not it:
            return
        grp = it.text().strip()
        confirm = QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group removed.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def get_selected_user(self):
        i = self.users_table.currentRow()
        if i<0:
            return None
        it = self.users_table.item(i,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user_to_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok = QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldg = c.fetchone()
        if not oldg:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if oldg[0]==grp.strip():
            QMessageBox.warning(self,"Error","User is already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm = QMessageBox.question(self,"Confirm","Remove user from group => moves user to BG1.")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def load_permissions(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp.strip(),))
        rows = c.fetchall()
        for row in rows:
            rr = self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(row[0]))

    def on_add_permission(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        table,ok = QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.Credit_Portfolio'):")
        if not ok or not table.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),table.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def on_remove_permission(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","No group selected.")
            return
        row = self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it = self.perm_table.item(row, 0)
        if not it:
            return
        table_name = it.text().strip()
        confirm = QMessageBox.question(self,"Confirm",f"Remove permission '{table_name}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(),table_name))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    def load_approvers(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        c = self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp.strip(),))
        rows = c.fetchall()
        self.appr_table.setRowCount(0)
        for row in rows:
            r_i = self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(row[1]))

    def on_add_approver(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        usern,ok = QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(),usern.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver '{usern}' added to {grp}.")
        self.load_approvers()

    def on_remove_approver(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        row = self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it = self.appr_table.item(row,0)
        if not it:
            return
        app_id = int(it.text())
        confirm = QMessageBox.question(self,"Confirm",f"Remove approver ID={app_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(app_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

###############################################################################
# USER MANAGEMENT TAB
###############################################################################
class UserManagementTab(QWidget):
    """
    Admin-only user management => can add, delete, change password.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.user_table = QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["User ID","Username","Password","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.on_add_user)
        bh.addWidget(add_btn)

        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.on_delete_user)
        bh.addWidget(del_btn)

        pass_btn = QPushButton("Change Password")
        pass_btn.clicked.connect(self.on_change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = c.fetchall()
        for row in rows:
            r_ = self.user_table.rowCount()
            self.user_table.insertRow(r_)
            for j,val in enumerate(row):
                self.user_table.setItem(r_, j, QTableWidgetItem(str(val)))

    def get_selected_user_id(self):
        row = self.user_table.currentRow()
        if row<0:
            return None
        it = self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user(self):
        name,ok = QInputDialog.getText(self,"Add User","Username:")
        if not ok or not name.strip():
            return
        pwd,ok2 = QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3 = QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(name.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","User added.")
        self.load_users()

    def on_delete_user(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","User removed.")
        self.load_users()

    def on_change_password(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok = QInputDialog.getText(self,"Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        c = self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Password changed.")
        self.load_users()

###############################################################################
# CUSTOM RULE GROUPS
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manages custom rule groups => backup/restore, add rules, remove rules, BFS child owners, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter = QtWidgets.QSplitter(Qt.Horizontal)

        self.tree = QTreeWidget()
        self.tree.setHeaderLabels(["Custom Group / Rule"])
        self.tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget = QWidget()
        rw_layout = QVBoxLayout(right_widget)

        self.rule_search = QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups = c.fetchall()
        for row in groups:
            cg_id, cg_name, owner = row
            disp = f"{cg_name} ({owner})"
            g_item = QTreeWidgetItem([disp])
            g_item.setData(0, Qt.UserRole, cg_id)
            g_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2 = self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned = c2.fetchall()
            for rr in assigned:
                rid, rname, isg, iscrit = rr
                txt = f"Rule {rid}: {rname}"
                rr_item = QTreeWidgetItem([txt])
                rr_item.setData(0, Qt.UserRole, rid)
                if isg==1:
                    rr_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightblue")))
                if iscrit==1:
                    rr_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt = self.rule_search.text().strip()
        c = self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)

        rows = c.fetchall()

        c2 = self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned = set(x[0] for x in c2.fetchall())

        for r in rows:
            rid, rname, og = r
            if rid in assigned:
                continue
            disp = f"Rule {rid}: {rname} (Owner {og})"
            it = QListWidgetItem(disp)
            it.setData(Qt.UserRole, rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item = self.tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            # child => rule
            menu = QMenu()
            rem_act = menu.addAction("Remove Rule from Group")
            chosen = menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen == rem_act:
                group_id = parent.data(0,Qt.UserRole)
                rule_id = item.data(0,Qt.UserRole)
                c = self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id, rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed.")
                self.refresh_all()

    def create_group(self):
        name = self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c = self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel = self.tree.selectedItems()
        if not sel:
            return None, None
        item = sel[0]
        par = item.parent()
        if par:
            item = par
        gid = item.data(0, Qt.UserRole)
        disp = item.text(0)
        return gid, disp

    def rename_group(self):
        gid, disp = self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name, ok = QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gid, disp = self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        gid, disp = self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname = row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned = [x[0] for x in c.fetchall()]
        backup_data = {"group_name": grpname, "members": assigned}
        import json
        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv = c.fetchone()
        new_ver = rowv[0]
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        gid, disp = self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c = self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items = [f"Version {r[0]} (ts {r[1]})" for r in rows]
        sel,ok = QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return
        import re
        m = re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver = int(m.group(1))
        confirm = QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return
        backup_json = None
        for r_ in rows:
            if r_[0] == ver:
                backup_json = r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found.")
            return
        import json
        backup_data = json.loads(backup_json)
        new_name = backup_data["group_name"]
        members = backup_data["members"]
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_name,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel = self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected in the tree.")
            return
        g_item = sel[0]
        if g_item.parent():
            g_item = g_item.parent()
        gid = g_item.data(0,Qt.UserRole)
        sel_rules = self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return
        c = self.connection.cursor()
        count = 0
        for it in sel_rules:
            rid = it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()

###############################################################################
# ALERTS & DASHBOARDS
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    """
    Shows alerts => e.g. approvals older than 3 days, upcoming schedules in next 24h.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)

        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()
        # find approvals older than 3 days => minimal stage
        c.execute("""
        SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
               DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE = (
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
          )
          AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE())>3
        """)
        old_ap = c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for row in old_ap:
                lines.append(f" - Rule {row[0]} stage={row[1]} age={row[3]} => {row[2]}")
        else:
            lines.append("No old approvals found.")

        lines.append("")
        # upcoming schedules in next 24h
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upcoming = c.fetchall()
        if upcoming:
            lines.append("Upcoming schedules in next 24h:")
            for up_ in upcoming:
                lines.append(f" - ID={up_[0]}, rule={up_[1]}, time={up_[2]}")
        else:
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Dialog that shows last 1000 entries in BRM_AUDIT_LOG.
    Allows searching columns 'action', 'table', 'action_by'.
    Can export to CSV.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs – Full Integration")
        self.resize(800,600)
        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table = QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels([
            "Audit ID","Action","Table","Record ID","Action By","Old Data","New Data","Timestamp"
        ])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        exp_btn = QPushButton("Export to CSV")
        exp_btn.clicked.connect(self.export_csv)
        bh.addWidget(exp_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.audit_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()
        import json
        for row in rows:
            r_ = self.audit_table.rowCount()
            self.audit_table.insertRow(r_)
            self.audit_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.audit_table.setItem(r_,1,QTableWidgetItem(row[1]))
            self.audit_table.setItem(r_,2,QTableWidgetItem(row[2]))
            self.audit_table.setItem(r_,3,QTableWidgetItem(row[3]))
            self.audit_table.setItem(r_,4,QTableWidgetItem(row[4]))

            oldtxt = ""
            if row[5]:
                try:
                    d_ = json.loads(row[5])
                    oldtxt = json.dumps(d_, indent=2)
                except:
                    oldtxt = row[5]
            self.audit_table.setItem(r_,5,QTableWidgetItem(oldtxt))

            newtxt = ""
            if row[6]:
                try:
                    d2 = json.loads(row[6])
                    newtxt = json.dumps(d2, indent=2)
                except:
                    newtxt = row[6]
            self.audit_table.setItem(r_,6,QTableWidgetItem(newtxt))

            self.audit_table.setItem(r_,7,QTableWidgetItem(str(row[7])))

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            show = False
            for col in (1,2,4):
                it = self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    show = True
                    break
            self.audit_table.setRowHidden(row, not show)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self,"Save CSV","","CSV Files (*.csv)")
        if not path:
            return
        import csv
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            headers = [self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row):
                    continue
                rowdata = []
                for col in range(self.audit_table.columnCount()):
                    it = self.audit_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported","Audit logs exported.")

###############################################################################
# SEARCH RULE
###############################################################################
class SearchRuleDialog(QDialog):
    """
    Dialog that searches BRM_RULES by name or SQL snippet.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules – Full Integration")
        self.resize(800,600)

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        rb = QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        layout.addWidget(rb)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows = c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_ = self.res_table.rowCount()
            self.res_table.insertRow(r_)
            for i_ in range(6):
                self.res_table.setItem(r_, i_, QTableWidgetItem(str(row[i_])))

###############################################################################
# VERSION HISTORY
###############################################################################
class VersionHistoryDialog(QDialog):
    """
    Shows version history for a rule => pulls from BRM_AUDIT_LOG where 
    table_name='BRM_RULES' and record_id= that rule, action in (INSERT,UPDATE).
    Allows rollback to a previous version if old_data is present.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id}")
        self.resize(800,400)

        layout = QVBoxLayout(self)
        self.table = QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["Audit ID","Action","Timestamp","Old Data","New Data"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh = QHBoxLayout()
        rb = QPushButton("Rollback Selected")
        rb.clicked.connect(self.do_rollback)
        bh.addWidget(rb)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows = c.fetchall()
        for row in rows:
            rr = self.table.rowCount()
            self.table.insertRow(rr)
            self.table.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(rr,1,QTableWidgetItem(row[1]))
            self.table.setItem(rr,2,QTableWidgetItem(str(row[2])))
            self.table.setItem(rr,3,QTableWidgetItem(row[3] if row[3] else ""))
            self.table.setItem(rr,4,QTableWidgetItem(row[4] if row[4] else ""))

    def do_rollback(self):
        sel = self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected for rollback.")
            return
        row = sel[0].row()
        old_data_item = self.table.item(row,3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self,"No Old Data","No old_data found in that row.")
            return
        confirm = QMessageBox.question(self,"Confirm","Rollback to selected version?")
        if confirm!=QMessageBox.Yes:
            return
        import json
        try:
            old_data = json.loads(old_data_item.text())
            self.apply_rollback(old_data)
            QMessageBox.information(self,"Rolled Back","Rule rollback done.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def apply_rollback(self, old_data):
        rid = old_data["RULE_ID"]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if not row:
            raise ValueError("Rule not found for rollback.")
        c.execute("BEGIN TRANSACTION")
        new_sql = old_data["RULE_SQL"]

        # update partial fields => 
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(
            old_data["RULE_NAME"],
            new_sql,
            old_data["OWNER_GROUP"],
            rid
        ))

        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        from part1 import enhanced_advanced_extract_tables, detect_operation_type
        op_type = detect_operation_type(new_sql)
        parse_info = enhanced_advanced_extract_tables(new_sql)
        col_op = "READ"
        if op_type in ("INSERT","UPDATE","DELETE"):
            col_op = "WRITE"
        for (sch,tb,alias,_) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                ) VALUES(?,?,?,?,?)
                """,(rid, sch if sch else "N/A", tb, "RolledBackCol", col_op))

        c.execute("COMMIT")

###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    """
    A QGroupBox that shows a paginated table of BRM_RULES,
    with optional search and status filter, plus lock/unlock if integrated with part5.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        # top filters
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL snippet...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)

        # If you have part5 => explicit lock
        lock_btn = QPushButton("Lock Rule")
        lock_btn.clicked.connect(self.lock_rule)
        top_h.addWidget(lock_btn)

        unlock_btn = QPushButton("Unlock Rule")
        unlock_btn.clicked.connect(self.unlock_rule)
        top_h.addWidget(unlock_btn)

        main_layout.addLayout(top_h)

        self.rule_table = QTableWidget(0,10)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Name","SQL","Status","Version","Owner Group","Created TS","Approval Status","Locked By","DecisionTableID"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_query(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%",f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()

        count_q = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, params)
        rowc = c.fetchone()
        total = rowc[0] if rowc else 0
        self.total_pages = max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page-1)*self.records_per_page

        data_q = f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,
               CREATED_TIMESTAMP,APPROVAL_STATUS,LOCKED_BY,DECISION_TABLE_ID
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*params, offset, self.records_per_page))
        rows = c.fetchall()

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_ = self.rule_table.rowCount()
            self.rule_table.insertRow(r_)
            for i in range(10):
                val = rd[i]
                item = QTableWidgetItem(str(val) if val is not None else "")
                if i==3: # status => color
                    if str(val).lower()=="active":
                        item.setBackground(QColor(144,238,144))
                    else:
                        item.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_, i, item)

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row,0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id = None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

    def lock_rule(self):
        """
        If part5 is available, you can call lock_rule(conn, rule_id, username).
        """
        from part5 import lock_rule
        rids = self.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Select One","Select exactly one rule to lock.")
            return
        rid = rids[0]
        user = f"User:{self.user_id}"
        try:
            lock_rule(self.connection, rid, user, timeout_minutes=30)
            QMessageBox.information(self,"Locked",f"Rule {rid} locked by {user}.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def unlock_rule(self):
        """
        If part5 is available, you can call unlock_rule(conn, rule_id, username).
        """
        from part5 import unlock_rule
        rids = self.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Select One","Select exactly one rule to unlock.")
            return
        rid = rids[0]
        user = f"User:{self.user_id}"
        try:
            unlock_rule(self.connection, rid, user, auto_release=False)
            QMessageBox.information(self,"Unlocked",f"Rule {rid} unlocked.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# RULE EDITOR DIALOG
###############################################################################
class RuleEditorDialog(QDialog):
    """
    A dialog for adding or updating a rule. 
    Integrates with advanced parser from part1, 
    and calls add_rule/update_rule from part2.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = (rule_data is not None)

        title = "Update Rule" if self.is_update else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(800,550)
        self.main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        # group combo
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows = c.fetchall()
        for row in grp_rows:
            disp = f"{row[1]} (ID={row[0]})"
            self.group_combo.addItem(disp, row[0])
        form_layout.addRow("Rule Group:", self.group_combo)

        # parent rule combo
        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        pr_rows = c.fetchall()
        for row in pr_rows:
            disp = f"{row[1]} (ID={row[0]})"
            self.parent_rule_combo.addItem(disp, row[0])
        form_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit = QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        # rule type
        self.rule_type_combo = QComboBox()
        c.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        rt_rows = c.fetchall()
        for row in rt_rows:
            self.rule_type_combo.addItem(row[1], row[0])
        form_layout.addRow("Rule Type:", self.rule_type_combo)

        # status
        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        # Start / End
        self.start_dt = QtWidgets.QDateTimeEdit(QtCore.QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_layout.addRow("Effective Start:", self.start_dt)

        self.end_dt = QtWidgets.QDateTimeEdit(QtCore.QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_layout.addRow("Effective End:", self.end_dt)

        # SQL
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, else => FAIL.")
        form_layout.addRow("Rule SQL:", self.sql_edit)

        # desc / justification
        self.desc_edit = QTextEdit()
        form_layout.addRow("Description:", self.desc_edit)
        self.just_edit = QTextEdit()
        form_layout.addRow("Justification:", self.just_edit)

        # global
        self.global_cb = None
        if self.user_group=="Admin":
            self.global_cb = QCheckBox("Global (Admin only)")
            form_layout.addRow("Global Rule:", self.global_cb)

        self.critical_cb = QCheckBox()
        form_layout.addRow("Critical Rule:", self.critical_cb)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_layout.addRow("Critical Scope:", self.scope_combo)

        # cdc
        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_layout.addRow("CDC Type:", self.cdc_combo)

        # decision table
        self.decision_combo = QComboBox()
        self.decision_combo.addItem("(None)", None)
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        dtb_rows = c.fetchall()
        for row in dtb_rows:
            disp = f"{row[1]} (ID={row[0]})"
            self.decision_combo.addItem(disp, row[0])
        form_layout.addRow("Decision Table:", self.decision_combo)

        self.main_layout.addLayout(form_layout)

        # buttons
        bh = QHBoxLayout()
        self.save_btn = QPushButton("Save" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.on_save)
        bh.addWidget(self.save_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(cancel_btn)
        self.main_layout.addLayout(bh)
        self.setLayout(self.main_layout)

        if self.is_update and self.rule_data:
            self.load_existing_rule_data()

    def load_existing_rule_data(self):
        rd = self.rule_data
        # group_id
        gid = rd.get("GROUP_ID")
        if gid:
            ix = self.group_combo.findData(gid)
            if ix>=0:
                self.group_combo.setCurrentIndex(ix)

        # parent
        pid = rd.get("PARENT_RULE_ID")
        if pid:
            ix2 = self.parent_rule_combo.findData(pid)
            if ix2>=0:
                self.parent_rule_combo.setCurrentIndex(ix2)
        else:
            self.parent_rule_combo.setCurrentIndex(0)

        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id = rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3 = self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)

        st = rd.get("STATUS","INACTIVE")
        i_st = self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        fmt = "%Y-%m-%d %H:%M:%S"
        sd = rd.get("EFFECTIVE_START_DATE","")
        if sd:
            try:
                dt_ = datetime.strptime(sd, fmt)
                self.start_dt.setDateTime(QtCore.QDateTime(dt_))
            except:
                pass
        ed = rd.get("EFFECTIVE_END_DATE","")
        if ed:
            try:
                dt2_ = datetime.strptime(ed, fmt)
                self.end_dt.setDateTime(QtCore.QDateTime(dt2_))
            except:
                pass

        self.sql_edit.setPlainText(rd.get("RULE_SQL",""))
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.user_group=="Admin" and "IS_GLOBAL" in rd:
            if rd["IS_GLOBAL"]==1 and self.global_cb:
                self.global_cb.setChecked(True)

        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_cb.setChecked(True)

        scp = rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp = self.scope_combo.findText(scp)
        if i_scp>=0:
            self.scope_combo.setCurrentIndex(i_scp)

        cdcv = rd.get("CDC_TYPE","NONE").upper()
        i_cdc = self.cdc_combo.findText(cdcv)
        if i_cdc>=0:
            self.cdc_combo.setCurrentIndex(i_cdc)

        dtid = rd.get("DECISION_TABLE_ID")
        if dtid:
            i_dt = self.decision_combo.findData(dtid)
            if i_dt>=0:
                self.decision_combo.setCurrentIndex(i_dt)

    def on_save(self):
        nm = self.name_edit.text().strip()
        sql_ = self.sql_edit.toPlainText().strip()
        if not nm:
            QMessageBox.warning(self,"Error","Rule name is required.")
            return
        if not sql_:
            QMessageBox.warning(self,"Error","SQL cannot be empty.")
            return

        group_id = self.group_combo.currentData()
        parent_id = self.parent_rule_combo.currentData()
        rt_id = self.rule_type_combo.currentData()
        st = self.status_combo.currentText()
        sd = self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        ed = self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        desc_ = self.desc_edit.toPlainText().strip()
        just_ = self.just_edit.toPlainText().strip()

        isg = 0
        if self.user_group=="Admin" and self.global_cb and self.global_cb.isChecked():
            isg = 1
        isc = 1 if self.critical_cb.isChecked() else 0
        scp_ = self.scope_combo.currentText().upper()
        cdcv = self.cdc_combo.currentText().upper()
        dtid = self.decision_combo.currentData()

        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?",(group_id,))
        rowg = c.fetchone()
        if rowg:
            gname = rowg[0]
        else:
            gname = "BG1"

        rule_dict = {
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id if parent_id else None,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sd,
            "EFFECTIVE_END_DATE": ed,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdcv,
            "OWNER_GROUP": gname,
            "DECISION_TABLE_ID": dtid
        }

        from part2 import add_rule, update_rule
        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Success",f"Rule '{nm}' updated (re-approval started).")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm = QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Success",f"Rule '{nm}' created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    """
    The main window that ties everything together (part 4).
    Provides tabs for business rules, approvals, global/critical admin, hierarchy, lineage, 
    custom groups, scheduling, control tables, metrics, alerts, group mgmt, user mgmt, 
    plus Tools menu for audit logs, search, version history, etc.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full, All Features (Part 4)")
        self.resize(1300,850)

        self.connection = None

        # get connection
        from part1 import DatabaseConnectionDialog
        dbdlg = DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection = dbdlg.get_connection()
            if not self.connection:
                import sys
                sys.exit(1)
        else:
            import sys
            sys.exit(0)

        # login
        from part1 import LoginDialog
        logdlg = LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            import sys
            sys.exit(0)
        self.user_id = logdlg.user_id

        c = self.connection.cursor()
        c.execute("SELECT USERNAME, USER_GROUP FROM USERS WHERE USER_ID=?",(self.user_id,))
        row = c.fetchone()
        if not row:
            import sys
            sys.exit(0)
        self.logged_in_username = row[0]
        self.user_group = row[1]

        self.init_ui()

    def init_ui(self):
        menubar = self.menuBar()
        fileMenu = menubar.addMenu("File")

        # from part3 import sync_metadata_improved
        from part3 import sync_metadata_improved

        syncAct = QAction("Sync Metadata",self)
        syncAct.triggered.connect(lambda: sync_metadata_improved(self.connection))
        fileMenu.addAction(syncAct)

        metricsAct = QAction("View Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        schedAct = QAction("New Schedule (Dialog)",self)
        schedAct.triggered.connect(self.launch_enh_sched)
        fileMenu.addAction(schedAct)

        chainAct = QAction("Simulate Rule Chain",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        grpAct = QAction("Simulate Custom Group",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        helpMenu = menubar.addMenu("Help")
        usageAct = QAction("Show Tips",self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        cw = QWidget()
        layout = QVBoxLayout(cw)

        if self.user_group=="Admin":
            top_h = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # business rules tab
        brw = QWidget()
        br_lay = QVBoxLayout(brw)
        cr_h = QHBoxLayout()

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        cr_h.addWidget(add_btn)

        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        cr_h.addWidget(upd_btn)

        deact_btn = QPushButton("Deactivate")
        deact_btn.clicked.connect(self.on_deactivate_rule)
        cr_h.addWidget(deact_btn)

        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.on_delete_rule)
        cr_h.addWidget(del_btn)

        etl_btn = QPushButton("Run ETL (BFS)")
        etl_btn.clicked.connect(self.run_etl_bfs)
        cr_h.addWidget(etl_btn)

        sim_btn = QPushButton("Simulate Rule")
        sim_btn.clicked.connect(self.simulate_single_rule)
        cr_h.addWidget(sim_btn)

        cr_h.addStretch()
        br_lay.addLayout(cr_h)

        from part4 import RuleDashboard  # or you can define it in the same file
        self.brm_dashboard = RuleDashboard(self.connection,self.user_id,self.user_group)
        br_lay.addWidget(self.brm_dashboard)
        brw.setLayout(br_lay)
        self.tabs.addTab(brw,"Business Rules")

        # approvals
        from part4 import MultiStepApprovalTab
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # GCR admin
        if self.user_group=="Admin":
            from part4 import GlobalCriticalAdminTab
            self.gcr_tab = GlobalCriticalAdminTab(self,self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # hierarchy
        from part4 import HierarchyViewTab
        self.hierarchy = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy,"Hierarchy")

        # lineage
        from part4 import EnhancedLineageGraphWidget
        lin_w = QWidget()
        lin_l = QVBoxLayout(lin_w)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lin_l.addWidget(lb)
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lin_l.addWidget(self.lineage_tab)

        line_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table..")
        sbtn = QPushButton("Search")
        sbtn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rb = QPushButton("Reset View")
        rb.clicked.connect(self.lineage_tab.resetView)
        refb = QPushButton("Refresh Graph")
        refb.clicked.connect(self.lineage_tab.populate_graph)
        line_h.addWidget(self.lineage_search)
        line_h.addWidget(sbtn)
        line_h.addWidget(rb)
        line_h.addWidget(refb)
        line_h.addStretch()
        lin_l.addLayout(line_h)
        lin_w.setLayout(lin_l)
        self.tabs.addTab(lin_w,"Lineage")

        # custom groups
        from part4 import CustomRuleGroupEnhancedTab
        self.custom_tab = CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # schedule
        from part3 import ScheduleManagementTab
        self.sch_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # control tables
        from part4 import CtrlTablesTab
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # metrics
        from part4 import MetricsDashboardTab
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # alerts
        from part4 import AlertsAndDashboardsTab
        self.alert_tab = AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Dashboards")

        # group mgmt
        from part4 import GroupManagementTab
        self.grp_mgmt = GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt,"Group Management")

        # user mgmt
        if self.user_group=="Admin":
            from part4 import UserManagementTab
            self.user_mgmt = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt,"User Management")

        # Tools
        toolsMenu = menubar.addMenu("Tools")

        from part4 import AuditLogViewer, SearchRuleDialog, VersionHistoryDialog

        alAct = QAction("View Audit Logs",self)
        alAct.triggered.connect(self.launch_audit_log)
        toolsMenu.addAction(alAct)

        srAct = QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_search)
        toolsMenu.addAction(srAct)

        verAct = QAction("Version History (Enter Rule ID)",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        # advanced
        advMenu = menubar.addMenu("Advanced")
        from part3 import DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab, SnapshotManagerTab, TagsManagerTab, DataValidationTab

        self.decision_tab = DecisionTablesTab(self.connection)
        self.conflict_tab = ConflictPriorityManagerTab(self.connection)
        self.composite_tab = CompositeRulesTab(self.connection)
        self.snap_tab = SnapshotManagerTab(self.connection)
        self.tags_tab = TagsManagerTab(self.connection)
        self.dv_tab = DataValidationTab(self.connection)

        advMenu.addAction("Open Decision Tables",lambda: self.tabs.addTab(self.decision_tab,"Decision Tables"))
        advMenu.addAction("Open Conflict Priority",lambda: self.tabs.addTab(self.conflict_tab,"Conflict Priority"))
        advMenu.addAction("Open Composite Rules",lambda: self.tabs.addTab(self.composite_tab,"Composite Rules"))
        advMenu.addAction("Open Snapshot Manager",lambda: self.tabs.addTab(self.snap_tab,"Snapshots"))
        advMenu.addAction("Open Tags Manager",lambda: self.tabs.addTab(self.tags_tab,"Tags Manager"))
        advMenu.addAction("Open Data Validation",lambda: self.tabs.addTab(self.dv_tab,"Data Validation"))

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        self.approv_timer = QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

        self.show()

    def show_metrics_dialog(self):
        from part4 import MetricsDashboardTab
        dlg = QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800,600)
        lay = QVBoxLayout(dlg)
        chart = MetricsDashboardTab(self.connection)
        lay.addWidget(chart)
        cb = QPushButton("Close")
        cb.clicked.connect(dlg.close)
        lay.addWidget(cb)
        dlg.exec_()

    def launch_enh_sched(self):
        from part3 import EnhancedScheduleDialog
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()

    def launch_chain_sim(self):
        from part3 import ChainSimulationDialog
        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()

    def launch_group_sim(self):
        from part3 import GroupSimulationDialog
        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()

    def show_help(self):
        msg = "BRM Tool – Full advanced version. Use the tabs to manage rules, approvals, etc."
        QMessageBox.information(self,"Help/Tips",msg)

    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        QMessageBox.information(self,"Switched",f"Impersonating user {new_uid} => group {new_grp}.")

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = c.fetchall()
        for row in rows:
            uid, uname, ugrp = row
            disp = f"{uname} ({ugrp})"
            self.switch_combo.addItem(disp, (uid,ugrp))

    def on_add_rule(self):
        from part4 import RuleEditorDialog
        dlg = RuleEditorDialog(self.connection, self.user_group, None, self)
        if dlg.exec_()==QDialog.Accepted:
            QMessageBox.information(self,"Success","New rule added.")
            self.brm_dashboard.load_rules()

    def on_update_rule(self):
        from part4 import RuleEditorDialog
        from part5 import lock_rule
        rids = self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid = rids[0]

        # attempt lock if part5 is integrated
        user = f"User:{self.user_id}"
        try:
            lock_rule(self.connection, rid, user)
        except Exception as ex:
            QMessageBox.critical(self,"Lock Error",str(ex))
            return

        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No rule with ID={rid}")
            return
        colnames = [desc[0] for desc in c.description]
        rule_data = dict(zip(colnames, row))

        dlg = RuleEditorDialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_()==QDialog.Accepted:
            QMessageBox.information(self,"Updated",f"Rule {rid} updated.")
            self.brm_dashboard.load_rules()

    def on_deactivate_rule(self):
        from part2 import deactivate_rule
        rids = self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg = f"Deactivation done. success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def on_delete_rule(self):
        from part2 import delete_rule
        rids = self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg = f"Deletion done. success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_etl_bfs(self):
        from part2 import execute_rules_in_order
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"Run ETL BFS => executed={executed}, skipped={list(skipped)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def simulate_single_rule(self):
        from part3 import SingleRuleSimulationDialog
        rids = self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid = rids[0]
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","No rule for that ID.")
            return
        sql_ = row[0]
        dlg = SingleRuleSimulationDialog(self.connection, rid, sql_, self)
        dlg.exec_()

    def launch_audit_log(self):
        from part4 import AuditLogViewer
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search(self):
        from part4 import SearchRuleDialog
        dlg = SearchRuleDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok = QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
        if not ok:
            return
        from part4 import VersionHistoryDialog
        dlg = VersionHistoryDialog(self.connection, rid, self)
        dlg.exec_()

    def check_due_schedules(self):
        """
        Periodic check if any scheduled rules are due => run them in a transaction => commit or fail => update schedule status.
        """
        c = self.connection.cursor()
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
        """,(now,))
        due = c.fetchall()
        for item in due:
            sch_id = item[0]
            rid = item[1]
            c2 = self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                row = c2.fetchone()
                if row:
                    try:
                        c2.execute(row[0])
                    except Exception as ex:
                        logger.error(f"Scheduled rule {rid} => FAIL: {ex}")
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                        self.connection.commit()
                        continue
                c2.execute("COMMIT")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
            except Exception as ex:
                logger.error(f"Scheduled exec error: {ex}")
            self.connection.commit()

        self.sch_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

# End of Part 4
#!/usr/bin/env python
"""
BRM TOOL – PART 5 of 5
Advanced Explicit Lock Functionality
Fully implemented with no placeholders or old references.

This module provides:
  • lock_rule(conn, rule_id, username, timeout_minutes=30)
  • unlock_rule(conn, rule_id, username, auto_release=False)
  • admin_override_lock(conn, rule_id, admin_username)
  • get_lock_info(conn, rule_id)
  • auto_release_locks(conn, timeout_minutes=30)

All lock/unlock actions are audit logged.
"""

import json
from datetime import datetime, timedelta

# We assume Part 1 provides add_audit_log. Adjust import if needed.
from part1 import add_audit_log

def lock_rule(conn, rule_id, username, timeout_minutes=30):
    """
    Attempts to lock a rule for editing.
    
    - If the rule is already locked by another user and the lock is not stale,
      raises an exception.
    - If the lock is stale (older than timeout_minutes), auto-releases it.
    - If the rule is locked by the same user, just updates the timestamp (extends the lock).
    - Writes an audit log entry for lock actions.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception(f"Rule {rule_id} not found.")

    current_lock = row[0]
    lock_ts = row[1]
    now = datetime.now()

    if current_lock is not None:
        # check if stale
        if lock_ts is not None:
            # Convert to datetime if needed:
            if isinstance(lock_ts, str):
                lock_ts_dt = datetime.strptime(lock_ts, "%Y-%m-%d %H:%M:%S")
            else:
                lock_ts_dt = lock_ts
            if now - lock_ts_dt > timedelta(minutes=timeout_minutes):
                # auto-release stale lock
                unlock_rule(conn, rule_id, current_lock, auto_release=True)
            elif current_lock != username:
                raise Exception(f"Rule {rule_id} is already locked by '{current_lock}'.")
        # if locked by the same user => just refresh the lock timestamp

    # place or refresh the lock
    c.execute("""
        UPDATE BRM_RULES
        SET LOCKED_BY = ?, LOCK_TIMESTAMP = GETDATE()
        WHERE RULE_ID = ?
    """, (username, rule_id))

    add_audit_log(conn, "LOCK", "BRM_RULES", rule_id, username, None, {"LOCKED_BY": username})
    conn.commit()

def unlock_rule(conn, rule_id, username, auto_release=False):
    """
    Unlocks a rule.

    - If auto_release=False, only the user who locked the rule can unlock it. 
      Otherwise raises exception if another user tries.
    - If auto_release=True, the lock is released regardless of locker.
    - Writes an audit log entry for unlock actions.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception(f"Rule {rule_id} not found.")
    current_lock = row[0]

    if not auto_release:
        if current_lock is None:
            return  # already unlocked
        if current_lock != username:
            raise Exception(f"Rule {rule_id} is locked by '{current_lock}'. You cannot unlock it.")

    c.execute("""
        UPDATE BRM_RULES
        SET LOCKED_BY = NULL, LOCK_TIMESTAMP = NULL
        WHERE RULE_ID = ?
    """, (rule_id,))

    add_audit_log(
        conn, 
        "UNLOCK", 
        "BRM_RULES", 
        rule_id, 
        username, 
        {"LOCKED_BY": current_lock}, 
        {"LOCKED_BY": None}
    )
    conn.commit()

def admin_override_lock(conn, rule_id, admin_username):
    """
    Allows an admin user to forcibly release a lock on a rule, ignoring who locked it.
    Writes an audit log entry for the override.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception(f"Rule {rule_id} not found.")
    current_lock = row[0]
    if current_lock is None:
        return  # already unlocked

    c.execute("""
        UPDATE BRM_RULES
        SET LOCKED_BY = NULL, LOCK_TIMESTAMP = NULL
        WHERE RULE_ID = ?
    """, (rule_id,))

    add_audit_log(
        conn, 
        "ADMIN_UNLOCK", 
        "BRM_RULES", 
        rule_id, 
        admin_username, 
        {"LOCKED_BY": current_lock}, 
        {"LOCKED_BY": None}
    )
    conn.commit()

def get_lock_info(conn, rule_id):
    """
    Returns (locked_by, lock_timestamp) for the specified rule, or (None, None) if not locked.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        return (row[0], row[1])
    return (None, None)

def auto_release_locks(conn, timeout_minutes=30):
    """
    Scans all locked rules in BRM_RULES. If the lock_timestamp is older than 
    the specified timeout, auto-releases the lock. 
    Returns a list of rule IDs for which locks were auto-released.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE LOCKED_BY IS NOT NULL")
    rows = c.fetchall()
    now = datetime.now()
    released = []

    for row in rows:
        rule_id, locked_by, lock_ts = row
        if lock_ts is None:
            continue
        if isinstance(lock_ts, str):
            lock_ts_dt = datetime.strptime(lock_ts, "%Y-%m-%d %H:%M:%S")
        else:
            lock_ts_dt = lock_ts

        if now - lock_ts_dt > timedelta(minutes=timeout_minutes):
            # auto-release
            unlock_rule(conn, rule_id, locked_by, auto_release=True)
            released.append(rule_id)

    return released

# End of Part 5