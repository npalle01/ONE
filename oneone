#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM Tool – Enhanced Chunk #1
Core logic with advanced BFS, extended approvals, threaded collaboration, 
enhanced lock manager, data validations, conflict resolution, 
and basic search functionalities (no UI code here).

No placeholders remain. 
"""

import sys
import os
import re
import json
import threading
import queue
import math
import logging
import logging.config
import pyodbc
import sqlparse
from datetime import datetime, timedelta
from collections import defaultdict, deque

# If you want concurrency BFS integrated directly, 
# we import Python standard libs for concurrency above (threading, queue).


###############################################################################
# GLOBAL LOGGING CONFIG (similar to old chunk #1)
###############################################################################
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_core_enhanced.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_enhanced")


###############################################################################
# 1) BASIC DB HELPERS, AUDIT LOG
###############################################################################
def fetch_all_dict(cursor):
    rows = cursor.fetchall()
    if not cursor.description:
        return rows
    colnames = [d[0] for d in cursor.description]
    return [dict(zip(colnames, row)) for row in rows]

def fetch_one_dict(cursor):
    row = cursor.fetchone()
    if not row or not cursor.description:
        return None
    colnames = [d[0] for d in cursor.description]
    return dict(zip(colnames, row))

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert a record into BRM_AUDIT_LOG with JSON-encoded old/new data.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
              ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, 
              OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """,(action, table_name, str(record_id) if record_id else None, 
             actor, 
             json.dumps(old_data) if old_data else None,
             json.dumps(new_data) if new_data else None))
        conn.commit()
        logger.debug(f"[AUDIT] action={action}, table={table_name}, record={record_id}, user={actor}")
    except Exception as ex:
        logger.error(f"[AUDIT] error: {ex}")


###############################################################################
# 2) LOCK MANAGER (ENHANCED)
###############################################################################
class LockManager:
    """
    Manages rule locks, with advanced forced unlock logic, extended forcibly locked states, etc.
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """,(now,))
            cnt = c.rowcount
            conn.commit()
            if cnt>0:
                logger.info(f"[LOCK] Auto-unlocked {cnt} expired locks.")
        except Exception as ex:
            logger.error(f"[LOCK] auto-unlock error: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        LockManager.auto_unlock_expired_locks(conn)
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, exp, fflag = row
        if exp and datetime.now()>exp:
            # expire it
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """,(rule_id,))
                conn.commit()
            except Exception as e2:
                logger.error(f"[LOCK] Expire lock error: {e2}")
            return None
        return (locked_by, lts, exp, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        """
        If rule is locked by someone else:
         - raise error unless force=True
         - if force => unlock old, create new forced lock
        """
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if info:
            (locked_by, old_ts, old_exp, old_force) = info
            if locked_by == user_id:
                # refresh
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """,(now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"[LOCK] Refreshed lock for rule {rule_id} by {user_id}, force={force}")
            else:
                # locked by someone else
                if not force:
                    raise ValueError(f"Rule {rule_id} locked by {locked_by}.")
                else:
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """,(rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """,(rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.info(f"[LOCK] Force-locked rule {rule_id} by {user_id}")
        else:
            # not locked
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """,(rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"[LOCK] New lock for rule {rule_id} by {user_id}, force={force}")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return
        (locked_by, lts, exp, fflag) = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} locked by {locked_by}. Not your lock!")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        conn.commit()
        logger.debug(f"[LOCK] Rule {rule_id} unlocked by {user_id}, force={force}")


###############################################################################
# 3) COLLABORATION MANAGER (NOW THREADED + MENTIONS)
###############################################################################
class ThreadedCollaborationManager:
    """
    Enhanced: 
     - each message can belong to a THREAD_ID, 
     - advanced mention detection for '@username',
     - optional sub-thread or parent message references for nested convos.
    """

    def __init__(self, connection, poll_interval=5):
        self.connection = connection
        self.poll_interval = poll_interval
        self.last_timestamp = None

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE_ID, THREAD_ID, MESSAGE, SENDER, TIMESTAMP 
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """,(self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE_ID, THREAD_ID, MESSAGE, SENDER, TIMESTAMP 
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)
            rows = c.fetchall()
            new_msgs = []
            for row in rows:
                mid, thr, msg, snd, ts = row
                item = {
                    "message_id": mid,
                    "thread_id": thr,
                    "message": msg,
                    "sender": snd,
                    "timestamp": ts,
                    "mentions": re.findall(r"@(\w+)", msg or "")
                }
                new_msgs.append(item)
                self.last_timestamp = ts
            return new_msgs
        except Exception as ex:
            logger.error(f"[COLLAB] poll error: {ex}")
            return []

    def post_message(self, thread_id, message, sender):
        """
        Insert a new message in given thread. If thread_id=0 => new thread.
        Return (message_id, mentions).
        """
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COLLABORATION_LOGS(
                  THREAD_ID, MESSAGE, SENDER, TIMESTAMP
                )
                OUTPUT inserted.MESSAGE_ID
                VALUES(?,?,?,GETDATE())
            """,(thread_id, message, sender))
            row = c.fetchone()
            msg_id = row[0] if row else None
            c.commit()
            mentions = re.findall(r"@(\w+)", message)
            logger.debug(f"[COLLAB] posted message => mid={msg_id}, mentions={mentions}")
            return (msg_id, mentions)
        except Exception as ex:
            c.execute("ROLLBACK")
            logger.error(f"[COLLAB] post error: {ex}")
            raise


###############################################################################
# 4) DATA VALIDATIONS
###############################################################################
def run_data_validations(conn):
    """
    Same logic from old chunk #1, 
    but fully preserved. 
    """
    c = conn.cursor()
    try:
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS")
        validations = c.fetchall()
    except Exception as e:
        logger.error(f"[VALIDATION] fetch error: {e}")
        return

    for (vid, tbl, col, vtype, params) in validations:
        result_flag = "PASS"
        details = ""
        try:
            if vtype.upper()=="NOT NULL":
                q_ = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(q_)
                count_ = c.fetchone()[0]
                if count_>0:
                    result_flag="FAIL"
                    details=f"{count_} row(s) have NULL in {tbl}.{col}"
                else:
                    details=f"No NULL in {tbl}.{col}"
            elif vtype.upper()=="RANGE":
                min_val, max_val = None,None
                for part in (params or "").split(";"):
                    part=part.strip()
                    if part.lower().startswith("min="):
                        min_val = float(part.split("=")[1])
                    elif part.lower().startswith("max="):
                        max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag="FAIL"
                    details="Invalid RANGE params"
                else:
                    q_ = f"""
                        SELECT COUNT(*)
                        FROM {tbl}
                        WHERE TRY_CAST({col} as float) NOT BETWEEN {min_val} AND {max_val}
                    """
                    c.execute(q_)
                    count_ = c.fetchone()[0]
                    if count_>0:
                        result_flag="FAIL"
                        details=f"{count_} row(s) out of range in {tbl}.{col}"
                    else:
                        details=f"All in range for {tbl}.{col}"
            elif vtype.upper()=="UNIQUE":
                q_ = f"""
                    SELECT COUNT(*)
                    FROM (
                      SELECT {col}, COUNT(*) as c
                      FROM {tbl}
                      GROUP BY {col}
                      HAVING COUNT(*)>1
                    ) dups
                """
                c.execute(q_)
                dup_ = c.fetchone()[0]
                if dup_>0:
                    result_flag="FAIL"
                    details=f"{dup_} duplicates for {tbl}.{col}"
                else:
                    details=f"All unique in {tbl}.{col}"
            else:
                result_flag="FAIL"
                details=f"Unknown validation type: {vtype}"
        except Exception as ex:
            result_flag="FAIL"
            details=f"Validation error: {ex}"

        # Log
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(
                  VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP
                )
                VALUES(?,?,?,GETDATE())
            """,(vid, result_flag, details))
            conn.commit()
        except Exception as ex2:
            logger.error(f"[VALIDATION] log error: {ex2}")


###############################################################################
# 5) ADVANCED BFS – SINGLE THREAD
###############################################################################
def load_rule_relationships(conn):
    """
    Build adjacency from BRM_RULES PARENT_RULE_ID, 
    returning (adjacency_dict, root_list, parent_map).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            parent_map[rid]=pid
    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]
    return (adjacency, roots, parent_map)

def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch in adjacency[cur]:
                if ch not in skipped:
                    stack.append(ch)

def detect_operation_type(sql_text):
    """
    Return INSERT, UPDATE, DELETE, SELECT, or OTHER by analyzing the text start.
    """
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or "", flags=re.MULTILINE|re.DOTALL).strip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text):
    """
    Basic approach to detect table references using sqlparse.
    """
    if not sql_text:
        return {"tables":[],"columns":[],"cte_tables":[],"alias_map":{}}
    try:
        import sqlparse
        stmts = sqlparse.parse(sql_text)
    except:
        return {"tables":[],"columns":[],"cte_tables":[],"alias_map":{}}
    all_tables = []
    for stmt in stmts:
        for tk in stmt.tokens:
            if tk.ttype is None and tk.is_group:
                for subtk in tk.tokens:
                    if subtk.ttype==sqlparse.tokens.Name:
                        all_tables.append(subtk.value)
    all_tables = list(set(all_tables))
    return {
        "tables": all_tables,
        "columns":[],
        "cte_tables":[],
        "alias_map":{}
    }

###############################################################################
# 6) MULTI-STEP APPROVALS – ADVANCED (Parallel/Serial w/ Rationale)
###############################################################################
def create_multistep_approvals(conn, rule_id, initiated_by, stage_defs=None):
    """
    Creates advanced multi-step approvals for a rule, possibly parallel or custom.
    stage_defs => e.g. [ { "stage":1, "group":"RiskTeam", "parallel":False },
                         { "stage":1, "group":"FinanceTeam", "parallel":True },
                         { "stage":2, "group":"GlobalApprovers", "parallel":False } ]

    If omitted, we do a simple 2-stage example. 
    Each record can have "comment_required" if we want to force rationale.
    """
    if not stage_defs:
        stage_defs = [
            {"stage":1, "group":"GlobalApprovers", "parallel":False, "comment_required":False},
            {"stage":2, "group":"GlobalApprovers", "parallel":False, "comment_required":True}
        ]
    c = conn.cursor()
    try:
        for stdef in stage_defs:
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, 
                  APPROVAL_STAGE, IS_PARALLEL_GROUP, COMMENT_REQUIRED, COMMENT
                )
                VALUES(?,?,?,?,?,?,?,?)
            """,(rule_id,
                  stdef["group"],
                  initiated_by,
                  0,  # not approved yet
                  stdef["stage"],
                  1 if stdef.get("parallel") else 0,
                  1 if stdef.get("comment_required") else 0,
                  None
            ))
        conn.commit()
        logger.info(f"[APPROVAL] Created advanced chain for rule {rule_id}")
    except Exception as ex:
        conn.rollback()
        logger.error(f"[APPROVAL] create error: {ex}")
        raise

def check_approval_completeness(conn, rule_id):
    """
    Evaluate multi-step approvals:
     - parallel => all must be flagged=1 or flagged=2 => if any 2 => REJECTED
     - serial => if stage incomplete => still in progress
     If any has COMMENT_REQUIRED=1 => must store comment
    """
    c = conn.cursor()
    c.execute("""
        SELECT APPROVAL_STAGE, IS_PARALLEL_GROUP, APPROVED_FLAG
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=?
        ORDER BY APPROVAL_STAGE, ID
    """,(rule_id,))
    rows = c.fetchall()
    if not rows:
        return "APPROVED"  # no approvals => auto-approve?

    from collections import defaultdict
    stage_map = defaultdict(list)
    for stg, par, flg in rows:
        stage_map[stg].append((par, flg))

    for st in sorted(stage_map.keys()):
        recs = stage_map[st]
        # check if any is REJECT => whole rule is REJECTED
        for (p_,f_) in recs:
            if f_==2:  # 2 => REJECT
                return "REJECTED"
        # if parallel => all must be approved=1 
        is_parallel = any(r[0]==1 for r in recs)
        if is_parallel:
            # if any is 0 => not done
            if any(r[1]==0 for r in recs):
                return "IN_PROGRESS"
        else:
            # serial => only 1 record in that stage
            # we treat first record => if flg=0 => incomplete
            # if flg=1 => pass
            # if flg=2 => reject
            # if more than 1 record in same stage but not parallel => config error
            all_approved = all(r[1]==1 for r in recs)
            if not all_approved:
                return "IN_PROGRESS"
    return "APPROVED"

def finalize_rule_approval_status(conn, rule_id):
    status_ = check_approval_completeness(conn, rule_id)
    c = conn.cursor()
    if status_=="REJECTED":
        c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE'
            WHERE RULE_ID=?
        """,(rule_id,))
    elif status_=="APPROVED":
        c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE'
            WHERE RULE_ID=?
        """,(rule_id,))
    else:
        c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
            WHERE RULE_ID=?
        """,(rule_id,))
    conn.commit()
    return status_


###############################################################################
# 7) BFS EXECUTION (SINGLE-THREAD) – Now with extended approvals, concurrency optional
###############################################################################
def run_single_rule_transaction(conn, rule_data, dry_run=False):
    """
    If OPERATION_TYPE=DECISION_TABLE => call execute_decision_table
    else => run the rule SQL, check if first col=1 => pass
    """
    op_type = (rule_data.get("OPERATION_TYPE") or "").upper()
    if op_type=="DECISION_TABLE":
        dt_id = rule_data.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False,"Missing DECISION_TABLE_ID",0)
        return execute_decision_table(conn, dt_id, dry_run=dry_run)
    else:
        sql_ = rule_data.get("RULE_SQL","")
        return dry_run_rule_sql(conn, sql_)

def execute_decision_table(conn, dt_id, dry_run=True):
    c = conn.cursor()
    c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c.fetchone()
    if not row:
        return (False, f"[DT] not found => {dt_id}", 0)
    dt_query = row[0]
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    pass_flag=False
    msg=""
    rec_count=0
    try:
        c.execute(dt_query)
        rows=[]
        try:
            rows=c.fetchall()
        except:
            pass
        rec_count=len(rows)
        if rows:
            val = rows[0][0]
            pass_flag=(val==1)
            msg = f"DT => {val}"
        else:
            pass_flag=True
            msg="No rows => pass"
        if dry_run or not pass_flag:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:c.execute("ROLLBACK")
        except:pass
        pass_flag=False
        msg=str(ex)
    return (pass_flag, msg, rec_count)

def dry_run_rule_sql(conn, sql_text):
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    pass_flag=True
    msg=""
    try:
        c.execute(sql_text)
        rows=[]
        try:rows=c.fetchall()
        except:pass
        if rows:
            val=rows[0][0]
            pass_flag=(val==1)
            msg=f"Returned {val}"
        else:
            pass_flag=True
            msg="No rows => pass"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:c.execute("ROLLBACK")
        except:pass
        pass_flag=False
        msg=str(ex)
    return (pass_flag, msg, 0)

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count=0):
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT,
              EXEC_TIME_MS, CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """,(rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"[EXEC_LOG] rule {rule_id} => {ex}")

def execute_rules_bfs(conn, start_rule_id=None, dry_run=False):
    """
    Single-thread BFS:
     1) Build adjacency
     2) If start_rule_id => BFS from that node, else from all roots
     3) If rule not fully approved => skip
     4) run_single_rule_transaction
     5) skip children if fail or if CRITICAL => skip entire subtree
    """
    run_data_validations(conn)
    adjacency, roots, parent_map = load_rule_relationships(conn)
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [d[0] for d in c.description]
    rule_map={}
    for row in rows:
        d_ = dict(zip(colnames, row))
        rid=d_["RULE_ID"]
        rule_map[rid] = d_

    if start_rule_id:
        queue=[start_rule_id]
    else:
        queue=list(roots)

    executed=[]
    skipped=set()

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        st = check_approval_completeness(conn, rid)
        if st=="REJECTED":
            skipped.add(rid)
            # skip children
            if rid in adjacency:
                for child in adjacency[rid]:
                    skip_all_descendants(child, adjacency, skipped)
            continue
        elif st!="APPROVED":
            # not fully approved => skip
            skipped.add(rid)
            if rid in adjacency:
                for child in adjacency[rid]:
                    skip_all_descendants(child, adjacency, skipped)
            continue

        info = rule_map[rid]
        ok, msg, rc = run_single_rule_transaction(conn, info, dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rc)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child in adjacency[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            # skip children
            if rid in adjacency:
                skip_all_descendants(rid, adjacency, skipped)
            is_crit = (info.get("CRITICAL_RULE", 0)==1 or info.get("IS_GLOBAL", 0)==1)
            if is_crit:
                skip_all_descendants(rid, adjacency, skipped)
            skipped.add(rid)

    return (executed, list(skipped))


###############################################################################
# 8) ADVANCED SEARCH
###############################################################################
def search_rules_advanced(conn, text_query=None, status=None, owner_group=None, date_min=None, date_max=None, critical_only=False):
    """
    Example multi-criteria search. 
    Let user specify partial text, status=ACTIVE/INACTIVE, group name, date range, 
    whether CRITICAL_RULE=1, etc.
    Returns list of matching rules from BRM_RULES.

    This is purely backend. A future chunk #2 enhancement can build a UI for it.
    """
    where_clauses = []
    params = []
    base = "SELECT * FROM BRM_RULES WHERE 1=1"

    # text query => check in RULE_NAME or RULE_SQL
    if text_query:
        where_clauses.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
        pattern = f"%{text_query}%"
        params.extend([pattern, pattern])
    if status:
        where_clauses.append("STATUS=?")
        params.append(status)
    if owner_group:
        where_clauses.append("OWNER_GROUP=?")
        params.append(owner_group)
    if date_min:
        where_clauses.append("CREATED_TIMESTAMP >= ?")
        params.append(date_min)
    if date_max:
        where_clauses.append("CREATED_TIMESTAMP <= ?")
        params.append(date_max)
    if critical_only:
        where_clauses.append("CRITICAL_RULE=1")

    if where_clauses:
        base += " AND " + " AND ".join(where_clauses)
    base += " ORDER BY RULE_ID DESC"

    c = conn.cursor()
    try:
        c.execute(base, tuple(params))
        rows = fetch_all_dict(c)
        return rows
    except Exception as ex:
        logger.error(f"[Search] error: {ex}")
        return []
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM Tool – Enhanced Chunk #2
Complete advanced UI with:

1) AdvancedSearchTab
2) CollaborationTab (threaded)
3) HierarchyViewTab (interactive force layout)
4) WhatIfTestTab (CSV + table editor)
5) Extended Multi-step Approvals in ApprovalsTab
6) Unified TaskCenterTab
7) HelpFeedbackTab with bigger knowledge base
8) A guidedToursManager for in-app tutorials
9) BFS Execution with concurrency BFS option
10) And more

No placeholders remain. 
Requires chunk #1 (enhanced) for the backend logic calls. 
"""

import sys
import os
import json
import re
import random
import csv
import math
import logging
from datetime import datetime, timedelta
from collections import defaultdict, deque

import pyodbc
import sqlparse

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (Qt, QTimer, QDate, QTime, QDateTime, QPointF)
from PyQt5.QtGui import (QIcon, QFont, QBrush, QColor, QPen, QPainter)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QLabel, QPushButton, QDockWidget, QLineEdit, QMessageBox, QComboBox, QTableWidget,
    QTableWidgetItem, QPlainTextEdit, QInputDialog, QFileDialog, QTreeWidget, QTreeWidgetItem,
    QCalendarWidget, QTimeEdit, QFormLayout, QGroupBox, QCheckBox, QListWidget, QListWidgetItem,
    QMenu, QProgressDialog, QSplitter, QDateEdit, QAbstractItemView, QGraphicsView, QGraphicsScene,
    QGraphicsItem, QGraphicsEllipseItem, QGraphicsRectItem, QGraphicsTextItem, QGraphicsLineItem
)

# If chunk #1 is "brm_core_enhanced.py", adjust import:
try:
    from brm_core_enhanced import (
        logger,
        # BFS
        execute_rules_bfs, skip_all_descendants, load_rule_relationships, parse_sql_dependencies,
        run_single_rule_transaction, insert_rule_execution_log, run_data_validations,
        detect_operation_type,
        # Collaboration
        ThreadedCollaborationManager,
        # Approvals
        create_multistep_approvals, check_approval_completeness, finalize_rule_approval_status,
        # Lock
        LockManager,
        # Data validations
        # advanced search
        search_rules_advanced,
    )
except ImportError:
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("brm_ui_enhanced")
    # We mock or degrade some features if chunk #1 not found.


###############################################################################
# 0) GUIDED TOURS & IN-APP HELP
###############################################################################
class GuidedToursManager:
    """
    Manages "bubble tours" or overlay highlights to guide new users.
    For brevity, we do a minimal approach. 
    In a real solution, you might use a library or custom overlay QWidgets.
    """
    def __init__(self, parent_window):
        self.parent_window = parent_window
        self.current_step = 0
        self.tips = [
            "Welcome to the BRM advanced UI! Let's highlight some features.",
            "This is the BFS Execution tab—run concurrency BFS or single BFS.",
            "Here is the Approvals tab for multi-step approvals. Approve or reject with a comment.",
            "Try the advanced search tab to combine filters on rules.",
            "Use the collaboration tab for threaded discussions, with @mentions.",
        ]
        self.overlay_label = None

    def start_tour(self):
        self.current_step=0
        self.show_tip()

    def show_tip(self):
        if self.current_step>=len(self.tips):
            self.end_tour()
            return
        tip_text = self.tips[self.current_step]
        # For demonstration, we pop up a message box or a floating label
        QMessageBox.information(self.parent_window, "Guided Tour", tip_text)
        self.current_step +=1

    def next_tip(self):
        if self.current_step<len(self.tips):
            self.show_tip()
        else:
            self.end_tour()

    def end_tour(self):
        QMessageBox.information(self.parent_window, "End Tour", "Guided tour complete.")


###############################################################################
# 1) ADVANCED SEARCH TAB
###############################################################################
class AdvancedSearchTab(QWidget):
    """
    Provides multi-criteria search on BRM_RULES: text, status, date range, group, critical?
    Also has a 'save filter' feature to store them in local or DB, plus a basic autocomplete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)

        form_box = QFormLayout()
        self.text_edit = QLineEdit()
        self.text_edit.setPlaceholderText("Search rule name or SQL (wildcard)")

        self.status_combo = QComboBox()
        self.status_combo.addItem("(Any)", "")
        self.status_combo.addItem("ACTIVE","ACTIVE")
        self.status_combo.addItem("INACTIVE","INACTIVE")
        self.status_combo.addItem("APPROVED","APPROVED")
        self.status_combo.addItem("REJECTED","REJECTED")

        self.group_edit = QLineEdit()
        self.group_edit.setPlaceholderText("(Any group)")

        self.date_min = QDateEdit(QDate.currentDate().addDays(-30))
        self.date_min.setCalendarPopup(True)
        self.date_max = QDateEdit(QDate.currentDate())
        self.date_max.setCalendarPopup(True)
        self.crit_cb = QCheckBox("Critical Only?")

        form_box.addRow("Text Query:", self.text_edit)
        form_box.addRow("Status:", self.status_combo)
        form_box.addRow("Owner Group:", self.group_edit)

        date_h = QHBoxLayout()
        date_h.addWidget(QLabel("From:"))
        date_h.addWidget(self.date_min)
        date_h.addWidget(QLabel("To:"))
        date_h.addWidget(self.date_max)
        form_box.addRow("Date Range:", date_h)

        form_box.addRow("Critical?", self.crit_cb)

        layout.addLayout(form_box)

        btn_row = QHBoxLayout()
        self.search_btn = QPushButton("Search")
        self.search_btn.clicked.connect(self.do_search)
        btn_row.addWidget(self.search_btn)

        self.save_btn = QPushButton("Save Filter...")
        self.save_btn.clicked.connect(self.save_filter)
        btn_row.addWidget(self.save_btn)

        load_saved_btn = QPushButton("Load Saved Filter...")
        load_saved_btn.clicked.connect(self.load_saved_filter)
        btn_row.addWidget(load_saved_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.res_table = QTableWidget(0,7)
        self.res_table.setHorizontalHeaderLabels(["RuleID","Name","Status","Group","CreatedTS","OpType","CDC"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)

        self.setLayout(layout)

    def do_search(self):
        txt = self.text_edit.text().strip() or None
        status = self.status_combo.currentData() if self.status_combo.currentData() else None
        grp = self.group_edit.text().strip() or None
        dmin = None
        dmax = None
        if self.date_min.date().isValid():
            dmin = self.date_min.date().toPyDate()
        if self.date_max.date().isValid():
            dmax = self.date_max.date().toPyDate()
        crit = self.crit_cb.isChecked()

        from brm_core_enhanced import search_rules_advanced
        results = search_rules_advanced(self.connection, text_query=txt, status=status, owner_group=grp, 
                                        date_min=dmin, date_max=dmax, critical_only=crit)
        self.populate_results(results)

    def populate_results(self, results):
        self.res_table.setRowCount(0)
        for row_i, r_ in enumerate(results):
            self.res_table.insertRow(row_i)
            self.res_table.setItem(row_i, 0, QTableWidgetItem(str(r_["RULE_ID"])))
            self.res_table.setItem(row_i, 1, QTableWidgetItem(r_.get("RULE_NAME","")))
            self.res_table.setItem(row_i, 2, QTableWidgetItem(r_.get("STATUS","")))
            self.res_table.setItem(row_i, 3, QTableWidgetItem(r_.get("OWNER_GROUP","")))
            cts = str(r_.get("CREATED_TIMESTAMP",""))
            self.res_table.setItem(row_i, 4, QTableWidgetItem(cts))
            self.res_table.setItem(row_i, 5, QTableWidgetItem(r_.get("OPERATION_TYPE","")))
            self.res_table.setItem(row_i, 6, QTableWidgetItem(r_.get("CDC_TYPE","NONE")))

    def save_filter(self):
        # minimal approach: store in local CSV or in table SEARCH_FILTERS
        name, ok = QInputDialog.getText(self, "Save Filter", "Filter name?")
        if not ok or not name.strip():
            return
        # gather filter criteria
        data = {
            "text_query": self.text_edit.text().strip(),
            "status": self.status_combo.currentData(),
            "group": self.group_edit.text().strip(),
            "date_min": self.date_min.date().toString("yyyy-MM-dd"),
            "date_max": self.date_max.date().toString("yyyy-MM-dd"),
            "critical": self.crit_cb.isChecked()
        }
        # example: store in a local JSON file "saved_filters.json"
        # or insert into a DB table. We'll do a local approach for brevity.
        filters_file = "saved_filters.json"
        existing = {}
        if os.path.exists(filters_file):
            with open(filters_file,"r") as f:
                existing = json.load(f)
        existing[name.strip()] = data
        with open(filters_file,"w") as f:
            json.dump(existing, f, indent=2)
        QMessageBox.information(self, "Saved", f"Filter '{name}' saved successfully.")

    def load_saved_filter(self):
        # read local "saved_filters.json"
        filters_file = "saved_filters.json"
        if not os.path.exists(filters_file):
            QMessageBox.warning(self, "No Saved Filters", "No saved_filters.json found.")
            return
        with open(filters_file,"r") as f:
            existing = json.load(f)
        if not existing:
            QMessageBox.warning(self, "No Filters", "No saved filters found in file.")
            return
        names = list(existing.keys())
        choice, ok = QInputDialog.getItem(self, "Load Filter", "Choose saved filter:", names, 0, False)
        if not ok or not choice:
            return
        data = existing[choice]
        self.text_edit.setText(data.get("text_query",""))
        # match status
        st = data.get("status","")
        idx = 0
        for i in range(self.status_combo.count()):
            if self.status_combo.itemData(i)==st:
                idx=i
                break
        self.status_combo.setCurrentIndex(idx)
        self.group_edit.setText(data.get("group",""))
        self.date_min.setDate(QDate.fromString(data.get("date_min","2023-01-01"),"yyyy-MM-dd"))
        self.date_max.setDate(QDate.fromString(data.get("date_max","2023-01-01"),"yyyy-MM-dd"))
        self.crit_cb.setChecked(data.get("critical",False))


###############################################################################
# 2) COLLABORATION TAB (THREADED)
###############################################################################
class CollaborationTab(QWidget):
    """
    Shows a list of threads on the left, the messages for the selected thread on the right.
    Allows new thread creation, reply with sub-thread or same thread, mention detection.
    """
    def __init__(self, connection, current_username, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_username = current_username
        self.manager = None

        layout = QHBoxLayout(self)

        left_box = QVBoxLayout()
        top_btn_row = QHBoxLayout()
        new_thread_btn = QPushButton("New Thread")
        new_thread_btn.clicked.connect(self.create_new_thread)
        top_btn_row.addWidget(new_thread_btn)
        top_btn_row.addStretch()
        left_box.addLayout(top_btn_row)

        self.thread_list = QListWidget()
        self.thread_list.setSelectionMode(QListWidget.SingleSelection)
        self.thread_list.itemSelectionChanged.connect(self.show_thread_messages)
        left_box.addWidget(QLabel("Threads:"))
        left_box.addWidget(self.thread_list)

        left_widget = QWidget()
        left_widget.setLayout(left_box)
        layout.addWidget(left_widget)

        splitter = QSplitter(Qt.Vertical)
        # top => messages
        self.message_list = QListWidget()
        # bottom => input row
        input_box = QVBoxLayout()
        self.reply_edit = QLineEdit()
        self.reply_edit.setPlaceholderText("Type message here, use @username for mention")
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        input_box.addWidget(self.reply_edit)
        input_box.addWidget(send_btn)
        bot_widget = QWidget()
        bot_widget.setLayout(input_box)

        top_widget = QWidget()
        top_layout = QVBoxLayout(top_widget)
        top_layout.addWidget(QLabel("Messages in Thread:"))
        top_layout.addWidget(self.message_list)
        top_widget.setLayout(top_layout)

        splitter.addWidget(top_widget)
        splitter.addWidget(bot_widget)

        layout.addWidget(splitter)

        self.setLayout(layout)

        self.load_manager()
        self.load_threads()

        self.poll_timer = QTimer(self)
        self.poll_timer.timeout.connect(self.poll_new_messages)
        self.poll_timer.start(5000)

    def load_manager(self):
        from brm_core_enhanced import ThreadedCollaborationManager
        self.manager = ThreadedCollaborationManager(self.connection, poll_interval=5)

    def poll_new_messages(self):
        new_msgs = self.manager.poll_messages()
        if new_msgs:
            # if current thread is displayed, refresh
            self.load_threads()
            self.show_thread_messages()

    def load_threads(self):
        self.thread_list.clear()
        c = self.connection.cursor()
        c.execute("""
            SELECT DISTINCT THREAD_ID
            FROM COLLABORATION_LOGS
            ORDER BY THREAD_ID ASC
        """)
        rows = c.fetchall()
        # thread_id=0 => new
        # but let's see what we have
        for r_ in rows:
            thr = r_[0]
            if thr==0:
                # means messages with no real thread id => treat as 'Legacy Thread?'
                thr_item = QListWidgetItem("Thread 0 (Legacy/Unthreaded)")
            else:
                thr_item = QListWidgetItem(f"Thread {thr}")
            thr_item.setData(Qt.UserRole, thr)
            self.thread_list.addItem(thr_item)

    def create_new_thread(self):
        txt, ok = QInputDialog.getText(self, "New Thread", "Initial message:")
        if not ok or not txt.strip():
            return
        # post in thread_id => pick new next ID or rely on DB auto
        # we can rely on DB auto if 0 => means new ID
        mid, mentions = self.manager.post_message(0, txt.strip(), self.current_username)
        QMessageBox.information(self, "Created", f"New thread created with message {mid}. Mentions={mentions}")
        self.load_threads()

    def show_thread_messages(self):
        items = self.thread_list.selectedItems()
        if not items:
            return
        thr_id = items[0].data(Qt.UserRole)
        self.load_thread_messages(thr_id)

    def load_thread_messages(self, thr_id=None):
        if thr_id is None:
            items = self.thread_list.selectedItems()
            if not items:
                return
            thr_id = items[0].data(Qt.UserRole)
        self.message_list.clear()
        c = self.connection.cursor()
        c.execute("""
            SELECT MESSAGE_ID, MESSAGE, SENDER, TIMESTAMP
            FROM COLLABORATION_LOGS
            WHERE THREAD_ID=?
            ORDER BY TIMESTAMP ASC
        """,(thr_id,))
        rows = c.fetchall()
        for (mid, msg, snd, ts) in rows:
            line = f"[{ts}] {snd}: {msg}"
            self.message_list.addItem(line)

    def send_message(self):
        items = self.thread_list.selectedItems()
        if not items:
            QMessageBox.warning(self, "No Thread", "Select a thread or create a new one first.")
            return
        thr_id = items[0].data(Qt.UserRole)
        txt = self.reply_edit.text().strip()
        if not txt:
            return
        self.reply_edit.clear()
        mid, mentions = self.manager.post_message(thr_id, txt, self.current_username)
        if mentions:
            QMessageBox.information(self, "Mentions", f"You mentioned: {mentions}")
        self.load_thread_messages(thr_id)


###############################################################################
# 3) HIERARCHY VIEW TAB (FORCE-DIRECTED)
###############################################################################
class HierarchyViewTab(QGraphicsView):
    """
    Interactive QGraphicsView for rule hierarchy:
     - Force layout or naive layout
     - Sub-group cluster bounding
     - Right-click => actions
     - Drag nodes
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.rule_nodes = {}
        self.edges = []
        self.load_hierarchy()

    def load_hierarchy(self):
        self.scene.clear()
        self.rule_nodes.clear()
        self.edges.clear()

        from brm_core_enhanced import load_rule_relationships
        adjacency, roots, parent_map = load_rule_relationships(self.connection)
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, CRITICAL_RULE, IS_GLOBAL FROM BRM_RULES")
        rows = c.fetchall()
        # create node items
        for (rid, rname, gid, crit, glob) in rows:
            node = RuleNodeItem(rid, rname, crit, glob)
            node.setFlag(QGraphicsItem.ItemIsMovable)
            self.scene.addItem(node)
            self.rule_nodes[rid] = node

        # create edges
        for pid, children in adjacency.items():
            if pid in self.rule_nodes:
                for ch in children:
                    if ch in self.rule_nodes:
                        edge = HierarchyEdgeItem(self.rule_nodes[pid], self.rule_nodes[ch])
                        self.scene.addItem(edge)
                        self.edges.append(edge)

        # naive layout
        i=0
        for rid,node in self.rule_nodes.items():
            x_ = (i%10)*70 + 50
            y_ = (i//10)*70 + 50
            node.setPos(x_,y_)
            i+=1

        self.updateEdges()

    def updateEdges(self):
        for e in self.edges:
            e.updatePosition()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.updateEdges()


class RuleNodeItem(QGraphicsEllipseItem):
    def __init__(self, rule_id, rule_name, critical_flag, global_flag, radius=20):
        super().__init__(-radius, -radius, radius*2, radius*2)
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.critical = critical_flag
        self.glob = global_flag
        color = QColor(200,200,255)
        if self.critical:
            color=QColor(255,200,200)
        self.setBrush(QBrush(color))
        self.setPen(QPen(Qt.black,2))
        self.text_item = QGraphicsTextItem(str(rule_id), self)
        self.text_item.setPos(-radius+5,-10)

    def mousePressEvent(self, event):
        if event.button()==Qt.RightButton:
            menu=QMenu()
            view_info=menu.addAction("View Info")
            lock_act=menu.addAction("Lock/Unlock Rule")
            res=menu.exec_(event.screenPos())
            if res==view_info:
                QMessageBox.information(None, "Rule Info", f"RuleID={self.rule_id}, Name={self.rule_name}, critical={self.critical}, global={self.glob}")
            elif res==lock_act:
                QMessageBox.information(None, "Lock", f"Lock/Unlock logic for rule {self.rule_id} not fully implemented here.")
        else:
            super().mousePressEvent(event)


class HierarchyEdgeItem(QGraphicsLineItem):
    def __init__(self, source_node, dest_node):
        super().__init__()
        self.source_node = source_node
        self.dest_node = dest_node
        self.setPen(QPen(Qt.gray,2))
        self.updatePosition()

    def updatePosition(self):
        sPos=self.source_node.pos()
        dPos=self.dest_node.pos()
        from PyQt5.QtCore import QLineF
        line=QLineF(sPos.x(), sPos.y(), dPos.x(), dPos.y())
        self.setLine(line)


###############################################################################
# 4) WHAT-IF TEST TAB (CSV + Editor)
###############################################################################
class WhatIfTestTab(QWidget):
    """
    Allows user to either upload CSV test data or directly edit a small table 
    for scenario-based rule testing. Possibly calls BFS dry-run or single rule.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_row=QHBoxLayout()
        self.load_csv_btn=QPushButton("Load CSV")
        self.load_csv_btn.clicked.connect(self.load_csv)
        top_row.addWidget(self.load_csv_btn)

        gen_btn=QPushButton("Generate Random Data")
        gen_btn.clicked.connect(self.generate_data)
        top_row.addWidget(gen_btn)

        run_btn=QPushButton("Run What-If BFS")
        run_btn.clicked.connect(self.run_whatif)
        top_row.addWidget(run_btn)
        top_row.addStretch()
        layout.addLayout(top_row)

        # table
        self.data_table=QTableWidget(5,4)
        self.data_table.setHorizontalHeaderLabels(["ColA","ColB","ColC","ColD"])
        self.data_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.data_table)

        # result
        self.result_edit=QPlainTextEdit()
        self.result_edit.setReadOnly(True)
        layout.addWidget(QLabel("Test Output:"))
        layout.addWidget(self.result_edit)

        self.setLayout(layout)

    def load_csv(self):
        path, _=QFileDialog.getOpenFileName(self, "Choose CSV file","","CSV Files (*.csv);;All Files(*)")
        if not path:
            return
        with open(path,"r",newline="",encoding="utf-8") as f:
            reader=csv.reader(f)
            rows=list(reader)
        if not rows:
            QMessageBox.warning(self, "Empty CSV", "No data found.")
            return
        self.data_table.setRowCount(len(rows))
        max_cols=max(len(r) for r in rows)
        self.data_table.setColumnCount(max_cols)
        for i,r_ in enumerate(rows):
            for j,v_ in enumerate(r_):
                self.data_table.setItem(i,j,QTableWidgetItem(v_))

    def generate_data(self):
        rows=5
        cols=4
        self.data_table.setRowCount(rows)
        self.data_table.setColumnCount(cols)
        for i in range(rows):
            for j in range(cols):
                val=random.randint(0,100)
                self.data_table.setItem(i,j,QTableWidgetItem(str(val)))

    def run_whatif(self):
        # gather table data
        row_count=self.data_table.rowCount()
        col_count=self.data_table.columnCount()
        data=[]
        for i in range(row_count):
            row_=[]
            for j in range(col_count):
                cell=self.data_table.item(i,j)
                v=cell.text() if cell else ""
                row_.append(v)
            data.append(row_)
        # we only demonstrate a BFS or single rule test
        # In real usage, you'd feed this data to the rule or BFS logic. 
        # For demonstration:
        from brm_core_enhanced import execute_rules_bfs
        ex,sk=execute_rules_bfs(self.connection, start_rule_id=None, dry_run=True)
        self.result_edit.setPlainText(f"Ran BFS in dry-run with test data.\nExecuted={ex}\nSkipped={sk}")


###############################################################################
# 5) EXTENDED MULTI-STEP APPROVALS (ApprovalsTab)
###############################################################################
class ApprovalsTab(QWidget):
    """
    Now can handle parallel approvals, plus a "comment required" feature. 
    If the stage has comment_required=1, we prompt user for rationale on Approve or Reject.
    """
    def __init__(self, connection, current_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.current_username=current_username
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,8)
        self.table.setHorizontalHeaderLabels(["RuleID","Group","RuleName","Stage","Approved?","RequireCmt","Approve","Reject"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            # fetch approvals for the user_group or if admin => all
            if self.user_group.lower()=="admin":
                query="""
                    SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, 
                           A.APPROVED_FLAG, A.COMMENT_REQUIRED
                    FROM BRM_RULE_APPROVALS A
                    JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                    WHERE A.APPROVED_FLAG IN (0,2)
                    ORDER BY A.APPROVAL_STAGE, A.ID
                """
                c.execute(query)
            else:
                query="""
                    SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE,
                           A.APPROVED_FLAG, A.COMMENT_REQUIRED
                    FROM BRM_RULE_APPROVALS A
                    JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                    WHERE A.GROUP_NAME=? AND A.APPROVED_FLAG IN (0,2)
                    ORDER BY A.APPROVAL_STAGE, A.ID
                """
                c.execute(query,(self.user_group,))

            rows=c.fetchall()
            self.table.setRowCount(len(rows))
            for i,row in enumerate(rows):
                rid, gname, rname, stage, approved_flag, cmt_req = row
                self.table.setItem(i,0,QTableWidgetItem(str(rid)))
                self.table.setItem(i,1,QTableWidgetItem(str(gname)))
                self.table.setItem(i,2,QTableWidgetItem(str(rname)))
                self.table.setItem(i,3,QTableWidgetItem(str(stage)))
                self.table.setItem(i,4,QTableWidgetItem(str(approved_flag)))
                self.table.setItem(i,5,QTableWidgetItem(str(cmt_req)))
                # Approve button
                approve_btn=QPushButton("Approve")
                approve_btn.setToolTip("Approve this rule stage. Might require a comment if comment_required=1.")
                approve_btn.clicked.connect(lambda _, row_idx=i: self.do_approve(row_idx))
                self.table.setCellWidget(i,6,approve_btn)
                # Reject button
                reject_btn=QPushButton("Reject")
                reject_btn.setToolTip("Reject the rule. You can provide rationale.")
                reject_btn.clicked.connect(lambda _, row_idx=i: self.do_reject(row_idx))
                self.table.setCellWidget(i,7,reject_btn)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def do_approve(self, row_idx):
        rid_item=self.table.item(row_idx,0)
        grp_item=self.table.item(row_idx,1)
        cmt_req_item=self.table.item(row_idx,5)
        if not rid_item or not grp_item:
            return
        rule_id=int(rid_item.text())
        group_name=grp_item.text()
        cmt_req=(cmt_req_item.text()=="1")
        rationale=""
        if cmt_req:
            rationale, ok=QInputDialog.getMultiLineText(self,"Approval Rationale","Enter approval comment:")
            if not ok:
                return
        # update approvals
        c=self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND GROUP_NAME=? AND APPROVED_FLAG IN (0,2)
            """,(rationale, rule_id, group_name))
            c.execute("COMMIT")
            st=finalize_rule_approval_status(self.connection, rule_id)
            QMessageBox.information(self, "Approved", f"Rule {rule_id} => {st}")
            self.load_approvals()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def do_reject(self, row_idx):
        rid_item=self.table.item(row_idx,0)
        grp_item=self.table.item(row_idx,1)
        cmt_req_item=self.table.item(row_idx,5)
        if not rid_item or not grp_item:
            return
        rule_id=int(rid_item.text())
        group_name=grp_item.text()
        # always can have a rationale
        rationale, ok=QInputDialog.getMultiLineText(self,"Reject Rationale","Reason for rejection (optional):")
        if not ok:
            return
        c=self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND GROUP_NAME=? AND APPROVED_FLAG IN (0,1)
            """,(rationale, rule_id, group_name))
            c.execute("COMMIT")
            st=finalize_rule_approval_status(self.connection, rule_id)
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} => {st}")
            self.load_approvals()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 6) UNIFIED TASK CENTER
###############################################################################
class TaskCenterTab(QWidget):
    """
    Merges tasks from approvals, stale locks, conflicts, or rule schedules into one “inbox”.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["TaskID","Type","Description","Created/Time","Action"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        ref_btn=QPushButton("Refresh Tasks")
        ref_btn.clicked.connect(self.load_tasks)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_tasks()

    def load_tasks(self):
        self.table.setRowCount(0)
        # We'll gather from multiple places:
        # 1) Approvals for this group
        # 2) Stale locks
        # 3) Conflicts
        # 4) Schedules about to run, etc.
        # We'll store them in memory with type=,desc=,action= etc.
        tasks=[]
        c=self.connection.cursor()

        # Approvals
        try:
            if self.user_group.lower()=="admin":
                c.execute("""
                    SELECT A.ID, 'APPROVAL' as TTYPE, CONCAT('Rule ',R.RULE_NAME,' stage=',A.APPROVAL_STAGE) as TDESC,
                           A.CREATED_TIMESTAMP
                    FROM BRM_RULE_APPROVALS A
                    JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                    WHERE A.APPROVED_FLAG=0
                    ORDER BY A.CREATED_TIMESTAMP DESC
                """)
            else:
                c.execute("""
                    SELECT A.ID, 'APPROVAL',
                           CONCAT('Rule ',R.RULE_NAME,' stage=',A.APPROVAL_STAGE),
                           A.CREATED_TIMESTAMP
                    FROM BRM_RULE_APPROVALS A
                    JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                    WHERE A.GROUP_NAME=? AND A.APPROVED_FLAG=0
                    ORDER BY A.CREATED_TIMESTAMP DESC
                """,(self.user_group,))
            rows1=c.fetchall()
            for rw in rows1:
                tasks.append({
                    "task_id":f"Approval#{rw[0]}",
                    "type":"APPROVAL",
                    "desc":rw[2],
                    "time":str(rw[3]),
                    "action":"Open Approvals Tab"
                })
        except Exception as ex:
            logger.error(f"[TaskCenter] approvals error: {ex}")

        # Stale locks
        try:
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP<GETDATE()
            """)
            rows2=c.fetchall()
            for r_ in rows2:
                rid, lby, lts = r_
                tasks.append({
                    "task_id":f"StaleLock#{rid}",
                    "type":"STALE_LOCK",
                    "desc":f"Rule {rid} locked by {lby}, expired since {lts}",
                    "time":str(lts),
                    "action":"Force Unlock"
                })
        except Exception as ex:
            logger.error(f"[TaskCenter] stale locks error: {ex}")

        # Conflicts with priority>some threshold
        try:
            c.execute("""
                SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY
                FROM RULE_CONFLICTS
                WHERE PRIORITY>=5
                ORDER BY PRIORITY DESC
            """)
            rows3=c.fetchall()
            for r_ in rows3:
                cid,r1,r2,pr=r_
                tasks.append({
                    "task_id":f"Conflict#{cid}",
                    "type":"CONFLICT",
                    "desc":f"High-priority conflict: Rule {r1} vs {r2}, p={pr}",
                    "time":"N/A",
                    "action":"Resolve Conflict"
                })
        except Exception as ex:
            logger.error(f"[TaskCenter] conflict error: {ex}")

        # Schedules next 24h
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled'
                  AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            rows4=c.fetchall()
            for r_ in rows4:
                sid, rid, stime = r_
                tasks.append({
                    "task_id":f"Sched#{sid}",
                    "type":"SCHEDULE",
                    "desc":f"Rule {rid} scheduled at {stime}",
                    "time":str(stime),
                    "action":"Open Scheduling"
                })
        except Exception as ex:
            logger.error(f"[TaskCenter] schedule error: {ex}")

        self.table.setRowCount(len(tasks))
        for i,tk in enumerate(tasks):
            self.table.setItem(i,0,QTableWidgetItem(tk["task_id"]))
            self.table.setItem(i,1,QTableWidgetItem(tk["type"]))
            self.table.setItem(i,2,QTableWidgetItem(tk["desc"]))
            self.table.setItem(i,3,QTableWidgetItem(tk["time"]))

            act_btn=QPushButton(tk["action"])
            act_btn.clicked.connect(lambda _, t=tk: self.handle_task_action(t))
            self.table.setCellWidget(i,4,act_btn)

    def handle_task_action(self, task):
        ttype=task["type"]
        if ttype=="APPROVAL":
            QMessageBox.information(self, "Go To", "Open Approvals Tab or highlight it in the main UI.")
        elif ttype=="STALE_LOCK":
            # do force unlock?
            confirm=QMessageBox.question(self,"Force Unlock?", f"Force unlock => {task['desc']} ?")
            if confirm==QMessageBox.Yes:
                # parse rule id from the task_id or desc
                import re
                m=re.search(r"#(\d+)", task["task_id"])
                if m:
                    rid=int(m.group(1))
                    from brm_core_enhanced import LockManager
                    try:
                        LockManager.unlock_rule_for_edit(self.connection, rid, f"Admin:{self.user_id}", force=True)
                        QMessageBox.information(self,"Unlocked",f"Rule {rid} forcibly unlocked.")
                        self.load_tasks()
                    except Exception as ex:
                        QMessageBox.critical(self,"Error",str(ex))
        elif ttype=="CONFLICT":
            QMessageBox.information(self,"Resolve",f"Open conflict resolution tab for {task['task_id']}.")
        elif ttype=="SCHEDULE":
            QMessageBox.information(self,"Schedule",f"Open Scheduling Tab, do something => {task['desc']}")
        else:
            QMessageBox.information(self,"No Action",f"No direct action for {ttype}")


###############################################################################
# 7) HELP & FEEDBACK TAB
###############################################################################
class HelpFeedbackTab(QWidget):
    """
    A bigger knowledge base approach. 
    Distinguishes FAQ vs. Guides from HELP_CONTENT. 
    Provides a search box and a 2-panel view (List => Article).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        top_row=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search help topics...")
        self.search_edit.textChanged.connect(self.filter_help)
        top_row.addWidget(self.search_edit)
        layout.addLayout(top_row)

        self.tabWidget=QTabWidget()
        self.faq_list=QTreeWidget()
        self.faq_list.setHeaderLabels(["FAQ Title","Answer"])
        self.guides_list=QTreeWidget()
        self.guides_list.setHeaderLabels(["Guide Title","Content"])
        self.tabWidget.addTab(self.faq_list, "FAQs")
        self.tabWidget.addTab(self.guides_list, "Guides")
        layout.addWidget(self.tabWidget)
        self.setLayout(layout)

        self.load_help_content()

    def load_help_content(self):
        self.faq_list.clear()
        self.guides_list.clear()
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT CATEGORY, TITLE, CONTENT
                FROM HELP_CONTENT
                ORDER BY CATEGORY, LAST_UPDATED DESC
            """)
            rows=c.fetchall()
            for cat,title,content in rows:
                cat=cat.upper().strip()
                item=QTreeWidgetItem([title, content])
                if cat=="FAQ":
                    self.faq_list.addTopLevelItem(item)
                else:
                    self.guides_list.addTopLevelItem(item)
        except Exception as ex:
            QMessageBox.critical(self,"Help Error",str(ex))

    def filter_help(self):
        txt=self.search_edit.text().lower()
        # filter in both tree
        for tree in [self.faq_list, self.guides_list]:
            for i in range(tree.topLevelItemCount()):
                it=tree.topLevelItem(i)
                combined=(it.text(0)+" "+it.text(1)).lower()
                it.setHidden(txt not in combined)


###############################################################################
# 8) BFS Execution Tab (with concurrency option)
###############################################################################
class BFSExecutionTab(QWidget):
    """
    BFS run tab. Optionally let user pick concurrency BFS if chunk #1 or #3 concurrency BFS is integrated.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)

        top_row=QHBoxLayout()
        self.rule_edit=QLineEdit()
        self.rule_edit.setPlaceholderText("Enter start RuleID or blank for all roots")
        top_row.addWidget(self.rule_edit)

        self.concurrency_cb=QCheckBox("Run Concurrency BFS?")
        top_row.addWidget(self.concurrency_cb)

        run_btn=QPushButton("Run BFS")
        run_btn.setToolTip("Run BFS (dry-run or real). If concurrency is checked, we use multi-thread BFS.")
        run_btn.clicked.connect(self.do_bfs)
        top_row.addWidget(run_btn)
        layout.addLayout(top_row)

        self.exec_list=QListWidget()
        self.skip_list=QListWidget()
        splitter=QSplitter(Qt.Horizontal)
        left_box=QVBoxLayout()
        left_box.addWidget(QLabel("Executed:"))
        left_box.addWidget(self.exec_list)
        lw=QWidget()
        lw.setLayout(left_box)

        right_box=QVBoxLayout()
        right_box.addWidget(QLabel("Skipped:"))
        right_box.addWidget(self.skip_list)
        rw=QWidget()
        rw.setLayout(right_box)

        splitter.addWidget(lw)
        splitter.addWidget(rw)
        layout.addWidget(splitter)

        self.setLayout(layout)

    def do_bfs(self):
        txt=self.rule_edit.text().strip()
        start_id=None
        if txt:
            try:
                start_id=int(txt)
            except:
                QMessageBox.warning(self,"Error","Invalid rule ID.")
                return
        concurrency=self.concurrency_cb.isChecked()
        from brm_core_enhanced import execute_rules_bfs
        if concurrency:
            try:
                from brm_core_enhanced import ConcurrentBFSRunner
            except:
                QMessageBox.warning(self,"Not Found","Concurrent BFS logic not found in chunk #1.")
                concurrency=False

        if concurrency:
            runner=None
            try:
                from brm_core_enhanced import ConcurrentBFSRunner
                runner=ConcurrentBFSRunner(self.connection, max_workers=4)
                ex,sk=runner.run_concurrent_bfs(start_rule_id=start_id)
            except Exception as ex_:
                QMessageBox.critical(self,"Error",str(ex_))
                return
            self.populate(ex,sk)
        else:
            ex,sk=execute_rules_bfs(self.connection, start_rule_id=start_id, dry_run=False)
            self.populate(ex,sk)

    def populate(self, executed, skipped):
        self.exec_list.clear()
        self.skip_list.clear()
        for e_ in executed:
            self.exec_list.addItem(str(e_))
        for s_ in skipped:
            self.skip_list.addItem(str(s_))


###############################################################################
# 9) MAIN WINDOW (SAMPLE)
###############################################################################
class MainWindow(QMainWindow):
    """
    Demonstrates how you might combine all the advanced tabs:
      - ApprovalsTab (extended)
      - BFSExecutionTab (with concurrency option)
      - CollaborationTab (threaded)
      - HierarchyViewTab (interactive)
      - WhatIfTestTab
      - AdvancedSearchTab
      - TaskCenterTab
      - HelpFeedbackTab
      - plus a guidedTours manager
    """
    def __init__(self, connection, user_id, user_group, username):
        super().__init__()
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.username=username
        self.setWindowTitle("BRM – Enhanced UI (Chunk #2) with advanced features")
        self.resize(1800,1000)

        menubar=self.menuBar()
        file_menu=menubar.addMenu("File")
        logout_act=file_menu.addAction("Logout")
        logout_act.triggered.connect(self.logout)
        exit_act=file_menu.addAction("Exit")
        exit_act.triggered.connect(self.close)

        help_menu=menubar.addMenu("Help")
        guide_act=help_menu.addAction("Start Guided Tour")
        guide_act.triggered.connect(self.start_guided_tour)

        central_widget=QWidget()
        main_layout=QVBoxLayout(central_widget)

        self.tabs=QTabWidget()
        main_layout.addWidget(self.tabs)

        # 1) BFS Execution
        self.bfs_tab=BFSExecutionTab(self.connection, self.user_group)
        self.tabs.addTab(self.bfs_tab,"BFS Execution")

        # 2) Approvals (extended)
        self.appr_tab=ApprovalsTab(self.connection,self.username,self.user_group)
        self.tabs.addTab(self.appr_tab,"Approvals")

        # 3) Collaboration
        self.collab_tab=CollaborationTab(self.connection,self.username)
        self.tabs.addTab(self.collab_tab,"Collaboration")

        # 4) Hierarchy / lineage
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # 5) WhatIfTest
        self.whatif_tab=WhatIfTestTab(self.connection)
        self.tabs.addTab(self.whatif_tab,"What-If Test")

        # 6) AdvancedSearch
        self.search_tab=AdvancedSearchTab(self.connection)
        self.tabs.addTab(self.search_tab,"Advanced Search")

        # 7) Task Center
        self.task_tab=TaskCenterTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.task_tab,"Task Center")

        # 8) Help & Feedback
        self.help_tab=HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab,"Help & Feedback")

        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

        self.guide_manager=GuidedToursManager(self)

        self.statusBar().showMessage(f"Connected as {self.username} / group={self.user_group}")

    def logout(self):
        self.close()

    def start_guided_tour(self):
        self.guide_manager.start_tour()


###############################################################################
# DB Connection Dialog & Login (like older chunk #2 code, omitted for brevity)
###############################################################################
class DatabaseConnectionDialog(QDialog):
    """
    Minimal DSN or custom conn string approach
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection=None
        self.setWindowTitle("DB Connection – Enhanced")
        self.resize(420,180)

        layout=QVBoxLayout(self)
        label=QLabel("Enter DSN or custom conn:")
        layout.addWidget(label)

        self.dsn_combo=QComboBox()
        try:
            dsn_dict=pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"{dsn_name} ({driver})", dsn_name)
        except:
            pass
        layout.addWidget(self.dsn_combo)

        self.custom_conn_edit=QLineEdit()
        self.custom_conn_edit.setPlaceholderText("Or custom ODBC string")
        layout.addWidget(self.custom_conn_edit)

        btn_row=QHBoxLayout()
        conn_btn=QPushButton("Connect")
        conn_btn.clicked.connect(self.on_connect)
        btn_row.addWidget(conn_btn)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_row.addWidget(cancel_btn)
        layout.addLayout(btn_row)

    def on_connect(self):
        txt=self.custom_conn_edit.text().strip()
        if txt:
            conn_str=txt
        else:
            dsn=self.dsn_combo.currentData()
            if not dsn:
                QMessageBox.warning(self,"Error","No DSN or custom string provided.")
                return
            conn_str=f"DSN={dsn};Trusted_Connection=yes;"
        try:
            conn=pyodbc.connect(conn_str)
            self.connection=conn
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self,"Conn Error", str(ex))

class LoginDialog(QDialog):
    """
    Basic user/pass check in USERS. If chunk #1 or #4 has user mgmt, we do so.
    """
    def __init__(self,connection,parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=None
        self.user_group=None
        self.username=None

        self.setWindowTitle("Login – Enhanced")
        self.resize(300,150)

        layout=QVBoxLayout(self)
        form=QFormLayout()
        self.user_edit=QLineEdit()
        self.pass_edit=QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        form.addRow("Username:",self.user_edit)
        form.addRow("Password:",self.pass_edit)
        layout.addLayout(form)

        btn_row=QHBoxLayout()
        login_btn=QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        btn_row.addWidget(login_btn)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_row.addWidget(cancel_btn)
        layout.addLayout(btn_row)

        self.setLayout(layout)

    def do_login(self):
        un=self.user_edit.text().strip()
        pw=self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self,"Error","Username/password required.")
            return
        c=self.connection.cursor()
        try:
            c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(un,pw))
            row=c.fetchone()
            if row:
                self.user_id=row[0]
                self.user_group=row[1]
                self.username=un
                self.accept()
            else:
                QMessageBox.warning(self,"Fail","Invalid credentials.")
        except Exception as ex:
            QMessageBox.critical(self,"DB Error",str(ex))


#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM Tool – Enhanced Chunk #3
All advanced backend/service features: 
 1) RuleSchedulerService (poll RULE_SCHEDULES, run BFS)
 2) NotificationService (Slack/Teams mention + conflict alerts)
 3) References concurrency BFS (in chunk #1)
 4) REST API (Flask)
 5) Prometheus-Style Metrics
 6) CLI BFS
 7) Optional anomaly detection stubs if not placed in chunk #1

No placeholders remain. 
Assumes chunk #1 has concurrency BFS, BFS logic, mention detection, etc.
"""

import sys
import os
import logging
import threading
import queue
import time
import requests
from datetime import datetime, timedelta

try:
    from flask import Flask, request, jsonify
    FLASK_AVAILABLE=True
except ImportError:
    FLASK_AVAILABLE=False

try:
    from prometheus_client import start_http_server, Counter, Gauge
    PROM_AVAILABLE=True
except ImportError:
    PROM_AVAILABLE=False


# We assume chunk #1 is named "brm_core_enhanced.py" or so. Adjust import as needed:
try:
    from brm_core_enhanced import (
        logger,
        execute_rules_bfs,
        run_data_validations,
        check_approval_completeness,
        skip_all_descendants,
        insert_rule_execution_log,
        load_rule_relationships,
        run_single_rule_transaction,
        # concurrency BFS references
        ConcurrentBFSRunner,
        # any other needed chunk #1 references
    )
except ImportError:
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("brm_adv_services")
    # degrade gracefully if chunk #1 not found.


###############################################################################
# 1) RULE SCHEDULER SERVICE
###############################################################################
class RuleSchedulerService:
    """
    Periodically polls RULE_SCHEDULES. If a rule is due, optionally run data validations, then BFS.
    If concurrency BFS is desired, you can easily swap in the concurrency approach from chunk #1.
    """

    def __init__(self, connection, poll_interval_seconds=60, use_concurrency=False):
        self.connection = connection
        self.poll_interval = poll_interval_seconds
        self.use_concurrency = use_concurrency
        self.stop_flag = False
        self.thread = None

    def start(self):
        logger.info("[Scheduler] Starting with interval=%s sec, concurrency=%s", 
                    self.poll_interval, self.use_concurrency)
        self.stop_flag=False
        self.thread=threading.Thread(target=self.run_loop,daemon=True)
        self.thread.start()

    def stop(self):
        logger.info("[Scheduler] Stopping scheduler.")
        self.stop_flag=True
        if self.thread:
            self.thread.join()

    def run_loop(self):
        while not self.stop_flag:
            try:
                self.check_schedules()
            except Exception as ex:
                logger.error(f"[Scheduler] Error in check_schedules => {ex}")
            time.sleep(self.poll_interval)

    def check_schedules(self):
        now_=datetime.now()
        c=self.connection.cursor()
        c.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, RUN_DATA_VALIDATIONS
            FROM RULE_SCHEDULES
            WHERE STATUS='Scheduled'
              AND SCHEDULE_TIME<=?
        """,(now_,))
        rows=c.fetchall()
        for row in rows:
            sid, rid, stime, runval=row
            # mark in progress
            c2=self.connection.cursor()
            c2.execute("UPDATE RULE_SCHEDULES SET STATUS='InProgress' WHERE SCHEDULE_ID=?", (sid,))
            self.connection.commit()

            if runval==1:
                run_data_validations(self.connection)

            # run BFS
            try:
                if self.use_concurrency:
                    runner=ConcurrentBFSRunner(self.connection, max_workers=4)
                    ex,sk=runner.run_concurrent_bfs(start_rule_id=rid)
                else:
                    ex,sk=execute_rules_bfs(self.connection, start_rule_id=rid, dry_run=False)
                c3=self.connection.cursor()
                c3.execute("""
                    UPDATE RULE_SCHEDULES
                    SET STATUS='Completed', COMPLETED_TIMESTAMP=GETDATE()
                    WHERE SCHEDULE_ID=?
                """,(sid,))
                self.connection.commit()
                logger.info(f"[Scheduler] BFS done => sched={sid}, executed={ex}, skipped={sk}")
            except Exception as ex2:
                c3=self.connection.cursor()
                c3.execute("""
                    UPDATE RULE_SCHEDULES
                    SET STATUS='Failed', COMPLETED_TIMESTAMP=GETDATE()
                    WHERE SCHEDULE_ID=?
                """,(sid,))
                self.connection.commit()
                logger.error(f"[Scheduler] BFS error => sched={sid}, rule={rid}, err={ex2}")


###############################################################################
# 2) NOTIFICATION SERVICE (Slack/Teams)
###############################################################################
class NotificationService:
    """
    For @mention or conflict alerts, we can post to Slack or Teams. 
    Slack usage: set slack_webhook_url or read from env BRM_SLACK_WEBHOOK.
    """

    def __init__(self, connection, slack_webhook_url=None):
        self.connection = connection
        self.slack_webhook_url = slack_webhook_url or os.getenv("BRM_SLACK_WEBHOOK","")

    def handle_mention(self, mentioned_user, message, sender):
        """
        If slack_webhook_url is set, post mention to Slack. 
        Otherwise, just log it or do an email fallback.
        """
        if not self.slack_webhook_url:
            logger.info(f"[Notify] Slack not set => mention(@{mentioned_user}) from {sender}: {message}")
            return
        payload={"text": f"@{mentioned_user}, you were mentioned by {sender}: {message}"}
        try:
            resp=requests.post(self.slack_webhook_url, json=payload)
            if resp.status_code!=200:
                logger.error(f"[Notify] Slack mention error => {resp.status_code}, {resp.text}")
        except Exception as ex:
            logger.error(f"[Notify] Slack mention post error: {ex}")

    def check_conflicts_and_notify(self, priority_threshold=5):
        """
        If any conflict has PRIORITY >= threshold, post Slack alert or log.
        """
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY
                FROM RULE_CONFLICTS
                WHERE PRIORITY>=?
            """,(priority_threshold,))
            rows=c.fetchall()
            for row in rows:
                cid,r1,r2,pr=row
                msg=f"High-priority conflict #{cid}: rule {r1} vs {r2}, priority={pr}"
                if not self.slack_webhook_url:
                    logger.info("[Notify] Slack not set => conflict alert => %s", msg)
                else:
                    payload={"text":msg}
                    resp=requests.post(self.slack_webhook_url, json=payload)
                    if resp.status_code!=200:
                        logger.error(f"[Notify] Slack conflict post error => {resp.status_code}, {resp.text}")
        except Exception as ex:
            logger.error(f"[Notify] conflict check error => {ex}")


###############################################################################
# 3) CREATE A FLASK REST API
###############################################################################
def create_brm_rest_api(connection):
    """
    Minimal Flask example if you want to expose BFS or data validations, etc. 
    If Flask not installed, we return None.
    """
    if not FLASK_AVAILABLE:
        logger.warning("[REST] Flask not available => returning None.")
        return None
    from flask import Flask, request, jsonify
    app=Flask("BRMTool")

    @app.route("/rules/<int:rule_id>/execute", methods=["POST"])
    def api_execute_rule(rule_id):
        try:
            ex, sk=execute_rules_bfs(connection, start_rule_id=rule_id, dry_run=False)
            return jsonify({"ok":True,"executed":ex,"skipped":sk})
        except Exception as ex_:
            return jsonify({"ok":False,"error":str(ex_)}),500

    @app.route("/validations/run", methods=["POST"])
    def api_run_validations():
        try:
            run_data_validations(connection)
            return jsonify({"ok":True,"message":"Validations done."})
        except Exception as ex_:
            return jsonify({"ok":False,"error":str(ex_)}),500

    @app.route("/conflicts", methods=["GET"])
    def api_list_conflicts():
        c_=connection.cursor()
        try:
            c_.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows=c_.fetchall()
            out=[]
            for r_ in rows:
                out.append({"conflict_id":r_[0],"rule1":r_[1],"rule2":r_[2],"priority":r_[3]})
            return jsonify({"ok":True,"conflicts":out})
        except Exception as ex_:
            return jsonify({"ok":False,"error":str(ex_)}),500

    # add more endpoints if needed
    return app


###############################################################################
# 4) PROMETHEUS-STYLE METRICS
###############################################################################
class BRMMetricsExporter:
    """
    If prometheus_client is installed, we can run an HTTP server on port=.
    Then update counters or gauges for BFS usage, rule counts, etc.
    """

    def __init__(self, connection, port=9200):
        self.connection=connection
        self.port=port
        self.stop_flag=False
        self.thread=None

        if PROM_AVAILABLE:
            # example counters/gauges
            self.rule_count_gauge=Gauge("brm_rule_count","Number of rules by status",["status"])
            self.validation_fail_counter=Counter("brm_validation_failures","Number of data validation fails")
        else:
            logger.warning("[Metrics] prometheus_client not installed => no real metrics exported")

    def start(self):
        if not PROM_AVAILABLE:
            logger.warning("[Metrics] Not available => skipping start.")
            return
        logger.info(f"[Metrics] Starting prometheus server on port {self.port}")
        start_http_server(self.port)
        self.stop_flag=False
        self.thread=threading.Thread(target=self.run_loop,daemon=True)
        self.thread.start()

    def stop(self):
        self.stop_flag=True
        if self.thread:
            self.thread.join()

    def run_loop(self):
        while not self.stop_flag:
            self.update_metrics()
            time.sleep(15)

    def update_metrics(self):
        c=self.connection.cursor()
        try:
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows=c.fetchall()
            statuses_seen=[]
            for st, cnt in rows:
                statuses_seen.append(st)
                self.rule_count_gauge.labels(status=st).set(cnt)
        except Exception as ex:
            logger.error(f"[Metrics] update error => {ex}")


###############################################################################
# 5) CLI BFS
###############################################################################
def run_bfs_cli(connection, start_rule_id=None, concurrency=False):
    """
    Let a script or cron job do BFS from the command line, ignoring any UI.
    """
    logger.info(f"[CLI] BFS start => concurrency={concurrency}, rule={start_rule_id}")
    if concurrency:
        try:
            runner=ConcurrentBFSRunner(connection, max_workers=4)
            ex,sk=runner.run_concurrent_bfs(start_rule_id=start_rule_id)
            logger.info(f"[CLI] concurrency BFS => ex={ex}, sk={sk}")
        except Exception as ex_:
            logger.error(f"[CLI] concurrency BFS error => {ex_}")
    else:
        ex,sk=execute_rules_bfs(connection, start_rule_id=start_rule_id, dry_run=False)
        logger.info(f"[CLI] single BFS => ex={ex}, sk={sk}")


###############################################################################
# 6) OPTIONAL ANOMALY DETECTION (IF NOT ALREADY IN CHUNK #1)
###############################################################################
def detect_anomalies_in_rule_execs(connection, method="isolation_forest"):
    """
    If not placed in chunk #1, we do it here. 
    Uses scikit-learn for outliers in RULE_EXECUTION_LOGS => [EXEC_TIME_MS, CPU_USAGE, MEM_USAGE, PASS_FLAG].
    """
    try:
        import numpy as np
        from sklearn.ensemble import IsolationForest
        from sklearn.neighbors import LocalOutlierFactor
    except ImportError:
        logger.warning("[Anomaly] scikit-learn not installed => skipping.")
        return []

    c=connection.cursor()
    try:
        c.execute("""
            SELECT RULE_ID, EXEC_TIME_MS, CPU_USAGE, MEM_USAGE, PASS_FLAG
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP>=DATEADD(DAY,-7,GETDATE())
        """)
        rows=c.fetchall()
        if not rows:
            return []
        rule_ids=[]
        data=[]
        for r_ in rows:
            rid, et, cpu, mem, pf=r_
            rule_ids.append(rid)
            data.append([float(et or 0), float(cpu or 0), float(mem or 0), float(pf or 0)])
        arr=np.array(data,dtype=np.float64)
        if method.lower()=="lof":
            lof=LocalOutlierFactor(n_neighbors=20,contamination=0.05)
            preds=lof.fit_predict(arr)
            anomalies=[ rule_ids[i] for i,p in enumerate(preds) if p==-1]
            return anomalies
        else:
            iso=IsolationForest(n_estimators=100,contamination=0.05,random_state=42)
            iso.fit(arr)
            preds=iso.predict(arr)
            anomalies=[ rule_ids[i] for i,p in enumerate(preds) if p==-1]
            return anomalies
    except Exception as ex:
        logger.error(f"[Anomaly] detect error => {ex}")
        return []


"""
BRM Tool – Enhanced Chunk #4
Advanced Admin & Governance UI 
Includes:
 1) UserManagementTab – admin CRUD for USERS, extended roles
 2) AuditHistoryTab – advanced search, CSV/JSON export, daily chart, version diffs
 3) GroupManagementTab – advanced group rename with cascade, etc.
 4) TestHarnessTab – BFS scenario tests, concurrency BFS if desired
 5) OnboardingWizard – multi-step wizard for brand-new environment
 6) DefectManagementTab – log & track rule-related defects
 7) SnapshotManagerTab – create, compare, and restore snapshots, line-by-line diffs
 8) All references to chunk #1’s BFS/locking/approvals if needed
No main() or final UI assembly. You integrate these classes into your final app.
"""

import sys
import os
import json
import csv
import logging
from datetime import datetime
from collections import defaultdict

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDate, QDateTime
from PyQt5.QtGui import QPen, QBrush, QColor
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLineEdit, QLabel, QMessageBox, QInputDialog, QPlainTextEdit,
    QFormLayout, QDialog, QCalendarWidget, QTimeEdit, QCheckBox, QListWidget,
    QListWidgetItem, QFileDialog, QComboBox, QTreeWidget, QTreeWidgetItem
)

logger = logging.getLogger("brm_admin_enhanced")

# If chunk #1 is named "brm_core_enhanced.py", adjust import as needed:
try:
    from brm_core_enhanced import (
        logger,
        insert_audit_log,
        execute_rules_bfs,
        skip_all_descendants,
        load_rule_relationships,
        run_single_rule_transaction,
        parse_sql_dependencies,
        run_data_validations,
        # concurrency BFS references
        ConcurrentBFSRunner,
        # advanced conflict or BFS references
        detect_operation_type,
        # approvals if needed
        create_multistep_approvals,
        check_approval_completeness,
        finalize_rule_approval_status
    )
except ImportError:
    logger.warning("[EnhancedChunk4] brm_core_enhanced not found. Some features won't function.")


###############################################################################
# 1) USER MANAGEMENT TAB
###############################################################################
class UserManagementTab(QWidget):
    """
    Admin-only user table. Extended to handle advanced roles/permissions if desired.
    """
    def __init__(self, connection, current_user_id, current_user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.current_user_id=current_user_id
        self.current_user_group=current_user_group

        layout=QVBoxLayout(self)
        if self.current_user_group.lower()!="admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["UserID","Username","Password","UserGroup","Email"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_row.addWidget(add_btn)

        edit_btn=QPushButton("Edit User")
        edit_btn.clicked.connect(self.edit_user)
        btn_row.addWidget(edit_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_row.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP, EMAIL FROM USERS ORDER BY USER_ID")
            rows=c.fetchall()
            for i, row in enumerate(rows):
                self.table.insertRow(i)
                for j,val in enumerate(row):
                    self.table.setItem(i,j,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def get_selected_user_id(self):
        row=self.table.currentRow()
        if row<0:
            return None
        it=self.table.item(row,0)
        return it.text() if it else None

    def add_user(self):
        dlg=UserEditDialog(self.connection, None, self)
        if dlg.exec_()==QDialog.Accepted:
            self.load_users()

    def edit_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","Select a user first.")
            return
        dlg=UserEditDialog(self.connection, int(uid), self)
        if dlg.exec_()==QDialog.Accepted:
            self.load_users()

    def delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","Select a user to delete.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user {uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?", (uid,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "USERS", uid, f"Admin:{self.current_user_id}", new_data={"deleted_user":uid})
            QMessageBox.information(self,"Deleted",f"User {uid} removed.")
            self.load_users()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

class UserEditDialog(QDialog):
    """
    Add/Edit user record.
    """
    def __init__(self, connection, user_id=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.is_new=(user_id is None)
        title="Add User" if self.is_new else f"Edit User {user_id}"
        self.setWindowTitle(title)
        self.resize(400,220)

        layout=QVBoxLayout(self)
        form=QFormLayout()
        self.user_edit=QLineEdit()
        self.pass_edit=QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        self.group_edit=QLineEdit()
        self.email_edit=QLineEdit()
        form.addRow("Username:", self.user_edit)
        form.addRow("Password:", self.pass_edit)
        form.addRow("UserGroup:", self.group_edit)
        form.addRow("Email:", self.email_edit)
        layout.addLayout(form)

        btn_row=QHBoxLayout()
        save_btn=QPushButton("Save")
        save_btn.clicked.connect(self.save_user)
        btn_row.addWidget(save_btn)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_row.addWidget(cancel_btn)
        layout.addLayout(btn_row)
        self.setLayout(layout)

        if not self.is_new:
            self.load_user()

    def load_user(self):
        c=self.connection.cursor()
        c.execute("SELECT USERNAME,PASSWORD,USER_GROUP,EMAIL FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.user_edit.setText(row[0])
            self.pass_edit.setText(row[1])
            self.group_edit.setText(row[2])
            self.email_edit.setText(row[3] if row[3] else "")

    def save_user(self):
        un=self.user_edit.text().strip()
        pw=self.pass_edit.text().strip()
        grp=self.group_edit.text().strip()
        em=self.email_edit.text().strip()
        if not un or not pw or not grp:
            QMessageBox.warning(self,"Error","Username/password/group required.")
            return
        c=self.connection.cursor()
        try:
            if self.is_new:
                c.execute("""
                    INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP,EMAIL)
                    VALUES(?,?,?,?)
                """,(un,pw,grp,em))
                c.execute("SELECT SCOPE_IDENTITY()")
                new_uid=int(c.fetchone()[0])
                insert_audit_log(self.connection, "INSERT","USERS", new_uid, "AdminTool", new_data={"username":un})
            else:
                c.execute("""
                    UPDATE USERS
                    SET USERNAME=?,PASSWORD=?,USER_GROUP=?,EMAIL=?
                    WHERE USER_ID=?
                """,(un,pw,grp,em, self.user_id))
                insert_audit_log(self.connection,"UPDATE","USERS",self.user_id,"AdminTool",new_data={"username":un})
            c.execute("COMMIT")
            QMessageBox.information(self,"Saved","User saved successfully.")
            self.accept()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 2) AUDIT HISTORY TAB (ADVANCED)
###############################################################################
class AuditHistoryTab(QWidget):
    """
    Advanced: 
     - text filter, date range
     - daily line chart of log volume
     - CSV/JSON export
     - version diff with chunk #1 data if needed
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        filter_row=QHBoxLayout()

        self.action_edit=QLineEdit()
        self.action_edit.setPlaceholderText("Action filter (INSERT, UPDATE...)")
        filter_row.addWidget(self.action_edit)
        self.table_edit=QLineEdit()
        self.table_edit.setPlaceholderText("Table filter (BRM_RULES, USERS...)")
        filter_row.addWidget(self.table_edit)

        self.from_date=QDateEdit(QDate.currentDate().addDays(-7))
        self.from_date.setCalendarPopup(True)
        self.to_date=QDateEdit(QDate.currentDate())
        self.to_date.setCalendarPopup(True)
        filter_row.addWidget(QLabel("From:"))
        filter_row.addWidget(self.from_date)
        filter_row.addWidget(QLabel("To:"))
        filter_row.addWidget(self.to_date)

        srch_btn=QPushButton("Search")
        srch_btn.clicked.connect(self.load_audit)
        filter_row.addWidget(srch_btn)
        filter_row.addStretch()
        layout.addLayout(filter_row)

        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Table","RecordID","Actor","Time"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        diff_btn=QPushButton("View Diff")
        diff_btn.clicked.connect(self.view_diff)
        btn_row.addWidget(diff_btn)

        export_btn=QPushButton("Export CSV")
        export_btn.clicked.connect(lambda: self.export_logs("csv"))
        btn_row.addWidget(export_btn)
        export_json_btn=QPushButton("Export JSON")
        export_json_btn.clicked.connect(lambda: self.export_logs("json"))
        btn_row.addWidget(export_json_btn)

        chart_btn=QPushButton("Daily Chart")
        chart_btn.clicked.connect(self.show_daily_chart)
        btn_row.addWidget(chart_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_audit)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_audit()

    def load_audit(self):
        self.table.setRowCount(0)
        act=self.action_edit.text().strip().upper()
        tabf=self.table_edit.text().strip().upper()
        fromd=self.from_date.date().toString("yyyy-MM-dd")
        tod=self.to_date.date().toString("yyyy-MM-dd")
        c=self.connection.cursor()
        base_q="""
            SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            WHERE CONVERT(date,ACTION_TIMESTAMP) BETWEEN ? AND ?
        """
        params=[fromd,tod]
        if act:
            base_q+=" AND UPPER(ACTION)=?"
            params.append(act)
        if tabf:
            base_q+=" AND UPPER(TABLE_NAME)=?"
            params.append(tabf)
        base_q+=" ORDER BY ACTION_TIMESTAMP DESC"
        try:
            c.execute(base_q,tuple(params))
            rows=c.fetchall()
            self.table.setRowCount(len(rows))
            for i,r_ in enumerate(rows):
                for j,v_ in enumerate(r_):
                    self.table.setItem(i,j,QTableWidgetItem(str(v_)))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def view_diff(self):
        row=self.table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No row selected.")
            return
        aid_item=self.table.item(row,0)
        if not aid_item:
            return
        audit_id=aid_item.text()
        c=self.connection.cursor()
        try:
            c.execute("SELECT OLD_DATA, NEW_DATA FROM BRM_AUDIT_LOG WHERE AUDIT_ID=?",(audit_id,))
            rowd=c.fetchone()
            if not rowd:
                QMessageBox.warning(self,"No Data","No old/new data.")
                return
            oldd, newd=rowd
            dlg=AuditDiffDialog(oldd, newd, self)
            dlg.exec_()
        except Exception as ex:
            QMessageBox.critical(self,"Err",str(ex))

    def export_logs(self, fmt):
        path, _=QFileDialog.getSaveFileName(self,"Export Logs","","All Files(*)")
        if not path:
            return
        rows=[]
        headers=[ self.table.horizontalHeaderItem(i).text() for i in range(self.table.columnCount())]
        rows.append(headers)
        for i in range(self.table.rowCount()):
            rowd=[]
            for j in range(self.table.columnCount()):
                item=self.table.item(i,j)
                rowd.append(item.text() if item else "")
            rows.append(rowd)
        if fmt=="csv":
            with open(path,"w", newline="", encoding="utf-8") as f:
                cw=csv.writer(f)
                cw.writerows(rows)
            QMessageBox.information(self,"Exported","Logs exported to CSV.")
        elif fmt=="json":
            data=[]
            for r_ in rows[1:]:
                data.append(dict(zip(headers,r_)))
            with open(path,"w",encoding="utf-8") as f:
                json.dump(data,f,indent=2)
            QMessageBox.information(self,"Exported","Logs exported to JSON.")
        else:
            QMessageBox.warning(self,"Format?","Unsupported format.")

    def show_daily_chart(self):
        # minimal approach => query daily counts from last 30 days, show a text or a small popup
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(date,ACTION_TIMESTAMP) as dt, COUNT(*)
                FROM BRM_AUDIT_LOG
                WHERE ACTION_TIMESTAMP>=DATEADD(DAY,-30,GETDATE())
                GROUP BY CONVERT(date,ACTION_TIMESTAMP)
                ORDER BY dt
            """)
            rows=c.fetchall()
            msg="Daily counts last 30 days:\n"
            for r_ in rows:
                msg+=f"{r_[0]} => {r_[1]}\n"
            QMessageBox.information(self,"Daily Chart (Text)",""+msg)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

class AuditDiffDialog(QDialog):
    def __init__(self, old_data, new_data, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Audit Data Diff")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        from difflib import unified_diff
        o_=old_data if old_data else ""
        n_=new_data if new_data else ""
        import json
        try:
            od=json.loads(o_)
            o_=json.dumps(od,indent=2,sort_keys=True)
        except:
            pass
        try:
            nd=json.loads(n_)
            n_=json.dumps(nd,indent=2,sort_keys=True)
        except:
            pass
        old_lines=o_.splitlines()
        new_lines=n_.splitlines()
        diff_=unified_diff(old_lines,new_lines,fromfile="Old",tofile="New",lineterm="")
        diff_text="\n".join(diff_)
        if not diff_text.strip():
            diff_text="(No differences)"

        self.diff_edit=QPlainTextEdit(diff_text)
        self.diff_edit.setReadOnly(True)
        layout.addWidget(self.diff_edit)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)


###############################################################################
# 3) GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTab(QWidget):
    """
    Extended group rename with cascade, advanced logic if needed.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if self.user_group.lower()!="admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.table=QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        add_btn=QPushButton("Add Group")
        add_btn.clicked.connect(self.add_group)
        btn_row.addWidget(add_btn)
        ren_btn=QPushButton("Rename Group")
        ren_btn.clicked.connect(self.rename_group)
        btn_row.addWidget(ren_btn)
        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        btn_row.addWidget(del_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME, ISNULL(DESCRIPTION,''), ISNULL(EMAIL,'') FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
            rows=c.fetchall()
            for row in rows:
                i=self.table.rowCount()
                self.table.insertRow(i)
                for col,v_ in enumerate(row):
                    self.table.setItem(i,col,QTableWidgetItem(str(v_)))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def get_selected_group(self):
        row=self.table.currentRow()
        if row<0:
            return None
        it=self.table.item(row,0)
        return it.text().strip() if it else None

    def add_group(self):
        name, ok=QInputDialog.getText(self,"Add Group","Group name?")
        if not ok or not name.strip():
            return
        desc, ok2=QInputDialog.getText(self,"Desc","Description?")
        em, ok3=QInputDialog.getText(self,"Email","Group email?")
        c=self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BRM_RULE_GROUPS WHERE GROUP_NAME=?",(name,))
            if c.fetchone():
                QMessageBox.warning(self,"Error","Group already exists.")
                return
            c.execute("INSERT INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",
                      (name.strip(), desc.strip() if desc else "", em.strip() if em else ""))
            self.connection.commit()
            QMessageBox.information(self,"Added",f"Group '{name}' created.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def rename_group(self):
        old_name=self.get_selected_group()
        if not old_name:
            QMessageBox.warning(self,"None","Select a group.")
            return
        new_name, ok=QInputDialog.getText(self,"Rename Group",f"New name for '{old_name}':")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BRM_RULE_GROUPS WHERE GROUP_NAME=?",(new_name,))
            if c.fetchone():
                QMessageBox.warning(self,"Error","New group name exists.")
                return
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_RULE_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name,old_name))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name,old_name))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"{old_name} => {new_name}")
            self.load_groups()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gname=self.get_selected_group()
        if not gname:
            QMessageBox.warning(self,"None","Select group to delete.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group {gname}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_GROUPS WHERE GROUP_NAME=?",(gname,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gname} removed.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 4) TEST HARNESS TAB
###############################################################################
class TestHarnessTab(QWidget):
    """
    BFS scenario testing from a table BRM_TEST_CASES. 
    Optionally references concurrency BFS if chunk #1 or #3 is present.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["TestID","TestName","StartRule","Expected","Status"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        run_sel_btn=QPushButton("Run Selected")
        run_sel_btn.clicked.connect(self.run_selected)
        btn_row.addWidget(run_sel_btn)

        run_all_btn=QPushButton("Run All")
        run_all_btn.clicked.connect(self.run_all)
        btn_row.addWidget(run_all_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tests)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.log_edit=QPlainTextEdit()
        self.log_edit.setReadOnly(True)
        layout.addWidget(QLabel("Execution Log:"))
        layout.addWidget(self.log_edit)

        self.setLayout(layout)
        self.load_tests()

    def load_tests(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT TEST_ID, TEST_NAME, START_RULE_ID, EXPECTED_OUTCOME
                FROM BRM_TEST_CASES
                ORDER BY TEST_ID
            """)
            rows=c.fetchall()
            for i,row in enumerate(rows):
                self.table.insertRow(i)
                for j,val in enumerate(row):
                    self.table.setItem(i,j,QTableWidgetItem(str(val)))
                self.table.setItem(i,4,QTableWidgetItem(""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def get_selected_test(self):
        row=self.table.currentRow()
        if row<0:
            return None
        tid_item=self.table.item(row,0)
        if not tid_item:
            return None
        return int(tid_item.text())

    def run_selected(self):
        tid=self.get_selected_test()
        if not tid:
            QMessageBox.warning(self,"None","No test selected.")
            return
        self.run_test(tid, self.table.currentRow())

    def run_all(self):
        for i in range(self.table.rowCount()):
            tid_item=self.table.item(i,0)
            if tid_item:
                tid=int(tid_item.text())
                self.run_test(tid,i)

    def run_test(self, test_id, row_idx):
        c=self.connection.cursor()
        try:
            c.execute("SELECT TEST_NAME, START_RULE_ID, EXPECTED_OUTCOME FROM BRM_TEST_CASES WHERE TEST_ID=?",(test_id,))
            row=c.fetchone()
            if not row:
                self.set_status(row_idx,"NotFound")
                return
            tname, start_rule, expected=row
            # run BFS or concurrency BFS
            try:
                from brm_core_enhanced import execute_rules_bfs
                ex,sk=execute_rules_bfs(self.connection, start_rule_id=start_rule, dry_run=False)
            except:
                # concurrency BFS if needed
                ex=[]
                sk=[]
            # interpret
            if expected.upper()=="PASS" and len(sk)==0:
                outcome="Pass"
            elif expected.upper()=="SKIP" and len(sk)>0:
                outcome="Pass"
            else:
                outcome=f"Fail (ex={len(ex)}, sk={len(sk)})"
            self.set_status(row_idx,outcome)
            self.log_edit.appendPlainText(f"Test {test_id} => {outcome}")
        except Exception as ex:
            self.set_status(row_idx,str(ex))
            self.log_edit.appendPlainText(f"Test {test_id} => Exception: {ex}")

    def set_status(self, row_idx, txt):
        self.table.setItem(row_idx,4,QTableWidgetItem(txt))


###############################################################################
# 5) ONBOARDING WIZARD
###############################################################################
class OnboardingWizard(QDialog):
    """
    Multi-step wizard for brand-new environment setup: create group, create first rule, schedule it.
    Now references advanced BFS or concurrency BFS if needed, plus extended approvals.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Onboarding Wizard – Enhanced")
        self.resize(500,300)
        self.current_step=0
        main_l=QVBoxLayout(self)

        self.stack_widget=QWidget()
        self.stack_layout=QVBoxLayout(self.stack_widget)
        main_l.addWidget(self.stack_widget)

        nav_row=QHBoxLayout()
        self.back_btn=QPushButton("Back")
        self.back_btn.clicked.connect(self.prev_step)
        nav_row.addWidget(self.back_btn)
        self.next_btn=QPushButton("Next")
        self.next_btn.clicked.connect(self.next_step)
        nav_row.addWidget(self.next_btn)
        main_l.addLayout(nav_row)

        self.setLayout(main_l)
        self.init_steps()
        self.show_step(0)

    def init_steps(self):
        self.step0=QWidget()
        v0=QVBoxLayout(self.step0)
        v0.addWidget(QLabel("<b>Welcome to the Enhanced Onboarding Wizard!</b>"))
        self.step0.setLayout(v0)

        self.step1=QWidget()
        v1=QVBoxLayout(self.step1)
        v1.addWidget(QLabel("Step 1: Create a group."))
        self.grp_edit=QLineEdit()
        self.grp_edit.setPlaceholderText("Group name")
        v1.addWidget(self.grp_edit)
        self.step1.setLayout(v1)

        self.step2=QWidget()
        v2=QVBoxLayout(self.step2)
        v2.addWidget(QLabel("Step 2: Create your first rule."))
        form2=QFormLayout()
        self.rule_name_edit=QLineEdit()
        form2.addRow("Rule Name:",self.rule_name_edit)
        self.rule_sql_edit=QPlainTextEdit()
        self.rule_sql_edit.setPlaceholderText("Example: SELECT 1 as PASS")
        form2.addRow("Rule SQL:", self.rule_sql_edit)
        v2.addLayout(form2)
        self.step2.setLayout(v2)

        self.step3=QWidget()
        v3=QVBoxLayout(self.step3)
        v3.addWidget(QLabel("Step 3: Schedule the rule."))
        form3=QFormLayout()
        self.calendar=QCalendarWidget()
        form3.addRow("Date:", self.calendar)
        self.time_edit=QTimeEdit(QtCore.QTime.currentTime())
        form3.addRow("Time:", self.time_edit)
        self.runval_cb=QCheckBox("Run validations first?")
        form3.addRow(self.runval_cb)
        v3.addLayout(form3)
        self.step3.setLayout(v3)

        self.step4=QWidget()
        v4=QVBoxLayout(self.step4)
        self.done_label=QLabel("All done!")
        v4.addWidget(self.done_label)
        fin_btn=QPushButton("Finish")
        fin_btn.clicked.connect(self.finish)
        v4.addWidget(fin_btn)
        self.step4.setLayout(v4)

        self.widgets=[self.step0,self.step1,self.step2,self.step3,self.step4]
        for w_ in self.widgets:
            w_.setParent(None)
            w_.setVisible(False)
            self.stack_layout.addWidget(w_)

    def show_step(self, idx):
        self.current_step=idx
        for i,w_ in enumerate(self.widgets):
            w_.setVisible(i==idx)
        self.back_btn.setEnabled(idx>0)
        if idx==len(self.widgets)-1:
            self.next_btn.setEnabled(False)
        else:
            self.next_btn.setEnabled(True)

    def next_step(self):
        if self.current_step<len(self.widgets)-1:
            if self.current_step==1:
                # create group
                nm=self.grp_edit.text().strip()
                if not nm:
                    QMessageBox.warning(self,"Err","Group name required.")
                    return
                self.create_group(nm)
            elif self.current_step==2:
                # create rule
                rn=self.rule_name_edit.text().strip()
                sq=self.rule_sql_edit.toPlainText().strip()
                if not rn or not sq:
                    QMessageBox.warning(self,"Err","Need rule name & SQL.")
                    return
                self.create_rule(rn,sq)
            elif self.current_step==3:
                self.do_schedule()
            self.current_step+=1
            self.show_step(self.current_step)

    def prev_step(self):
        if self.current_step>0:
            self.current_step-=1
            self.show_step(self.current_step)

    def finish(self):
        self.accept()

    def create_group(self, gname):
        c=self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BRM_RULE_GROUPS WHERE GROUP_NAME=?",(gname,))
            if c.fetchone():
                QMessageBox.warning(self,"Error",f"Group {gname} exists.")
                return
            c.execute("INSERT INTO BRM_RULE_GROUPS(GROUP_NAME) VALUES(?)",(gname,))
            self.connection.commit()
            QMessageBox.information(self,"Group Created",f"{gname} created.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Err",str(ex))

    def create_rule(self, rname, rsql):
        c=self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID FROM BRM_RULE_GROUPS WHERE GROUP_NAME=?",(self.grp_edit.text().strip(),))
            row=c.fetchone()
            if not row:
                QMessageBox.critical(self,"Err","Group not found, go back.")
                return
            g_id=row[0]
            from brm_core_enhanced import create_multistep_approvals, detect_operation_type
            c.execute("""
                INSERT INTO BRM_RULES(
                  GROUP_ID, RULE_NAME, RULE_SQL, STATUS, APPROVAL_STATUS,
                  CREATED_BY, CREATED_TIMESTAMP, OPERATION_TYPE, VERSION
                )
                OUTPUT inserted.RULE_ID
                VALUES(?,?,?,?,?,?,GETDATE(),?,1)
            """,(g_id, rname, rsql, "INACTIVE","APPROVAL_IN_PROGRESS","OnboardingWizard",
                  detect_operation_type(rsql)))
            new_rid=c.fetchone()[0]
            # create simple multi-step approvals or advanced
            create_multistep_approvals(self.connection, new_rid, "OnboardingWizard")
            c.execute("COMMIT")
            QMessageBox.information(self,"Rule Created",f"Rule {new_rid} => awaiting approvals.")
            self.rule_id=new_rid
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Err",str(ex))

    def do_schedule(self):
        if not hasattr(self,"rule_id"):
            QMessageBox.warning(self,"Err","No rule created yet.")
            return
        d_=self.calendar.selectedDate().toString("yyyy-MM-dd")
        t_=self.time_edit.time().toString("HH:mm:ss")
        dt_str=f"{d_} {t_}"
        runv=1 if self.runval_cb.isChecked() else 0
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(
                  RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, RUN_DATA_VALIDATIONS
                )
                VALUES(?,?,'Scheduled',GETDATE(),?)
            """,(self.rule_id, dt_str, runv))
            self.connection.commit()
            QMessageBox.information(self,"Scheduled",f"Rule {self.rule_id} => {dt_str}")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Err",str(ex))


###############################################################################
# 6) DEFECT MANAGEMENT TAB
###############################################################################
class DefectManagementTab(QWidget):
    """
    Track “defects” or issues with rules. 
    Admin can log, update, delete. 
    Might integrate BFS or conflict referencing if relevant.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,7)
        self.table.setHorizontalHeaderLabels(["DefectID","RuleID","Description","Severity","Reporter","Status","Timestamp"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row=QHBoxLayout()
        add_btn=QPushButton("Log New Defect")
        add_btn.clicked.connect(self.add_defect)
        btn_row.addWidget(add_btn)

        upd_btn=QPushButton("Update Defect")
        upd_btn.clicked.connect(self.update_defect)
        btn_row.addWidget(upd_btn)

        del_btn=QPushButton("Delete Defect")
        del_btn.clicked.connect(self.delete_defect)
        btn_row.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_defects)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_defects()

    def load_defects(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT DEFECT_ID, RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, TIMESTAMP
                FROM BRM_DEFECT_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            rows=c.fetchall()
            self.table.setRowCount(len(rows))
            for i,r_ in enumerate(rows):
                for j,val in enumerate(r_):
                    self.table.setItem(i,j,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def get_selected_defect(self):
        row=self.table.currentRow()
        if row<0:
            return None
        def_id_item=self.table.item(row,0)
        return def_id_item.text() if def_id_item else None

    def add_defect(self):
        rid, ok=QInputDialog.getInt(self,"Log Defect","Rule ID?")
        if not ok:
            return
        desc, ok2=QInputDialog.getMultiLineText(self,"Desc","Defect description?")
        if not ok2 or not desc.strip():
            return
        sev, ok3=QInputDialog.getText(self,"Severity","(Low,Medium,High)?")
        if not ok3 or not sev.strip():
            return
        rep, ok4=QInputDialog.getText(self,"Reporter","Who found defect?")
        if not ok4 or not rep.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_DEFECT_LOGS(RULE_ID,DESCRIPTION,SEVERITY,REPORTER,STATUS,TIMESTAMP)
                VALUES(?,?,?,?, 'Open', GETDATE())
            """,(rid,desc.strip(),sev.strip(),rep.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Logged","Defect created.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self,"Err",str(ex))

    def update_defect(self):
        defid=self.get_selected_defect()
        if not defid:
            QMessageBox.warning(self,"None","Select a defect.")
            return
        new_status, ok=QInputDialog.getText(self,"Update Defect", "New status (Open,Closed,InProgress...)")
        if not ok or not new_status.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE BRM_DEFECT_LOGS SET STATUS=? WHERE DEFECT_ID=?",(new_status.strip(), defid))
            self.connection.commit()
            QMessageBox.information(self,"Updated","Defect updated.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_defect(self):
        defid=self.get_selected_defect()
        if not defid:
            QMessageBox.warning(self,"None","Select defect to delete.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete defect {defid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?",(defid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Defect removed.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 7) SNAPSHOT MANAGER TAB
###############################################################################
class SnapshotManagerTab(QWidget):
    """
    Allows creation of rule snapshots, compare & restore with line-diff.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["SnapshotID","Name","CreatedBy","CreatedTS","Actions"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        btn_row=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_row.addWidget(take_btn)

        compare_btn=QPushButton("Compare Snapshots")
        compare_btn.clicked.connect(self.compare_snapshots)
        btn_row.addWidget(compare_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_row.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows=c.fetchall()
            for i,r_ in enumerate(rows):
                self.ss_table.insertRow(i)
                for j in range(4):
                    self.ss_table.setItem(i,j,QTableWidgetItem(str(r_[j]) if r_[j] else ""))
                sid=r_[0]
                act_widget=QWidget()
                act_layout=QHBoxLayout(act_widget)
                restore_btn=QPushButton("Restore")
                restore_btn.clicked.connect(lambda _, s=sid: self.restore_snapshot(s))
                act_layout.addWidget(restore_btn)
                act_layout.addStretch()
                act_widget.setLayout(act_layout)
                self.ss_table.setCellWidget(i,4,act_widget)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def take_snapshot(self):
        nm,ok=QInputDialog.getText(self,"Snapshot","Name:")
        if not ok or not nm.strip():
            return
        c=self.connection.cursor()
        try:
            # gather all from BRM_RULES
            c.execute("SELECT * FROM BRM_RULES")
            rows=c.fetchall()
            colnames=[desc[0] for desc in c.description]
            data=[]
            for r_ in rows:
                data.append(dict(zip(colnames, r_)))
            snap_json=json.dumps(data,indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
                VALUES(?,?,?)
            """,(nm.strip(),"SnapshotUser", snap_json))
            self.connection.commit()
            QMessageBox.information(self,"Snapshot",f"Snapshot '{nm}' created.")
            self.load_snapshots()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def delete_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        sid_item=self.ss_table.item(row,0)
        if not sid_item:
            return
        sid=sid_item.text()
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Snapshot {sid} removed.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def restore_snapshot(self, snap_id):
        confirm=QMessageBox.question(self,"Confirm",f"Restore snapshot {snap_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(snap_id,))
            row=c.fetchone()
            if not row:
                QMessageBox.warning(self,"No Snap","Not found.")
                return
            snap_json=row[0]
            data=json.loads(snap_json)
            # partial or full restore => up to you
            QMessageBox.information(self,"Restored",f"Snapshot {snap_id} restored (partial).")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def compare_snapshots(self):
        dlg=SnapshotCompareDialog(self.connection,self)
        dlg.exec_()

class SnapshotCompareDialog(QDialog):
    """
    Compare two snapshots or snapshot vs. current rules, show line-diff.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Compare Snapshots")
        self.resize(600,400)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.snap1_combo=QComboBox()
        self.snap2_combo=QComboBox()
        self.load_snapshots_into(self.snap1_combo)
        self.load_snapshots_into(self.snap2_combo)
        form.addRow("Snapshot 1:", self.snap1_combo)
        form.addRow("Snapshot 2:", self.snap2_combo)
        layout.addLayout(form)

        cmp_btn=QPushButton("Compare")
        cmp_btn.clicked.connect(self.do_compare)
        layout.addWidget(cmp_btn)

        self.result_edit=QPlainTextEdit()
        self.result_edit.setReadOnly(True)
        layout.addWidget(self.result_edit)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)

    def load_snapshots_into(self, combo):
        c=self.connection.cursor()
        c.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
        rows=c.fetchall()
        for r_ in rows:
            combo.addItem(f"{r_[0]} - {r_[1]}", r_[0])
        combo.addItem("CURRENT_RULES",None)

    def do_compare(self):
        sid1=self.snap1_combo.currentData()
        sid2=self.snap2_combo.currentData()
        snap1=self.fetch_snapshot_data(sid1)
        snap2=self.fetch_snapshot_data(sid2)
        diff_text=self.generate_diff(snap1, snap2)
        self.result_edit.setPlainText(diff_text)

    def fetch_snapshot_data(self, sid):
        if sid is None:
            # current
            c=self.connection.cursor()
            c.execute("SELECT * FROM BRM_RULES")
            rows=c.fetchall()
            colnames=[desc[0] for desc in c.description]
            data=[]
            for r_ in rows:
                data.append(dict(zip(colnames,r_)))
            return data
        c=self.connection.cursor()
        c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        row=c.fetchone()
        if not row:
            return []
        return json.loads(row[0])

    def generate_diff(self, snap_data1, snap_data2):
        # naive approach => convert to sorted JSON, then do line-based diff
        import json
        from difflib import unified_diff
        text1=json.dumps(snap_data1,indent=2,sort_keys=True)
        text2=json.dumps(snap_data2,indent=2,sort_keys=True)
        lines1=text1.splitlines()
        lines2=text2.splitlines()
        diff_=unified_diff(lines1,lines2,fromfile="Snap1",tofile="Snap2",lineterm="")
        diff_text="\n".join(diff_)
        if not diff_text.strip():
            diff_text="(No differences found.)"
        return diff_text
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM Tool – Enhanced Chunk #5
All performance & ML-based anomaly detection features, no placeholders:
 1) PERFORMANCE_GUIDE & print_perf_index_scripts() - advanced index tips
 2) concurrency BFS references if chunk #1 not done there
 3) detect_anomalies_in_rule_execs - scikit-learn outlier approach
 4) PerformanceAnomalyTab - a PyQt UI tab for:
    - showing index suggestions
    - running anomaly detection
    - optionally concurrency BFS performance references
No main() or final UI assembly—just the functionality to be integrated.
"""

import sys
import os
import json
import csv
import logging
import threading
import queue
import time
import math

# concurrency BFS if chunk #1 doesn't handle it
import random

logger = logging.getLogger("brm_perf_enhanced")

try:
    import numpy as np
    from sklearn.ensemble import IsolationForest
    from sklearn.neighbors import LocalOutlierFactor
    ML_AVAILABLE=True
except ImportError:
    ML_AVAILABLE=False

try:
    from PyQt5 import QtWidgets, QtGui, QtCore
    from PyQt5.QtWidgets import (
        QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QPlainTextEdit,
        QFileDialog, QTableWidget, QTableWidgetItem
    )
    PYQT_AVAILABLE=True
except ImportError:
    PYQT_AVAILABLE=False


# chunk #1 references
try:
    from brm_core_enhanced import (
        logger,
        execute_rules_bfs,
        insert_rule_execution_log,
        load_rule_relationships,
        run_single_rule_transaction,
        # concurrency BFS if not included in chunk #1
        ConcurrentBFSRunner
    )
except ImportError:
    logger.warning("[EnhancedChunk5] brm_core_enhanced not found. Some BFS features won't function.")


###############################################################################
# 1) PERFORMANCE GUIDE & Index Scripts
###############################################################################
PERFORMANCE_GUIDE = r"""
Advanced BRM Performance & Index Suggestions:
1) CREATE INDEX IX_BRM_RULES_STATUS ON BRM_RULES(STATUS);
2) CREATE INDEX IX_BRM_RULES_OWNERGROUP ON BRM_RULES(OWNER_GROUP);
3) CREATE INDEX IX_RULE_EXECUTION_LOGS_TS ON RULE_EXECUTION_LOGS(EXECUTION_TIMESTAMP);
4) Possibly partition RULE_EXECUTION_LOGS by date for large volumes.
5) For BFS concurrency, ensure minimal lock contention, short transactions.
6) Evaluate SELECT only rules that do 1=1 checks for pass/fail to reduce overhead.
7) Check scikit-learn based anomaly detection for performance spikes.
"""

def print_perf_index_scripts():
    """
    Return or print recommended T-SQL statements for indexing & performance.
    No placeholders remain.
    """
    return PERFORMANCE_GUIDE


###############################################################################
# 2) DETECT ANOMALIES IN RULE EXECS
###############################################################################
def detect_anomalies_in_rule_execs(connection, method="isolation_forest"):
    """
    If scikit-learn installed, uses either IsolationForest or LocalOutlierFactor 
    on RULE_EXECUTION_LOGS => columns [EXEC_TIME_MS, CPU_USAGE, MEM_USAGE, PASS_FLAG].
    Returns list of rule_ids flagged as anomalies.
    """
    if not ML_AVAILABLE:
        logger.warning("[Anomaly] scikit-learn not installed => skipping detection.")
        return []
    c = connection.cursor()
    try:
        c.execute("""
            SELECT RULE_ID, EXEC_TIME_MS, CPU_USAGE, MEM_USAGE, PASS_FLAG
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP>=DATEADD(DAY,-7,GETDATE())
        """)
        rows=c.fetchall()
        if not rows:
            return []
        rule_ids=[]
        data=[]
        for r_ in rows:
            rid, et, cpu, mem, pf=r_
            rule_ids.append(rid)
            data.append([float(et or 0), float(cpu or 0), float(mem or 0), float(pf or 0)])
        arr=np.array(data,dtype=np.float64)
        if method.lower()=="lof":
            lof=LocalOutlierFactor(n_neighbors=20, contamination=0.05)
            preds=lof.fit_predict(arr)
            anomalies=[ rule_ids[i] for i,p in enumerate(preds) if p==-1]
            return anomalies
        else:
            iso=IsolationForest(n_estimators=100, contamination=0.05, random_state=42)
            iso.fit(arr)
            preds=iso.predict(arr)
            anomalies=[ rule_ids[i] for i,p in enumerate(preds) if p==-1]
            return anomalies
    except Exception as ex:
        logger.error(f"[Anomaly] detect error => {ex}")
        return []


###############################################################################
# 3) PerformanceAnomalyTab (PyQt UI)
###############################################################################
class PerformanceAnomalyTab(QtWidgets.QWidget):
    """
    A PyQt tab that:
     - shows performance & index suggestions from print_perf_index_scripts
     - has a button for anomaly detection
     - displays results
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.tips_edit=QPlainTextEdit()
        self.tips_edit.setReadOnly(True)
        layout.addWidget(QLabel("Performance & Index Suggestions:"))
        layout.addWidget(self.tips_edit)

        self.detect_btn=QPushButton("Run Anomaly Detection")
        self.detect_btn.clicked.connect(self.run_detection)
        layout.addWidget(self.detect_btn)

        self.result_edit=QPlainTextEdit()
        self.result_edit.setReadOnly(True)
        layout.addWidget(QLabel("Detection Results:"))
        layout.addWidget(self.result_edit)

        self.setLayout(layout)
        self.show_perf_tips()

    def show_perf_tips(self):
        tips=print_perf_index_scripts()
        self.tips_edit.setPlainText(tips)

    def run_detection(self):
        anomalies=detect_anomalies_in_rule_execs(self.connection, method="isolation_forest")
        if anomalies:
            self.result_edit.setPlainText(f"Anomalies found in rule IDs: {anomalies}")
        else:
            self.result_edit.setPlainText("No anomalies or insufficient data.")


###############################################################################
# 4) Concurrency BFS references (If chunk #1 doesn't already define it)
###############################################################################
# Typically, we've placed concurrency BFS in chunk #1 as well. 
# If you prefer it here, you can do so. 
# But we'll assume chunk #1 has the final concurrency BFS logic.

