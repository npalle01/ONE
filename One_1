#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: core_foundation.py
Description:
  Core foundation module for the Advanced BRM Tool. It includes:
   • Centralized logging configuration and helper functions
   • DatabaseConnectionDialog for user selection of DSN/custom conn strings
   • LoginDialog for credential-based authentication
   • LockManager for concurrency control and (partial) live-collaboration presence
   • EmailNotifier for SMTP-based notifications
   • insert_audit_log for capturing user or system actions in BRM_AUDIT_LOG
"""

import os
import sys
import logging
import logging.config
import smtplib
import pyodbc
from datetime import datetime
from email.mime.text import MIMEText

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog, QLabel, QLineEdit, QPushButton, QVBoxLayout, QHBoxLayout,
    QMessageBox, QComboBox
)

# ===================== Logging Setup =====================
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "detailed": {
            "format": "%(asctime)s %(levelname)s [%(name)s] %(message)s"
        }
    },
    "handlers": {
        "file_handler": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "advanced_brm_tool.log"),
            "formatter": "detailed",
            "level": os.getenv("BRM_LOG_LEVEL", "DEBUG")
        },
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "detailed",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["file_handler", "console"],
        "level": os.getenv("BRM_LOG_LEVEL", "DEBUG")
    }
}
logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("core_foundation")

# -------------------- Audit Logging Function --------------------
def insert_audit_log(conn, action_type, target_table, target_id, performed_by, old_data, new_data):
    """
    Insert an audit log entry into the BRM_AUDIT_LOG table.

    :param conn: pyodbc connection
    :param action_type: e.g. "LOGIN", "UPDATE_RULE", "RUN_SIMULATION", etc.
    :param target_table: e.g. "BRM_RULES"
    :param target_id: the primary key or unique identifier
    :param performed_by: username or system identifier
    :param old_data: dictionary or string representing the old state
    :param new_data: dictionary or string representing the new state
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION_TYPE, TARGET_TABLE, TARGET_ID,
                PERFORMED_BY, OLD_DATA_JSON, NEW_DATA_JSON, TIMESTAMP
            )
            VALUES (?, ?, ?, ?, ?, ?, GETDATE())
        """, (
            action_type,
            target_table,
            str(target_id) if target_id is not None else None,
            performed_by,
            str(old_data) if old_data is not None else None,
            str(new_data) if new_data is not None else None
        ))
        conn.commit()
        logger.debug(f"Audit log inserted: action={action_type}, table={target_table}, id={target_id}")
    except Exception as ex:
        logger.error(f"Failed to insert audit log: {ex}")

# ===================== Email Notifier =====================
class EmailNotifier:
    """
    Basic SMTP-based email notifier. Production usage can expand to Slack/Teams integration.
    """
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject, body, recipients):
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)
            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as ex:
            logger.error(f"Error sending email to {recipients}: {ex}")

# ===================== Database Connection Dialog =====================
class DatabaseConnectionDialog(QDialog):
    """
    Dialog for selecting an ODBC DSN or providing a custom connection string.
    Returns a pyodbc connection or None if canceled.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Advanced BRM Tool")
        self.resize(400, 200)
        main_layout = QVBoxLayout(self)

        lbl = QLabel("Select an ODBC DSN or enter a custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error retrieving DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom connection string")
        main_layout.addWidget(self.conn_str_edit)

        btn_layout = QHBoxLayout()
        connect_btn = QPushButton("Connect")
        connect_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(connect_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            selected_dsn = self.dsn_combo.currentData()
            if not selected_dsn:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={selected_dsn};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

# ===================== Login Dialog =====================
class LoginDialog(QDialog):
    """
    Basic credential-based login. In production, consider SSO or hashed passwords.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – Advanced BRM Tool")
        self.resize(300, 150)

        main_layout = QVBoxLayout(self)
        self.username_edit = QLineEdit()
        self.username_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.username_edit)

        self.password_edit = QLineEdit()
        self.password_edit.setPlaceholderText("Password")
        self.password_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.password_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)

        self.setLayout(main_layout)

    def do_login(self):
        username = self.username_edit.text().strip()
        password = self.password_edit.text().strip()
        if not username or not password:
            QMessageBox.warning(self, "Input Error", "Please enter both username and password.")
            return
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (username, password))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {username} logged in successfully.")
                insert_audit_log(self.connection, "LOGIN", "USERS", self.user_id, username, None, {"login":"success"})
                self.accept()
            else:
                QMessageBox.warning(self, "Authentication Failed", "Invalid credentials.")
        except Exception as ex:
            logger.error(f"Login error: {ex}")
            QMessageBox.critical(self, "Error", f"An error occurred: {ex}")

# ===================== Lock Manager (live collaboration concept) =====================
class LockManager:
    """
    Manages rule locks to prevent concurrent edits. 
    Optionally used to show presence for 'live collaboration' if extended with websockets.
    """
    @staticmethod
    def lock_rule(conn, rule_id, locked_by, force=False):
        c = conn.cursor()
        # Cleanup old locks older than 30 minutes
        c.execute("DELETE FROM RULE_LOCKS WHERE DATEDIFF(MINUTE, LOCK_TIMESTAMP, GETDATE()) > 30")
        conn.commit()

        c.execute("SELECT LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if row:
            existing_lock = row[0]
            if existing_lock != locked_by and not force:
                raise ValueError(f"Rule {rule_id} is already locked by {existing_lock}.")
            else:
                # Overwrite or force
                c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        c.execute("""
            INSERT INTO RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP) 
            VALUES (?, ?, GETDATE())
        """, (rule_id, locked_by))
        conn.commit()
        logger.info(f"Rule {rule_id} locked by {locked_by}.")
        insert_audit_log(conn, "LOCK_RULE", "RULE_LOCKS", rule_id, locked_by, None, {"lock":"acquired"})

    @staticmethod
    def unlock_rule(conn, rule_id, locked_by, force=False):
        c = conn.cursor()
        c.execute("SELECT LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if not row:
            return  # Not locked
        if row[0] != locked_by and not force:
            raise ValueError(f"Cannot unlock rule {rule_id}; locked by {row[0]}.")
        c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        conn.commit()
        logger.info(f"Rule {rule_id} unlocked by {locked_by}.")
        insert_audit_log(conn, "UNLOCK_RULE", "RULE_LOCKS", rule_id, locked_by, None, {"lock":"released"})