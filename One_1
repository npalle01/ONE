#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_core_foundation.py
Description:
  This is the core foundation of the BRM Tool, handling:
    • Logging and configuration
    • Email sending (SMTP)
    • Database connection dialogs
    • Basic DB helper functions (fetch dict, insert_audit)
    • User login dialog
    • Optional OnboardingWizard for new users
    • LockManager (rule-level locking/unlocking) for concurrency control

All other modules (rule_engine, approvals, lineage, etc.) can import from here
as needed for these foundational utilities.
"""

import os
import sys
import json
import logging
import logging.config
import smtplib
import pyodbc
from datetime import datetime, timedelta
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtWidgets import (
    QApplication, QDialog, QLabel, QLineEdit, QPushButton, QVBoxLayout, 
    QHBoxLayout, QMessageBox, QComboBox, QPlainTextEdit, QSystemTrayIcon
)

###############################################################################
# 1) Logging Configuration
###############################################################################
# Adjust to your preference or use a logging config dict.
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "detailed": {
            "format": "%(asctime)s %(levelname)s [%(name)s] %(message)s"
        }
    },
    "handlers": {
        "file_handler": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_tool.log"),
            "formatter": "detailed",
            "level": os.getenv("BRM_LOG_LEVEL", "DEBUG")
        },
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "detailed",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["file_handler", "console"],
        "level": os.getenv("BRM_LOG_LEVEL", "DEBUG")
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")


###############################################################################
# 2) Email Sender Configuration
###############################################################################
class EmailNotifier:
    """
    Handles sending emails using SMTP.
    Configuration is taken from environment variables if available, or defaults.
    """
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", "587"))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as ex:
            logger.error(f"Error sending email to {recipients}: {ex}")
            raise


###############################################################################
# 3) Database Connection Dialog
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Presents a dialog to choose an ODBC DSN or provide a custom connection string.
    The user can then connect to the DB and retrieve a pyodbc.Connection.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – BRM Tool")
        self.resize(400, 200)

        layout = QVBoxLayout(self)

        lbl = QLabel("Select an ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error retrieving DSNs: {ex}")
        layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom connection string (optional)")
        layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        connect_btn = QPushButton("Connect")
        connect_btn.clicked.connect(self.accept)
        btn_h.addWidget(connect_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            selected_dsn = self.dsn_combo.currentData()
            if not selected_dsn:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={selected_dsn};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None


###############################################################################
# 4) DB Helper Functions
###############################################################################
def fetch_all_dict(cursor):
    """
    Convert all rows in cursor.fetchall() into a list of dicts.
    If no description => return raw rows.
    """
    rows = cursor.fetchall()
    if not cursor.description:
        return rows
    colnames = [desc[0] for desc in cursor.description]
    out = []
    for row in rows:
        out.append(dict(zip(colnames, row)))
    return out

def fetch_one_dict(cursor):
    """
    Fetch one row as a dict, or None if none, or raw row if no description.
    """
    row = cursor.fetchone()
    if not row:
        return None
    if not cursor.description:
        return row
    colnames = [desc[0] for desc in cursor.description]
    return dict(zip(colnames, row))

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    """
    Insert into a standard BRM_AUDIT_LOG table if you have one. 
    Or skip if using a unified activity log. 
    For now, we keep it here for backward compatibility.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, 
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES (?,?,?,?,?,?,GETDATE())
        """,(
            action,
            table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")


###############################################################################
# 5) Login Dialog
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Minimal login form => checks USERS table => sets user_id, user_group.
    In production, handle password hashing or external auth.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – BRM Tool")
        self.resize(300, 150)

        layout = QVBoxLayout(self)

        self.username_edit = QLineEdit()
        self.username_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.username_edit)

        self.password_edit = QLineEdit()
        self.password_edit.setPlaceholderText("Password")
        self.password_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.password_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        layout.addWidget(login_btn)

        self.setLayout(layout)

    def do_login(self):
        un = self.username_edit.text().strip()
        pw = self.password_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Please enter both username and password.")
            return
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in successfully.")
                self.accept()
            else:
                QMessageBox.warning(self, "Authentication Failed", "Invalid credentials.")
        except Exception as ex:
            logger.error(f"Login error: {ex}")
            QMessageBox.critical(self, "Error", f"An error occurred: {ex}")


###############################################################################
# 6) Onboarding Wizard (Optional)
###############################################################################
class OnboardingWizard(QDialog):
    """
    A wizard for new users or new installations, guiding them to create a group,
    add a rule, schedule, etc. You can extend or skip entirely.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Welcome Wizard – BRM Tool")
        self.resize(400, 300)
        main_layout = QVBoxLayout(self)

        self.label = QLabel("Welcome to the advanced BRM Tool!\nThis wizard helps you do initial setup.")
        main_layout.addWidget(self.label)

        self.current_step = 0
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        main_layout.addWidget(self.next_btn)

        self.setLayout(main_layout)

    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Go to 'Group Management' => create a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Go to 'Business Rules' => add your first rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Proceed to 'Scheduling' => create a new schedule.")
        else:
            self.label.setText("Setup complete! Enjoy using the BRM Tool.")
            self.accept()


###############################################################################
# 7) LockManager for concurrency on rule editing
###############################################################################
class LockManager:
    """
    Provides static methods to lock/unlock a rule to prevent concurrent edits.
    Relies on a 'RULE_LOCKS' table or 'BRM_RULE_LOCKS' with columns:
      RULE_ID int
      LOCKED_BY varchar
      LOCK_TIMESTAMP datetime
      ...
    We show one approach. You can adapt your DB schema.
    """
    @staticmethod
    def lock_rule(conn, rule_id, locked_by: str, force: bool=False):
        """
        Attempt to lock the rule. If it's locked by someone else, either fail or override if force=True.
        Also can auto-clean old locks if you want. 
        """
        c = conn.cursor()
        # remove stale locks older than 30 min
        c.execute("""
            DELETE FROM BRM_RULE_LOCKS
            WHERE DATEDIFF(MINUTE, LOCK_TIMESTAMP, GETDATE()) > 30
        """)
        conn.commit()

        c.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if row:
            existing = row[0]
            if existing != locked_by and not force:
                raise ValueError(f"Rule {rule_id} is locked by {existing}. Use force if admin.")
            else:
                # override lock => remove old
                c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
                conn.commit()
        # add new lock
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP)
            VALUES(?,?, GETDATE())
        """,(rule_id, locked_by))
        conn.commit()
        logger.info(f"Rule {rule_id} locked by {locked_by}. Force={force}")

    @staticmethod
    def unlock_rule(conn, rule_id, locked_by: str, force: bool=False):
        c = conn.cursor()
        c.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if not row:
            return  # not locked
        if row[0] != locked_by and not force:
            raise ValueError(f"Cannot unlock rule {rule_id}, locked by {row[0]}. Force or same user required.")
        c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        conn.commit()
        logger.info(f"Rule {rule_id} unlocked by {locked_by}. Force={force}")


###############################################################################
# End of brm_core_foundation
###############################################################################