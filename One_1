#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_core_foundation.py
Description: 
  The fundamental “core” module for the advanced BRM Tool. 
  Includes:
    • Centralized logging config
    • EmailNotifier class
    • DatabaseConnectionDialog
    • Basic DB helpers (fetch, audit insertion)
    • A robust LockManager for rules 
    • Advanced SQL parsing (parse_sql_dependencies, detect_operation_type)
    • LoginDialog for user auth
    • OnboardingWizard (optional usage)
    
All references are fully implemented (no minimal stubs).
"""
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, sys, json, logging, logging.config, smtplib, pyodbc, sqlparse, re
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout, QMessageBox, QComboBox
from PyQt5.QtCore import Qt, QTimer

LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {"standard": {"format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"}},
    "handlers": {
        "console": {"class": "logging.StreamHandler", "formatter": "standard", "level": "DEBUG"},
        "file": {"class": "logging.FileHandler", "filename": os.getenv("BRM_LOG_FILE", "brm_core.log"), "formatter": "standard", "level": os.getenv("BRM_LOG_LEVEL", "INFO")}
    },
    "root": {"handlers": ["console", "file"], "level": "DEBUG"}
}
logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")

class EmailNotifier:
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")
    def send_email(self, subject, body, recipients):
        if not recipients:
            logger.warning("No recipients provided.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)
            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email: {e}")
            raise

class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – BRM Tool")
        self.resize(400, 200)
        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select an ODBC DSN or enter a custom connection string:")
        main_layout.addWidget(lbl)
        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)
        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)
    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

def fetch_all_dict(cursor):
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        return [dict(zip(colnames, row)) for row in rows]
    return rows

def fetch_one_dict(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
            VALUES (?, ?, ?, ?, ?, ?, GETDATE())
        """, (action, table_name, str(record_id) if record_id else None, actor, json.dumps(old_data) if old_data else None, json.dumps(new_data) if new_data else None))
        conn.commit()
        logger.debug(f"Audit log inserted for action {action} on table {table_name}.")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")

class LockManager:
    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < ?", (now,))
        rc = c.rowcount
        conn.commit()
        if rc > 0:
            logger.info(f"Auto-unlocked {rc} expired locks.")
    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
            FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag, active = row
        if not active:
            return None
        if et and datetime.now() > et:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
            conn.commit()
            return None
        return (locked_by, lts, et, fflag)
    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if info:
            locked_by, _, _, _ = info
            if locked_by == user_id:
                c.execute("UPDATE BRM_RULE_LOCKS SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=? WHERE RULE_ID=? AND ACTIVE_LOCK=1",
                          (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
                    c.execute("INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK) VALUES(?,?,?,?,?,1)",
                              (rule_id, user_id, now, expiry, 1 if force else 0))
                    conn.commit()
                    return
        else:
            c.execute("INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK) VALUES(?,?,?,?,?,1)",
                      (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return
        locked_by, _, _, _ = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
        c = conn.cursor()
        c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        conn.commit()

class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – BRM Tool")
        self.resize(300, 150)
        main_l = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_l.addWidget(QLabel("Username:"))
        main_l.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_l.addWidget(QLabel("Password:"))
        main_l.addWidget(self.pass_edit)
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_l.addWidget(login_btn)
        self.setLayout(main_l)
    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password required.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (un, pw))
        row = c.fetchone()
        if row:
            self.user_id, self.user_group = row
            logger.info(f"User {un} logged in.")
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")

class OnboardingWizard(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Welcome Wizard – BRM Tool")
        self.resize(400, 250)
        main_l = QVBoxLayout(self)
        self.label = QLabel("Welcome to the BRM Tool Onboarding Wizard!")
        main_l.addWidget(self.label)
        self.current_step = 0
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        main_l.addWidget(self.next_btn)
        self.setLayout(main_l)
    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Create a new business group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Add a new business rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Schedule the rule execution.")
        else:
            self.label.setText("All done. Enjoy using the BRM Tool.")
            self.accept()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    dlg = DatabaseConnectionDialog()
    dlg.exec_()
