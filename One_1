
#core.py

#!/usr/bin/env python
# core.py
"""
Core Module for BRM Tool
  - Logging & Email configuration
  - DatabaseConnectionDialog and LoginDialog
  - Basic DB helper functions (fetch_all_dict, fetch_one_dict, insert_audit_log)
  - SQL parsing utilities: detect_operation_type() and parse_sql_dependencies()
"""

import sys
import json
import logging
import pyodbc
import sqlparse
import re
import csv
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QLineEdit, QMessageBox
from PyQt5.QtCore import Qt, QDateTime

# Configure logging
logging.basicConfig(
    filename='brm_tool.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

# Email configuration
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_user",
    "smtp_password": "your_smtp_pass",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        # For production, use smtplib.SMTP â€“ here we simply log the send event.
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email: {ex}")

# Database Connection Dialog
class DatabaseConnectionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection")
        self.resize(400, 200)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Select ODBC DSN or enter connection string:"))
        self.dsnCombo = QtWidgets.QComboBox(self)
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsnCombo.addItem(dsn, dsn)
        except Exception as e:
            logger.error(f"Error listing DSNs: {e}")
        layout.addWidget(self.dsnCombo)
        self.connStrEdit = QLineEdit(self)
        self.connStrEdit.setPlaceholderText("Or custom connection string")
        layout.addWidget(self.connStrEdit)
        btnLayout = QHBoxLayout()
        btnConnect = QPushButton("Connect", self)
        btnConnect.clicked.connect(self.accept)
        btnCancel = QPushButton("Cancel", self)
        btnCancel.clicked.connect(self.reject)
        btnLayout.addWidget(btnConnect)
        btnLayout.addWidget(btnCancel)
        layout.addLayout(btnLayout)

    def get_connection(self):
        conn_str = self.connStrEdit.text().strip()
        if not conn_str:
            dsn = self.dsnCombo.currentData()
            if not dsn:
                QMessageBox.critical(self, "Error", "No DSN provided.")
                return None
            conn_str = f"DSN={dsn};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

# Login Dialog
class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.resize(300, 150)
        layout = QVBoxLayout(self)
        self.userEdit = QLineEdit(self)
        self.userEdit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.userEdit)
        self.passEdit = QLineEdit(self)
        self.passEdit.setPlaceholderText("Password")
        self.passEdit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.passEdit)
        btn = QPushButton("Login", self)
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

    def do_login(self):
        username = self.userEdit.text().strip()
        password = self.passEdit.text().strip()
        if not username or not password:
            QMessageBox.warning(self, "Error", "Username and Password required.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (username, password))
        row = c.fetchone()
        if row:
            self.user_id = row[0]
            self.user_group = row[1]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")

# Basic DB Helper Functions
def fetch_all_dict(cursor):
    rows = cursor.fetchall()
    if cursor.description:
        cols = [d[0] for d in cursor.description]
        return [dict(zip(cols, row)) for row in rows]
    return rows

def fetch_one_dict(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [d[0] for d in cursor.description]
        return dict(zip(cols, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG (ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
    VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (action, table_name, str(record_id) if record_id else None, actor,
          json.dumps(old_data) if old_data else None, json.dumps(new_data) if new_data else None))
    conn.commit()

# SQL Parsing Utilities
def detect_operation_type(rule_sql: str, decision_table_id=None) -> str:
    if (not rule_sql.strip()) and decision_table_id:
        return "DECISION_TABLE"
    txt = rule_sql.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def parse_sql_dependencies(sql_text: str):
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []
    for stmt in statements:
        ctes = _extract_with_clauses(stmt)
        for cte_name, refs in ctes.items():
            cte_info.append((cte_name, refs))
        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)
        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)
    unique_tables = list({t for t in all_tables})
    return {"tables": unique_tables, "cte_tables": cte_info, "alias_map": alias_map, "columns": columns}

def _extract_with_clauses(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, sqlparse.sql.Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if tk.value.upper() == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, sqlparse.sql.Parenthesis):
                    cte_map[cte_name] = _extract_subselect_tokens(sub.tokens)
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    for tk in tokens:
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("FROM", "JOIN"):
            from_seen = True
        if from_seen:
            if isinstance(tk, sqlparse.sql.Identifier):
                results.append((tk.get_parent_name(), tk.get_real_name(), tk.get_alias(), False))
            elif isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    results.append((ident.get_parent_name(), ident.get_real_name(), ident.get_alias(), False))
    return results

def _extract_main_from(tokenlist, known_ctes):
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    for tk in tokens:
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("FROM", "JOIN"):
            from_seen = True
        if from_seen:
            if isinstance(tk, sqlparse.sql.Identifier):
                rname = tk.get_real_name()
                schema = tk.get_parent_name()
                alias = tk.get_alias()
                if rname and rname.upper() not in (cte.upper() for cte in known_ctes):
                    results.append((schema, rname, alias, False))
                    if alias:
                        alias_map[alias] = (schema, rname)
            elif isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    rname = ident.get_real_name()
                    schema = ident.get_parent_name()
                    alias = ident.get_alias()
                    if rname and rname.upper() not in (cte.upper() for cte in known_ctes):
                        results.append((schema, rname, alias, False))
                        if alias:
                            alias_map[alias] = (schema, rname)
    return results, alias_map

def _extract_columns(statement):
    results = []
    tokens = list(statement.tokens)
    for tk in tokens:
        if tk.ttype is sqlparse.tokens.DML and tk.value.upper() == "SELECT":
            results.extend(_parse_select_list(tokens))
    return results

def _parse_select_list(tokens):
    cols = []
    for tk in tokens:
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("FROM", "WHERE", "GROUP", "ORDER"):
            break
        if isinstance(tk, sqlparse.sql.IdentifierList):
            for ident in tk.get_identifiers():
                nm = ident.get_name()
                if nm:
                    cols.append(nm)
        elif isinstance(tk, sqlparse.sql.Identifier):
            nm = tk.get_name()
            if nm:
                cols.append(nm)
    return cols
