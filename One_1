#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: core_foundation.py
Description: Core foundation for the BRM Tool with production‐ready enhancements.
Includes:
  - Centralized logging with configurable levels.
  - EmailNotifier for SMTP-based notifications.
  - DatabaseConnectionDialog to connect using DSN or custom connection strings.
  - LoginDialog for user authentication.
  - LockManager to handle rule locking and unlocking.
  - Advanced SQL parsing utilities.
  - OnboardingWizard for new users.
  - RealTimeNotifier (using QSystemTrayIcon) for live notifications.
  
All configuration values are loaded from environment variables when available.
"""

import os
import sys
import json
import math
import smtplib
import logging
import logging.config
import pyodbc
import sqlparse
import re
import csv
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports for UI components and system tray notifications
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import (
    QApplication, QDialog, QLabel, QLineEdit, QPushButton, QVBoxLayout, QHBoxLayout,
    QMessageBox, QComboBox, QPlainTextEdit, QSystemTrayIcon
)

# ===================== Logging Setup =====================
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "detailed": {
            "format": "%(asctime)s %(levelname)s [%(name)s] %(message)s"
        }
    },
    "handlers": {
        "file_handler": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_tool.log"),
            "formatter": "detailed",
            "level": os.getenv("BRM_LOG_LEVEL", "DEBUG")
        },
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "detailed",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["file_handler", "console"],
        "level": os.getenv("BRM_LOG_LEVEL", "DEBUG")
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("core_foundation")

# ===================== Email Notifier =====================
class EmailNotifier:
    """
    Handles sending emails using SMTP.
    Configuration is taken from environment variables if available.
    """
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")
    
    def send_email(self, subject: str, body: str, recipients: list):
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)
            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as ex:
            logger.error(f"Error sending email to {recipients}: {ex}")
            raise

# ===================== Database Connection Dialog =====================
class DatabaseConnectionDialog(QDialog):
    """
    Presents a dialog to choose an ODBC DSN or provide a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – BRM Tool")
        self.resize(400, 200)
        main_layout = QVBoxLayout(self)
        
        lbl = QLabel("Select an ODBC DSN or enter a custom connection string:")
        main_layout.addWidget(lbl)
        
        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error retrieving DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)
        
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom connection string")
        main_layout.addWidget(self.conn_str_edit)
        
        btn_layout = QHBoxLayout()
        connect_btn = QPushButton("Connect")
        connect_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(connect_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)
    
    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            selected_dsn = self.dsn_combo.currentData()
            if not selected_dsn:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={selected_dsn};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

# ===================== Login Dialog =====================
class LoginDialog(QDialog):
    """
    Basic login dialog to authenticate a user.
    (In production, consider password hashing and secure sessions.)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – BRM Tool")
        self.resize(300, 150)
        
        main_layout = QVBoxLayout(self)
        self.username_edit = QLineEdit()
        self.username_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.username_edit)
        
        self.password_edit = QLineEdit()
        self.password_edit.setPlaceholderText("Password")
        self.password_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.password_edit)
        
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)
        
        self.setLayout(main_layout)
    
    def do_login(self):
        username = self.username_edit.text().strip()
        password = self.password_edit.text().strip()
        if not username or not password:
            QMessageBox.warning(self, "Input Error", "Please enter both username and password.")
            return
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (username, password))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {username} logged in successfully.")
                self.accept()
            else:
                QMessageBox.warning(self, "Authentication Failed", "Invalid credentials.")
        except Exception as ex:
            logger.error(f"Login error: {ex}")
            QMessageBox.critical(self, "Error", f"An error occurred: {ex}")

# ===================== Lock Manager =====================
class LockManager:
    """
    Provides locking and unlocking functions to prevent concurrent edits.
    """
    @staticmethod
    def lock_rule(conn, rule_id: int, locked_by: str, force: bool = False):
        c = conn.cursor()
        # Cleanup old locks older than 30 minutes
        c.execute("DELETE FROM RULE_LOCKS WHERE DATEDIFF(MINUTE, LOCK_TIMESTAMP, GETDATE()) > 30")
        conn.commit()
        c.execute("SELECT LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if row:
            existing_lock = row[0]
            if existing_lock != locked_by and not force:
                raise ValueError(f"Rule {rule_id} is already locked by {existing_lock}.")
            else:
                c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        c.execute("INSERT INTO RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP) VALUES (?, ?, GETDATE())",
                  (rule_id, locked_by))
        conn.commit()
        logger.info(f"Rule {rule_id} locked by {locked_by}.")

    @staticmethod
    def unlock_rule(conn, rule_id: int, locked_by: str, force: bool = False):
        c = conn.cursor()
        c.execute("SELECT LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if not row:
            return  # Not locked
        if row[0] != locked_by and not force:
            raise ValueError(f"Cannot unlock rule {rule_id} as it is locked by {row[0]}.")
        c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?", (rule_id,))
        conn.commit()
        logger.info(f"Rule {rule_id} unlocked by {locked_by}.")

# ===================== Advanced SQL Parsing Utilities =====================
def parse_sql_dependencies(sql_text: str):
    """
    Parse SQL text using sqlparse to extract table dependencies,
    common table expressions, aliases, and referenced columns.
    Returns a dictionary with keys:
      - 'tables': list of (schema, table, alias, is_subquery)
      - 'cte_tables': list of defined CTE names and their references
      - 'alias_map': dict mapping alias to (schema, table)
      - 'columns': list of referenced column names (with flags for write/read)
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []

    for stmt in statements:
        ctes = _extract_with_clauses(stmt)
        for cte_name, cte_refs in ctes.items():
            cte_info.append((cte_name, cte_refs))
        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)
        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)

    unique_tables = list({t for t in all_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }

def _extract_with_clauses(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, sqlparse.sql.Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is None and tk.value.upper() == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, sqlparse.sql.Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if hasattr(tk, 'is_group') and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is sqlparse.tokens.Keyword:
            if tk.value.upper() in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    results.append(_parse_identifier(ident, set()))
            elif isinstance(tk, sqlparse.sql.Identifier):
                results.append(_parse_identifier(tk, set()))
        i += 1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is sqlparse.tokens.DML and sub.value.upper() == "SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_ctes):
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if hasattr(tk, 'is_group') and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is sqlparse.tokens.Keyword:
            if tk.value.upper() in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    parsed = _parse_identifier(ident, known_ctes)
                    results.append(parsed)
                    if parsed[2]:
                        alias_map[parsed[2]] = (parsed[0], parsed[1])
            elif isinstance(tk, sqlparse.sql.Identifier):
                parsed = _parse_identifier(tk, known_ctes)
                results.append(parsed)
                if parsed[2]:
                    alias_map[parsed[2]] = (parsed[0], parsed[1])
        i += 1
    return (results, alias_map)

def _parse_identifier(ident, known_ctes):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema_name = ident.get_parent_name()
    if real_name and real_name.upper() in (name.upper() for name in known_ctes):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.DML:
            word = tk.value.upper()
            if word == "SELECT":
                results.extend(_parse_select_list(tokens, i+1))
            elif word in ("INSERT", "UPDATE"):
                results.extend(_parse_dml_columns(tokens, i, word))
        i += 1
    return results

def _parse_select_list(tokens, start_idx):
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in (
            "FROM", "JOIN", "WHERE", "GROUP", "ORDER", "UNION", "INTERSECT"
        ):
            break
        if isinstance(tk, sqlparse.sql.IdentifierList):
            for ident in tk.get_identifiers():
                nm = ident.get_name()
                if nm and nm.upper() not in ("DISTINCT", "TOP", "ALL"):
                    columns.append(nm)
        elif isinstance(tk, sqlparse.sql.Identifier):
            nm = tk.get_name()
            if nm and nm.upper() not in ("DISTINCT", "TOP", "ALL"):
                columns.append(nm)
        i += 1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, sqlparse.sql.Parenthesis):
                for sub in tk.tokens:
                    if isinstance(sub, sqlparse.sql.IdentifierList):
                        for ident in sub.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(sub, sqlparse.sql.Identifier):
                        columns.append(sub.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return columns

def _parse_update_set_list(tokens, start_i):
    columns = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("WHERE", "FROM"):
            break
        if isinstance(tk, sqlparse.sql.Identifier):
            columns.append(tk.get_name())
        i += 1
    return columns

# ===================== Onboarding Wizard =====================
class OnboardingWizard(QDialog):
    """
    A wizard for new users to perform initial setup.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Welcome Wizard – BRM Tool")
        self.resize(400, 300)
        main_layout = QVBoxLayout(self)
        self.steps_label = QLabel(
            "Welcome to the advanced BRM Tool!\nThis wizard will guide you through the initial setup."
        )
        main_layout.addWidget(self.steps_label)
        self.current_step = 0
        next_btn = QPushButton("Next")
        next_btn.clicked.connect(self.advance_step)
        main_layout.addWidget(next_btn)
        self.setLayout(main_layout)
    
    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.steps_label.setText("Step 1: Navigate to 'Group Management' and create a new group.")
        elif self.current_step == 2:
            self.steps_label.setText("Step 2: Go to 'Business Rules' and add a new rule.")
        elif self.current_step == 3:
            self.steps_label.setText("Step 3: Proceed to 'Scheduling' and create a new schedule.")
        else:
            self.steps_label.setText("Setup complete. Enjoy using the BRM Tool!")
            self.accept()

# ===================== Real-Time Notifier =====================
class RealTimeNotifier(QtWidgets.QSystemTrayIcon):
    """
    Uses the system tray to display real-time notifications.
    This can be used for simulation results, approvals, or performance alerts.
    """
    def __init__(self, icon: QIcon, parent=None):
        super().__init__(icon, parent)
        self.setToolTip("BRM Tool Notifications")
        self.menu = QtWidgets.QMenu(parent)
        quit_action = self.menu.addAction("Quit")
        quit_action.triggered.connect(QtWidgets.qApp.quit)
        self.setContextMenu(self.menu)
        self.show()

    def show_notification(self, title: str, message: str, msecs: int = 5000):
        # Depending on the platform, the showMessage method may display a balloon tooltip.
        self.showMessage(title, message, QSystemTrayIcon.Information, msecs)

# ===================== Example Main Testing (for Core Module) =====================
if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    # Optionally load a custom stylesheet for modern UI (you can replace the string below with your QSS)
    style_sheet = """
        QWidget { font-family: Arial; font-size: 12pt; }
        QLineEdit, QPlainTextEdit, QTextEdit { background-color: #F5F5F5; border: 1px solid #CCCCCC; }
        QPushButton { background-color: #4CAF50; color: white; padding: 5px; border-radius: 3px; }
        QPushButton:hover { background-color: #45a049; }
    """
    app.setStyleSheet(style_sheet)
    
    # Create system tray notifier for real-time notifications
    tray_icon = RealTimeNotifier(QIcon("icon.png"))
    
    # Show the database connection dialog
    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() == QDialog.Accepted:
        conn = db_dialog.get_connection()
        if not conn:
            sys.exit(1)
    else:
        sys.exit(0)
    
    # Show login dialog
    login_dialog = LoginDialog(conn)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    
    # For testing, show the onboarding wizard (optional)
    wizard = OnboardingWizard(conn)
    wizard.exec_()
    
    # Send a test notification (simulate a simulation run log)
    tray_icon.show_notification("Simulation Complete", "Dry-run simulation: 100 records impacted, SUCCESS")
    
    # Run the application loop (for testing this module alone)
    sys.exit(app.exec_())