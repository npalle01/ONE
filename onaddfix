class RuleEditorDialog(QDialog):
    """
    A dialog that either creates a new rule (if rule_data is None)
    or updates an existing rule (if rule_data is a dict).
    It uses add_rule(...) / update_rule(...) from your logic.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data  # if None => new, else update
        self.is_update = (rule_data is not None)

        # Set window title
        title = "Update Rule" if self.is_update else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(700, 500)

        # Main layout
        main_layout = QVBoxLayout(self)

        # Left side basic info
        form_box = QFormLayout()
        # RULE NAME
        self.name_edit = QLineEdit()
        form_box.addRow("Rule Name:", self.name_edit)
        # RULE SQL
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("Enter SQL logic here...")
        form_box.addRow("Rule SQL:", self.sql_edit)
        # STATUS
        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE", "ACTIVE"])  # or from DB
        form_box.addRow("Status:", self.status_combo)
        # START DATE
        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_box.addRow("Effective Start:", self.start_dt)
        # END DATE
        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_box.addRow("Effective End:", self.end_dt)
        # DESCRIPTION
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlaceholderText("Optional description...")
        form_box.addRow("Description:", self.desc_edit)

        # CRITICAL? GLOBAL? etc.
        self.global_cb = None
        if self.user_group == "Admin":
            self.global_cb = QCheckBox("Global (Admin only)")
            form_box.addRow("Global Rule:", self.global_cb)

        self.critical_cb = QCheckBox()
        form_box.addRow("Critical Rule?:", self.critical_cb)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        form_box.addRow("Critical Scope:", self.scope_combo)

        # BUSINESS JUSTIFICATION
        self.just_edit = QTextEdit()
        self.just_edit.setPlaceholderText("Why is this rule needed / justification?")
        form_box.addRow("Justification:", self.just_edit)

        main_layout.addLayout(form_box)

        # Buttons
        btn_h = QHBoxLayout()
        self.save_btn = QPushButton("Save" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_h.addWidget(self.save_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

        # If we are updating, load existing data
        if self.is_update and self.rule_data:
            self.load_rule_data(self.rule_data)

        self.setLayout(main_layout)

    def load_rule_data(self, rd):
        """
        Pre-fill fields from existing rule_data for update mode.
        """
        self.name_edit.setText(rd.get("RULE_NAME", ""))
        self.sql_edit.setPlainText(rd.get("RULE_SQL", ""))

        st = rd.get("STATUS", "INACTIVE")
        idx_status = self.status_combo.findText(st)
        if idx_status >= 0:
            self.status_combo.setCurrentIndex(idx_status)

        # Parse the string date from DB (yyyy-mm-dd HH:MM:SS?)
        from datetime import datetime
        fmt = "%Y-%m-%d %H:%M:%S"
        try:
            sdate = datetime.strptime(rd["EFFECTIVE_START_DATE"], fmt)
            self.start_dt.setDateTime(QDateTime(sdate))
        except:
            pass

        if rd.get("EFFECTIVE_END_DATE"):
            try:
                edate = datetime.strptime(rd["EFFECTIVE_END_DATE"], fmt)
                self.end_dt.setDateTime(QDateTime(edate))
            except:
                pass

        if "DESCRIPTION" in rd and rd["DESCRIPTION"]:
            self.desc_edit.setText(rd["DESCRIPTION"])

        if self.global_cb is not None:
            if rd.get("IS_GLOBAL", 0) == 1:
                self.global_cb.setChecked(True)

        if rd.get("CRITICAL_RULE", 0) == 1:
            self.critical_cb.setChecked(True)

        cscope = rd.get("CRITICAL_SCOPE", "NONE").upper()
        i_scope = self.scope_combo.findText(cscope)
        if i_scope >= 0:
            self.scope_combo.setCurrentIndex(i_scope)

        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

    def on_save(self):
        """
        Collect user input, call add_rule(...) or update_rule(...).
        """
        # Basic checks
        nm = self.name_edit.text().strip()
        sq = self.sql_edit.toPlainText().strip()
        if not nm:
            QMessageBox.warning(self, "Error", "Rule name is required.")
            return
        if not sq:
            QMessageBox.warning(self, "Error", "SQL cannot be empty.")
            return

        # Build dictionary
        st = self.status_combo.currentText()
        start_dt_str = self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_dt_str   = self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")

        rule_dict = {
            "RULE_NAME": nm,
            "RULE_SQL": sq,
            "STATUS": st,
            "EFFECTIVE_START_DATE": start_dt_str,
            "EFFECTIVE_END_DATE": end_dt_str,
            "DESCRIPTION": self.desc_edit.toPlainText().strip(),
            "BUSINESS_JUSTIFICATION": self.just_edit.toPlainText().strip(),
            "CRITICAL_RULE": 1 if self.critical_cb.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
        }

        if self.global_cb:  # only if user is admin
            rule_dict["IS_GLOBAL"] = 1 if self.global_cb.isChecked() else 0
        else:
            rule_dict["IS_GLOBAL"] = 0

        # If we are updating
        from your_brm_crud_module import add_rule, update_rule  # or wherever your add_rule/update_rule are

        if self.is_update:
            # We already have the existing RULE_ID in self.rule_data
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            # Possibly keep same group_id, owner_group from old
            rule_dict["OWNER_GROUP"] = self.rule_data["OWNER_GROUP"]
            rule_dict["GROUP_ID"]    = self.rule_data["GROUP_ID"]
            rule_dict["RULE_TYPE_ID"]= self.rule_data["RULE_TYPE_ID"]  # or allow user to pick?

            # Now call update_rule
            try:
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self, "Success", f"Rule '{nm}' updated successfully!")
                self.accept()  # close with success
            except Exception as ex:
                QMessageBox.critical(self, "Update Error", str(ex))

        else:
            # It's a new rule
            # Possibly let user pick an owner_group from a combo? 
            # Or default to this user group or an input field
            # For now we assume a default group_id=1, or the user is asked
            # We'll do a minimal approach:
            rule_dict["OWNER_GROUP"] = self.user_group  # or "BG1"
            rule_dict["GROUP_ID"]    = 1
            rule_dict["RULE_TYPE_ID"]= 1

            try:
                new_id = add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self, "Success", f"Rule '{nm}' created with ID={new_id}.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Add Error", str(ex))


def on_add_rule(self):
    """
    Opens a dialog to create a brand-new rule.
    Calls add_rule(...) if user confirms.
    """
    # Step 1: Create the dialog in "add mode"
    dialog = RuleEditorDialog(
        connection=self.connection,
        user_group=self.user_group,
        parent=self,
        rule_data=None  # means we're creating new
    )

    # Step 2: If user clicks Save (QDialog.Accepted), retrieve the rule_data
    if dialog.exec_() == QtWidgets.QDialog.Accepted:
        # The dialog itself calls add_rule(...) internally or returns new rule_data
        # or it might call a method in MainWindow. Variation depends on your approach.

        QMessageBox.information(self, "Success", "New rule added successfully.")
        self.brm_dashboard.load_rules()  # Refresh the table

def on_update_rule(self):
    """
    Opens a dialog to update an existing rule.
    Calls update_rule(...) if user confirms.
    """
    # Step 1: Get the selected rule ID(s)
    rids = self.brm_dashboard.get_selected_rule_ids()
    if len(rids) != 1:
        QMessageBox.warning(self, "Error", "Select exactly one rule to update.")
        return
    rule_id = rids[0]

    # Step 2: Fetch the existing rule from DB
    c = self.connection.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old_row = c.fetchone()
    if not old_row:
        QMessageBox.warning(self, "Not Found", f"No rule found with ID={rule_id}.")
        return

    # Convert that row to a dictionary, so we can pass to RuleEditorDialog
    colnames = [desc[0] for desc in c.description]
    rule_data = dict(zip(colnames, old_row))

    # Step 3: Create the dialog in "update mode," passing the existing data
    dialog = RuleEditorDialog(
        connection=self.connection,
        user_group=self.user_group,
        parent=self,
        rule_data=rule_data  # so the dialog can pre-fill the fields
    )

    # Step 4: If user clicks Save, inside the dialog we call update_rule(...)
    if dialog.exec_() == QtWidgets.QDialog.Accepted:
        QMessageBox.information(self, "Updated", f"Rule ID={rule_id} updated successfully.")
        self.brm_dashboard.load_rules()  # Refresh