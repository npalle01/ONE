"""
Enterprise GL Data Mart Prototype (PyQt) â€” Recon + Variance + Reg Reporting + Lineage + Audit
------------------------------------------------------------------------------------------
âœ… No Streamlit. Pure PyQt desktop app with enterprise-style navigation + screens.
âœ… Embedded small demo data (GL, SOR, CRRT, CR360, feed health, mappings, DQ rules)
âœ… Reg/vertical coverage in UI: FR2590, Y-9C, FR Y (Other placeholder), CCAR, CECL/ACL, STARE, ERA
âœ… Recon flows: GLâ†”SOR and CRRTâ†”CR360 + Break lifecycle (create/edit/close) + Audit log
âœ… Error-safe: handles empty selections, empty tables, safe conversions, no crashes on missing data.

Install:
  pip install PyQt6 pandas numpy

Run:
  python app.py
"""

import sys
from dataclasses import dataclass
from datetime import datetime, date, timedelta
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

from PyQt6.QtCore import (
    QAbstractTableModel,
    QModelIndex,
    QObject,
    Qt,
    QSortFilterProxyModel,
)
from PyQt6.QtGui import QAction, QFont
from PyQt6.QtWidgets import (
    QApplication,
    QComboBox,
    QDateEdit,
    QDialog,
    QFormLayout,
    QFrame,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMainWindow,
    QMenuBar,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QSplitter,
    QStackedWidget,
    QStatusBar,
    QTableView,
    QTabWidget,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

# ----------------------------
# Helpers
# ----------------------------

def safe_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None or (isinstance(x, float) and np.isnan(x)):
            return default
        return float(x)
    except Exception:
        return default

def fmt_money(x: Any) -> str:
    v = safe_float(x, 0.0)
    return f"{v:,.2f}"

def fmt_int(x: Any) -> str:
    try:
        return f"{int(round(float(x))):,}"
    except Exception:
        return "0"

def now_str() -> str:
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def hash_id(prefix="BRK") -> str:
    return f"{prefix}-{np.random.randint(10000, 99999)}"

def severity_from_amt(amt: Any, materiality: float) -> str:
    a = abs(safe_float(amt, 0.0))
    if a >= materiality:
        return "MATERIAL"
    if a >= materiality * 0.25:
        return "HIGH"
    if a >= materiality * 0.10:
        return "MEDIUM"
    return "LOW"

# ----------------------------
# Data seeding (embedded demo)
# ----------------------------

def seed_data() -> Dict[str, Any]:
    entities = ["US_HOLDCO", "US_BANK", "UK_BRANCH"]
    books = ["GAAP", "STAT"]
    currencies = ["USD", "GBP"]
    products = ["LOANS", "DEPOSITS", "TRADING", "TREASURY"]
    accounts = [
        ("100100", "Cash & Due From Banks"),
        ("120200", "Loans - HFI"),
        ("200100", "Deposits"),
        ("310000", "Trading Assets"),
        ("510000", "Interest Income"),
        ("610000", "Interest Expense"),
        ("710000", "Provision for Credit Losses"),
    ]

    asof = date(2026, 1, 8)
    prior = asof - timedelta(days=31)

    rng = np.random.default_rng(7)

    rows = []
    for d in [prior, asof]:
        for le in entities:
            for book in books:
                for ccy in currencies:
                    for acc, acc_name in accounts:
                        for prod in products:
                            base = rng.normal(0, 1)
                            scale = {
                                "100100": 2.2e9,
                                "120200": 6.8e9,
                                "200100": 7.1e9,
                                "310000": 1.9e9,
                                "510000": 0.45e9,
                                "610000": 0.25e9,
                                "710000": 0.12e9,
                            }[acc]
                            le_mult = {"US_HOLDCO": 1.0, "US_BANK": 0.9, "UK_BRANCH": 0.35}[le]
                            prod_mult = {"LOANS": 1.1, "DEPOSITS": 0.95, "TRADING": 1.0, "TREASURY": 0.7}[prod]
                            book_mult = {"GAAP": 1.0, "STAT": 0.8}[book]
                            ccy_mult = {"USD": 1.0, "GBP": 0.28}[ccy]

                            amt = (base * 0.015 + 1.0) * scale * le_mult * prod_mult * book_mult * ccy_mult
                            drift = 1.0 if d == prior else (1.0 + rng.normal(0.01, 0.006))
                            amt *= drift

                            rows.append(
                                dict(
                                    as_of=d,
                                    legal_entity=le,
                                    book=book,
                                    ccy=ccy,
                                    account=acc,
                                    account_name=acc_name,
                                    product=prod,
                                    gl_amount=float(amt),
                                )
                            )
    gl = pd.DataFrame(rows)

    sor = gl.copy().rename(columns={"gl_amount": "sor_amount"})
    mask_asof = sor["as_of"] == asof

    bump = np.where(
        (sor["account"].isin(["120200", "200100"])) & (sor["product"].isin(["LOANS", "DEPOSITS"])) & mask_asof,
        1.0 + rng.normal(0.002, 0.001, size=len(sor)),
        1.0
    )
    sor.loc[mask_asof, "sor_amount"] = sor.loc[mask_asof, "sor_amount"] * bump

    miss_mask = (
        (sor["as_of"] == asof)
        & (sor["legal_entity"] == "UK_BRANCH")
        & (sor["product"] == "TRADING")
        & (sor["account"] == "310000")
    )
    sor.loc[miss_mask, "sor_amount"] = sor.loc[miss_mask, "sor_amount"] * 0.92

    crrt = gl.groupby(["as_of", "legal_entity", "book", "ccy", "account"]).agg(
        crrt_amount=("gl_amount", "sum")
    ).reset_index()

    cr360 = crrt.copy()
    cr360["cr360_amount"] = cr360["crrt_amount"] * (1.0 + rng.normal(0.0008, 0.0005, size=len(cr360)))

    feed_sources = [
        ("GL_CORE", "GL"),
        ("SUBLEDGER_SOR", "SOR"),
        ("CRRT_PIPE", "CRRT"),
        ("CR360_PIPE", "CR360"),
        ("ERA_SCCL", "ERA"),
        ("STARE_FORECAST", "STARE"),
    ]
    feed_rows = []
    for src, layer in feed_sources:
        for d in [prior, asof]:
            status = "SUCCESS"
            latency_min = int(abs(rng.normal(18, 9)))
            recs = int(abs(rng.normal(120000, 15000)))
            rejects = int(abs(rng.normal(180, 70)))
            if src == "STARE_FORECAST" and d == asof:
                status = "LATE"
                latency_min += 120
            if src == "SUBLEDGER_SOR" and d == asof:
                rejects += 420
            feed_rows.append(
                dict(
                    as_of=d,
                    source=src,
                    layer=layer,
                    status=status,
                    latency_min=latency_min,
                    records=recs,
                    rejects=rejects,
                    control_total=float(abs(rng.normal(1.8e10, 3.5e9))),
                    run_id=f"RUN-{src}-{d.strftime('%Y%m%d')}",
                )
            )
    feed = pd.DataFrame(feed_rows)

    mapping_rows = [
        ("FR2590", "L1", "Cash & Central Bank", ["100100"]),
        ("FR2590", "L2", "Loans Outstanding", ["120200"]),
        ("FR2590", "L3", "Trading Assets", ["310000"]),
        ("FR2590", "L4", "Deposits", ["200100"]),
        ("Y-9C", "HC-A1", "Cash and balances due", ["100100"]),
        ("Y-9C", "HC-C1", "Loans and leases", ["120200"]),
        ("Y-9C", "HC-L1", "Deposits", ["200100"]),
        ("Y-9C", "HC-B1", "Trading assets", ["310000"]),
        ("CCAR", "P&L1", "Net Interest Income", ["510000", "610000"]),
        ("CECL/ACL", "ACL1", "Provision / ACL expense", ["710000"]),
        ("STARE", "S1", "Forecast Loans", ["120200"]),
        ("ERA", "E1", "SCCL Recon Coverage", ["120200", "200100", "310000"]),
    ]
    rep_map = []
    for rep, line, desc, accs in mapping_rows:
        for a in accs:
            rep_map.append(dict(report=rep, report_line=line, line_desc=desc, account=a))
    map_df = pd.DataFrame(rep_map)

    rules = pd.DataFrame([
        {"rule_id": "DQ-001", "rule_name": "Completeness - Required dimensions present", "severity": "HIGH", "owner": "Data Steward"},
        {"rule_id": "DQ-002", "rule_name": "Balance - Assets = Liabilities + Equity (entity/book)", "severity": "MATERIAL", "owner": "Controller"},
        {"rule_id": "DQ-003", "rule_name": "Timeliness - Feeds within SLA", "severity": "MEDIUM", "owner": "Ops"},
        {"rule_id": "DQ-004", "rule_name": "Recon - GL vs SOR within tolerance", "severity": "MATERIAL", "owner": "Recon Lead"},
        {"rule_id": "DQ-005", "rule_name": "Mapping - Report line coverage >= 99%", "severity": "HIGH", "owner": "Report Owner"},
    ])

    return {
        "asof": asof,
        "prior": prior,
        "gl": gl,
        "sor": sor,
        "crrt": crrt,
        "cr360": cr360,
        "feed": feed,
        "map": map_df,
        "rules": rules,
    }

# ----------------------------
# Table model for pandas
# ----------------------------

class DataFrameModel(QAbstractTableModel):
    def __init__(self, df: Optional[pd.DataFrame] = None, parent: Optional[QObject] = None):
        super().__init__(parent)
        self._df = df if df is not None else pd.DataFrame()

    def set_df(self, df: pd.DataFrame):
        self.beginResetModel()
        self._df = df.copy() if df is not None else pd.DataFrame()
        self.endResetModel()

    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:
        return 0 if parent.isValid() else len(self._df.index)

    def columnCount(self, parent: QModelIndex = QModelIndex()) -> int:
        return 0 if parent.isValid() else len(self._df.columns)

    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        if not index.isValid():
            return None
        if role not in (Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.EditRole):
            return None
        try:
            val = self._df.iat[index.row(), index.column()]
            if isinstance(val, float):
                # show large floats nicely
                return f"{val:,.4f}" if abs(val) < 1e6 else f"{val:,.0f}"
            return str(val)
        except Exception:
            return ""

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        if role != Qt.ItemDataRole.DisplayRole:
            return None
        if orientation == Qt.Orientation.Horizontal:
            try:
                return str(self._df.columns[section])
            except Exception:
                return ""
        else:
            return str(section + 1)

    def flags(self, index: QModelIndex) -> Qt.ItemFlag:
        if not index.isValid():
            return Qt.ItemFlag.NoItemFlags
        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable

    def get_row(self, row: int) -> Dict[str, Any]:
        if row < 0 or row >= len(self._df.index):
            return {}
        return self._df.iloc[row].to_dict()

# ----------------------------
# Break Editor dialog
# ----------------------------

class BreakEditorDialog(QDialog):
    def __init__(self, break_row: Dict[str, Any], parent: QWidget = None):
        super().__init__(parent)
        self.setWindowTitle("Break Detail")
        self.setMinimumWidth(520)

        self.break_row = break_row.copy()

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.lbl_id = QLabel(self.break_row.get("break_id", ""))
        self.cmb_status = QComboBox()
        self.cmb_status.addItems(["OPEN", "IN REVIEW", "APPROVED", "CLOSED"])
        self.cmb_status.setCurrentText(self.break_row.get("status", "OPEN"))

        self.ed_owner = QLineEdit(self.break_row.get("owner", "Recon Analyst"))
        self.cmb_root = QComboBox()
        self.cmb_root.addItems(["UNCLASSIFIED", "TIMING", "MAPPING", "MISSING_FEED", "FX", "SIGN", "DUPLICATION", "THRESHOLD", "MANUAL_ADJ"])
        self.cmb_root.setCurrentText(self.break_row.get("root_cause", "UNCLASSIFIED"))

        self.ed_evidence = QLineEdit(self.break_row.get("evidence_ref", ""))
        self.txt_notes = QTextEdit()
        self.txt_notes.setPlainText(self.break_row.get("notes", ""))

        form.addRow("Break ID", self.lbl_id)
        form.addRow("Status", self.cmb_status)
        form.addRow("Owner", self.ed_owner)
        form.addRow("Root Cause", self.cmb_root)
        form.addRow("Evidence Ref", self.ed_evidence)
        form.addRow("Notes / Narrative", self.txt_notes)

        layout.addLayout(form)

        btns = QHBoxLayout()
        self.btn_cancel = QPushButton("Cancel")
        self.btn_save = QPushButton("Save")
        self.btn_save.setDefault(True)
        btns.addStretch(1)
        btns.addWidget(self.btn_cancel)
        btns.addWidget(self.btn_save)

        layout.addLayout(btns)

        self.btn_cancel.clicked.connect(self.reject)
        self.btn_save.clicked.connect(self._on_save)

    def _on_save(self):
        self.break_row["status"] = self.cmb_status.currentText()
        self.break_row["owner"] = self.ed_owner.text().strip() or "Recon Analyst"
        self.break_row["root_cause"] = self.cmb_root.currentText()
        self.break_row["evidence_ref"] = self.ed_evidence.text().strip()
        self.break_row["notes"] = self.txt_notes.toPlainText().strip()
        self.accept()

# ----------------------------
# Main App
# ----------------------------

@dataclass
class GlobalFilters:
    as_of: date
    legal_entity: str
    book: str
    ccy: str
    materiality: float

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Enterprise GL Platform | Recon & Regulatory Reporting (Prototype)")
        self.resize(1500, 860)

        self.data = seed_data()

        # state tables
        self.breaks = pd.DataFrame(columns=[
            "break_id","created_ts","as_of","recon_type","legal_entity","book","ccy",
            "account","product","gl_amount","other_amount","variance","severity",
            "root_cause","owner","status","sla_due","notes","evidence_ref"
        ])
        self.audit = pd.DataFrame(columns=["ts","user","action","object_type","object_id","details"])
        self.current_user = "NAVEEN.P (Prototype)"

        # default filters
        self.filters = GlobalFilters(
            as_of=self.data["asof"],
            legal_entity="US_HOLDCO",
            book="GAAP",
            ccy="USD",
            materiality=1_000_000.0,
        )

        self._build_menu()
        self._build_ui()
        self.refresh_all()

    # ----------------------
    # Menu
    # ----------------------
    def _build_menu(self):
        mb = QMenuBar(self)
        self.setMenuBar(mb)

        file_menu = mb.addMenu("&File")
        act_reset = QAction("Reset Prototype Data", self)
        act_reset.triggered.connect(self.reset_prototype)
        file_menu.addAction(act_reset)

        act_exit = QAction("Exit", self)
        act_exit.triggered.connect(self.close)
        file_menu.addAction(act_exit)

        help_menu = mb.addMenu("&Help")
        act_about = QAction("About", self)
        act_about.triggered.connect(self.show_about)
        help_menu.addAction(act_about)

    def show_about(self):
        QMessageBox.information(
            self,
            "About",
            "Enterprise GL Platform Prototype\n\n"
            "PyQt desktop UI demonstrating GL/SOR reconciliation, breaks workflow,\n"
            "variance explainability, regulatory reporting workspace, lineage and audit.",
        )

    # ----------------------
    # UI layout
    # ----------------------
    def _build_ui(self):
        central = QWidget()
        self.setCentralWidget(central)

        root = QHBoxLayout(central)

        # Left navigation
        nav = QFrame()
        nav.setFrameShape(QFrame.Shape.StyledPanel)
        nav.setFixedWidth(280)
        nav_l = QVBoxLayout(nav)

        title = QLabel("ðŸ¦ Enterprise GL")
        title.setFont(QFont("Arial", 16, QFont.Weight.Bold))
        nav_l.addWidget(title)

        subtitle = QLabel("Recon â€¢ Reporting â€¢ Lineage â€¢ Audit")
        subtitle.setStyleSheet("color: #888;")
        nav_l.addWidget(subtitle)

        nav_l.addSpacing(8)

        self.nav_list = QListWidget()
        for p in [
            "1. Landing Dashboard",
            "2. Feed Health & Ingestion",
            "3. GL Explorer",
            "4. Reconciliation Workspace",
            "5. Variance Management",
            "6. Regulatory Reporting",
            "7. Lineage & Mapping (BCBS239)",
            "8. Audit & Evidence Vault",
            "9. Admin (Config/RBAC)",
        ]:
            self.nav_list.addItem(QListWidgetItem(p))
        self.nav_list.setCurrentRow(0)
        self.nav_list.currentRowChanged.connect(self._on_nav_change)
        nav_l.addWidget(self.nav_list, 1)

        # Global filters
        filters_box = QGroupBox("Global Filters")
        fl = QFormLayout(filters_box)

        # As-of date (only two demo dates)
        self.cmb_asof = QComboBox()
        dates = sorted(self.data["gl"]["as_of"].unique())
        for d in dates:
            self.cmb_asof.addItem(str(d), d)
        self.cmb_asof.setCurrentIndex(len(dates)-1)
        self.cmb_asof.currentIndexChanged.connect(lambda _: self._update_filters_and_refresh())
        fl.addRow("As-of", self.cmb_asof)

        self.cmb_le = QComboBox()
        for le in sorted(self.data["gl"]["legal_entity"].unique()):
            self.cmb_le.addItem(le)
        self.cmb_le.setCurrentText(self.filters.legal_entity)
        self.cmb_le.currentTextChanged.connect(lambda _: self._update_filters_and_refresh())
        fl.addRow("Legal Entity", self.cmb_le)

        self.cmb_book = QComboBox()
        for b in sorted(self.data["gl"]["book"].unique()):
            self.cmb_book.addItem(b)
        self.cmb_book.setCurrentText(self.filters.book)
        self.cmb_book.currentTextChanged.connect(lambda _: self._update_filters_and_refresh())
        fl.addRow("Book", self.cmb_book)

        self.cmb_ccy = QComboBox()
        for c in sorted(self.data["gl"]["ccy"].unique()):
            self.cmb_ccy.addItem(c)
        self.cmb_ccy.setCurrentText(self.filters.ccy)
        self.cmb_ccy.currentTextChanged.connect(lambda _: self._update_filters_and_refresh())
        fl.addRow("CCY", self.cmb_ccy)

        self.spn_mat = QSpinBox()
        self.spn_mat.setRange(100_000, 25_000_000)
        self.spn_mat.setSingleStep(100_000)
        self.spn_mat.setValue(int(self.filters.materiality))
        self.spn_mat.valueChanged.connect(lambda _: self._update_filters_and_refresh())
        fl.addRow("Materiality", self.spn_mat)

        self.ed_user = QLineEdit(self.current_user)
        self.ed_user.textChanged.connect(self._on_user_changed)
        fl.addRow("User", self.ed_user)

        nav_l.addWidget(filters_box)

        # Main content area
        self.stack = QStackedWidget()

        self.page_dashboard = self._make_dashboard_page()
        self.page_feed = self._make_feed_page()
        self.page_gl = self._make_gl_page()
        self.page_recon = self._make_recon_page()
        self.page_var = self._make_variance_page()
        self.page_report = self._make_reporting_page()
        self.page_lineage = self._make_lineage_page()
        self.page_audit = self._make_audit_page()
        self.page_admin = self._make_admin_page()

        for w in [
            self.page_dashboard,
            self.page_feed,
            self.page_gl,
            self.page_recon,
            self.page_var,
            self.page_report,
            self.page_lineage,
            self.page_audit,
            self.page_admin,
        ]:
            self.stack.addWidget(w)

        root.addWidget(nav)
        root.addWidget(self.stack, 1)

        self.status = QStatusBar()
        self.setStatusBar(self.status)

    # ----------------------
    # Pages
    # ----------------------
    def _make_kpi_card(self, title: str, value: str, hint: str = "") -> QWidget:
        box = QGroupBox(title)
        v = QVBoxLayout(box)
        lbl = QLabel(value)
        lbl.setFont(QFont("Arial", 18, QFont.Weight.Bold))
        v.addWidget(lbl)
        if hint:
            h = QLabel(hint)
            h.setStyleSheet("color: #777;")
            v.addWidget(h)
        return box

    def _make_dashboard_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)

        header = QLabel("âœ¨ Landing Dashboard")
        header.setFont(QFont("Arial", 16, QFont.Weight.Bold))
        layout.addWidget(header)

        kpi_row = QHBoxLayout()
        self.kpi_material = self._make_kpi_card("Material Breaks", "0")
        self.kpi_open = self._make_kpi_card("Open Breaks", "0")
        self.kpi_feeds = self._make_kpi_card("Feeds Late/Failed", "0")
        self.kpi_recon = self._make_kpi_card("Recon Completion", "0%")
        self.kpi_cert = self._make_kpi_card("Certifiable Reports", "0/6")
        for c in [self.kpi_material, self.kpi_open, self.kpi_feeds, self.kpi_recon, self.kpi_cert]:
            kpi_row.addWidget(c)
        layout.addLayout(kpi_row)

        splitter = QSplitter(Qt.Orientation.Horizontal)

        # left: top breaks table
        left = QWidget()
        ll = QVBoxLayout(left)
        ll.addWidget(QLabel("Top Breaks (GLâ†”SOR)"))
        self.tbl_top_breaks = QTableView()
        self.model_top_breaks = DataFrameModel(pd.DataFrame())
        self.tbl_top_breaks.setModel(self.model_top_breaks)
        self.tbl_top_breaks.setSortingEnabled(True)
        ll.addWidget(self.tbl_top_breaks, 1)

        self.btn_create_largest_break = QPushButton("Create Break for Largest Variance")
        self.btn_create_largest_break.clicked.connect(self.create_largest_break)
        ll.addWidget(self.btn_create_largest_break)

        # right: feed snapshot + readiness
        right = QWidget()
        rl = QVBoxLayout(right)
        rl.addWidget(QLabel("Feed Health Snapshot"))
        self.tbl_feed_snap = QTableView()
        self.model_feed_snap = DataFrameModel(pd.DataFrame())
        self.tbl_feed_snap.setModel(self.model_feed_snap)
        self.tbl_feed_snap.setSortingEnabled(True)
        rl.addWidget(self.tbl_feed_snap, 1)

        rl.addWidget(QLabel("Report Readiness (Prototype)"))
        self.tbl_readiness = QTableView()
        self.model_readiness = DataFrameModel(pd.DataFrame())
        self.tbl_readiness.setModel(self.model_readiness)
        rl.addWidget(self.tbl_readiness)

        splitter.addWidget(left)
        splitter.addWidget(right)
        splitter.setSizes([900, 600])

        layout.addWidget(splitter, 1)
        return w

    def _make_feed_page(self) -> QWidget:
        w = QWidget()
        layout = QHBoxLayout(w)

        splitter = QSplitter(Qt.Orientation.Horizontal)

        # left: feed table + rejects sample
        left = QWidget()
        ll = QVBoxLayout(left)
        header = QLabel("ðŸ“¡ Feed Health & Ingestion Control")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        ll.addWidget(header)

        self.tbl_feed = QTableView()
        self.model_feed = DataFrameModel(pd.DataFrame())
        self.tbl_feed.setModel(self.model_feed)
        self.tbl_feed.setSortingEnabled(True)
        ll.addWidget(self.tbl_feed, 1)

        ll.addWidget(QLabel("Reject Samples (Prototype)"))
        self.tbl_rejects = QTableView()
        self.model_rejects = DataFrameModel(pd.DataFrame())
        self.tbl_rejects.setModel(self.model_rejects)
        ll.addWidget(self.tbl_rejects)

        # right: actions + rules
        right = QWidget()
        rl = QVBoxLayout(right)
        rl.addWidget(QLabel("Actions"))
        self.cmb_feed_pick = QComboBox()
        rl.addWidget(self.cmb_feed_pick)

        btn_rerun = QPushButton("â–¶ Re-run Ingestion (log)")
        btn_rerun.clicked.connect(self.rerun_feed)
        rl.addWidget(btn_rerun)

        btn_inc = QPushButton("ðŸ“ Create Incident (log)")
        btn_inc.clicked.connect(self.create_incident)
        rl.addWidget(btn_inc)

        rl.addSpacing(12)
        rl.addWidget(QLabel("BCBS239 Controls / Rules"))
        self.tbl_rules = QTableView()
        self.model_rules = DataFrameModel(pd.DataFrame())
        self.tbl_rules.setModel(self.model_rules)
        rl.addWidget(self.tbl_rules, 1)

        splitter.addWidget(left)
        splitter.addWidget(right)
        splitter.setSizes([1000, 450])

        layout.addWidget(splitter)
        return w

    def _make_gl_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("ðŸ”Ž GL Explorer")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        top = QHBoxLayout()
        top.addWidget(QLabel("Search account/name:"))
        self.ed_gl_search = QLineEdit("120200")
        self.ed_gl_search.textChanged.connect(self.refresh_gl_explorer)
        top.addWidget(self.ed_gl_search, 1)
        layout.addLayout(top)

        splitter = QSplitter(Qt.Orientation.Horizontal)

        left = QWidget()
        ll = QVBoxLayout(left)
        ll.addWidget(QLabel("Balances (Account Ã— Product)"))
        self.tbl_gl = QTableView()
        self.model_gl = DataFrameModel(pd.DataFrame())
        self.tbl_gl.setModel(self.model_gl)
        self.tbl_gl.setSortingEnabled(True)
        self.tbl_gl.clicked.connect(self.on_gl_row_selected)
        ll.addWidget(self.tbl_gl, 1)

        right = QWidget()
        rl = QVBoxLayout(right)
        rl.addWidget(QLabel("Context Pane"))
        self.lbl_ctx = QLabel("Select a row to see mappings and lineage.")
        self.lbl_ctx.setWordWrap(True)
        rl.addWidget(self.lbl_ctx)

        rl.addWidget(QLabel("Report Mappings"))
        self.tbl_map_for_acc = QTableView()
        self.model_map_for_acc = DataFrameModel(pd.DataFrame())
        self.tbl_map_for_acc.setModel(self.model_map_for_acc)
        rl.addWidget(self.tbl_map_for_acc, 1)

        splitter.addWidget(left)
        splitter.addWidget(right)
        splitter.setSizes([950, 500])

        layout.addWidget(splitter, 1)
        return w

    def _make_recon_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("ðŸ§® Reconciliation Workspace")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        self.recon_tabs = QTabWidget()

        # Tab 1: GL vs SOR
        tab1 = QWidget()
        t1 = QVBoxLayout(tab1)
        controls = QHBoxLayout()
        controls.addWidget(QLabel("Tolerance (abs):"))
        self.spn_tol = QSpinBox()
        self.spn_tol.setRange(0, 100_000_000)
        self.spn_tol.setSingleStep(10_000)
        self.spn_tol.setValue(1000)  # will set in refresh
        self.spn_tol.valueChanged.connect(self.refresh_recon)
        controls.addWidget(self.spn_tol)
        controls.addStretch(1)
        self.btn_create_selected_breaks = QPushButton("âž• Create Break(s) for Selected Rows")
        self.btn_create_selected_breaks.clicked.connect(self.create_breaks_from_selected_recon_rows)
        controls.addWidget(self.btn_create_selected_breaks)
        t1.addLayout(controls)

        self.tbl_recon = QTableView()
        self.model_recon = DataFrameModel(pd.DataFrame())
        self.tbl_recon.setModel(self.model_recon)
        self.tbl_recon.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.tbl_recon.setSortingEnabled(True)
        t1.addWidget(self.tbl_recon, 1)

        # Tab 2: CRRT vs CR360
        tab2 = QWidget()
        t2 = QVBoxLayout(tab2)
        controls2 = QHBoxLayout()
        controls2.addWidget(QLabel("Tolerance (CRRTâ†”CR360):"))
        self.spn_tol2 = QSpinBox()
        self.spn_tol2.setRange(0, 100_000_000)
        self.spn_tol2.setSingleStep(10_000)
        self.spn_tol2.setValue(500)
        self.spn_tol2.valueChanged.connect(self.refresh_recon)
        controls2.addWidget(self.spn_tol2)
        controls2.addStretch(1)
        t2.addLayout(controls2)

        self.tbl_recon2 = QTableView()
        self.model_recon2 = DataFrameModel(pd.DataFrame())
        self.tbl_recon2.setModel(self.model_recon2)
        self.tbl_recon2.setSortingEnabled(True)
        t2.addWidget(self.tbl_recon2, 1)

        # Tab 3: Breaks
        tab3 = QWidget()
        t3 = QVBoxLayout(tab3)

        top = QHBoxLayout()
        self.cmb_break_status = QComboBox()
        self.cmb_break_status.addItems(["(All)", "OPEN", "IN REVIEW", "APPROVED", "CLOSED"])
        self.cmb_break_status.currentIndexChanged.connect(self.refresh_breaks_view)
        top.addWidget(QLabel("Status:"))
        top.addWidget(self.cmb_break_status)
        top.addStretch(1)

        self.btn_edit_break = QPushButton("âœï¸ Edit Selected Break")
        self.btn_edit_break.clicked.connect(self.edit_selected_break)
        top.addWidget(self.btn_edit_break)

        t3.addLayout(top)

        self.tbl_breaks = QTableView()
        self.model_breaks = DataFrameModel(pd.DataFrame())
        self.tbl_breaks.setModel(self.model_breaks)
        self.tbl_breaks.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.tbl_breaks.setSortingEnabled(True)
        t3.addWidget(self.tbl_breaks, 1)

        self.recon_tabs.addTab(tab1, "GL â†” SOR")
        self.recon_tabs.addTab(tab2, "CRRT â†” CR360")
        self.recon_tabs.addTab(tab3, "Breaks (Work Items)")
        layout.addWidget(self.recon_tabs, 1)
        return w

    def _make_variance_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("ðŸ“ˆ Variance Management")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        self.tbl_variance = QTableView()
        self.model_variance = DataFrameModel(pd.DataFrame())
        self.tbl_variance.setModel(self.model_variance)
        self.tbl_variance.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.tbl_variance.clicked.connect(self.on_variance_selected)
        self.tbl_variance.setSortingEnabled(True)
        layout.addWidget(self.tbl_variance, 1)

        explain = QGroupBox("Explainability Capture")
        ex = QFormLayout(explain)
        self.lbl_var_pick = QLabel("(Select a variance row)")
        self.cmb_var_reason = QComboBox()
        self.cmb_var_reason.addItems([
            "Volume change","Rate/Spread change","Mix change","Reclass/Mapping change","Timing/Accrual",
            "FX impact","One-time event","Model/Forecast update (STARE)","Credit loss update (CECL/ACL)"
        ])
        self.txt_var_narr = QTextEdit()
        self.txt_var_narr.setFixedHeight(90)
        self.btn_save_expl = QPushButton("âœ… Save Explanation (to Audit Log)")
        self.btn_save_expl.clicked.connect(self.save_variance_explanation)

        ex.addRow("Selected", self.lbl_var_pick)
        ex.addRow("Reason", self.cmb_var_reason)
        ex.addRow("Narrative", self.txt_var_narr)
        ex.addRow("", self.btn_save_expl)

        layout.addWidget(explain)
        return w

    def _make_reporting_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("ðŸ§¾ Regulatory Reporting Workspace")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        top = QHBoxLayout()
        top.addWidget(QLabel("Report:"))
        self.cmb_report = QComboBox()
        self.cmb_report.addItems(["FR2590", "Y-9C", "FR Y (Other)", "CCAR", "CECL/ACL", "STARE", "ERA"])
        self.cmb_report.currentTextChanged.connect(self.refresh_reporting)
        top.addWidget(self.cmb_report)
        top.addStretch(1)

        self.btn_cert_line = QPushButton("âœ” Certify Selected Line (log)")
        self.btn_cert_line.clicked.connect(self.certify_selected_line)
        top.addWidget(self.btn_cert_line)

        self.btn_lock_report = QPushButton("ðŸ”’ Lock Report Cycle (log)")
        self.btn_lock_report.clicked.connect(self.lock_report_cycle)
        top.addWidget(self.btn_lock_report)

        layout.addLayout(top)

        splitter = QSplitter(Qt.Orientation.Horizontal)

        left = QWidget()
        ll = QVBoxLayout(left)
        ll.addWidget(QLabel("Report Lines"))
        self.tbl_report_lines = QTableView()
        self.model_report_lines = DataFrameModel(pd.DataFrame())
        self.tbl_report_lines.setModel(self.model_report_lines)
        self.tbl_report_lines.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.tbl_report_lines.clicked.connect(self.on_report_line_selected)
        self.tbl_report_lines.setSortingEnabled(True)
        ll.addWidget(self.tbl_report_lines, 1)

        right = QWidget()
        rl = QVBoxLayout(right)
        rl.addWidget(QLabel("Line Drilldown (GL by mapped accounts)"))
        self.tbl_line_drill = QTableView()
        self.model_line_drill = DataFrameModel(pd.DataFrame())
        self.tbl_line_drill.setModel(self.model_line_drill)
        self.tbl_line_drill.setSortingEnabled(True)
        rl.addWidget(self.tbl_line_drill, 1)

        splitter.addWidget(left)
        splitter.addWidget(right)
        splitter.setSizes([900, 600])
        layout.addWidget(splitter, 1)

        self._selected_report_line_id = None
        return w

    def _make_lineage_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("ðŸ§¬ Lineage & Mapping (BCBS239)")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        splitter = QSplitter(Qt.Orientation.Horizontal)

        left = QWidget()
        ll = QVBoxLayout(left)
        ll.addWidget(QLabel("Mapping Repository"))
        self.tbl_map = QTableView()
        self.model_map = DataFrameModel(pd.DataFrame())
        self.tbl_map.setModel(self.model_map)
        self.tbl_map.setSortingEnabled(True)
        ll.addWidget(self.tbl_map, 1)

        right = QWidget()
        rl = QVBoxLayout(right)

        hl = QHBoxLayout()
        hl.addWidget(QLabel("Account:"))
        self.cmb_lineage_acc = QComboBox()
        self.cmb_lineage_acc.currentTextChanged.connect(self.refresh_lineage_side)
        hl.addWidget(self.cmb_lineage_acc, 1)
        rl.addLayout(hl)

        self.lbl_lineage = QLabel("")
        self.lbl_lineage.setWordWrap(True)
        self.lbl_lineage.setStyleSheet("color:#333; background:#f6f6f6; padding:10px; border-radius:8px;")
        rl.addWidget(self.lbl_lineage)

        rl.addWidget(QLabel("Related Report Lines"))
        self.tbl_related_lines = QTableView()
        self.model_related_lines = DataFrameModel(pd.DataFrame())
        self.tbl_related_lines.setModel(self.model_related_lines)
        rl.addWidget(self.tbl_related_lines, 1)

        splitter.addWidget(left)
        splitter.addWidget(right)
        splitter.setSizes([900, 600])
        layout.addWidget(splitter, 1)
        return w

    def _make_audit_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("ðŸ§¾ Audit & Evidence Vault")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        self.tbl_audit = QTableView()
        self.model_audit = DataFrameModel(pd.DataFrame())
        self.tbl_audit.setModel(self.model_audit)
        self.tbl_audit.setSortingEnabled(True)
        layout.addWidget(self.tbl_audit, 1)

        layout.addWidget(QLabel("Evidence Index (from Breaks)"))
        self.tbl_evidence = QTableView()
        self.model_evidence = DataFrameModel(pd.DataFrame())
        self.tbl_evidence.setModel(self.model_evidence)
        layout.addWidget(self.tbl_evidence)

        return w

    def _make_admin_page(self) -> QWidget:
        w = QWidget()
        layout = QVBoxLayout(w)
        header = QLabel("âš™ï¸ Admin (Config / RBAC)")
        header.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        layout.addWidget(header)

        info = QLabel(
            "Prototype admin screen.\n"
            "Production features: maker-checker on mapping/threshold overrides, entitlements, versioning."
        )
        info.setStyleSheet("color:#666;")
        layout.addWidget(info)

        rbac = pd.DataFrame([
            {"role":"Recon Analyst","can_create_break":"Y","can_close_break":"N","can_certify":"N","data_export":"Limited"},
            {"role":"Controller","can_create_break":"Y","can_close_break":"Y","can_certify":"Y","data_export":"Controlled"},
            {"role":"Report Owner","can_create_break":"Y","can_close_break":"Y","can_certify":"Y","data_export":"Controlled"},
            {"role":"Auditor","can_create_break":"N","can_close_break":"N","can_certify":"N","data_export":"Read-only"},
            {"role":"Admin","can_create_break":"Y","can_close_break":"Y","can_certify":"Y","data_export":"Admin"},
        ])
        cal = pd.DataFrame([
            {"cycle":"Month-End Close","cutoff":"T+1 18:00","recon_due":"T+2 12:00","certify_due":"T+3 17:00"},
            {"cycle":"FR2590","cutoff":"T+1 20:00","recon_due":"T+2 14:00","certify_due":"T+3 12:00"},
            {"cycle":"Y-9C","cutoff":"T+2 18:00","recon_due":"T+4 12:00","certify_due":"T+5 17:00"},
            {"cycle":"CCAR/STARE","cutoff":"Scenario freeze","recon_due":"Model run+1d","certify_due":"Review+2d"},
            {"cycle":"CECL/ACL","cutoff":"Quarter-end","recon_due":"T+3 12:00","certify_due":"T+5 17:00"},
        ])

        splitter = QSplitter(Qt.Orientation.Horizontal)
        left = QWidget()
        ll = QVBoxLayout(left)
        ll.addWidget(QLabel("RBAC Matrix"))
        self.tbl_rbac = QTableView()
        self.model_rbac = DataFrameModel(rbac)
        self.tbl_rbac.setModel(self.model_rbac)
        ll.addWidget(self.tbl_rbac, 1)

        right = QWidget()
        rl = QVBoxLayout(right)
        rl.addWidget(QLabel("Close Calendar"))
        self.tbl_cal = QTableView()
        self.model_cal = DataFrameModel(cal)
        self.tbl_cal.setModel(self.model_cal)
        rl.addWidget(self.tbl_cal, 1)

        splitter.addWidget(left)
        splitter.addWidget(right)
        splitter.setSizes([700, 700])
        layout.addWidget(splitter, 1)

        return w

    # ----------------------
    # Navigation & filters
    # ----------------------
    def _on_nav_change(self, idx: int):
        idx = max(0, min(idx, self.stack.count()-1))
        self.stack.setCurrentIndex(idx)
        self.status.showMessage(f"Viewing: {self.nav_list.currentItem().text()}", 3000)

    def _on_user_changed(self, txt: str):
        self.current_user = txt.strip() or "User (Prototype)"

    def _update_filters_and_refresh(self):
        self.filters.as_of = self.cmb_asof.currentData()
        self.filters.legal_entity = self.cmb_le.currentText()
        self.filters.book = self.cmb_book.currentText()
        self.filters.ccy = self.cmb_ccy.currentText()
        self.filters.materiality = float(self.spn_mat.value())
        self.refresh_all()

    # ----------------------
    # Core computations
    # ----------------------
    def gl_filtered(self, as_of: Optional[date] = None) -> pd.DataFrame:
        d = as_of if as_of is not None else self.filters.as_of
        gl = self.data["gl"]
        return gl[
            (gl["as_of"] == d)
            & (gl["legal_entity"] == self.filters.legal_entity)
            & (gl["book"] == self.filters.book)
            & (gl["ccy"] == self.filters.ccy)
        ].copy()

    def sor_filtered(self, as_of: Optional[date] = None) -> pd.DataFrame:
        d = as_of if as_of is not None else self.filters.as_of
        sor = self.data["sor"]
        return sor[
            (sor["as_of"] == d)
            & (sor["legal_entity"] == self.filters.legal_entity)
            & (sor["book"] == self.filters.book)
            & (sor["ccy"] == self.filters.ccy)
        ].copy()

    def recon_gl_vs_sor(self) -> pd.DataFrame:
        gl = self.gl_filtered()
        sor = self.sor_filtered()
        key = ["as_of","legal_entity","book","ccy","account","account_name","product"]

        if gl.empty:
            return pd.DataFrame(columns=key + ["gl_amount","sor_amount","variance","abs_var","status","severity"])

        g = gl[key + ["gl_amount"]].copy()
        o = sor[key + ["sor_amount"]].copy() if not sor.empty else pd.DataFrame(columns=key + ["sor_amount"])
        m = g.merge(o, on=key, how="left")
        m["sor_amount"] = m["sor_amount"].fillna(0.0)
        m["variance"] = m["gl_amount"] - m["sor_amount"]
        m["abs_var"] = m["variance"].abs()
        tol = float(self.spn_tol.value())
        m["status"] = np.where(m["abs_var"] <= tol, "MATCH", "BREAK")
        m["severity"] = m["variance"].apply(lambda x: severity_from_amt(x, self.filters.materiality))
        return m

    def recon_crrt_vs_cr360(self) -> pd.DataFrame:
        d = self.filters.as_of
        crrt = self.data["crrt"]
        cr360 = self.data["cr360"]
        crrt_f = crrt[
            (crrt["as_of"]==d)
            & (crrt["legal_entity"]==self.filters.legal_entity)
            & (crrt["book"]==self.filters.book)
            & (crrt["ccy"]==self.filters.ccy)
        ].copy()
        cr360_f = cr360[
            (cr360["as_of"]==d)
            & (cr360["legal_entity"]==self.filters.legal_entity)
            & (cr360["book"]==self.filters.book)
            & (cr360["ccy"]==self.filters.ccy)
        ].copy()

        key = ["as_of","legal_entity","book","ccy","account"]
        if crrt_f.empty:
            return pd.DataFrame(columns=key + ["crrt_amount","cr360_amount","variance","abs_var","status"])

        m = crrt_f.merge(cr360_f[key + ["cr360_amount"]], on=key, how="left")
        m["cr360_amount"] = m["cr360_amount"].fillna(0.0)
        m["variance"] = m["crrt_amount"] - m["cr360_amount"]
        m["abs_var"] = m["variance"].abs()
        tol2 = float(self.spn_tol2.value())
        m["status"] = np.where(m["abs_var"] <= tol2, "MATCH", "BREAK")
        return m

    def variance_period_over_period(self) -> pd.DataFrame:
        cur = self.gl_filtered(self.filters.as_of)
        prior = self.gl_filtered(self.data["prior"])
        if cur.empty:
            return pd.DataFrame(columns=["account","account_name","product","cur","prior","variance","abs_var","severity"])

        c = cur.groupby(["account","account_name","product"]).agg(cur=("gl_amount","sum")).reset_index()
        p = prior.groupby(["account","account_name","product"]).agg(prior=("gl_amount","sum")).reset_index() if not prior.empty else pd.DataFrame(columns=["account","account_name","product","prior"])
        v = c.merge(p, on=["account","account_name","product"], how="left").fillna(0.0)
        v["variance"] = v["cur"] - v["prior"]
        v["abs_var"] = v["variance"].abs()
        v["severity"] = v["variance"].apply(lambda x: severity_from_amt(x, self.filters.materiality))
        return v.sort_values("abs_var", ascending=False)

    def report_lines(self, report: str) -> Tuple[pd.DataFrame, Dict[str, List[str]]]:
        map_df = self.data["map"].copy()
        if report == "FR Y (Other)":
            # Placeholder mapping concept: reuse Y-9C mapping but label as FR Y (Other)
            map_df = map_df[map_df["report"] == "Y-9C"].copy()
            map_df["report"] = report
        else:
            map_df = map_df[map_df["report"] == report].copy()

        gl = self.gl_filtered()

        if map_df.empty or gl.empty:
            cols = ["report_line","line_desc","amount","recon_abs_var","recon_status","mapped_accounts"]
            return pd.DataFrame(columns=cols), {}

        joined = map_df.merge(gl, on="account", how="left")
        joined["gl_amount"] = joined["gl_amount"].fillna(0.0)

        line_amt = joined.groupby(["report_line","line_desc"]).agg(
            amount=("gl_amount","sum"),
            mapped_accounts=("account","nunique"),
        ).reset_index()

        # recon risk per line based on abs variance for mapped accounts (by account)
        recon = self.recon_gl_vs_sor()
        by_acc = recon.groupby(["account"]).agg(abs_var=("abs_var","sum")).reset_index() if not recon.empty else pd.DataFrame(columns=["account","abs_var"])

        accs_by_line: Dict[str, List[str]] = (
            map_df.groupby("report_line")["account"].apply(lambda x: sorted(set(x))).to_dict()
        )

        def risk(accs: List[str]) -> float:
            if not accs:
                return 0.0
            return float(by_acc[by_acc["account"].isin(accs)]["abs_var"].sum()) if not by_acc.empty else 0.0

        line_amt["recon_abs_var"] = line_amt["report_line"].apply(lambda ln: risk(accs_by_line.get(ln, [])))
        line_amt["recon_status"] = np.where(line_amt["recon_abs_var"] <= self.filters.materiality * 0.001, "OK", "AT_RISK")
        return line_amt.sort_values("recon_abs_var", ascending=False), accs_by_line

    # ----------------------
    # Audit logging
    # ----------------------
    def log_action(self, action: str, object_type: str, object_id: str, details: str):
        new = pd.DataFrame([{
            "ts": now_str(),
            "user": self.current_user,
            "action": action,
            "object_type": object_type,
            "object_id": object_id,
            "details": details,
        }])
        self.audit = pd.concat([self.audit, new], ignore_index=True)
        self.refresh_audit()

    # ----------------------
    # Refresh all views
    # ----------------------
    def refresh_all(self):
        # default tolerance based on materiality (safe, non-zero)
        self.spn_tol.blockSignals(True)
        self.spn_tol.setValue(max(0, int(self.filters.materiality * 0.001)))
        self.spn_tol.blockSignals(False)

        self.spn_tol2.blockSignals(True)
        self.spn_tol2.setValue(max(0, int(self.filters.materiality * 0.0005)))
        self.spn_tol2.blockSignals(False)

        self.refresh_dashboard()
        self.refresh_feed()
        self.refresh_gl_explorer()
        self.refresh_recon()
        self.refresh_breaks_view()
        self.refresh_variance()
        self.refresh_reporting()
        self.refresh_lineage()
        self.refresh_audit()

        self.status.showMessage(
            f"Filters: {self.filters.as_of} | {self.filters.legal_entity} | {self.filters.book} | {self.filters.ccy} | Mat={fmt_int(self.filters.materiality)}",
            5000
        )

    def refresh_dashboard(self):
        recon = self.recon_gl_vs_sor()
        breaks = recon[recon.get("status", "") == "BREAK"] if not recon.empty else pd.DataFrame()
        material_breaks = breaks[breaks["abs_var"] >= self.filters.materiality] if not breaks.empty else pd.DataFrame()

        feeds_today = self.data["feed"][self.data["feed"]["as_of"] == self.filters.as_of].copy()
        late_failed = feeds_today[feeds_today["status"].isin(["LATE", "FAILED"])]

        completion = 1.0
        if not recon.empty:
            # very simple completion proxy
            completion = 1.0 - (len(breaks) / max(len(recon), 1))

        # Update KPI labels
        self.kpi_material.findChildren(QLabel)[0].setText(str(len(material_breaks)))
        self.kpi_open.findChildren(QLabel)[0].setText(str(len(breaks)))
        self.kpi_feeds.findChildren(QLabel)[0].setText(str(len(late_failed)))
        self.kpi_recon.findChildren(QLabel)[0].setText(f"{max(0.0, min(1.0, completion))*100:.1f}%")
        self.kpi_cert.findChildren(QLabel)[0].setText("3/6")

        # Top breaks
        top = pd.DataFrame()
        if not recon.empty:
            top = recon.sort_values("abs_var", ascending=False).head(12)[
                ["product","account","account_name","gl_amount","sor_amount","variance","abs_var","status","severity"]
            ].copy()
        self.model_top_breaks.set_df(top)

        # Feed snapshot
        snap = feeds_today[["source","layer","status","latency_min","records","rejects","run_id"]].copy() if not feeds_today.empty else pd.DataFrame()
        self.model_feed_snap.set_df(snap)

        readiness = pd.DataFrame([
            {"Report":"FR2590","Recon Complete":"OK" if len(material_breaks) < 8 else "AT RISK","DQ Passed":"AT RISK","Approvals":"PENDING","Status":"IN PROGRESS"},
            {"Report":"Y-9C","Recon Complete":"OK","DQ Passed":"OK","Approvals":"PENDING","Status":"IN PROGRESS"},
            {"Report":"FR Y (Other)","Recon Complete":"AT RISK","DQ Passed":"AT RISK","Approvals":"PENDING","Status":"AT RISK"},
            {"Report":"CCAR","Recon Complete":"OK","DQ Passed":"OK","Approvals":"OK","Status":"READY"},
            {"Report":"CECL/ACL","Recon Complete":"OK","DQ Passed":"OK","Approvals":"PENDING","Status":"IN PROGRESS"},
            {"Report":"STARE / ERA","Recon Complete":"AT RISK","DQ Passed":"AT RISK","Approvals":"PENDING","Status":"AT RISK"},
        ])
        self.model_readiness.set_df(readiness)

    def refresh_feed(self):
        f = self.data["feed"][self.data["feed"]["as_of"] == self.filters.as_of].copy()
        self.model_feed.set_df(f)

        # Populate picklist
        self.cmb_feed_pick.blockSignals(True)
        self.cmb_feed_pick.clear()
        for s in f["source"].tolist():
            self.cmb_feed_pick.addItem(s)
        self.cmb_feed_pick.blockSignals(False)

        # Reject sample (synthetic)
        if not f.empty:
            rej = pd.DataFrame({
                "source": np.random.choice(f["source"], 30),
                "error_code": np.random.choice(["MISSING_DIM","INVALID_ACCOUNT","BAD_CCY","DUP_KEY","CONTROL_MISMATCH"], 30),
                "sample_key": [f"K{np.random.randint(100000,999999)}" for _ in range(30)],
                "detail": np.random.choice([
                    "Missing cost_center", "Account not in COA", "Currency mismatch", "Duplicate reference id", "Control total variance"
                ], 30),
            })
        else:
            rej = pd.DataFrame(columns=["source","error_code","sample_key","detail"])
        self.model_rejects.set_df(rej)

        self.model_rules.set_df(self.data["rules"].copy())

    def refresh_gl_explorer(self):
        q = (self.ed_gl_search.text() or "").strip().lower()
        gl = self.gl_filtered()
        if gl.empty:
            self.model_gl.set_df(pd.DataFrame(columns=["account","account_name","product","gl_amount"]))
            self.model_map_for_acc.set_df(pd.DataFrame(columns=["report","report_line","line_desc"]))
            self.lbl_ctx.setText("No GL data for current filters.")
            return

        tb = gl.groupby(["account","account_name","product"]).agg(gl_amount=("gl_amount","sum")).reset_index()
        if q:
            tb = tb[
                tb["account"].astype(str).str.contains(q, case=False)
                | tb["account_name"].astype(str).str.lower().str.contains(q)
            ].copy()
        tb = tb.sort_values(["account","product"])
        self.model_gl.set_df(tb)

        # reset context
        self.model_map_for_acc.set_df(pd.DataFrame(columns=["report","report_line","line_desc"]))
        self.lbl_ctx.setText("Select a row to see mappings and lineage.")

    def on_gl_row_selected(self, idx: QModelIndex):
        row = idx.row()
        item = self.model_gl.get_row(row)
        acc = item.get("account", "")
        prod = item.get("product", "")
        amt = item.get("gl_amount", 0.0)

        m = self.data["map"]
        mm = m[m["account"] == acc][["report","report_line","line_desc"]].drop_duplicates().copy()

        self.model_map_for_acc.set_df(mm)
        self.lbl_ctx.setText(
            f"Account {acc} | Product {prod}\n"
            f"Amount: {fmt_money(amt)}\n\n"
            "Lineage:\n"
            "Source: GL_CORE / SUBLEDGER_SOR â†’ Canonical: Enterprise GL Mart â†’ CRRT â†’ CR360 â†’ Reporting"
        )

    def refresh_recon(self):
        recon = self.recon_gl_vs_sor()
        view = recon.sort_values("abs_var", ascending=False)[
            ["product","account","account_name","gl_amount","sor_amount","variance","abs_var","status","severity"]
        ].copy() if not recon.empty else pd.DataFrame(columns=[
            "product","account","account_name","gl_amount","sor_amount","variance","abs_var","status","severity"
        ])
        self.model_recon.set_df(view)

        recon2 = self.recon_crrt_vs_cr360()
        view2 = recon2.sort_values("abs_var", ascending=False)[
            ["account","crrt_amount","cr360_amount","variance","abs_var","status"]
        ].copy() if not recon2.empty else pd.DataFrame(columns=[
            "account","crrt_amount","cr360_amount","variance","abs_var","status"
        ])
        self.model_recon2.set_df(view2)

        # dashboard depends on recon
        self.refresh_dashboard()

    def refresh_breaks_view(self):
        b = self.breaks.copy()
        status = self.cmb_break_status.currentText() if hasattr(self, "cmb_break_status") else "(All)"
        if status and status != "(All)" and not b.empty:
            b = b[b["status"] == status].copy()
        self.model_breaks.set_df(
            b.sort_values(["severity","created_ts"], ascending=[False, False]) if not b.empty else b
        )

        # evidence index + audit page depends on breaks
        self.refresh_audit()

    def refresh_variance(self):
        v = self.variance_period_over_period()
        view = v.head(30)[["account","account_name","product","cur","prior","variance","abs_var","severity"]].copy() if not v.empty else pd.DataFrame(columns=[
            "account","account_name","product","cur","prior","variance","abs_var","severity"
        ])
        self.model_variance.set_df(view)
        self._selected_variance_key = None
        self.lbl_var_pick.setText("(Select a variance row)")
        self.txt_var_narr.setPlainText("")

    def refresh_reporting(self):
        report = self.cmb_report.currentText() if hasattr(self, "cmb_report") else "FR2590"
        lines, accs_by_line = self.report_lines(report)
        self._accs_by_line = accs_by_line

        view = lines.copy()
        if not view.empty:
            view = view[["report_line","line_desc","amount","recon_abs_var","recon_status","mapped_accounts"]].copy()
        else:
            view = pd.DataFrame(columns=["report_line","line_desc","amount","recon_abs_var","recon_status","mapped_accounts"])

        self.model_report_lines.set_df(view)
        self.model_line_drill.set_df(pd.DataFrame(columns=["account","account_name","product","amount"]))
        self._selected_report_line_id = None

    def refresh_lineage(self):
        self.model_map.set_df(self.data["map"].sort_values(["report","report_line","account"]).copy())
        gl = self.gl_filtered()
        accs = sorted(gl["account"].unique().tolist()) if not gl.empty else sorted(self.data["map"]["account"].unique().tolist())

        self.cmb_lineage_acc.blockSignals(True)
        self.cmb_lineage_acc.clear()
        for a in accs:
            self.cmb_lineage_acc.addItem(str(a))
        self.cmb_lineage_acc.blockSignals(False)

        if accs:
            self.cmb_lineage_acc.setCurrentIndex(0)
            self.refresh_lineage_side()

    def refresh_lineage_side(self):
        acc = self.cmb_lineage_acc.currentText().strip()
        if not acc:
            self.lbl_lineage.setText("No account selected.")
            self.model_related_lines.set_df(pd.DataFrame(columns=["report","report_line","line_desc"]))
            return

        related = self.data["map"][self.data["map"]["account"] == acc][["report","report_line","line_desc"]].drop_duplicates().copy()
        self.model_related_lines.set_df(related)

        self.lbl_lineage.setText(
            f"Account: {acc}\n"
            f"Entity: {self.filters.legal_entity} | Book: {self.filters.book} | CCY: {self.filters.ccy} | As-of: {self.filters.as_of}\n\n"
            "Lineage Path:\n"
            "1) Sources: GL_CORE + SUBLEDGER_SOR\n"
            "2) Canonical: Enterprise GL Data Mart\n"
            "3) Aggregation: CRRT\n"
            "4) Curation: CR360\n"
            "5) Reporting: FR2590 / Y-9C / FR Y (Other) / CCAR / CECL-ACL / STARE / ERA\n\n"
            "Controls:\n"
            "â€¢ Completeness â€¢ Timeliness â€¢ Recon tolerance â€¢ Mapping coverage â€¢ Audit trail"
        )

    def refresh_audit(self):
        a = self.audit.sort_values("ts", ascending=False).copy() if not self.audit.empty else pd.DataFrame(columns=["ts","user","action","object_type","object_id","details"])
        self.model_audit.set_df(a)

        b = self.breaks.copy()
        if b.empty:
            evid = pd.DataFrame(columns=["break_id","as_of","recon_type","severity","status","evidence_ref","notes"])
        else:
            evid = b[b["evidence_ref"].astype(str).str.len() > 0][
                ["break_id","as_of","recon_type","severity","status","evidence_ref","notes"]
            ].copy()
        self.model_evidence.set_df(evid)

    # ----------------------
    # Actions
    # ----------------------
    def create_largest_break(self):
        recon = self.recon_gl_vs_sor()
        if recon.empty:
            QMessageBox.warning(self, "No Data", "No recon data available for current filters.")
            return
        row = recon.sort_values("abs_var", ascending=False).iloc[0].to_dict()
        bid = hash_id("BRK")
        new_break = {
            "break_id": bid,
            "created_ts": now_str(),
            "as_of": self.filters.as_of,
            "recon_type": "GL vs SOR",
            "legal_entity": self.filters.legal_entity,
            "book": self.filters.book,
            "ccy": self.filters.ccy,
            "account": row.get("account", ""),
            "product": row.get("product", ""),
            "gl_amount": safe_float(row.get("gl_amount"), 0.0),
            "other_amount": safe_float(row.get("sor_amount"), 0.0),
            "variance": safe_float(row.get("variance"), 0.0),
            "severity": severity_from_amt(row.get("variance"), self.filters.materiality),
            "root_cause": "UNCLASSIFIED",
            "owner": "Recon Analyst",
            "status": "OPEN",
            "sla_due": (date.today() + timedelta(days=2)).isoformat(),
            "notes": "Auto-created from dashboard action",
            "evidence_ref": "",
        }
        self.breaks = pd.concat([self.breaks, pd.DataFrame([new_break])], ignore_index=True)
        self.log_action("CREATE", "BREAK", bid, f"Created from dashboard for account={new_break['account']} product={new_break['product']}")
        self.refresh_breaks_view()
        QMessageBox.information(self, "Break Created", f"Created break: {bid}")

    def create_breaks_from_selected_recon_rows(self):
        sel = self.tbl_recon.selectionModel().selectedRows()
        if not sel:
            QMessageBox.information(self, "Select Rows", "Select one or more recon rows to create breaks.")
            return
        df = self.model_recon._df
        if df is None or df.empty:
            QMessageBox.warning(self, "No Data", "Recon table is empty.")
            return

        created = 0
        # Only create for BREAK rows (optional); here we create for selected rows regardless
        for idx in sel:
            r = self.model_recon.get_row(idx.row())
            bid = hash_id("BRK")
            new_break = {
                "break_id": bid,
                "created_ts": now_str(),
                "as_of": self.filters.as_of,
                "recon_type": "GL vs SOR",
                "legal_entity": self.filters.legal_entity,
                "book": self.filters.book,
                "ccy": self.filters.ccy,
                "account": r.get("account", ""),
                "product": r.get("product", ""),
                "gl_amount": safe_float(r.get("gl_amount"), 0.0),
                "other_amount": safe_float(r.get("sor_amount"), 0.0),
                "variance": safe_float(r.get("variance"), 0.0),
                "severity": severity_from_amt(r.get("variance"), self.filters.materiality),
                "root_cause": "UNCLASSIFIED",
                "owner": "Recon Analyst",
                "status": "OPEN",
                "sla_due": (date.today() + timedelta(days=2)).isoformat(),
                "notes": "",
                "evidence_ref": "",
            }
            self.breaks = pd.concat([self.breaks, pd.DataFrame([new_break])], ignore_index=True)
            self.log_action("CREATE", "BREAK", bid, f"Created from recon selection account={new_break['account']} product={new_break['product']}")
            created += 1

        self.refresh_breaks_view()
        QMessageBox.information(self, "Breaks Created", f"Created {created} breaks.")

    def edit_selected_break(self):
        sel = self.tbl_breaks.selectionModel().selectedRows()
        if not sel:
            QMessageBox.information(self, "Select Break", "Select a break row to edit.")
            return
        df = self.model_breaks._df
        if df is None or df.empty:
            QMessageBox.warning(self, "No Data", "No breaks available.")
            return

        pick = self.model_breaks.get_row(sel[0].row())
        break_id = pick.get("break_id", "")
        if not break_id:
            QMessageBox.warning(self, "Invalid Selection", "Selected break row is invalid.")
            return

        # Locate in master breaks df
        idx_master = self.breaks.index[self.breaks["break_id"] == break_id]
        if len(idx_master) == 0:
            QMessageBox.warning(self, "Not Found", "Break not found in master store.")
            return
        master_row = self.breaks.loc[idx_master[0]].to_dict()

        dlg = BreakEditorDialog(master_row, self)
        if dlg.exec() == QDialog.DialogCode.Accepted:
            updated = dlg.break_row
            for k, v in updated.items():
                if k in self.breaks.columns:
                    self.breaks.loc[idx_master[0], k] = v
            self.log_action("UPDATE", "BREAK", break_id, f"status={updated.get('status')} root={updated.get('root_cause')} owner={updated.get('owner')}")
            self.refresh_breaks_view()
            QMessageBox.information(self, "Saved", "Break updated.")

    def rerun_feed(self):
        src = self.cmb_feed_pick.currentText().strip()
        if not src:
            QMessageBox.warning(self, "No Feed", "No feed selected.")
            return
        self.log_action("RERUN", "FEED", src, f"Rerun requested for {src} as_of={self.filters.as_of}")
        QMessageBox.information(self, "Logged", "Rerun request logged (prototype).")

    def create_incident(self):
        src = self.cmb_feed_pick.currentText().strip()
        inc = hash_id("INC")
        self.log_action("CREATE", "INCIDENT", inc, f"Incident for feed={src or '(none)'} as_of={self.filters.as_of}")
        QMessageBox.information(self, "Incident Created", f"Incident created: {inc}")

    def on_variance_selected(self, idx: QModelIndex):
        r = self.model_variance.get_row(idx.row())
        acc = r.get("account", "")
        prod = r.get("product", "")
        abs_var = r.get("abs_var", 0.0)
        self._selected_variance_key = f"{acc}|{prod}"
        self.lbl_var_pick.setText(f"{acc} | {prod} | abs_var={fmt_money(abs_var)}")

    def save_variance_explanation(self):
        if not getattr(self, "_selected_variance_key", None):
            QMessageBox.information(self, "Select Variance", "Select a variance row first.")
            return
        reason = self.cmb_var_reason.currentText()
        narrative = self.txt_var_narr.toPlainText().strip()
        if not narrative:
            # enforce for material variances; here we enforce always to be safe
            QMessageBox.warning(self, "Narrative Required", "Please enter a narrative explanation.")
            return
        self.log_action("EXPLAIN", "VARIANCE", self._selected_variance_key, f"reason={reason}; narrative={narrative[:200]}")
        QMessageBox.information(self, "Saved", "Variance explanation saved to audit log.")

    def on_report_line_selected(self, idx: QModelIndex):
        r = self.model_report_lines.get_row(idx.row())
        line = r.get("report_line", None)
        if not line:
            self.model_line_drill.set_df(pd.DataFrame(columns=["account","account_name","product","amount"]))
            self._selected_report_line_id = None
            return

        self._selected_report_line_id = f"{self.cmb_report.currentText()}-{line}"
        accs = self._accs_by_line.get(line, [])

        gl = self.gl_filtered()
        if gl.empty or not accs:
            self.model_line_drill.set_df(pd.DataFrame(columns=["account","account_name","product","amount"]))
            return

        drill = gl[gl["account"].isin(accs)].groupby(["account","account_name","product"]).agg(amount=("gl_amount","sum")).reset_index()
        drill = drill.sort_values("amount", ascending=False)
        self.model_line_drill.set_df(drill)

    def certify_selected_line(self):
        sel = self.tbl_report_lines.selectionModel().selectedRows()
        if not sel:
            QMessageBox.information(self, "Select Line", "Select a report line to certify.")
            return
        r = self.model_report_lines.get_row(sel[0].row())
        line = r.get("report_line", "")
        rep = self.cmb_report.currentText()
        if not line:
            QMessageBox.warning(self, "Invalid", "Selected line is invalid.")
            return
        self.log_action("CERTIFY", "REPORT_LINE", f"{rep}-{line}", f"Certified by {self.current_user} as_of={self.filters.as_of}")
        QMessageBox.information(self, "Certified", "Report line certified (prototype log).")

    def lock_report_cycle(self):
        rep = self.cmb_report.currentText()
        self.log_action("LOCK", "REPORT", rep, f"Locked cycle for {rep} as_of={self.filters.as_of}")
        QMessageBox.information(self, "Locked", "Report cycle locked (prototype log).")

    def reset_prototype(self):
        self.data = seed_data()
        self.breaks = self.breaks.iloc[0:0].copy()
        self.audit = self.audit.iloc[0:0].copy()
        self.refresh_all()
        QMessageBox.information(self, "Reset", "Prototype data has been reset.")

# ----------------------------
# Entrypoint
# ----------------------------

def main():
    app = QApplication(sys.argv)

    # Optional: subtle enterprise-friendly font
    app.setFont(QFont("Arial", 10))

    w = MainWindow()
    w.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
