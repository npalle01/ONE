#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: advanced_lineage.py
Description:
  Combines advanced decision lineage with a new, Erwin-like flattened lineage visualization.
  Features:
    • parse_sql_dependencies(...) for extracting tables from SQL.
    • DecisionTableManager for add/edit/delete/run of decision tables.
    • AdvancedLineageGraphView for drawing rules and tables in a BFS-layered layout (no overlap).
    • Each rule is numbered in BFS "execution" order. 
    • highlight_impact(...) method to highlight downstream rules if a given rule changes.
    
Database Requirements:
  - BRM_RULES(RULE_ID, RULE_NAME, STATUS, APPROVAL_STATUS, PARENT_RULE_ID, RULE_SQL, CRITICAL_RULE, etc.)
  - BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, etc.)
  - DECISION_TABLES(DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY, etc.)
"""

import sys
import logging
import pyodbc
import sqlparse
from collections import deque
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QColor, QFont, QPen, QBrush
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget,
    QTableWidgetItem, QPushButton, QMessageBox, QInputDialog,
    QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsEllipseItem,
    QGraphicsLineItem, QGraphicsTextItem, QLabel, QPlainTextEdit
)

from core_foundation import logger, insert_audit_log

# -----------------------------------------------------------------------------
# 1. parse_sql_dependencies(...) – an SQL parsing utility
# -----------------------------------------------------------------------------
def parse_sql_dependencies(sql_text):
    """
    Parses an SQL statement using sqlparse to extract table references.
    Returns a dict with keys:
      "tables": list of (schema, table, alias, is_subquery)
    This is a simplified approach. 
    """
    result = {"tables": []}
    statements = sqlparse.parse(sql_text)
    for stmt in statements:
        from_seen = False
        token_list = list(stmt.tokens)
        i = 0
        while i < len(token_list):
            tk = token_list[i]
            val_up = tk.value.upper() if tk.value else ""
            if val_up in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            elif from_seen:
                # If next keyword is WHERE, GROUP, etc. we stop
                if tk.ttype is sqlparse.tokens.Keyword:
                    if val_up in ("WHERE","GROUP","ORDER","HAVING","UNION","INTERSECT"):
                        from_seen = False
                else:
                    if isinstance(tk, sqlparse.sql.Identifier):
                        schema_name = tk.get_parent_name()
                        real_name = tk.get_real_name()
                        alias = tk.get_alias()
                        result["tables"].append((schema_name, real_name, alias, False))
                    elif isinstance(tk, sqlparse.sql.IdentifierList):
                        for ident in tk.get_identifiers():
                            s = ident.get_parent_name()
                            r = ident.get_real_name()
                            a = ident.get_alias()
                            result["tables"].append((s, r, a, False))
            i += 1
    return result

# -----------------------------------------------------------------------------
# 2. DecisionTableManager – QDialog to manage decision tables
# -----------------------------------------------------------------------------
class DecisionTableManager(QDialog):
    """
    Dialog to view, add, edit, delete, and run Decision Tables from DECISION_TABLES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Decision Table Manager")
        self.resize(700, 500)
        self.init_ui()
        self.load_decision_tables()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0,4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","Table Name","Description","Decision Query"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_decision_table)
        btn_layout.addWidget(add_btn)

        edit_btn = QPushButton("Edit Decision Table")
        edit_btn.clicked.connect(self.edit_decision_table)
        btn_layout.addWidget(edit_btn)

        delete_btn = QPushButton("Delete Decision Table")
        delete_btn.clicked.connect(self.delete_decision_table)
        btn_layout.addWidget(delete_btn)

        run_btn = QPushButton("Run Decision Table")
        run_btn.clicked.connect(self.run_decision_table)
        btn_layout.addWidget(run_btn)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_decision_tables)
        btn_layout.addWidget(refresh_btn)

        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.result_log = QPlainTextEdit()
        self.result_log.setReadOnly(True)
        layout.addWidget(self.result_log)

        self.setLayout(layout)

    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_i = self.dt_table.rowCount()
                self.dt_table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.dt_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading decision tables: {ex}")

    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Description", "Optional desc:")
        if not ok2:
            desc = ""
        query, ok3 = QInputDialog.getMultiLineText(self, "Decision Query", "SQL here:")
        if not ok3 or not query.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION,DECISION_QUERY)
                VALUES(?,?,?)
            """, (name.strip(), desc.strip(), query.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision table created.")
            insert_audit_log(self.connection, "ADD_DECISION_TABLE","DECISION_TABLES", None,
                             "User", None, {"table":name})
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def edit_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "Selection Error", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        cur_name = self.dt_table.item(row,1).text()
        cur_desc = self.dt_table.item(row,2).text()
        cur_query = self.dt_table.item(row,3).text()

        name, ok = QInputDialog.getText(self, "Edit Table Name", "New name:", text=cur_name)
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Edit Description", "New desc:", text=cur_desc)
        if not ok2:
            desc = cur_desc
        query, ok3 = QInputDialog.getMultiLineText(self, "Edit Query", "New query:", text=cur_query)
        if not ok3 or not query.strip():
            return

        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE DECISION_TABLES
                SET TABLE_NAME=?, DESCRIPTION=?, DECISION_QUERY=?
                WHERE DECISION_TABLE_ID=?
            """, (name.strip(), desc.strip(), query.strip(), dt_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Decision table updated.")
            insert_audit_log(self.connection, "EDIT_DECISION_TABLE","DECISION_TABLES", dt_id,
                             "User", None, {"new_name":name})
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Update Error", str(ex))

    def delete_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "Selection Error", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        confirm = QMessageBox.question(self, "Confirm Deletion", f"Delete DT {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"DT {dt_id} deleted.")
            insert_audit_log(self.connection, "DELETE_DECISION_TABLE","DECISION_TABLES", dt_id,
                             "User", None, {"deleted":True})
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

    def run_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "Selection Error", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())

        c = self.connection.cursor()
        c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
        rowq = c.fetchone()
        if not rowq or not rowq[0]:
            QMessageBox.warning(self, "No Query", "No SQL found for this DT.")
            return
        query = rowq[0]

        # Dry-run
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute(query)
            try:
                rows = c.fetchall()
            except:
                rows = []
            impacted = len(rows)
            c.execute("ROLLBACK")
            msg = f"DT {dt_id} impacted {impacted} row(s)."
            self.result_log.appendPlainText(msg)
            QMessageBox.information(self, "Run Decision Table", msg)
            insert_audit_log(self.connection, "RUN_DECISION_TABLE","DECISION_TABLES", dt_id,
                             "User", None, {"impacted":impacted})
        except Exception as ex:
            c.execute("ROLLBACK")
            err = f"Run error for DT {dt_id}: {ex}"
            self.result_log.appendPlainText(err)
            QMessageBox.critical(self, "Run Error", err)

# -----------------------------------------------------------------------------
# 3. AdvancedLineageGraphView – BFS-based layered approach with order numbering
# -----------------------------------------------------------------------------
class AdvancedLineageGraphView(QGraphicsView):
    """
    Draws an Erwin-like flattened lineage diagram with BFS layering for BRM_RULES,
    plus table nodes on the far right. Each rule is labeled with a BFS "execution" number
    to show order. No overlapping is done by carefully spacing each BFS layer in columns.
    Also, highlight_impact(...) for BFS-based "Rule Change Impact Analysis."
    """
    def __init__(self, connection, parent=None, auto_refresh_interval=45000):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.SmoothPixmapTransform)

        self.rule_nodes = {}  # rule_id -> QGraphicsRectItem
        self.table_nodes = {} # (db, tbl) -> QGraphicsEllipseItem

        # Timer for auto-refresh
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.populate_graph)
        self.refresh_timer.start(auto_refresh_interval)

        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.rule_nodes.clear()
        self.table_nodes.clear()
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT RULE_ID, RULE_NAME, STATUS, APPROVAL_STATUS, PARENT_RULE_ID
                FROM BRM_RULES
            """)
            rule_rows = c.fetchall()

            # Build adjacency for rule->child
            children_map = {}
            rule_map = {}
            for (rid, rname, rstat, rappr, pid) in rule_rows:
                rule_map[rid] = (rname, rstat, rappr, pid)
                if pid:
                    children_map.setdefault(pid, []).append(rid)

            # BFS layering
            # Find roots = rules with no PARENT_RULE_ID
            roots = [r for (r, data) in rule_map.items() if data[3] is None]
            if not roots:
                # If none found, let's treat all as roots
                roots = list(rule_map.keys())

            # BFS to find layering
            visited = set()
            layers = []  # list of lists; each sub-list is a BFS layer
            queue = deque(roots)
            layer_index = {}
            # We also want an overall BFS "execution order" counter
            execution_order = []
            current_depth = 0

            # We'll do a multi-root BFS. We'll keep track of depth in a queue
            multi_queue = deque()
            for r in roots:
                multi_queue.append((r,0))

            while multi_queue:
                (node, depth) = multi_queue.popleft()
                if node in visited:
                    continue
                visited.add(node)
                # ensure layers list is big enough
                while len(layers) <= depth:
                    layers.append([])
                layers[depth].append(node)
                execution_order.append(node)
                for child in children_map.get(node, []):
                    multi_queue.append((child, depth+1))

            # Now we have BFS layers in 'layers'. 
            # We'll place each layer in a vertical column, left->right
            x_start = 50
            y_start = 50
            x_spacing = 250
            y_spacing = 100

            # We'll also store an index for BFS execution order so we can show a number
            order_map = { rid: i+1 for i, rid in enumerate(execution_order) }

            for depth, layer_nodes in enumerate(layers):
                x_pos = x_start + depth*x_spacing
                for i, rid in enumerate(layer_nodes):
                    (rname, rstat, rappr, pid) = rule_map[rid]
                    y_pos = y_start + i*y_spacing
                    # create a node
                    node = BFSRuleNodeItem(rid, rname, rstat, rappr, order_map[rid])
                    node.setPos(x_pos, y_pos)
                    self.scene.addItem(node)
                    self.rule_nodes[rid] = node

            # Next, place table nodes on the far right
            # Gather table deps
            c.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
            deps = c.fetchall()
            # We'll keep track of (db,tbl) -> list of rules that reference it
            table_ref_map = {}
            for (rid, dbname, tblname) in deps:
                db_low = dbname.lower() if dbname else "nodb"
                tbl_low = tblname.lower() if tblname else "notable"
                key = (db_low, tbl_low)
                table_ref_map.setdefault(key, []).append(rid)

            # Place each unique table in one vertical column after the last BFS layer
            table_x = x_start + len(layers)*x_spacing + 200
            tables_sorted = sorted(table_ref_map.keys())
            for i, key in enumerate(tables_sorted):
                db, tbl = key
                t_node = BFSTableNodeItem(db, tbl)
                t_node.setPos(table_x, y_start + i*y_spacing)
                self.scene.addItem(t_node)
                self.table_nodes[key] = t_node

            # Draw arrows rule->child rule, then rule->table
            # rule->child is handled by BFS, we just connect them visually
            for depth, layer_nodes in enumerate(layers):
                # connect to next layer
                if depth < len(layers)-1:
                    for rid in layer_nodes:
                        node_source = self.rule_nodes[rid]
                        # children
                        for child in children_map.get(rid, []):
                            node_target = self.rule_nodes.get(child)
                            if node_target:
                                arrow = BFSArrowItem(node_source, node_target, color=Qt.darkGray, label="")
                                self.scene.addItem(arrow)

            # Now connect rules to tables
            for key, rlist in table_ref_map.items():
                if key in self.table_nodes:
                    table_item = self.table_nodes[key]
                    for rid in rlist:
                        if rid in self.rule_nodes:
                            arrow = BFSArrowItem(self.rule_nodes[rid], table_item, color=Qt.darkBlue, label="")
                            self.scene.addItem(arrow)

            self.resetView()
        except Exception as ex:
            logger.error(f"populate_graph error: {ex}")
            QMessageBox.critical(self, "Lineage Error", str(ex))

    def resetView(self):
        self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)

    def highlight_impact(self, changed_rule_id):
        """
        BFS to find all descendants of changed_rule_id, highlight them. 
        Keeps the BFS layering layout.
        """
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
            rows = c.fetchall()
            children_map = {}
            for (rule_id, parent_id) in rows:
                if parent_id:
                    children_map.setdefault(parent_id, []).append(rule_id)

            impacted = []
            visited = set()
            queue = [changed_rule_id]

            while queue:
                current = queue.pop()
                if current in visited:
                    continue
                visited.add(current)
                impacted.append(current)
                for child in children_map.get(current, []):
                    queue.append(child)

            # dim all
            for rnode in self.rule_nodes.values():
                rnode.setOpacity(0.3)
            # highlight impacted
            for rid in impacted:
                if rid in self.rule_nodes:
                    self.rule_nodes[rid].setOpacity(1.0)

            msg = f"Rule {changed_rule_id} changes affect: {impacted}"
            QMessageBox.information(self, "Impact Analysis", msg)
            logger.info(msg)

        except Exception as ex:
            logger.error(f"highlight_impact error: {ex}")
            QMessageBox.critical(self, "Impact Error", str(ex))

# -----------------------------------------------------------------------------
# BFSNode Items for Graph
# -----------------------------------------------------------------------------
class BFSRuleNodeItem(QGraphicsRectItem):
    """
    A rectangle representing a rule, color-coded by status, with a BFS "execution order" number shown.
    """
    def __init__(self, rule_id, rule_name, status, approval_status, bfs_number):
        super().__init__(0,0,180,60)
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.status = status
        self.approval_status = approval_status
        self.bfs_number = bfs_number  # The BFS execution order

        # Color
        if status.upper()=="ACTIVE":
            fill_color = QColor("#C8E6C9")
        elif status.upper()=="INACTIVE":
            fill_color = QColor("#FFCDD2")
        else:
            fill_color = QColor("#FFF9C4")  # pending or unknown

        self.setBrush(QBrush(fill_color))
        self.setPen(QPen(Qt.black,2))

        # label text: BFS number + name
        text_str = f"[{self.bfs_number}] {rule_name}\nRule {rule_id}"
        text_item = QGraphicsTextItem(text_str, self)
        text_item.setFont(QFont("Arial", 9))
        br = text_item.boundingRect()
        rw, rh = self.rect().width(), self.rect().height()
        text_item.setPos((rw-br.width())/2, (rh-br.height())/2)

        tooltip = f"Rule {rule_id}\nStatus: {status}\nApproval: {approval_status}\nOrder: {self.bfs_number}"
        self.setToolTip(tooltip)

class BFSTableNodeItem(QGraphicsEllipseItem):
    """
    A circle representing a database table. 
    """
    def __init__(self, db_name, table_name):
        super().__init__(0,0,80,80)
        self.db_name = db_name
        self.table_name = table_name
        self.setBrush(QBrush(QColor("#BBDEFB")))
        self.setPen(QPen(Qt.darkBlue,2))

        label = f"{db_name}.{table_name}"
        text_item = QGraphicsTextItem(label, self)
        text_item.setFont(QFont("Arial",8))
        br = text_item.boundingRect()
        w, h = self.rect().width(), self.rect().height()
        text_item.setPos((w-br.width())/2, (h-br.height())/2)

        self.setToolTip(f"Table: {db_name}.{table_name}")

class BFSArrowItem(QGraphicsLineItem):
    """
    An arrow line item connecting BFS nodes or BFS->Table nodes, with optional label.
    """
    def __init__(self, source_item, target_item, color=Qt.darkGray, label=""):
        super().__init__()
        self.source_item = source_item
        self.target_item = target_item
        self.color = color
        self.label = label

        pen = QPen(self.color, 2)
        self.setPen(pen)
        self.text_item = None
        if label:
            self.text_item = QGraphicsTextItem(label)
        self.update_position()

    def update_position(self):
        sr = self.source_item.sceneBoundingRect().center()
        tr = self.target_item.sceneBoundingRect().center()
        self.setLine(sr.x(), sr.y(), tr.x(), tr.y())

    def paint(self, painter, option, widget=None):
        self.update_position()
        super().paint(painter, option, widget)
        # If we have a label, place it mid-line
        if self.label and self.text_item:
            line = self.line()
            midpoint = QtCore.QPointF((line.x1()+line.x2())/2, (line.y1()+line.y2())/2)
            self.text_item.setPos(midpoint)
            # but we'd need to ensure it's added to the same scene, etc.