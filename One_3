#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_approvals_and_lineage.py
Description:
  Implements advanced multi-step approvals for BRM rules and partial lineage references related to approvals.
  Key features:
    • MultiStepApprovalTab: show pending approvals for the current user, with minimal stage checks.
    • Force override or forced unlock for admin.
    • Possibly a GlobalCriticalAdminTab for admin-only global/critical management, if desired.
    • Basic reference to rule adjacency if needed for approval warnings.

Note:
  - Full BFS lineage is in `brm_lineage_visualization.py`
  - BFS execution is in `brm_rule_engine.py`
  - This module focuses on approvals, partial lineage for impacted group checks, and optional GCR admin.
"""

import sys
import logging
from datetime import datetime
import pyodbc

# PyQt5
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QCheckBox, QLineEdit,
    QDialog, QHBoxLayout
)
from PyQt5.QtCore import Qt, QTimer

# from brm_core_foundation
from brm_core_foundation import logger, LockManager, insert_audit_log

###############################################################################
# 1) Multi-Step Approval Tab
###############################################################################
class MultiStepApprovalTab(QWidget):
    """
    Displays pending approvals for the logged-in user. 
    Only shows rows at the minimal (current) approval stage. 
    Provides Approve, Reject, Force Unlock (admin only).
    Auto-refresh is optional.

    Table columns:
      [RuleID, Group, RuleName, Stage, Approved?, ApproveBtn, RejectBtn, ForceUnlockBtn]
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)

        self.approval_table = QTableWidget(0,8)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","Group","RuleName","Stage","Approved?","Approve","Reject","ForceUnlock"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        self.approval_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.approval_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.approval_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c = self.connection.cursor()
        # Fetch approvals for the current user where approved_flag=0
        c.execute("""
            SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG,
                   A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS, R.LOCK_STATUS, R.LOCKED_BY
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
            WHERE A.USERNAME=?
              AND A.APPROVED_FLAG=0
            ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows = c.fetchall()

        def get_min_stage(rule_id):
            c2 = self.connection.cursor()
            c2.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rule_id,))
            row_ = c2.fetchone()
            return row_[0] if row_ and row_[0] else None

        # Filter to only those at minimal pending stage
        filtered = []
        for row in rows:
            rid = row[0]
            stg = row[4]
            min_st = get_min_stage(rid)
            if min_st==stg:
                filtered.append(row)

        self.approval_table.setRowCount(len(filtered))
        for idx, rowd in enumerate(filtered):
            rid, grp, un, appflag, stage, rname, appstat, lockstat, lockedby = rowd
            self.approval_table.setItem(idx, 0, QTableWidgetItem(str(rid)))
            self.approval_table.setItem(idx, 1, QTableWidgetItem(str(grp)))
            self.approval_table.setItem(idx, 2, QTableWidgetItem(str(rname)))
            self.approval_table.setItem(idx, 3, QTableWidgetItem(str(stage)))
            self.approval_table.setItem(idx, 4, QTableWidgetItem(str(appflag)))

            # Approve button
            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rr=idx: self.do_approve(rr))
            self.approval_table.setCellWidget(idx, 5, approve_btn)

            # Reject button
            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rr=idx: self.do_reject(rr))
            self.approval_table.setCellWidget(idx, 6, reject_btn)

            # Force unlock button (only admin can do it)
            fu_btn = QPushButton("ForceUnlock")
            if self.user_group!="Admin":
                fu_btn.setEnabled(False)
            else:
                fu_btn.clicked.connect(lambda _, rr=idx: self.do_force_unlock(rr))
            self.approval_table.setCellWidget(idx, 7, fu_btn)

        self.approval_table.resizeColumnsToContents()

    def get_row_data(self, row_idx):
        rid_item = self.approval_table.item(row_idx, 0)
        grp_item = self.approval_table.item(row_idx, 1)
        if not rid_item or not grp_item:
            return (None,None)
        return (int(rid_item.text()), grp_item.text().strip())

    def do_approve(self, row_i):
        (rid, grp) = self.get_row_data(row_i)
        if not rid or not grp:
            return
        c = self.connection.cursor()
        # Mark as approved
        c.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
            WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))

        # Check if all approvals are done => min pending stage?
        def get_min_stage(rule_id):
            c2=self.connection.cursor()
            c2.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rule_id,))
            ro=c2.fetchone()
            return ro[0] if ro and ro[0] else None

        ms = get_min_stage(rid)
        if ms is None:
            # all approvals => set rule ACTIVE
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                WHERE RULE_ID=?
            """,(rid,))
        else:
            # still pending => set status=INACTIVE
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                WHERE RULE_ID=?
            """,(rid,))

        insert_audit_log(self.connection, "APPROVE","BRM_RULE_APPROVALS", rid, self.logged_in_username, {"old":0}, {"approved":1})
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} => Approved at stage for group {grp}.")
        self.load_approvals()

    def do_reject(self, row_i):
        (rid, grp) = self.get_row_data(row_i)
        if not rid or not grp:
            return
        confirm = QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
            WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))
        c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
            WHERE RULE_ID=?
        """,(rid,))
        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"rejected":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} => Rejected.")
        self.load_approvals()

    def do_force_unlock(self, row_i):
        if self.user_group!="Admin":
            QMessageBox.warning(self,"Denied","Only Admin can force unlock.")
            return
        (rid, grp) = self.get_row_data(row_i)
        if not rid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force unlock rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            LockManager.unlock_rule(self.connection, rid, "AdminOverride", force=True)
            insert_audit_log(self.connection,"FORCE_UNLOCK","BRM_RULES", rid,"AdminOverride",{"locked":True},{"locked":False})
            QMessageBox.information(self,"Unlocked",f"Rule {rid} forcibly unlocked.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_approvals()


###############################################################################
# 2) (Optional) Global Critical Admin Tab
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    Admin-only interface for managing global or critical flags, as well as GCR links.
    If you prefer to keep this in brm_custom_groups_and_alerts, that's also valid.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)
        if self.user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin Only"))
            self.setLayout(layout)
            return

        top_h = QHBoxLayout()
        self.show_gcr_only = QCheckBox("Show only GCR rules?")
        self.show_gcr_only.setChecked(True)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(self.show_gcr_only)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        # rule table
        from PyQt5.QtWidgets import QTableWidget
        self.rule_table = QTableWidget(0,9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IS_GLOBAL","CRITICAL_RULE",
            "CRITICAL_SCOPE","STATUS","LOCKED_BY","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        # G/C update panel
        gc_h = QHBoxLayout()
        self.global_cb = QCheckBox("Set Global?")
        gc_h.addWidget(self.global_cb)
        self.critical_cb = QCheckBox("Set Critical?")
        gc_h.addWidget(self.critical_cb)
        gc_h.addWidget(QLabel("Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        gc_h.addWidget(self.scope_combo)
        apply_btn = QPushButton("Apply G/C to Selected")
        apply_btn.clicked.connect(self.apply_gcr)
        gc_h.addWidget(apply_btn)
        gc_h.addStretch()
        layout.addLayout(gc_h)

        # GCR linking
        link_h = QHBoxLayout()
        self.gcr_parent_combo = QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_parent_combo)
        self.gcr_child_combo = QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.gcr_child_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(link_btn)
        link_h.addWidget(unlink_btn)
        link_h.addStretch()
        layout.addLayout(link_h)

        # link table
        from PyQt5.QtWidgets import QTableWidgetItem
        self.link_view = QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all_btn = QPushButton("Refresh All")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        if self.show_gcr_only.isChecked():
            c.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       CRITICAL_SCOPE, STATUS, LOCKED_BY, UPDATED_BY
                FROM BRM_RULES
                WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       CRITICAL_SCOPE, STATUS, LOCKED_BY, UPDATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.rule_table.setItem(r_i, col_i, QTableWidgetItem(str(val)))

        self.rule_table.resizeColumnsToContents()

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c=self.connection.cursor()
        c.execute("""
            SELECT RULE_ID, RULE_NAME
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID
        """)
        for (rid,rn) in c.fetchall():
            self.gcr_parent_combo.addItem(f"{rid} - {rn}", rid)

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            self.gcr_child_combo.addItem(f"{rid} - {rn}", rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for row_ in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            from PyQt5.QtWidgets import QTableWidgetItem
            self.link_view.setItem(r_i,0, QTableWidgetItem(str(row_[0])))
            self.link_view.setItem(r_i,1, QTableWidgetItem(str(row_[1])))

    def get_selected_rule_ids(self):
        sel = self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in sel:
            row=i_.row()
            it = self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def apply_gcr(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        is_global = 1 if self.global_cb.isChecked() else 0
        is_crit = 1 if self.critical_cb.isChecked() else 0
        scope_ = self.scope_combo.currentText().upper()

        c = self.connection.cursor()
        for rid in rids:
            # forcibly override lock if needed
            try:
                LockManager.lock_rule(self.connection, rid, "AdminOverride", force=True)
            except Exception as ex:
                logger.warning(f"Lock override failed for rule {rid}: {ex}")
            c.execute("""
                UPDATE BRM_RULES
                SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
                WHERE RULE_ID=?
            """,(is_global, is_crit, scope_, rid))
            insert_audit_log(self.connection,"GCR_UPDATE","BRM_RULES", rid,"Admin",None,{"IS_GLOBAL":is_global,"CRIT":is_crit,"SCOPE":scope_})
            try:
                LockManager.unlock_rule(self.connection, rid, "AdminOverride", force=True)
            except Exception as ex2:
                logger.warning(f"Unlock override failed for rule {rid}: {ex2}")

        self.connection.commit()
        QMessageBox.information(self,"Updated",f"Updated G/C flags for {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            QMessageBox.warning(self,"Invalid","Select both parent & child.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID)
            VALUES(?,?)
        """,(pid,cid))
        insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"child":cid})
        self.connection.commit()
        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}.")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink {cid} from parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
        insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",{"child":cid},None)
        self.connection.commit()
        QMessageBox.information(self,"Unlinked",f"Child {cid} unlinked from parent {pid}.")
        self.load_link_view()


###############################################################################
# End of brm_approvals_and_lineage
###############################################################################