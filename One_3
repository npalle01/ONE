#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: advanced_lineage.py

Enhancements:
  • parse_sql_dependencies(...) – unchanged SQL parser.
  • DecisionTableManager – same as before, for editing/running decision tables.
  • AdvancedLineageGraphView – now with:
      - Dynamic arrowheads (rule->rule or rule->table edges).
      - Interactive node dragging: user can move the rectangles/circles, and arrows update automatically.
      - A simplified Sugiyama-like layering algorithm for complex DAGs (avoids major overlaps, reduces crossing).
      - highlight_impact(...) to dim all nodes except BFS descendants of a changed rule.

Database Requirements:
  - BRM_RULES(RULE_ID, RULE_NAME, STATUS, APPROVAL_STATUS, PARENT_RULE_ID, RULE_SQL, CRITICAL_RULE, etc.)
  - BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, etc.)
  - DECISION_TABLES(DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY, etc.)
"""

import sys
import logging
import pyodbc
import sqlparse
from collections import defaultdict, deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QColor, QFont, QPen, QBrush
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTableWidget,
    QTableWidgetItem, QPushButton, QMessageBox, QInputDialog,
    QGraphicsView, QGraphicsScene, QGraphicsItem, QGraphicsRectItem,
    QGraphicsEllipseItem, QGraphicsLineItem, QGraphicsTextItem, QLabel, QPlainTextEdit
)

from core_foundation import logger, insert_audit_log

# =============================================================================
# 1. parse_sql_dependencies(...) – an SQL parsing utility
# =============================================================================
def parse_sql_dependencies(sql_text):
    """
    Parses an SQL statement using sqlparse to extract table references.
    Returns a dict with:
      "tables": list of (schema, table, alias, is_subquery)
    This is a simplified approach.
    """
    result = {"tables": []}
    statements = sqlparse.parse(sql_text)
    for stmt in statements:
        from_seen = False
        token_list = list(stmt.tokens)
        i = 0
        while i < len(token_list):
            tk = token_list[i]
            val_up = tk.value.upper() if tk.value else ""
            if val_up in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            elif from_seen:
                if tk.ttype is sqlparse.tokens.Keyword:
                    if val_up in ("WHERE","GROUP","ORDER","HAVING","UNION","INTERSECT"):
                        from_seen = False
                else:
                    if isinstance(tk, sqlparse.sql.Identifier):
                        sch = tk.get_parent_name()
                        tbl = tk.get_real_name()
                        alias = tk.get_alias()
                        result["tables"].append((sch, tbl, alias, False))
                    elif isinstance(tk, sqlparse.sql.IdentifierList):
                        for ident in tk.get_identifiers():
                            sch = ident.get_parent_name()
                            tbl = ident.get_real_name()
                            alias = ident.get_alias()
                            result["tables"].append((sch, tbl, alias, False))
            i += 1
    return result

# =============================================================================
# 2. DecisionTableManager – QDialog for decision tables
# =============================================================================
class DecisionTableManager(QDialog):
    """
    Displays, edits, deletes, runs Decision Tables from DECISION_TABLES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Decision Table Manager")
        self.resize(700, 500)
        self.init_ui()
        self.load_decision_tables()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0,4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","Table Name","Description","Decision Query"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_decision_table)
        btn_layout.addWidget(add_btn)

        edit_btn = QPushButton("Edit Decision Table")
        edit_btn.clicked.connect(self.edit_decision_table)
        btn_layout.addWidget(edit_btn)

        delete_btn = QPushButton("Delete Decision Table")
        delete_btn.clicked.connect(self.delete_decision_table)
        btn_layout.addWidget(delete_btn)

        run_btn = QPushButton("Run Decision Table")
        run_btn.clicked.connect(self.run_decision_table)
        btn_layout.addWidget(run_btn)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_decision_tables)
        btn_layout.addWidget(refresh_btn)

        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.result_log = QPlainTextEdit()
        self.result_log.setReadOnly(True)
        layout.addWidget(self.result_log)

        self.setLayout(layout)

    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                ridx = self.dt_table.rowCount()
                self.dt_table.insertRow(ridx)
                for col_i, val in enumerate(row):
                    self.dt_table.setItem(ridx, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading DT: {ex}")

    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        query, ok3 = QInputDialog.getMultiLineText(self, "Decision Query", "Enter SQL:")
        if not ok3 or not query.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION,DECISION_QUERY)
                VALUES(?,?,?)
            """,(name.strip(), desc.strip(), query.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision table created.")
            insert_audit_log(self.connection, "ADD_DT","DECISION_TABLES",None,
                             "User", None, {"table":name})
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def edit_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "Selection Error", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        cur_name = self.dt_table.item(row,1).text()
        cur_desc = self.dt_table.item(row,2).text()
        cur_query = self.dt_table.item(row,3).text()

        name, ok = QInputDialog.getText(self, "Edit Table Name", "New name:", text=cur_name)
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Edit Description", "New desc:", text=cur_desc)
        if not ok2:
            desc = cur_desc
        query, ok3 = QInputDialog.getMultiLineText(self, "Edit Query", "New SQL:", text=cur_query)
        if not ok3 or not query.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE DECISION_TABLES
                SET TABLE_NAME=?, DESCRIPTION=?, DECISION_QUERY=?
                WHERE DECISION_TABLE_ID=?
            """,(name.strip(), desc.strip(), query.strip(), dt_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Decision table updated.")
            insert_audit_log(self.connection, "EDIT_DT","DECISION_TABLES",dt_id,
                             "User", None, {"table":name})
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Update Error", str(ex))

    def delete_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "Selection Error", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete DT {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"DT {dt_id} deleted.")
            insert_audit_log(self.connection, "DELETE_DT","DECISION_TABLES", dt_id,
                             "User", None, {"deleted":True})
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

    def run_decision_table(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "Selection Error", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())

        c = self.connection.cursor()
        c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
        rowq = c.fetchone()
        if not rowq or not rowq[0]:
            QMessageBox.warning(self, "No Query", "No SQL found for this DT.")
            return
        query = rowq[0]
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute(query)
            try:
                rows = c.fetchall()
            except:
                rows = []
            impacted = len(rows)
            c.execute("ROLLBACK")
            msg = f"DT {dt_id} impacted {impacted} rows (dry-run)."
            self.result_log.appendPlainText(msg)
            QMessageBox.information(self, "Run Decision Table", msg)
            insert_audit_log(self.connection, "RUN_DT","DECISION_TABLES", dt_id,
                             "User", None, {"impacted":impacted})
        except Exception as ex:
            c.execute("ROLLBACK")
            err = f"Run error: {ex}"
            self.result_log.appendPlainText(err)
            QMessageBox.critical(self, "Run Error", err)

# =============================================================================
# 3. AdvancedLineageGraphView – with arrowheads, node dragging, advanced layering
# =============================================================================
class AdvancedLineageGraphView(QGraphicsView):
    """
    Renders a DAG of rules + tables with advanced layering (Sugiyama-like),
    arrowheads, and interactive node dragging. Also highlight_impact(...) BFS.
    """
    def __init__(self, connection, parent=None, auto_refresh_interval=45000):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.SmoothPixmapTransform)

        self.rule_nodes = {}  # rule_id -> BFSRuleNodeItem
        self.table_nodes = {} # (db, tbl) -> BFSTableNodeItem
        self.arrows = []      # store references to BFSArrowItem for updating

        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.populate_graph)
        self.refresh_timer.start(auto_refresh_interval)

        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.rule_nodes.clear()
        self.table_nodes.clear()
        self.arrows.clear()
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT RULE_ID, RULE_NAME, STATUS, APPROVAL_STATUS, PARENT_RULE_ID
                FROM BRM_RULES
            """)
            rule_rows = c.fetchall()

            # Build adjacency for rule->child
            children_map = defaultdict(list)
            rule_map = {}
            for (rid, rname, rstat, rappr, pid) in rule_rows:
                rule_map[rid] = (rname, rstat, rappr, pid)
                if pid:
                    children_map[pid].append(rid)

            # We'll do a topological or BFS approach to detect levels, 
            # but then apply a simple "Sugiyama-like" pass to minimize crossing

            # 1) Collect indegree
            indegree = defaultdict(int)
            for rid in rule_map.keys():
                indegree[rid] = 0
            for pid, clist in children_map.items():
                for child in clist:
                    indegree[child]+=1

            # 2) Kahn's algorithm for topological order
            topo_order = []
            queue = deque([r for r in rule_map.keys() if indegree[r]==0])
            while queue:
                node = queue.popleft()
                topo_order.append(node)
                for child in children_map[node]:
                    indegree[child]-=1
                    if indegree[child]==0:
                        queue.append(child)

            # If there's a cycle, some nodes won't be in topo_order. We'll just add them last
            for r in rule_map.keys():
                if r not in topo_order:
                    topo_order.append(r)

            # 3) Assign each node an initial "layer" = distance from roots
            layer_map = {}
            for r in topo_order:
                pid = rule_map[r][3]  # parent
                if not pid or pid not in rule_map:
                    layer_map[r] = 0
                else:
                    layer_map[r] = layer_map[pid]+1

            # 4) Group nodes by layer
            layer_groups = defaultdict(list)
            for r, layer in layer_map.items():
                layer_groups[layer].append(r)
            max_layer = max(layer_map.values()) if layer_map else 0

            # 5) Place nodes in vertical columns based on layer
            x_spacing = 220
            y_spacing = 100
            x_start = 50
            y_start = 50

            for layer in range(max_layer+1):
                nodes_in_layer = layer_groups[layer]
                for i, rid in enumerate(nodes_in_layer):
                    rname, rstat, rappr, pid = rule_map[rid]
                    node_item = BFSRuleNodeItem(rid, rname, rstat, rappr)
                    node_item.setPos(x_start + layer*x_spacing, y_start + i*y_spacing)
                    self.scene.addItem(node_item)
                    self.rule_nodes[rid] = node_item
                    # For node dragging: connect signals
                    node_item.position_changed.connect(self.update_arrows)

            # 6) Now place table nodes on a separate pseudo-layer on the far right
            # gather table deps
            c.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
            deps = c.fetchall()
            table_map = defaultdict(list)  # (db,tbl) -> [rule_ids]
            for (rid, db, tbl) in deps:
                db_low = db.lower() if db else "nodb"
                tbl_low = tbl.lower() if tbl else "notable"
                table_map[(db_low, tbl_low)].append(rid)
            # place them in a single column after max_layer
            table_x = x_start + (max_layer+1)*x_spacing + 200
            idx_tbl = 0
            for key, rid_list in table_map.items():
                db, tbl = key
                node_item = BFSTableNodeItem(db, tbl)
                y_pos = y_start + idx_tbl*y_spacing
                node_item.setPos(table_x, y_pos)
                self.scene.addItem(node_item)
                self.table_nodes[key] = node_item
                idx_tbl+=1
                node_item.position_changed.connect(self.update_arrows)

            # 7) Draw arrow edges
            # 7a) rule->child
            for pid, clist in children_map.items():
                source_item = self.rule_nodes.get(pid)
                if source_item:
                    for child in clist:
                        target_item = self.rule_nodes.get(child)
                        if target_item:
                            arrow = BFSArrowItem(source_item, target_item, Qt.darkGray)
                            self.arrows.append(arrow)
                            self.scene.addItem(arrow)

            # 7b) rule->table
            for (db_low, tbl_low), rid_list in table_map.items():
                tbl_item = self.table_nodes.get((db_low,tbl_low))
                if tbl_item:
                    for rid in rid_list:
                        if rid in self.rule_nodes:
                            rule_item = self.rule_nodes[rid]
                            arrow = BFSArrowItem(rule_item, tbl_item, Qt.darkBlue)
                            self.arrows.append(arrow)
                            self.scene.addItem(arrow)

            self.resetView()
        except Exception as ex:
            logger.error(f"populate_graph error: {ex}")
            QMessageBox.critical(self, "Lineage Error", str(ex))

    def resetView(self):
        self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)

    def highlight_impact(self, changed_rule_id):
        """
        BFS to find all descendants of changed_rule_id. 
        We'll dim others, highlight these in full opacity.
        """
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
            rows = c.fetchall()
            children_map = defaultdict(list)
            for (rid, pid) in rows:
                if pid:
                    children_map[pid].append(rid)

            impacted = []
            visited = set()
            stack = [changed_rule_id]
            while stack:
                current = stack.pop()
                if current in visited:
                    continue
                visited.add(current)
                impacted.append(current)
                for ch in children_map[current] if current in children_map else []:
                    stack.append(ch)

            # dim all
            for rn in self.rule_nodes.values():
                rn.setOpacity(0.3)
            # highlight impacted
            for rid in impacted:
                if rid in self.rule_nodes:
                    self.rule_nodes[rid].setOpacity(1.0)

            msg = f"Rule {changed_rule_id} changes affect: {impacted}"
            QMessageBox.information(self, "Impact Analysis", msg)
            logger.info(msg)
        except Exception as ex:
            logger.error(f"highlight_impact error: {ex}")
            QMessageBox.critical(self, "Impact Error", str(ex))

    def update_arrows(self):
        """
        Called whenever a node is moved (interactive dragging).
        We recalc arrow positions for all BFSArrowItems.
        """
        for arrow in self.arrows:
            arrow.update_position()

# -----------------------------------------------------------------------------
# Graphics Item Classes with Node Dragging and Arrowheads
# -----------------------------------------------------------------------------
class BFSRuleNodeItem(QGraphicsRectItem):
    """
    A rectangle representing a rule node, with node dragging capability.
    """
    position_changed = QtCore.pyqtSignal()  # custom signal

    def __init__(self, rule_id, rule_name, status, approval_status):
        super().__init__(0,0,180,60)
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.status = status
        self.approval_status = approval_status
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable)

        if status.upper()=="ACTIVE":
            fill_color = QColor("#C8E6C9")
        elif status.upper()=="INACTIVE":
            fill_color = QColor("#FFCDD2")
        else:
            fill_color = QColor("#FFF9C4")

        self.setBrush(QBrush(fill_color))
        self.setPen(QPen(Qt.black,2))

        text_str = f"{rule_name}\n(Rule {rule_id})"
        text_item = QGraphicsTextItem(text_str, self)
        font = QFont("Arial",9)
        text_item.setFont(font)
        br = text_item.boundingRect()
        rw, rh = self.rect().width(), self.rect().height()
        text_item.setPos((rw-br.width())/2, (rh-br.height())/2)

        tip = f"Rule {rule_id}\nStatus: {status}\nApproval: {approval_status}"
        self.setToolTip(tip)

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange:
            # whenever position changes, emit signal so arrows can update
            self.position_changed.emit()
        return super().itemChange(change, value)

class BFSTableNodeItem(QGraphicsEllipseItem):
    """
    A circle representing a table node, with drag support.
    """
    position_changed = QtCore.pyqtSignal()

    def __init__(self, db_name, tbl_name):
        super().__init__(0,0,80,80)
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable)

        self.setBrush(QBrush(QColor("#BBDEFB")))
        self.setPen(QPen(Qt.darkBlue,2))

        lbl = f"{db_name}.{tbl_name}"
        text_item = QGraphicsTextItem(lbl, self)
        text_item.setFont(QFont("Arial",8))
        br = text_item.boundingRect()
        w, h = self.rect().width(), self.rect().height()
        text_item.setPos((w-br.width())/2, (h-br.height())/2)

        self.setToolTip(f"Table: {db_name}.{tbl_name}")

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange:
            self.position_changed.emit()
        return super().itemChange(change, value)

class BFSArrowItem(QGraphicsLineItem):
    """
    An arrow from a BFSRuleNodeItem or BFSTableNodeItem to another. 
    Includes an arrowhead drawn dynamically.
    """
    def __init__(self, source_item, target_item, color=Qt.darkGray):
        super().__init__()
        self.source_item = source_item
        self.target_item = target_item
        self.color = color
        self.setPen(QPen(self.color,2))
        self.update_position()

    def update_position(self):
        sr = self.source_item.sceneBoundingRect().center()
        tr = self.target_item.sceneBoundingRect().center()
        self.setLine(sr.x(), sr.y(), tr.x(), tr.y())

    def paint(self, painter, option, widget=None):
        # update line first
        self.update_position()
        super().paint(painter, option, widget)

        # draw arrowhead at end
        line = self.line()
        angle = line.angle()  # in degrees
        # Convert to radians
        angle_rads = (360 - angle) * 3.14159 / 180.0
        arrow_size = 10
        # endpoints
        end_point = line.p2()
        # two side points for arrow
        p1 = QtCore.QPointF(
            end_point.x() + arrow_size * -1 * QtCore.qCos(angle_rads + 0.3),
            end_point.y() + arrow_size * -1 * QtCore.qSin(angle_rads + 0.3)
        )
        p2 = QtCore.QPointF(
            end_point.x() + arrow_size * -1 * QtCore.qCos(angle_rads - 0.3),
            end_point.y() + arrow_size * -1 * QtCore.qSin(angle_rads - 0.3)
        )

        arrow_head = QtGui.QPolygonF([end_point, p1, p2])
        painter.setBrush(QtGui.QBrush(self.color))
        painter.drawPolygon(arrow_head)

# end of file