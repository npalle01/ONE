#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM Full Aggregator – Single File Demo
Implements all requested features and optional enhancements.

IMPORTANT:
 - This code references hypothetical table structures (USERS, RULES, etc.) 
 - Replace stubs (like BFS placeholders, parse_sql_dependencies, etc.) 
   with your actual logic or reuse from earlier modules.

Usage:
  python brm_full_aggregator.py
"""

import sys
import os
import logging
import pyodbc
import csv
import json
from datetime import datetime, timedelta

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime, QDate
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QTabWidget,
    QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton, QLineEdit,
    QComboBox, QPlainTextEdit, QMessageBox, QTableWidget, QTableWidgetItem,
    QCalendarWidget, QTimeEdit, QCheckBox, QRadioButton, QGroupBox,
    QTreeWidget, QTreeWidgetItem, QListWidget, QListWidgetItem,
    QSplitter, QMenu, QInputDialog, QDialogButtonBox, QFileDialog
)

##############################################
# 1) DatabaseConnectionDialog
##############################################
class DatabaseConnectionDialog(QDialog):
    """
    Prompts user for ODBC DSN or custom conn string => sets self.connection if success.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection=None
        self.setWindowTitle("DB Connection – Full Aggregator")
        self.resize(400,200)

        main_layout=QVBoxLayout(self)

        main_layout.addWidget(QLabel("Select ODBC DSN or provide custom ODBC connection string:"))
        self.dsn_combo=QComboBox()
        try:
            dsn_dict=pyodbc.dataSources()
            for dsn_name,driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"{dsn_name}",dsn_name)
        except Exception as ex:
            print(f"DSN listing error: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit=QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h=QHBoxLayout()
        okb=QPushButton("Connect")
        okb.clicked.connect(self.accept)
        cb=QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        btn_h.addWidget(okb)
        btn_h.addWidget(cb)
        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)

    def get_connection(self):
        d_=self.conn_str_edit.text().strip()
        if d_:
            conn_str=d_
        else:
            ds=self.dsn_combo.currentData()
            if not ds:
                QMessageBox.critical(self,"Error","No DSN or custom string provided.")
                return None
            conn_str=f"DSN={ds};Trusted_Connection=yes;"
        try:
            conn=pyodbc.connect(conn_str)
            return conn
        except Exception as ex:
            QMessageBox.critical(self,"Connection Error",str(ex))
            return None

    def accept(self):
        test=self.get_connection()
        if test:
            self.connection=test
            super().accept()

##############################################
# 2) LoginDialog
##############################################
class LoginDialog(QDialog):
    """
    Minimal user/password => check USERS table => sets user_id, user_group.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=None
        self.user_group=None
        self.setWindowTitle("Login - Full Aggregator")
        self.resize(300,150)

        ml=QVBoxLayout(self)
        self.user_edit=QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        ml.addWidget(QLabel("Username:"))
        ml.addWidget(self.user_edit)

        self.pass_edit=QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        ml.addWidget(QLabel("Password:"))
        ml.addWidget(self.pass_edit)

        lb=QPushButton("Login")
        lb.clicked.connect(self.do_login)
        ml.addWidget(lb)

        self.setLayout(ml)

    def do_login(self):
        un=self.user_edit.text().strip()
        pw=self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self,"Error","Enter username + password.")
            return
        c=self.connection.cursor()
        # Checking simple:
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(un,pw))
        row=c.fetchone()
        if row:
            self.user_id=row[0]
            self.user_group=row[1]
            self.accept()
        else:
            QMessageBox.warning(self,"Invalid","Bad credentials.")

##############################################
# UTILITY: sync_metadata_improved stub
##############################################
def sync_metadata_improved(conn):
    """
    A stub or partial example: Mark missing tables in BRM_RULE_TABLE_DEPENDENCIES with 'MISSING_' prefix.
    """
    c=conn.cursor()
    try:
        c.execute("SELECT s.name,t.name FROM sys.tables t JOIN sys.schemas s on t.schema_id=s.schema_id")
        actual=set()
        for row in c.fetchall():
            fulln=(f"{row[0]}.{row[1]}").lower()
            actual.add(fulln)

        c.execute("SELECT DEPENDENCY_ID,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
        rows=c.fetchall()
        missing_ct=0
        for (depid,tbl) in rows:
            if not tbl:
                continue
            low=tbl.lower()
            if "." not in low:
                low=f"dbo.{low}"
            if low not in actual:
                c2=conn.cursor()
                c2.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET TABLE_NAME='MISSING_'+TABLE_NAME WHERE DEPENDENCY_ID=?",(depid,))
                missing_ct+=1
        conn.commit()
        return f"Metadata sync done. Marked {missing_ct} references as missing."
    except Exception as ex:
        return f"Sync error: {ex}"

##############################################
# 3) Placeholders for BFS, etc.
##############################################
def simulate_chain_bfs(rule_id):
    """
    BFS stub => returns "Executed [rule_id]" => no real logic
    """
    return ([rule_id],[ ])  # executed, skipped

def simulate_group_bfs(group_id):
    """
    BFS for custom group => returns pass, fail => stub
    """
    return ([10,20],[30])  # pass: 10,20; fail: 30

##############################################
# 4) Main tabs / components
##############################################

### 4.1 Dashboard Tab
class DashboardTab(QWidget):
    """
    Show metric 'cards' or placeholders. We add radio buttons or toggles for quick context if needed.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        ml=QVBoxLayout(self)

        # top label or summary
        ml.addWidget(QLabel("Dashboard - quick metrics or card placeholders."))

        # Example: 4 or 5 'cards' in a horizontal layout
        row_h=QHBoxLayout()
        self.card_active=QPushButton("Active Rules: (Click for details)")
        self.card_active.clicked.connect(self.show_active_details)
        row_h.addWidget(self.card_active)

        self.card_approvals=QPushButton("Approvals Pending: ...")
        self.card_approvals.clicked.connect(self.show_approvals_details)
        row_h.addWidget(self.card_approvals)

        self.card_defects=QPushButton("Open Defects: ...")
        self.card_defects.clicked.connect(self.show_defects_details)
        row_h.addWidget(self.card_defects)

        ml.addLayout(row_h)

        # add more if needed
        # refresh button
        refb=QPushButton("Refresh Metrics")
        refb.clicked.connect(self.load_metrics)
        ml.addWidget(refb)

        self.setLayout(ml)
        self.load_metrics()

    def load_metrics(self):
        """
        Example: we do simple queries or stubs
        """
        c=self.connection.cursor()
        # Active rules
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE STATUS='ACTIVE'")
            row=c.fetchone()
            act_ct=row[0] if row else 0
            self.card_active.setText(f"Active Rules: {act_ct}")
        except:
            self.card_active.setText("Active Rules: N/A")

        # approvals
        try:
            c.execute("""
            SELECT COUNT(DISTINCT RULE_ID)
            FROM BRM_RULE_APPROVALS
            WHERE APPROVED_FLAG=0
            """)
            row2=c.fetchone()
            app_ct=row2[0] if row2 else 0
            self.card_approvals.setText(f"Approvals Pending: {app_ct}")
        except:
            self.card_approvals.setText("Approvals Pending: N/A")

        # defects
        try:
            c.execute("""
            SELECT COUNT(*)
            FROM BRM_DEFECT_LOGS
            WHERE STATUS IN ('Open','In Progress')
            """)
            row3=c.fetchone()
            def_ct=row3[0] if row3 else 0
            self.card_defects.setText(f"Open Defects: {def_ct}")
        except:
            self.card_defects.setText("Open Defects: N/A")

    def show_active_details(self):
        QMessageBox.information(self,"Active Rules","Would jump to Business Rules tab filtered by ACTIVE.")

    def show_approvals_details(self):
        QMessageBox.information(self,"Approvals","Jump to Approvals tab or do a direct filter if needed.")

    def show_defects_details(self):
        QMessageBox.information(self,"Defects","Jump to Defect Management tab or filter there.")


### 4.2 Business Rules Tab
class BusinessRulesTab(QWidget):
    """
    With BFS simulation, radio buttons for CRUD, and on operation -> open a wizard dialog if needed.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        ml=QVBoxLayout(self)

        # Radio group
        op_group=QGroupBox("Rule Operations:")
        op_h=QHBoxLayout(op_group)
        self.radio_create=QRadioButton("Create")
        self.radio_update=QRadioButton("Update")
        self.radio_deactivate=QRadioButton("Deactivate")
        self.radio_delete=QRadioButton("Delete")
        op_h.addWidget(self.radio_create)
        op_h.addWidget(self.radio_update)
        op_h.addWidget(self.radio_deactivate)
        op_h.addWidget(self.radio_delete)

        # BFS button
        self.bfs_btn=QPushButton("BFS Simulation")
        self.bfs_btn.clicked.connect(self.do_bfs_sim)
        op_h.addWidget(self.bfs_btn)
        op_group.setLayout(op_h)

        ml.addWidget(op_group)

        # table
        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","OwnerGroup"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        # bottom buttons
        bh=QHBoxLayout()
        self.perform_btn=QPushButton("Perform Operation")
        self.perform_btn.clicked.connect(self.perform_operation)
        bh.addWidget(self.perform_btn)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_rules)
        bh.addWidget(refb)

        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.load_rules()

    def load_rules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP
        FROM BRM_RULES
        ORDER BY RULE_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)

    def get_selected_rule_id(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        return int(it.text()) if it else None

    def perform_operation(self):
        rid=self.get_selected_rule_id()
        if not rid:
            QMessageBox.warning(self,"No selection","Pick a rule row first.")
            return
        if self.radio_create.isChecked():
            self.open_create_wizard()
        elif self.radio_update.isChecked():
            self.open_update_wizard(rid)
        elif self.radio_deactivate.isChecked():
            self.deactivate_rule(rid)
        elif self.radio_delete.isChecked():
            self.delete_rule(rid)
        else:
            QMessageBox.information(self,"No Option","Select an operation via radio button.")

    def open_create_wizard(self):
        QMessageBox.information(self,"Create Wizard","Open a custom dialog for new rule creation...")

    def open_update_wizard(self, rule_id):
        QMessageBox.information(self,"Update Wizard",f"Open a dialog to update rule {rule_id}...")

    def deactivate_rule(self, rule_id):
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE', APPROVAL_STATUS='INACTIVE'
        WHERE RULE_ID=?
        """,(rule_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deactivated",f"Rule {rule_id} => Inactive.")
        self.load_rules()

    def delete_rule(self, rule_id):
        confirm=QMessageBox.question(self,"Confirm",f"Delete rule {rule_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Rule {rule_id} removed.")
        self.load_rules()

    def do_bfs_sim(self):
        rid=self.get_selected_rule_id()
        if not rid:
            QMessageBox.warning(self,"None","Select a rule to BFS simulate.")
            return
        executed,skipped=simulate_chain_bfs(rid)
        msg=(
            f"BFS from rule {rid}\n"
            f"Executed => {executed}\n"
            f"Skipped => {skipped}\n"
        )
        QMessageBox.information(self,"BFS Sim",msg)


### 4.3 Approvals Tab
class ApprovalsTab(QWidget):
    """
    A direct usage: multi-step approvals
    (But we have the MultiStepApprovalTab – we'll rename to avoid confusion.)
    We'll just adapt from the final approach
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        ml=QVBoxLayout(self)

        self.table=QTableWidget(0,9)
        self.table.setHorizontalHeaderLabels(["RuleID","GroupName","RuleName","Stage","Approved?","Approve","Reject","LockStatus","ForceUnlock"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        refb=QPushButton("Refresh Approvals")
        refb.clicked.connect(self.load_approvals)
        ml.addWidget(refb)

        self.setLayout(ml)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE,
               A.APPROVED_FLAG, R.LOCK_STATUS, R.LOCKED_BY
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()

        def get_current_stage(rid):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid,))
            ro=c2.fetchone()
            return ro[0] if ro else None

        filtered=[]
        for row_ in rows:
            rid,grp,rn,st,apflag,lockstat,locked_by=row_
            cs=get_current_stage(rid)
            if cs==st:
                filtered.append((rid,grp,rn,st,apflag,lockstat,locked_by))

        self.table.setRowCount(len(filtered))
        for i, row_ in enumerate(filtered):
            rid,grp,rn,st,apflag,lockstat,locked_by=row_
            self.table.setItem(i,0,QTableWidgetItem(str(rid)))
            self.table.setItem(i,1,QTableWidgetItem(str(grp)))
            self.table.setItem(i,2,QTableWidgetItem(str(rn)))
            self.table.setItem(i,3,QTableWidgetItem(str(st)))
            self.table.setItem(i,4,QTableWidgetItem(str(apflag)))

            app_btn=QPushButton("Approve")
            app_btn.clicked.connect(lambda _, idx=i: self.do_approve(idx))
            self.table.setCellWidget(i,5,app_btn)

            rej_btn=QPushButton("Reject")
            rej_btn.clicked.connect(lambda _, idx=i: self.do_reject(idx))
            self.table.setCellWidget(i,6,rej_btn)

            ls_txt="UNLOCKED" if not lockstat else f"LOCKED by {locked_by}"
            self.table.setItem(i,7,QTableWidgetItem(ls_txt))

            fu_btn=QPushButton("ForceUnlock")
            fu_btn.setEnabled(self.user_group=="Admin")
            fu_btn.clicked.connect(lambda _, idx=i: self.do_forceunlock(idx))
            self.table.setCellWidget(i,8,fu_btn)

    def do_approve(self, row_i):
        rid=int(self.table.item(row_i,0).text())
        grp=self.table.item(row_i,1).text()
        c=self.connection.cursor()
        # Approve
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))

        # check if all done
        def min_stage(ruleid):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(ruleid,))
            ro=c2.fetchone()
            return ro[0] if ro else None

        nxt=min_stage(rid)
        if nxt is None:
            # finalize
            c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE'
            WHERE RULE_ID=?
            """,(rid,))
        else:
            c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS',STATUS='INACTIVE'
            WHERE RULE_ID=?
            """,(rid,))
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} => approved for stage.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid=int(self.table.item(row_i,0).text())
        grp=self.table.item(row_i,1).text()
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))
        c.execute("""
        UPDATE BRM_RULES
        SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE'
        WHERE RULE_ID=?
        """,(rid,))
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} => Rejected.")
        self.load_approvals()

    def do_forceunlock(self, row_i):
        if self.user_group!="Admin":
            return
        rid=int(self.table.item(row_i,0).text())
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rid,))
        self.connection.commit()
        QMessageBox.information(self,"Forced","Unlocked rule.")
        self.load_approvals()


### 4.4 Scheduling Tab
class SchedulingTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)

        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["SchedID","RuleID","SchedTime","Status","RunVal?","Actions"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_schedules)
        bh.addWidget(refb)

        addb=QPushButton("Add Schedule")
        addb.clicked.connect(self.add_schedule)
        bh.addWidget(addb)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS,RUN_DATA_VALIDATIONS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(5):
                it=QTableWidgetItem(str(row[col_i]) if row[col_i] else "")
                self.table.setItem(r_i,col_i,it)
            # actions
            w=QWidget()
            hl=QHBoxLayout(w)
            hl.setContentsMargins(0,0,0,0)
            modb=QPushButton("Modify")
            modb.clicked.connect(lambda _, idx=r_i: self.modify_schedule(idx))
            hl.addWidget(modb)

            delb=QPushButton("Delete")
            delb.clicked.connect(lambda _, idx=r_i: self.delete_schedule(idx))
            hl.addWidget(delb)
            hl.addStretch()
            self.table.setCellWidget(r_i,5,w)

    def add_schedule(self):
        dlg=AddScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def modify_schedule(self, row_i):
        sid_item=self.table.item(row_i,0)
        if not sid_item:
            return
        sid=int(sid_item.text())
        newdt,ok=QInputDialog.getText(self,"Modify","New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not newdt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(newdt.strip(),sid))
            self.connection.commit()
            QMessageBox.information(self,"Modified",f"Sched {sid} => {newdt}")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, row_i):
        sid_item=self.table.item(row_i,0)
        if not sid_item:
            return
        sid=int(sid_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Sched {sid} removed.")
        self.load_schedules()

class AddScheduleDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Add Schedule")
        self.resize(400,300)
        ml=QVBoxLayout(self)

        form=QFormLayout()
        self.rule_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            self.rule_combo.addItem(f"{rid}-{rn}",rid)
        form.addRow("Rule:",self.rule_combo)

        self.cal=QCalendarWidget()
        form.addRow("Date:",self.cal)
        self.time_edit=QTimeEdit()
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Time:",self.time_edit)

        self.run_val_cb=QCheckBox("Run Data Validations?")
        form.addRow(self.run_val_cb)

        ml.addLayout(form)

        bh=QHBoxLayout()
        addb=QPushButton("Add")
        addb.clicked.connect(self.do_add)
        bh.addWidget(addb)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)

    def do_add(self):
        rid=self.rule_combo.currentData()
        dt_str=f"{self.cal.selectedDate().toString('yyyy-MM-dd')} {self.time_edit.time().toString('HH:mm:ss')}"
        runv=1 if self.run_val_cb.isChecked() else 0
        c=self.connection.cursor()
        try:
            c.execute("""
            INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP,RUN_DATA_VALIDATIONS)
            VALUES(?,?,'Scheduled',GETDATE(),?)
            """,(rid, dt_str, runv))
            self.connection.commit()
            QMessageBox.information(self,"Scheduled",f"Rule {rid} => {dt_str}, validations={runv}")
            self.close()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

### 4.5 Defect Management
class DefectManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)

        # radio group
        op_box=QGroupBox("Defect Operations:")
        op_h=QHBoxLayout(op_box)
        self.radio_create=QRadioButton("Create")
        self.radio_update=QRadioButton("Update")
        self.radio_resolve=QRadioButton("Resolve/Close")
        self.radio_delete=QRadioButton("Delete")
        op_h.addWidget(self.radio_create)
        op_h.addWidget(self.radio_update)
        op_h.addWidget(self.radio_resolve)
        op_h.addWidget(self.radio_delete)
        op_box.setLayout(op_h)
        ml.addWidget(op_box)

        self.table=QTableWidget(0,7)
        self.table.setHorizontalHeaderLabels(["DefectID","RuleID","Description","Severity","Reporter","Status","Resolution"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        self.op_btn=QPushButton("Perform Operation")
        self.op_btn.clicked.connect(self.perform_op)
        bh.addWidget(self.op_btn)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_defects)
        bh.addWidget(refb)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.load_defects()

    def load_defects(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT DEFECT_ID,RULE_ID,DESCRIPTION,SEVERITY,REPORTER,STATUS,RESOLUTION
        FROM BRM_DEFECT_LOGS
        ORDER BY DEFECT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_sel_defect_id(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def perform_op(self):
        did=self.get_sel_defect_id()
        if not did:
            QMessageBox.warning(self,"None","No defect selected.")
            return
        if self.radio_create.isChecked():
            self.open_create_defect_wizard()
        elif self.radio_update.isChecked():
            self.update_defect(did)
        elif self.radio_resolve.isChecked():
            self.resolve_defect(did)
        elif self.radio_delete.isChecked():
            self.delete_defect(did)
        else:
            QMessageBox.information(self,"No Option","Pick an operation via radio button.")

    def open_create_defect_wizard(self):
        QMessageBox.information(self,"Create Defect","Open a wizard or dialog to fill out new defect details...")

    def update_defect(self, defect_id):
        QMessageBox.information(self,"Update Defect",f"Open a dialog to update defect {defect_id}...")

    def resolve_defect(self, defect_id):
        confirm=QMessageBox.question(self,"Resolve",f"Mark defect {defect_id} as resolved/closed?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_DEFECT_LOGS
        SET STATUS='Resolved',RESOLUTION='Manually closed',TIMESTAMP=GETDATE()
        WHERE DEFECT_ID=?
        """,(defect_id,))
        self.connection.commit()
        QMessageBox.information(self,"Resolved",f"Defect {defect_id} => Resolved.")
        self.load_defects()

    def delete_defect(self, defect_id):
        confirm=QMessageBox.question(self,"Confirm",f"Delete defect {defect_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?",(defect_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Defect {defect_id} removed.")
        self.load_defects()

### 4.6 Metrics Tab
class MetricsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)

        ml.addWidget(QLabel("pyqtgraph or placeholders for performance metrics, usage stats, etc."))
        # Could place 2 or 3 charts here. We'll do placeholders for demonstration.
        # e.g. self.chart1=pg.PlotWidget() ...
        # or we do a layout of graphs.

        refresh_btn=QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        ml.addWidget(refresh_btn)

        self.setLayout(ml)

    def load_metrics(self):
        QMessageBox.information(self,"Metrics","Would query RULE_EXECUTION_LOGS or RULE_PERF_STATS, update charts.")


### 4.7 Composite Rule Tab
class CompositeRuleTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)

        # radio
        op_box=QGroupBox("Composite Ops:")
        op_h=QHBoxLayout(op_box)
        self.rb_create=QRadioButton("Create")
        self.rb_update=QRadioButton("Update")
        self.rb_delete=QRadioButton("Delete")
        self.rb_run=QRadioButton("Run BFS")
        op_h.addWidget(self.rb_create)
        op_h.addWidget(self.rb_update)
        op_h.addWidget(self.rb_delete)
        op_h.addWidget(self.rb_run)
        op_box.setLayout(op_h)
        ml.addWidget(op_box)

        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["CompRuleID","Name","LogicExpr","ActionOnPass"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        self.do_op_btn=QPushButton("Perform Operation")
        self.do_op_btn.clicked.connect(self.perform_op)
        bh.addWidget(self.do_op_btn)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_composites)
        bh.addWidget(refb)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.load_composites()

    def load_composites(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS
        FROM COMPOSITE_RULES
        ORDER BY COMPOSITE_RULE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_sel_composite_id(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        return int(it.text()) if it else None

    def perform_op(self):
        cid=self.get_sel_composite_id()
        if not cid:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        if self.rb_create.isChecked():
            QMessageBox.information(self,"Create Composite","Open wizard for new composite rule creation.")
        elif self.rb_update.isChecked():
            QMessageBox.information(self,"Update Composite",f"Open update dialog for composite {cid}")
        elif self.rb_delete.isChecked():
            confirm=QMessageBox.question(self,"Confirm",f"Delete composite {cid}?")
            if confirm!=QMessageBox.Yes:
                return
            c=self.connection.cursor()
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
            self.connection.commit()
            QMessageBox.information(self,"Removed",f"Composite {cid} deleted.")
            self.load_composites()
        elif self.rb_run.isChecked():
            QMessageBox.information(self,"Run BFS",f"Stub BFS for composite {cid}")
        else:
            QMessageBox.information(self,"No Option","Pick a radio button.")


### 4.8 Hierarchy Tab
class HierarchyTab(QTreeWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule Hierarchy"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        # example: group list
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        groups=c.fetchall()
        group_nodes={}
        for (gid,gname) in groups:
            it=QTreeWidgetItem([f"{gname} (ID={gid})"])
            it.setData(0,Qt.UserRole,("group",gid))
            self.addTopLevelItem(it)
            group_nodes[gid]=it

        # load rules
        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rules=c.fetchall()
        rule_map={}
        for (rid,rn,gid,pid) in rules:
            rule_map[rid]=(rn,gid,pid)

        # top-level
        for rid,(rn,gid,pid) in rule_map.items():
            if not pid:  # no parent
                if gid in group_nodes:
                    parent_it=group_nodes[gid]
                    child=QTreeWidgetItem([f"Rule {rid}:{rn}"])
                    child.setData(0,Qt.UserRole,("rule",rid))
                    parent_it.addChild(child)
        # second pass => child rules
        for rid,(rn,gid,pid) in rule_map.items():
            if pid and pid in rule_map:
                par_node=self.find_node_for_rule(pid)
                if par_node:
                    child=QTreeWidgetItem([f"Rule {rid}:{rn}"])
                    child.setData(0,Qt.UserRole,("rule",rid))
                    par_node.addChild(child)

        self.expandAll()

    def find_node_for_rule(self, rule_id):
        stack=[]
        for i in range(self.topLevelItemCount()):
            stack.append(self.topLevelItem(i))
        while stack:
            node=stack.pop()
            d=node.data(0,Qt.UserRole)
            if d and d[0]=="rule" and d[1]==rule_id:
                return node
            for j in range(node.childCount()):
                stack.append(node.child(j))
        return None

    def dropEvent(self, event):
        super().dropEvent(event)
        # after reorder => update DB
        self.update_db_reparenting()
        self.load_hierarchy()

    def update_db_reparenting(self):
        c=self.connection.cursor()
        for i in range(self.topLevelItemCount()):
            group_item=self.topLevelItem(i)
            gd=group_item.data(0,Qt.UserRole)
            if gd and gd[0]=="group":
                grp_id=gd[1]
                for j in range(group_item.childCount()):
                    child=group_item.child(j)
                    self.recursive_update(child,None,grp_id,c)
        c.commit()

    def recursive_update(self, item, parent_rule_id, group_id, cursor):
        d_=item.data(0,Qt.UserRole)
        if d_ and d_[0]=="rule":
            rid=d_[1]
            # set group_id + parent
            cursor.execute("""
            UPDATE BRM_RULES
            SET GROUP_ID=?,PARENT_RULE_ID=?,STATUS='INACTIVE',APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
            WHERE RULE_ID=?
            """,(group_id,parent_rule_id,rid))
            for i in range(item.childCount()):
                ch=item.child(i)
                self.recursive_update(ch, rid, group_id, cursor)


### 4.9 Custom Rule Groups Tab
class CustomRuleGroupsTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        ml=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("CreateGroup")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("RenameGroup")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("DeleteGroup")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("BackupGroup")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("RestoreGroup")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        ml.addLayout(top_h)

        splitter=QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        ml.addWidget(splitter)

        left_widget=QWidget()
        lw=QVBoxLayout(left_widget)
        self.group_tree=QTreeWidget()
        self.group_tree.setHeaderLabels(["CustomGroup / Rule"])
        self.group_tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        lw.addWidget(self.group_tree)
        left_widget.setLayout(lw)
        splitter.addWidget(left_widget)

        right_widget=QWidget()
        rw=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        rw.addWidget(self.rule_list)

        assign_btn=QPushButton("AssignSelectedRules")
        assign_btn.clicked.connect(self.assign_rules)
        rw.addWidget(assign_btn)

        right_widget.setLayout(rw)
        splitter.addWidget(right_widget)

        self.setLayout(ml)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.group_tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for (cgid,cgname,owner) in groups:
            disp=f"{cgname} (Owner={owner})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0,Qt.UserRole,cgid)
            self.group_tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT M.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE,R.OPERATION_TYPE,R.LOCKED_BY
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cgid,))
            assigned=c2.fetchall()
            for row_ in assigned:
                rid,rn,isg,iscrit,optype,lockedby=row_
                txt=f"Rule {rid}:{rn}"
                ch=QTreeWidgetItem([txt])
                ch.setData(0,Qt.UserRole,rid)
                # color
                if isg==1:
                    ch.setBackground(0,QBrush(QColor("#D5EEFF")))
                if iscrit==1:
                    ch.setBackground(0,QBrush(QColor("#FFD1D1")))
                if str(optype).upper()=="DECISION_TABLE":
                    ch.setBackground(0,QBrush(QColor("#FFFFCC")))
                if lockedby:
                    ch.setToolTip(0,f"Locked by {lockedby}")
                g_item.addChild(ch)
        self.group_tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        rows=c.fetchall()

        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned_set=set([r[0] for r in c2.fetchall()])

        for (rid,rn,og) in rows:
            if rid in assigned_set:
                continue
            disp=f"Rule {rid}:{rn} (Owner={og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.group_tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # it's a rule => remove
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                self.remove_rule(group_id,rule_id)

    def remove_rule(self, group_id, rule_id):
        c=self.connection.cursor()
        # check lock
        c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
        row=c.fetchone()
        locked_by=row[0] if row else None
        if locked_by and (locked_by!=f"User:{self.user_id}" and self.user_group!="Admin"):
            QMessageBox.warning(self,"Locked",f"Rule locked by {locked_by}, only admin can remove forcibly.")
            return
        if locked_by and self.user_group=="Admin":
            # force unlock
            c2=self.connection.cursor()
            c2.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rule_id,))
        c3=self.connection.cursor()
        try:
            c3.execute("""
            DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
            WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
            """,(group_id,rule_id))
            self.connection.commit()
            QMessageBox.information(self,"Removed",f"Rule {rule_id} from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def create_group(self):
        nm=self.new_group_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","No group name provided.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(nm,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{nm}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_group_item(self):
        sel=self.group_tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        pr=it.parent()
        if pr:
            it=pr
        g_id=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (g_id,disp)

    def rename_group(self):
        (gid,disp)=self.get_selected_group_item()
        if not gid:
            QMessageBox.warning(self,"None","No group selected in tree.")
            return
        newn,ok=QInputDialog.getText(self,"Rename",f"New name for {disp}:")
        if not ok or not newn.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(newn.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group {gid} => {newn}")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        (gid,disp)=self.get_selected_group_item()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group {gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        (gid,disp)=self.get_selected_group_item()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","Group not found.")
            return
        grpname=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[r[0] for r in c.fetchall()]
        backup_data={"group_name":grpname,"members":assigned}

        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        r2=c.fetchone()
        new_ver=r2[0] if r2 else 1
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        (gid,disp)=self.get_selected_group_item()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups for that group.")
            return
        items=[f"Version {r[0]} - {r[1]}" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore Backup","Pick version:",items,0,False)
        if not ok or not sel:
            return
        import re
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        ver=int(m.group(1))
        # find row with that version
        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Not Found","Backup not found.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            data=json.loads(backup_json)
            new_gname=data.get("group_name","RestoredGroup")
            members=data.get("members",[])
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_gname,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                # check lock etc
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))


### 4.10 Backup & Restore or Snapshots Tab
class SnapshotTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["SnapID","Name","CreatedBy","Timestamp","JSONPreview"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        takeb=QPushButton("Take Snapshot")
        takeb.clicked.connect(self.take_snapshot)
        bh.addWidget(takeb)

        rollb=QPushButton("Restore Snapshot")
        rollb.clicked.connect(self.restore_snapshot)
        bh.addWidget(rollb)

        delb=QPushButton("Delete Snapshot")
        delb.clicked.connect(self.delete_snapshot)
        bh.addWidget(delb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_snapshots)
        bh.addWidget(refb)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.load_snapshots()

    def load_snapshots(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                if col_i<4:
                    self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))
                else:
                    # JSON preview
                    js=str(val)[:50]+"..." if val else ""
                    self.table.setItem(r_i,col_i,QTableWidgetItem(js))

    def get_sel_snapshot_id(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        return int(it.text()) if it else None

    def take_snapshot(self):
        nm,ok=QInputDialog.getText(self,"Snapshot","Name:")
        if not ok or not nm.strip():
            return
        c=self.connection.cursor()
        # gather all rules => store as JSON
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        arr=[]
        for r_ in rows:
            arr.append(dict(zip(colnames,r_)))
        snap_json=json.dumps(arr,indent=2)

        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(nm.strip(),"SnapshotUser",snap_json))
        self.connection.commit()
        QMessageBox.information(self,"Snap","Created snapshot.")
        self.load_snapshots()

    def restore_snapshot(self):
        sid=self.get_sel_snapshot_id()
        if not sid:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Restore from snapshot {sid}? (Stub logic...)")
        if confirm!=QMessageBox.Yes:
            return
        QMessageBox.information(self,"Restore","Implementation depends on your domain => replace entire RULES table or partial?")

    def delete_snapshot(self):
        sid=self.get_sel_snapshot_id()
        if not sid:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Snapshot {sid} removed.")
        self.load_snapshots()

### 4.11 What-If Testing
class WhatIfTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.csv_path=None

        ml=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            self.rule_combo.addItem(f"{rid}-{rn}",rid)
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        up_btn=QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(up_btn)

        run_btn=QPushButton("Run Dry-Run")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)
        top_h.addStretch()
        ml.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        ml.addWidget(self.result_text)

        self.setLayout(ml)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if not path:
            return
        self.csv_path=path
        QMessageBox.information(self,"Uploaded",f"CSV {path} selected. Could be used in your rule logic as needed.")

    def run_test(self):
        rid=self.rule_combo.currentData()
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL,OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            self.result_text.setPlainText("Rule not found.")
            return
        (sql_text,op_type)=row
        # stub => do a transaction => row[0][0]==1 => pass
        c.execute("BEGIN TRANSACTION")
        pass_flag=True
        msg=""
        rec=0
        try:
            c.execute(sql_text)
            allrows=c.fetchall()
            rec=len(allrows)
            if allrows:
                val=allrows[0][0]
                pass_flag=(val==1)
                msg=f"Returned={val}"
            else:
                pass_flag=True
                msg="No rows => pass"
            c.execute("ROLLBACK")
        except Exception as ex:
            pass_flag=False
            msg=str(ex)
            c.execute("ROLLBACK")

        out=f"Rule {rid} => pass={pass_flag}, msg={msg}, rec={rec}\n"
        if self.csv_path:
            out+=f"Used CSV {self.csv_path} for advanced scenario? (Stub logic)\n"
        self.result_text.setPlainText(out)


### 4.12 Conflict Priority Management
class ConflictPriorityTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)

        # radio
        op_box=QGroupBox("Conflict Ops:")
        op_h=QHBoxLayout(op_box)
        self.rb_add=QRadioButton("Add Conflict")
        self.rb_priority=QRadioButton("Set Priority")
        self.rb_delete=QRadioButton("Delete Conflict")
        op_h.addWidget(self.rb_add)
        op_h.addWidget(self.rb_priority)
        op_h.addWidget(self.rb_delete)
        op_box.setLayout(op_h)
        ml.addWidget(op_box)

        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        self.op_btn=QPushButton("Perform Operation")
        self.op_btn.clicked.connect(self.perform_op)
        bh.addWidget(self.op_btn)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_conflicts)
        bh.addWidget(refb)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.load_conflicts()

    def load_conflicts(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY
        FROM RULE_CONFLICTS
        ORDER BY CONFLICT_ID
        """)
        rows=c.fetchall()
        for row_ in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row_):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_sel_conflict_id(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        return int(it.text()) if it else None

    def perform_op(self):
        cfid=self.get_sel_conflict_id()
        if self.rb_add.isChecked():
            self.add_conflict()
        elif self.rb_priority.isChecked():
            if not cfid:
                QMessageBox.warning(self,"None","Select a conflict row.")
                return
            self.set_priority(cfid)
        elif self.rb_delete.isChecked():
            if not cfid:
                QMessageBox.warning(self,"None","Select a conflict row.")
                return
            self.del_conflict(cfid)
        else:
            QMessageBox.information(self,"No Option","Pick a radio button.")

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule1 ID:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule2 ID:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Integer priority:")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY)
        VALUES(?,?,?)
        """,(r1,r2,pri))
        self.connection.commit()
        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self, cfid):
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cfid}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cfid))
        self.connection.commit()
        QMessageBox.information(self,"PrioritySet",f"Conflict {cfid} => {newp}")
        self.load_conflicts()

    def del_conflict(self, cfid):
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cfid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cfid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Conflict {cfid} removed.")
        self.load_conflicts()

### 4.13 Collaboration Tab
class CollaborationManager(QtCore.QObject):
    locks_updated=QtCore.pyqtSignal(list)
    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.timer=QTimer(self)
        self.timer.timeout.connect(self.poll_locks)
        self.timer.start(poll_ms)

    def poll_locks(self):
        c=self.connection.cursor()
        try:
            c.execute("""
            SELECT RULE_ID,LOCKED_BY,LOCK_TIMESTAMP,EXPIRY_TIMESTAMP,FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE ACTIVE_LOCK=1
            """)
            rows=c.fetchall()
            lock_list=[]
            for row_ in rows:
                lock_list.append((row_[0],row_[1],row_[2],row_[3],row_[4]))
            self.locks_updated.emit(lock_list)
        except Exception as ex:
            print(f"Collab poll error: {ex}")

class CollaborationTab(QWidget):
    def __init__(self, connection, collab_manager, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.collab_manager=collab_manager
        ml=QVBoxLayout(self)
        ml.addWidget(QLabel("Live Collaboration / Locks"))
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["RuleID","LockedBy","LockTime","Expiry","ForceLock?"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        fub=QPushButton("Force Unlock Selected")
        fub.clicked.connect(self.do_force_unlock)
        bh.addWidget(fub)
        bh.addStretch()
        ml.addLayout(bh)

        self.setLayout(ml)
        self.collab_manager.locks_updated.connect(self.update_table)

    def update_table(self, lock_list):
        self.table.setRowCount(0)
        for row_ in lock_list:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row_):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_sel_ruleid(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        return int(it.text()) if it else None

    def do_force_unlock(self):
        rid=self.get_sel_ruleid()
        if not rid:
            QMessageBox.warning(self,"None","No locked rule selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force unlock rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rid,))
            self.connection.commit()
            QMessageBox.information(self,"Unlocked",f"Rule {rid} forcibly unlocked.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


### 4.14 Admin Tab
class UserManagementWidget(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)
        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["UserID","Username","Password","UserGroup"])
        self.table.horizontalHeader().setStretchLastSection(True)
        ml.addWidget(self.table)

        bh=QHBoxLayout()
        addb=QPushButton("AddUser")
        addb.clicked.connect(self.add_user)
        bh.addWidget(addb)

        delb=QPushButton("DeleteUser")
        delb.clicked.connect(self.del_user)
        bh.addWidget(delb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_users)
        bh.addWidget(refb)

        bh.addStretch()
        ml.addLayout(bh)
        self.setLayout(ml)
        self.load_users()

    def load_users(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row_ in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row_):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_uid(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        return int(it.text()) if it else None

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"AddUser","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Conflict","Username already exists.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(uname.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","User added.")
        self.load_users()

    def del_user(self):
        uid=self.get_selected_uid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user {uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"User {uid} removed.")
        self.load_users()

class GroupManagementWidget(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)
        ml.addWidget(QLabel("Group + Approver + Control Table placeholders."))

        # Could show group table, membership, etc.
        self.setLayout(ml)

class ControlTablesWidget(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        ml=QVBoxLayout(self)
        ml.addWidget(QLabel("Control Tables: pick table => show data => if Admin => can edit."))

        self.table_combo=QComboBox()
        self.table_list=["USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES","BRM_RULE_GROUPS",
                         "BRM_RULES","RULE_SCHEDULES","BRM_DEFECT_LOGS","DECISION_TABLES","DATA_VALIDATIONS",
                         "RULE_CONFLICTS","COMPOSITE_RULES","RULE_SNAPSHOTS","RULE_TAGS","..."]  # example
        for t_ in self.table_list:
            self.table_combo.addItem(t_)
        ml.addWidget(self.table_combo)

        loadb=QPushButton("Load Data")
        loadb.clicked.connect(self.on_load_data)
        ml.addWidget(loadb)

        self.data_table=QTableWidget(0,0)
        ml.addWidget(self.data_table)

        self.setLayout(ml)

    def on_load_data(self):
        tbl=self.table_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Describe error: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Load error: {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row_ in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for j,val in enumerate(row_):
                it=QTableWidgetItem(str(val) if val!=None else "")
                self.data_table.setItem(r_i,j,it)


class AdminTab(QWidget):
    """
    If user is admin => show sub-tabs: user mgmt, group mgmt, control tables, etc.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        ml=QVBoxLayout(self)
        if user_group!="Admin":
            ml.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(ml)
            return

        self.inner_tabs=QTabWidget()
        ml.addWidget(self.inner_tabs)

        self.user_mgmt=UserManagementWidget(self.connection)
        self.inner_tabs.addTab(self.user_mgmt,"UserManagement")

        self.group_mgmt=GroupManagementWidget(self.connection)
        self.inner_tabs.addTab(self.group_mgmt,"GroupManagement")

        self.ctrl_tables=ControlTablesWidget(self.connection)
        self.inner_tabs.addTab(self.ctrl_tables,"ControlTables")

        ml.addStretch()
        self.setLayout(ml)

##############################################
# Main Window aggregator
##############################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – All Features, with Radio Buttons and Wizards")
        self.resize(1500,900)
        self.connection=None
        self.user_id=None
        self.user_group=None
        self.logged_in_username=None

        # Step 1: DB
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection=dbdlg.connection
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Step 2: Login
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group

        # fetch username
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="Unknown"

        self.init_ui()

    def init_ui(self):
        # Menu
        menubar=self.menuBar()
        filem=menubar.addMenu("File")

        sync_act=QtWidgets.QAction("Sync Metadata",self)
        sync_act.triggered.connect(self.do_sync)
        filem.addAction(sync_act)

        chain_act=QtWidgets.QAction("Chain BFS Sim",self)
        chain_act.triggered.connect(self.chain_sim)
        filem.addAction(chain_act)

        group_act=QtWidgets.QAction("Group BFS Sim",self)
        group_act.triggered.connect(self.group_sim)
        filem.addAction(group_act)

        helpm=menubar.addMenu("Help")
        about_act=QtWidgets.QAction("About / Usage",self)
        about_act.triggered.connect(self.show_about)
        helpm.addAction(about_act)

        central_w=QWidget()
        main_l=QVBoxLayout(central_w)

        # If admin => impersonation
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.impersonate_combo=QComboBox()
            self.impersonate_btn=QPushButton("Switch User")
            self.impersonate_btn.clicked.connect(self.switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.impersonate_combo)
            top_h.addWidget(self.impersonate_btn)
            top_h.addStretch()
            main_l.addLayout(top_h)
            self.load_impersonation_options()

        self.tabs=QTabWidget()
        main_l.addWidget(self.tabs)

        # Add all tabs:
        # 1) Dashboard
        self.dashboard_tab=DashboardTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.dashboard_tab,"Dashboard")

        # 2) Business Rules
        self.biz_tab=BusinessRulesTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.biz_tab,"Business Rules")

        # 3) Approvals
        self.approvals_tab=ApprovalsTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approvals_tab,"Approvals")

        # 4) Scheduling
        self.sched_tab=SchedulingTab(self.connection)
        self.tabs.addTab(self.sched_tab,"Scheduling")

        # 5) Defects
        self.defect_tab=DefectManagementTab(self.connection)
        self.tabs.addTab(self.defect_tab,"Defects")

        # 6) Metrics
        self.metrics_tab=MetricsTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # 7) Composite
        self.composite_tab=CompositeRuleTab(self.connection)
        self.tabs.addTab(self.composite_tab,"Composite Rules")

        # 8) Hierarchy
        self.hierarchy_tab=HierarchyTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab,"Hierarchy")

        # 9) Custom Groups
        self.custom_tab=CustomRuleGroupsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # 10) Snapshots
        self.snapshot_tab=SnapshotTab(self.connection)
        self.tabs.addTab(self.snapshot_tab,"Backup/Restore")

        # 11) What-If
        self.whatif_tab=WhatIfTab(self.connection)
        self.tabs.addTab(self.whatif_tab,"What-If Testing")

        # 12) Conflict Priority
        self.conflict_tab=ConflictPriorityTab(self.connection)
        self.tabs.addTab(self.conflict_tab,"Conflict Priority")

        # 13) Collaboration
        self.collab_manager=CollaborationManager(self.connection, poll_ms=5000)
        self.collab_tab=CollaborationTab(self.connection,self.collab_manager)
        self.tabs.addTab(self.collab_tab,"Collaboration")

        # 14) Admin
        self.admin_tab=AdminTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.admin_tab,"Admin")

        central_w.setLayout(main_l)
        self.setCentralWidget(central_w)

        # Timers (e.g. refresh approvals or schedules)
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

        self.show()

    def load_impersonation_options(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for (uid,un,grp) in rows:
            disp=f"{un} ({grp})"
            self.impersonate_combo.addItem(disp,(uid,grp))

    def switch_user(self):
        data=self.impersonate_combo.currentData()
        if not data:
            return
        (new_uid,new_grp)=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="Unknown"

        QMessageBox.information(self,"Switched",f"Now impersonating {self.logged_in_username} ({self.user_group}).")

        # Hide or show admin tab if not admin
        if self.user_group!="Admin":
            # remove or disable the admin tab
            # We can search for the index of self.admin_tab
            for i in range(self.tabs.count()):
                if self.tabs.widget(i)==self.admin_tab:
                    self.tabs.setTabVisible(i,False)
                    break
        else:
            # re-enable
            for i in range(self.tabs.count()):
                if self.tabs.widget(i)==self.admin_tab:
                    self.tabs.setTabVisible(i,True)

        # Also update other tabs that store user contexts:
        self.biz_tab.user_id=self.user_id
        self.biz_tab.user_group=self.user_group
        self.biz_tab.load_rules()

        self.approvals_tab.logged_in_username=self.logged_in_username
        self.approvals_tab.user_group=self.user_group
        self.approvals_tab.load_approvals()

        self.custom_tab.user_id=self.user_id
        self.custom_tab.user_group=self.user_group
        self.custom_tab.refresh_all()

    def do_sync(self):
        msg=sync_metadata_improved(self.connection)
        QMessageBox.information(self,"Sync",msg)

    def chain_sim(self):
        # BFS from selected rule or ask user
        rid,ok=QInputDialog.getInt(self,"Chain BFS","Enter parent rule ID:")
        if not ok:
            return
        executed,skipped=simulate_chain_bfs(rid)
        msg=(
            f"Chain BFS => start={rid}\n"
            f"Executed => {executed}\n"
            f"Skipped => {skipped}\n"
        )
        QMessageBox.information(self,"Chain Sim",msg)

    def group_sim(self):
        gid,ok=QInputDialog.getInt(self,"Group BFS","Enter custom group ID:")
        if not ok:
            return
        passed,failed=simulate_group_bfs(gid)
        msg=(
            f"Group BFS => group_id={gid}\n"
            f"Passed => {passed}\n"
            f"Failed => {failed}\n"
        )
        QMessageBox.information(self,"Group Sim",msg)

    def show_about(self):
        info=(
            "BRM Full Aggregator:\n"
            "Includes Dashboard, Business Rules w/ BFS, Approvals, Scheduling, Defects,\n"
            "Metrics, Composite, Hierarchy, CustomGroups, Snapshots, What-If, ConflictPriority, Collaboration,\n"
            "and Admin tab with user mgmt.\n"
            "Radio buttons open wizards or prompt for relevant operations.\n"
            "Impersonation for admin => hide admin features if user is not admin.\n"
        )
        QMessageBox.information(self,"About/Usage",info)

    def check_due_schedules(self):
        now_str=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
        """,(now_str,))
        rows=c.fetchall()
        for row_ in rows:
            sid=row_[0]
            rid=row_[1]
            # do BFS or single run => stub => mark as executed or fail
            try:
                # stub => pass
                c2=self.connection.cursor()
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sid,))
                self.connection.commit()
            except Exception as ex:
                c3=self.connection.cursor()
                c3.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sid,))
                self.connection.commit()
        self.sched_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

##############################################
# main entry
##############################################
def main():
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()