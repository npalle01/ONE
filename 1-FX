#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
EnhancedLineageGraphWidget – Advanced End‑to‑End Lineage Visualization

Features:
  • Advanced force‑directed layout with repulsion and spring forces.
  • Table‑like node visualization: each node displays rule name (in header), owner, operation type,
    plus a summary of source and target tables.
  • Directional edges with arrowheads and an edge label showing the linking table name.
  • A public setSearchQuery(query) method to filter nodes by any searchable attribute.
  • Constructs lineage based on BRM_RULES and BRM_RULE_TABLE_DEPENDENCIES.
  • Colors and text indicate special types of rules (e.g. if CRITICAL_RULE is set or if OPERATION_TYPE is DATA_VALIDATION).
  
Note: This code expects a pyodbc connection and that your DB tables are defined as in your DDL.
"""

import math, json
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QBrush, QPen, QColor, QPolygonF
from PyQt5.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsItem

# ---------------------- RuleNodeItem Class ----------------------
class RuleNodeItem(QtWidgets.QGraphicsItem):
    def __init__(self, rule_data, width=220, height=90):
        super().__init__()
        self.rule_data = rule_data
        self.width = width
        self.height = height
        self.force = QPointF(0, 0)
        self.velocity = QPointF(0, 0)
        # Color coding: critical rules, data validations, etc.
        if rule_data.get("CRITICAL_RULE") == 1:
            self.bg_color = QColor("#FFCCCC")
        elif (rule_data.get("OPERATION_TYPE") or "").upper() == "DATA_VALIDATION":
            self.bg_color = QColor("#CCFFCC")
        else:
            self.bg_color = QColor("#CCCCFF")
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | QtWidgets.QGraphicsItem.ItemSendsGeometryChanges)
    
    def boundingRect(self):
        return QtCore.QRectF(0, 0, self.width, self.height)
    
    def paint(self, painter, option, widget):
        rect = self.boundingRect()
        painter.setPen(QPen(Qt.black))
        painter.setBrush(QBrush(self.bg_color))
        painter.drawRoundedRect(rect, 5, 5)
        # Header for rule name
        header_rect = QtCore.QRectF(0, 0, self.width, 25)
        painter.setBrush(QBrush(Qt.darkGray))
        painter.drawRoundedRect(header_rect, 5, 5)
        painter.setPen(Qt.white)
        painter.drawText(header_rect, Qt.AlignCenter, self.rule_data.get("RULE_NAME", ""))
        # Body: details (owner, operation type, and tables)
        painter.setPen(Qt.black)
        body_rect = QtCore.QRectF(5, 30, self.width - 10, self.height - 35)
        owner = self.rule_data.get("OWNER_GROUP", "Unknown")
        op_type = self.rule_data.get("OPERATION_TYPE", "N/A")
        src_tables = sorted({tbl for db, tbl, col in self.rule_data.get("source_tables", set())})
        tgt_tables = sorted({tbl for db, tbl, col in self.rule_data.get("target_tables", set())})
        text = f"Owner: {owner}\nType: {op_type}"
        if src_tables:
            text += f"\nSrc: {', '.join(src_tables)}"
        if tgt_tables:
            text += f"\nTgt: {', '.join(tgt_tables)}"
        painter.drawText(body_rect, Qt.AlignLeft | Qt.AlignTop, text)
    
    def itemChange(self, change, value):
        if change == QtWidgets.QGraphicsItem.ItemPositionChange:
            for item in self.scene().items():
                if isinstance(item, EdgeItem):
                    if item.source == self or item.dest == self:
                        item.updatePosition()
        return super().itemChange(change, value)

# ---------------------- EdgeItem Class ----------------------
class EdgeItem(QtWidgets.QGraphicsLineItem):
    def __init__(self, source, dest, table_info):
        super().__init__()
        self.source = source
        self.dest = dest
        self.table_info = table_info  # Tuple (dbname, tblname)
        self._pen = QPen(Qt.gray, 2)
        self.setPen(self._pen)
        self.arrow_head = None
        self.label_item = None
        # Ensure arrowhead and label are on top
        self.setZValue(-1)
    
    def updatePosition(self):
        src_center = self.source.pos() + QPointF(self.source.width / 2, self.source.height / 2)
        dst_center = self.dest.pos() + QPointF(self.dest.width / 2, self.dest.height / 2)
        line = QtCore.QLineF(src_center, dst_center)
        self.setLine(line)
        self.update_arrowhead(line)
    
    def update_arrowhead(self, line):
        scene = self.scene()
        if self.arrow_head:
            scene.removeItem(self.arrow_head)
            self.arrow_head = None
        angle = math.atan2(-line.dy(), line.dx())
        arrow_size = 10.0
        p1 = line.p2() - QPointF(math.cos(angle - math.pi / 6) * arrow_size,
                                  -math.sin(angle - math.pi / 6) * arrow_size)
        p2 = line.p2() - QPointF(math.cos(angle + math.pi / 6) * arrow_size,
                                  -math.sin(angle + math.pi / 6) * arrow_size)
        polygon = QPolygonF([line.p2(), p1, p2])
        self.arrow_head = scene.addPolygon(polygon, self._pen, QBrush(Qt.gray))
        self.arrow_head.setZValue(10)
        mid_point = (line.p1() + line.p2()) / 2
        if self.label_item is None:
            self.label_item = scene.addText("")
            self.label_item.setDefaultTextColor(Qt.darkGray)
            self.label_item.setZValue(10)
        self.label_item.setPlainText(f"{self.table_info[1]}")
        self.label_item.setPos(mid_point)

# ---------------------- EnhancedLineageGraphWidget Class ----------------------
class EnhancedLineageGraphWidget(QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.nodes = {}   # rule_id -> RuleNodeItem
        self.edges = []   # list of EdgeItem
        self.search_query = ""
        self.load_data()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_forces)
        self.timer.start(30)
    
    def load_data(self):
        """Load rules and dependencies from the database and build the graph."""
        c = self.connection.cursor()
        c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, OPERATION_TYPE, CRITICAL_RULE 
            FROM BRM_RULES
        """)
        rules = c.fetchall()
        self.rule_data = {}
        for row in rules:
            rid, rname, owner, op_type, critical = row
            self.rule_data[rid] = {
                "RULE_ID": rid,
                "RULE_NAME": rname,
                "OWNER_GROUP": owner,
                "OPERATION_TYPE": op_type,
                "CRITICAL_RULE": critical,
                "source_tables": set(),  # set of (dbname, tblname, column)
                "target_tables": set()
            }
        c.execute("""
            SELECT RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP 
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps = c.fetchall()
        for dep in deps:
            rid, dbname, tblname, colname, col_op = dep
            if rid in self.rule_data:
                if col_op.upper() == "READ":
                    self.rule_data[rid]["source_tables"].add((dbname, tblname, colname))
                elif col_op.upper() == "WRITE":
                    self.rule_data[rid]["target_tables"].add((dbname, tblname, colname))
        # Create node items
        for rid, data in self.rule_data.items():
            node = RuleNodeItem(data)
            node.setPos(50 + (rid % 10) * 80, 50 + (rid // 10) * 80)
            self.scene.addItem(node)
            self.nodes[rid] = node
        # Build edges: if a rule A writes to a table that rule B reads, draw an edge A -> B.
        added_edges = set()
        for rid_a, data_a in self.rule_data.items():
            targets = { (db, tbl) for db, tbl, col in data_a["target_tables"] }
            for rid_b, data_b in self.rule_data.items():
                if rid_a == rid_b:
                    continue
                sources = { (db, tbl) for db, tbl, col in data_b["source_tables"] }
                common = targets & sources
                if common:
                    for table in common:
                        edge_key = (rid_a, rid_b, table)
                        if edge_key in added_edges:
                            continue
                        edge = EdgeItem(self.nodes[rid_a], self.nodes[rid_b], table)
                        self.scene.addItem(edge)
                        self.edges.append(edge)
                        added_edges.add(edge_key)
    
    def update_forces(self):
        repulsion = 1000.0
        spring_length = 150.0
        spring_strength = 0.05
        damping = 0.85
        for node in self.nodes.values():
            node.force = QPointF(0, 0)
        node_list = list(self.nodes.values())
        for i in range(len(node_list)):
            for j in range(i + 1, len(node_list)):
                node_a = node_list[i]
                node_b = node_list[j]
                delta = node_a.pos() - node_b.pos()
                distance = max(1.0, math.hypot(delta.x(), delta.y()))
                force_magnitude = repulsion / (distance * distance)
                force = (delta / distance) * force_magnitude
                node_a.force += force
                node_b.force -= force
        for edge in self.edges:
            delta = edge.source.pos() - edge.dest.pos()
            distance = max(1.0, math.hypot(delta.x(), delta.y()))
            displacement = distance - spring_length
            force = (delta / distance) * (spring_strength * displacement)
            edge.source.force -= force
            edge.dest.force += force
        for node in self.nodes.values():
            velocity = node.velocity + node.force * 0.1
            velocity *= damping
            node.velocity = velocity
            new_pos = node.pos() + velocity
            node.setPos(new_pos)
        for edge in self.edges:
            edge.updatePosition()
        self.apply_search_filter()
    
    def setSearchQuery(self, query):
        """Public method to set the search query and filter nodes."""
        self.search_query = query.lower()
        self.apply_search_filter()
    
    def apply_search_filter(self):
        for node in self.nodes.values():
            data = node.rule_data
            searchable = " ".join([
                str(data.get("RULE_NAME", "")),
                str(data.get("OWNER_GROUP", "")),
                " ".join([tbl for db, tbl, col in data.get("source_tables", set())]),
                " ".join([tbl for db, tbl, col in data.get("target_tables", set())]),
                str(data.get("OPERATION_TYPE", ""))
            ]).lower()
            node.setVisible(self.search_query in searchable)
        for edge in self.edges:
            if edge.source.isVisible() and edge.dest.isVisible():
                edge.setVisible(True)
                if edge.label_item:
                    edge.label_item.setVisible(True)
            else:
                edge.setVisible(False)
                if edge.label_item:
                    edge.label_item.setVisible(False)
    
    def refresh(self):
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()
        self.load_data()
        
        
self.searchField = QLineEdit()
self.searchField.setPlaceholderText("Search lineage (rule, table, DB, user group)...")
self.searchField.textChanged.connect(lambda text: self.lineageWidget.setSearchQuery(text))
layout.addWidget(self.searchField)
self.lineageWidget = EnhancedLineageGraphWidget(db_connection)
layout.addWidget(self.lineageWidget)