def execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=None, skip_data_validation=False, measure_perf=False):
    """
    Executes BFS over rules considering child, global-critical, conflict, and composite relationships.
    This revised version uses a "visited" set to ensure each rule is processed only once.
    
    Returns a tuple (executed_rule_ids, skipped_rule_ids).
    """
    adjacency, roots, _ = load_rule_relationships(conn)
    rule_map = get_all_rules_map(conn)
    
    # Start BFS from provided roots or selected rule IDs.
    queue = list(selected_rule_ids) if selected_rule_ids else list(roots)
    
    executed = []      # Rules that successfully executed
    visited = set()    # All rules that have been processed (executed or skipped)
    start_time = time.time() if measure_perf else None

    while queue:
        rid = queue.pop(0)
        if rid in visited:
            continue
        if rid not in rule_map:
            visited.add(rid)
            continue

        rule_info = rule_map[rid]

        # Run data validations unless explicitly skipped.
        if not skip_data_validation:
            cursor = conn.cursor()
            cursor.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rid,))
            validation_failed = False
            for dbn, tbl in cursor.fetchall():
                if tbl:
                    full_table = f"{dbn}.{tbl}".lower()
                    if not run_data_validations_for_table(conn, full_table):
                        validation_failed = True
                        break
            if validation_failed:
                visited.add(rid)
                if rid in adjacency:
                    for child in adjacency[rid]:
                        skip_descendants(child, adjacency, visited)
                continue

        # Execute the rule
        ok, msg, rec_count, elapsed = run_single_rule(conn, rule_info, is_dry_run=False)
        insert_performance_log(conn, rid, ok, msg, rec_count, elapsed)
        visited.add(rid)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child in adjacency[rid]:
                    if child not in visited:
                        queue.append(child)
        else:
            # For critical rules, skip all descendants.
            is_critical = (rule_info.get("CRITICAL_RULE") == 1 or rule_info.get("IS_GLOBAL") == 1)
            scope = (rule_info.get("CRITICAL_SCOPE") or "NONE").upper()
            if is_critical and scope != "NONE" and rid in adjacency:
                for child in adjacency[rid]:
                    skip_descendants(child, adjacency, visited)
    if measure_perf and start_time is not None:
        total_elapsed = time.time() - start_time
        logger.debug(f"BFS execution total elapsed: {total_elapsed:.4f} seconds")
    # Return executed rules and those marked as skipped (visited minus executed)
    return (executed, visited - set(executed))
    
    
def lock_rule_for_edit(conn, rule_id, user_id, force=False, user_group=None, admin_override=False):
    """
    Attempt to lock the rule for editing.
    Ensures that the LOCKED_BY column (VARCHAR) receives a string.
    """
    info = rule_current_lock_owner(conn, rule_id)
    now = datetime.now()
    expiry = now + timedelta(minutes=30)
    cursor = conn.cursor()
    user_str = str(user_id)  # Ensure user_id is a string for the LOCKED_BY column.
    
    if info:
        current_locked_by = str(info[0])
        if current_locked_by == user_str:
            cursor.execute("""
                UPDATE BRM_RULE_LOCKS
                SET EXPIRY_TIMESTAMP = ?, LOCK_TIMESTAMP = ?, FORCE_LOCK = ?
                WHERE RULE_ID = ? AND ACTIVE_LOCK = 1
            """, (expiry, now, 1 if (force or admin_override) else 0, rule_id))
            conn.commit()
            logger.debug(f"Lock refreshed for rule {rule_id} by user {user_str}.")
            return (True, f"Lock refreshed for rule {rule_id}.")
        else:
            if not force and not admin_override:
                raise ValueError(f"Rule {rule_id} is already locked by user {current_locked_by}.")
            else:
                cursor.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK = 0
                    WHERE RULE_ID = ? AND ACTIVE_LOCK = 1
                """, (rule_id,))
                cursor.execute("""
                    INSERT INTO BRM_RULE_LOCKS (
                        RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                """, (rule_id, user_str, now, expiry, 1 if (force or admin_override) else 0))
                conn.commit()
                logger.debug(f"Rule {rule_id} forcibly locked by user {user_str}.")
                return (True, f"Rule {rule_id} forcibly locked by user {user_str}.")
    else:
        cursor.execute("""
            INSERT INTO BRM_RULE_LOCKS (
                RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
            )
            VALUES (?, ?, ?, ?, ?, 1)
        """, (rule_id, user_str, now, expiry, 1 if (force or admin_override) else 0))
        conn.commit()
        logger.debug(f"Rule {rule_id} locked by user {user_str}.")
        return (True, f"Rule {rule_id} locked by user {user_str}.")


def unlock_rule_for_edit(conn, rule_id, user_id=None, force=False, admin_override=False, user_group=None):
    """
    Unlocks the rule.
    Ensures that user_id is converted to a string for comparison with LOCKED_BY.
    """
    info = rule_current_lock_owner(conn, rule_id)
    user_str = str(user_id) if user_id is not None else None
    if not info:
        return
    locked_by = str(info[0])
    if not force and not admin_override:
        if user_str and locked_by != user_str:
            raise ValueError("Cannot unlock: rule locked by another user.")
    cursor = conn.cursor()
    cursor.execute("""
        UPDATE BRM_RULE_LOCKS
        SET ACTIVE_LOCK = 0
        WHERE RULE_ID = ? AND ACTIVE_LOCK = 1
    """, (rule_id,))
    conn.commit()
    logger.debug(f"Rule {rule_id} unlocked by user {user_str} (admin_override={admin_override}).")
    
-- ======================================
-- DROP STATEMENTS
-- ======================================

DROP TABLE IF EXISTS BRM_AUDIT_LOG;
DROP TABLE IF EXISTS USERS;
DROP TABLE IF EXISTS GROUP_PERMISSIONS;
DROP TABLE IF EXISTS DATA_VALIDATIONS;
DROP TABLE IF EXISTS BRM_RULES;
DROP TABLE IF EXISTS BRM_RULE_LOCKS;
DROP TABLE IF EXISTS BRM_RULE_TABLE_DEPENDENCIES;
DROP TABLE IF EXISTS BRM_RULE_APPROVALS;
DROP TABLE IF EXISTS BRM_GLOBAL_CRITICAL_LINKS;
DROP TABLE IF EXISTS RULE_CONFLICTS;
DROP TABLE IF EXISTS COMPOSITE_RULES;
DROP TABLE IF EXISTS RULE_EXECUTION_LOGS;
DROP TABLE IF EXISTS BRM_COLUMN_MAPPING;
DROP TABLE IF EXISTS RULE_SCHEDULES;
DROP TABLE IF EXISTS RULE_SNAPSHOTS;
DROP TABLE IF EXISTS DECISION_TABLES;
DROP TABLE IF EXISTS RULE_TAGS;
DROP TABLE IF EXISTS BUSINESS_GROUPS;
DROP TABLE IF EXISTS BUSINESS_GROUP_APPROVERS;
DROP TABLE IF EXISTS BRM_RULE_TYPES;
DROP TABLE IF EXISTS BRM_CUSTOM_RULE_GROUPS;
DROP TABLE IF EXISTS BRM_CUSTOM_GROUP_MEMBERS;
DROP TABLE IF EXISTS BRM_CUSTOM_GROUP_BACKUPS;
DROP TABLE IF EXISTS DATA_VALIDATION_LOGS;

-- ======================================
-- CREATE TABLE STATEMENTS
-- ======================================

-- 1. BRM_AUDIT_LOG
CREATE TABLE BRM_AUDIT_LOG (
    AUDIT_ID INT IDENTITY(1,1) PRIMARY KEY,
    ACTION VARCHAR(50) NOT NULL,
    TABLE_NAME VARCHAR(100) NOT NULL,
    RECORD_ID VARCHAR(50),
    ACTION_BY VARCHAR(50) NOT NULL,
    OLD_DATA NVARCHAR(MAX),
    NEW_DATA NVARCHAR(MAX),
    ACTION_TIMESTAMP DATETIME DEFAULT GETDATE()
);

-- 2. USERS
CREATE TABLE USERS (
    USER_ID INT IDENTITY(1,1) PRIMARY KEY,
    USERNAME VARCHAR(50) UNIQUE NOT NULL,
    PASSWORD VARCHAR(100) NOT NULL,
    USER_GROUP VARCHAR(50) NOT NULL
);

-- 3. GROUP_PERMISSIONS
CREATE TABLE GROUP_PERMISSIONS (
    PERMISSION_ID INT IDENTITY(1,1) PRIMARY KEY,
    GROUP_NAME VARCHAR(50) NOT NULL,
    TARGET_TABLE VARCHAR(100) NOT NULL
);

-- 4. DATA_VALIDATIONS
CREATE TABLE DATA_VALIDATIONS (
    VALIDATION_ID INT IDENTITY(1,1) PRIMARY KEY,
    TABLE_NAME VARCHAR(100) NOT NULL,
    COLUMN_NAME VARCHAR(100) NULL,
    VALIDATION_TYPE VARCHAR(50) NOT NULL,
    PARAMS VARCHAR(200) NULL
);

-- 5. BRM_RULES
CREATE TABLE BRM_RULES (
    RULE_ID INT IDENTITY(1,1) PRIMARY KEY,
    GROUP_ID INT NULL,
    PARENT_RULE_ID INT NULL,
    RULE_TYPE_ID INT NOT NULL,
    RULE_NAME VARCHAR(200) NOT NULL,
    RULE_SQL NVARCHAR(MAX) NOT NULL,
    EFFECTIVE_START_DATE DATETIME NOT NULL,
    EFFECTIVE_END_DATE DATETIME NULL,
    STATUS VARCHAR(50) NOT NULL,
    VERSION INT NOT NULL DEFAULT 1,
    CREATED_BY VARCHAR(50) NOT NULL,
    DESCRIPTION NVARCHAR(MAX) NULL,
    OPERATION_TYPE VARCHAR(20) NOT NULL,
    BUSINESS_JUSTIFICATION NVARCHAR(MAX) NULL,
    CREATED_TIMESTAMP DATETIME DEFAULT GETDATE(),
    UPDATED_BY VARCHAR(50) NULL,
    OWNER_GROUP VARCHAR(50) NOT NULL,
    APPROVAL_STATUS VARCHAR(50) NOT NULL,
    IS_GLOBAL BIT NOT NULL DEFAULT 0,
    CRITICAL_RULE BIT NOT NULL DEFAULT 0,
    CRITICAL_SCOPE VARCHAR(20) NOT NULL DEFAULT 'NONE',
    CDC_TYPE VARCHAR(20) NOT NULL DEFAULT 'NONE',
    LIFECYCLE_STATE VARCHAR(20) NOT NULL
);

-- 6. BRM_RULE_LOCKS
CREATE TABLE BRM_RULE_LOCKS (
    LOCK_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID INT NOT NULL,
    LOCKED_BY VARCHAR(50) NOT NULL,
    LOCK_TIMESTAMP DATETIME NOT NULL,
    EXPIRY_TIMESTAMP DATETIME NULL,
    FORCE_LOCK BIT NOT NULL DEFAULT 0,
    ACTIVE_LOCK BIT NOT NULL DEFAULT 1
);

-- 7. BRM_RULE_TABLE_DEPENDENCIES
CREATE TABLE BRM_RULE_TABLE_DEPENDENCIES (
    DEPENDENCY_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID INT NOT NULL,
    DATABASE_NAME VARCHAR(50) NOT NULL,
    TABLE_NAME VARCHAR(100) NOT NULL,
    COLUMN_NAME VARCHAR(100) NULL,
    COLUMN_OP VARCHAR(20) NOT NULL,
    DATA_TYPE VARCHAR(50) NULL
);

-- 8. BRM_RULE_APPROVALS
CREATE TABLE BRM_RULE_APPROVALS (
    APPROVAL_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID INT NOT NULL,
    GROUP_NAME VARCHAR(50) NOT NULL,
    USERNAME VARCHAR(50) NOT NULL,
    APPROVED_FLAG INT NOT NULL DEFAULT 0,  -- 0: pending, 1: approved, 2: rejected
    APPROVED_TIMESTAMP DATETIME NULL,
    APPROVAL_STAGE INT NOT NULL
);

-- 9. BRM_GLOBAL_CRITICAL_LINKS
CREATE TABLE BRM_GLOBAL_CRITICAL_LINKS (
    LINK_ID INT IDENTITY(1,1) PRIMARY KEY,
    GCR_RULE_ID INT NOT NULL,
    TARGET_RULE_ID INT NOT NULL
);

-- 10. RULE_CONFLICTS
CREATE TABLE RULE_CONFLICTS (
    CONFLICT_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID1 INT NOT NULL,
    RULE_ID2 INT NOT NULL,
    PRIORITY INT NOT NULL
);

-- 11. COMPOSITE_RULES
CREATE TABLE COMPOSITE_RULES (
    COMPOSITE_RULE_ID INT IDENTITY(1,1) PRIMARY KEY,
    CRULE_NAME VARCHAR(200) NOT NULL,
    LOGIC_EXPR NVARCHAR(MAX) NULL,
    ACTION_ON_PASS VARCHAR(100) NULL
);

-- 12. RULE_EXECUTION_LOGS
CREATE TABLE RULE_EXECUTION_LOGS (
    LOG_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID INT NOT NULL,
    EXECUTION_TIMESTAMP DATETIME DEFAULT GETDATE(),
    PASS_FLAG INT NOT NULL,
    MESSAGE NVARCHAR(MAX) NULL,
    RECORD_COUNT INT NOT NULL,
    EXECUTION_TIME_MS INT NOT NULL
);

-- 13. BRM_COLUMN_MAPPING
CREATE TABLE BRM_COLUMN_MAPPING (
    MAPPING_ID INT IDENTITY(1,1) PRIMARY KEY,
    SOURCE_RULE_ID INT NOT NULL,
    RULE_ID INT NOT NULL,
    COLUMN_NAME VARCHAR(100) NOT NULL
);

-- 14. RULE_SCHEDULES
CREATE TABLE RULE_SCHEDULES (
    SCHEDULE_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID INT NOT NULL,
    SCHEDULE_TIME DATETIME NOT NULL,
    STATUS VARCHAR(50) NOT NULL,
    CREATED_TIMESTAMP DATETIME DEFAULT GETDATE(),
    VALIDATION_FLAG BIT NOT NULL DEFAULT 0
);

-- 15. RULE_SNAPSHOTS
CREATE TABLE RULE_SNAPSHOTS (
    SNAPSHOT_ID INT IDENTITY(1,1) PRIMARY KEY,
    SNAPSHOT_NAME VARCHAR(200) NOT NULL,
    CREATED_BY VARCHAR(50) NOT NULL,
    CREATED_TIMESTAMP DATETIME DEFAULT GETDATE(),
    SNAPSHOT_JSON NVARCHAR(MAX) NOT NULL
);

-- 16. DECISION_TABLES
CREATE TABLE DECISION_TABLES (
    DECISION_TABLE_ID INT IDENTITY(1,1) PRIMARY KEY,
    TABLE_NAME VARCHAR(100) NOT NULL,
    DESCRIPTION NVARCHAR(MAX) NULL
);

-- 17. RULE_TAGS
CREATE TABLE RULE_TAGS (
    TAG_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_ID INT NOT NULL,
    TAG_NAME VARCHAR(50) NOT NULL
);

-- 18. BUSINESS_GROUPS
CREATE TABLE BUSINESS_GROUPS (
    GROUP_ID INT IDENTITY(1,1) PRIMARY KEY,
    GROUP_NAME VARCHAR(50) UNIQUE NOT NULL,
    DESCRIPTION NVARCHAR(MAX) NULL,
    EMAIL VARCHAR(100) NULL
);

-- 19. BUSINESS_GROUP_APPROVERS
CREATE TABLE BUSINESS_GROUP_APPROVERS (
    APPROVER_ID INT IDENTITY(1,1) PRIMARY KEY,
    GROUP_NAME VARCHAR(50) NOT NULL,
    USERNAME VARCHAR(50) NOT NULL
);

-- 20. BRM_RULE_TYPES
CREATE TABLE BRM_RULE_TYPES (
    RULE_TYPE_ID INT IDENTITY(1,1) PRIMARY KEY,
    RULE_TYPE_NAME VARCHAR(50) NOT NULL
);

-- 21. BRM_CUSTOM_RULE_GROUPS
CREATE TABLE BRM_CUSTOM_RULE_GROUPS (
    CUSTOM_GROUP_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUSTOM_GROUP_NAME VARCHAR(100) NOT NULL,
    OWNER_BUSINESS_GROUP VARCHAR(50) NOT NULL,
    CREATED_BY VARCHAR(50) NOT NULL,
    CREATED_TIMESTAMP DATETIME DEFAULT GETDATE()
);

-- 22. BRM_CUSTOM_GROUP_MEMBERS
CREATE TABLE BRM_CUSTOM_GROUP_MEMBERS (
    MEMBER_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUSTOM_GROUP_ID INT NOT NULL,
    RULE_ID INT NOT NULL
);

-- 23. BRM_CUSTOM_GROUP_BACKUPS
CREATE TABLE BRM_CUSTOM_GROUP_BACKUPS (
    BACKUP_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUSTOM_GROUP_ID INT NOT NULL,
    BACKUP_TIMESTAMP DATETIME DEFAULT GETDATE(),
    BACKUP_VERSION INT NOT NULL,
    BACKUP_JSON NVARCHAR(MAX) NOT NULL
);

-- 24. DATA_VALIDATION_LOGS
CREATE TABLE DATA_VALIDATION_LOGS (
    LOG_ID INT IDENTITY(1,1) PRIMARY KEY,
    VALIDATION_TIMESTAMP DATETIME DEFAULT GETDATE(),
    RESULT_FLAG VARCHAR(10) NOT NULL  -- e.g., 'PASS' or 'FAIL'
);

