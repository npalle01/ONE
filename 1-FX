#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8 (FINAL, NO ENCRYPTION, FULL LOCK/UNLOCK)
-------------------------------------------------------------------
This part contains:
  - All necessary imports (PyQt5, logging, smtplib, etc.)
  - Logging configuration
  - Email sending function
  - Database connection dialog
  - Database helper functions (fetch, audit logging)
  - Login dialog
  - SQL parsing helpers (detect_operation_type, parse_sql_dependencies, etc.)
  - Rule lifecycle constants
  - (Optional) OnboardingWizard for new users
  - Production-ready lock/unlock logic for rule editing (with admin override support)
No references to old encryption or “secure tab” remain.
All future parts rely on these definitions.
"""

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re
import csv

from datetime import datetime, date, time, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 for GUI usage
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate, QMimeData, QPoint
from PyQt5.QtGui import QColor, QPainter, QBrush, QPen, QDrag
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog
)

# (Optional) pyqtgraph usage in later parts
import pyqtgraph as pg

# From sqlparse – advanced SQL parsing helpers
from sqlparse.sql import Identifier, IdentifierList, Parenthesis, Token
from sqlparse.tokens import Keyword, DML

# ---------------------------------------------------------------------------
# LOGGING SETUP
# ---------------------------------------------------------------------------
logging.basicConfig(
    filename='brm_tool_production.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# EMAIL CONFIGURATION + SENDER
# ---------------------------------------------------------------------------
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "YOUR_SMTP_USERNAME",
    "smtp_password": "YOUR_SMTP_PASSWORD",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Send an email using the SMTP configuration.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email to {recipients}: {ex}")

# ---------------------------------------------------------------------------
# DATABASE CONNECTION DIALOG
# ---------------------------------------------------------------------------
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    A dialog for selecting an ODBC DSN or entering a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400, 200)
        main_layout = QVBoxLayout(self)

        prompt_label = QLabel("Select an ODBC DSN (SQL Server) or provide a custom connection string:")
        main_layout.addWidget(prompt_label)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error(f"Error listing DSNs: {e}")
        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional).")
        main_layout.addWidget(self.conn_str_edit)

        btn_layout = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

    def get_connection(self):
        """
        After acceptance, returns a pyodbc connection.
        """
        override_str = self.conn_str_edit.text().strip()
        if override_str:
            conn_str = override_str
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

# ---------------------------------------------------------------------------
# DATABASE HELPER FUNCTIONS
# ---------------------------------------------------------------------------
def fetch_all_dict(cursor):
    """
    Fetch all rows from a cursor and return a list of dictionaries.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    return rows

def fetch_one_dict(cursor):
    """
    Fetch the next row from a cursor as a dictionary.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    """
    Insert a record into the BRM_AUDIT_LOG table.
    """
    c = conn.cursor()
    c.execute("""
        INSERT INTO BRM_AUDIT_LOG(
            ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        )
        VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (
        action,
        table_name,
        str(record_id) if record_id else None,
        actor,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

# ---------------------------------------------------------------------------
# LOGIN DIALOG
# ---------------------------------------------------------------------------
class LoginDialog(QtWidgets.QDialog):
    """
    Minimal username/password login that checks the USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – Part 1")
        self.resize(300, 150)
        main_layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)
        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Please enter both username and password.")
            return
        cur = self.connection.cursor()
        cur.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (un, pw))
        row = fetch_one_dict(cur)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")

# ---------------------------------------------------------------------------
# DETECT OPERATION TYPE
# ---------------------------------------------------------------------------
def detect_operation_type(rule_sql: str) -> str:
    """
    Returns one of: INSERT, UPDATE, DELETE, SELECT, or OTHER
    based on the first keyword of the rule_sql.
    """
    stripped = rule_sql.strip().upper()
    if stripped.startswith("INSERT"):
        return "INSERT"
    elif stripped.startswith("UPDATE"):
        return "UPDATE"
    elif stripped.startswith("DELETE"):
        return "DELETE"
    elif stripped.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

# ---------------------------------------------------------------------------
# ADVANCED SQL PARSER for Dependencies
# ---------------------------------------------------------------------------
def parse_sql_dependencies(sql_text: str):
    """
    Uses sqlparse to identify table references, columns, etc.
    Returns a dict with keys: tables, cte_tables, alias_map, columns.
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []
    for stmt in statements:
        ctes = extract_with_clauses(stmt)
        for cte_name, cte_refs in ctes.items():
            cte_info.append((cte_name, cte_refs))
        main_refs, main_alias = extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)
        col_refs = extract_columns(stmt)
        columns.extend(col_refs)
    unique_tables = list({x for x in all_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }

def extract_with_clauses(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is Keyword and token.value.upper() == "WITH":
            i += 1
            i = parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def parse_cte_block(tokens, i, cte_map):
    while i < len(tokens):
        token = tokens[i]
        if isinstance(token, Identifier):
            cte_name = token.get_real_name()
            i += 1
            i = parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif token.ttype is Keyword and token.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i

def parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        token = tokens[i]
        token_val = token.value.upper() if token.ttype else ""
        if token_val == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs = extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.is_group and is_subselect(token):
            results.extend(extract_subselect_tokens(token.tokens))
        if token.ttype is Keyword:
            up_value = token.value.upper()
            if up_value in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(token, IdentifierList):
                for identifier in token.get_identifiers():
                    parsed = parse_identifier(identifier, set())
                    results.append((parsed[0], parsed[1], parsed[2], True))
            elif isinstance(token, Identifier):
                parsed = parse_identifier(token, set())
                results.append((parsed[0], parsed[1], parsed[2], True))
        i += 1
    return results

def is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper() == "SELECT":
            return True
    return False

def extract_main_from(token_list, known_cte_names):
    results = []
    alias_map = {}
    tokens = list(token_list)
    from_seen = False
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.is_group and is_subselect(token):
            results.extend(extract_subselect_tokens(token.tokens))
        if token.ttype is Keyword:
            up_value = token.value.upper()
            if up_value in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(token, IdentifierList):
                for identifier in token.get_identifiers():
                    parsed = parse_identifier(identifier, known_cte_names)
                    results.append(parsed)
                    if parsed[2]:
                        alias_map[parsed[2]] = (parsed[0], parsed[1])
            elif isinstance(token, Identifier):
                parsed = parse_identifier(token, known_cte_names)
                results.append(parsed)
                if parsed[2]:
                    alias_map[parsed[2]] = (parsed[0], parsed[1])
        i += 1
    return (results, alias_map)

def parse_identifier(identifier, known_cte_names):
    alias = identifier.get_alias()
    real_name = identifier.get_real_name()
    schema_name = identifier.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def extract_columns(statement):
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is DML:
            dml_word = token.value.upper()
            if dml_word == "SELECT":
                col_refs = parse_select_list(tokens, i + 1)
                for col in col_refs:
                    results.append((col, False, True))
            elif dml_word in ("INSERT", "UPDATE"):
                col_refs = parse_dml_columns(tokens, i, dml_word)
                for col in col_refs:
                    results.append((col, True, False))
        i += 1
    return results

def parse_select_list(tokens, start_idx):
    columns = []
    i = start_idx
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is Keyword:
            if token.value.upper() in ("FROM", "JOIN", "WHERE", "GROUP", "ORDER", "UNION", "INTERSECT"):
                break
        if isinstance(token, IdentifierList):
            for identifier in token.get_identifiers():
                col_name = identifier.get_name()
                if col_name and col_name.upper() not in ("DISTINCT", "TOP", "ALL"):
                    columns.append(col_name)
        elif isinstance(token, Identifier):
            col_name = token.get_name()
            if col_name and col_name.upper() not in ("DISTINCT", "TOP", "ALL"):
                columns.append(col_name)
        i += 1
    return columns

def parse_dml_columns(tokens, start_idx, dml_word):
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            token = tokens[i]
            if token.is_group and isinstance(token, Parenthesis):
                for sub in token.tokens:
                    if isinstance(sub, IdentifierList):
                        for identifier in sub.get_identifiers():
                            columns.append(identifier.get_name())
                    elif isinstance(sub, Identifier):
                        columns.append(sub.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            token = tokens[i]
            if token.ttype is Keyword and token.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(parse_update_set_list(tokens, i))
                break
            i += 1
    return columns

def parse_update_set_list(tokens, start_index):
    columns = []
    i = start_index
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is Keyword and token.value.upper() in ("WHERE", "FROM"):
            break
        if isinstance(token, Identifier):
            columns.append(token.get_name())
        i += 1
    return columns

# ---------------------------------------------------------------------------
# RULE LIFECYCLE STATES
# ---------------------------------------------------------------------------
RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]

# ---------------------------------------------------------------------------
# ONBOARDING WIZARD (OPTIONAL)
# ---------------------------------------------------------------------------
class OnboardingWizard(QDialog):
    """
    Optional wizard for new users. (Illustrative steps.)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Welcome Wizard (Part 1)")
        self.resize(400, 300)
        main_layout = QVBoxLayout(self)
        self.label = QLabel("Welcome to the BRM Onboarding Wizard!")
        main_layout.addWidget(self.label)
        self.current_step = 0
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.go_next)
        main_layout.addWidget(self.next_btn)
        self.setLayout(main_layout)

    def go_next(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Go to 'Group Management' => add a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Go to 'Business Rules' => add a new rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Go to 'Scheduling' => add a schedule.")
        else:
            self.label.setText("All done. Enjoy the BRM Tool.")
            self.accept()

# ---------------------------------------------------------------------------
# RULE LOCK/UNLOCK FUNCTIONS (WITH ADMIN OVERRIDE SUPPORT)
# ---------------------------------------------------------------------------
def rule_current_lock_owner(conn, rule_id):
    """
    Return (locked_by, lock_timestamp, expiry_timestamp, force_lock_flag)
    or None if no active lock (or if expired).
    """
    c = conn.cursor()
    c.execute("""
    SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
    FROM BRM_RULE_LOCKS
    WHERE RULE_ID=? AND ACTIVE_LOCK=1
    """, (rule_id,))
    row = c.fetchone()
    if not row:
        return None
    (locked_by, lock_ts, expiry_ts, force_lock, active_lock) = row
    if not active_lock:
        return None
    if expiry_ts is not None:
        now = datetime.now()
        if now > expiry_ts:
            c2 = conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """, (rule_id,))
            conn.commit()
            return None
    return (locked_by, lock_ts, expiry_ts, force_lock)

def lock_rule_for_edit(conn, rule_id, user_id, force=False, user_group=None, admin_override=False):
    """
    Attempt to lock a rule for editing.
    
    If already locked by another user and neither force nor admin_override is True,
    a ValueError is raised. If the same user calls again, the expiry is refreshed.
    """
    info = rule_current_lock_owner(conn, rule_id)
    now = datetime.now()
    expiry = now + timedelta(minutes=30)
    c = conn.cursor()
    if info is not None:
        (locked_by, _, _, _) = info
        if locked_by == user_id:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET EXPIRY_TIMESTAMP=?, LOCK_TIMESTAMP=?, FORCE_LOCK=?
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """, (expiry, now, 1 if (force or admin_override) else 0, rule_id))
            conn.commit()
            logger.debug(f"Lock refreshed for user {user_id} on rule {rule_id}.")
            return (True, f"Lock refreshed for rule {rule_id}.")
        else:
            if not force and not admin_override:
                raise ValueError(f"Rule {rule_id} is already locked by user {locked_by}.")
            else:
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                c.execute("""
                    INSERT INTO BRM_RULE_LOCKS(
                      RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
                    )
                    VALUES (?, ?, ?, ?, ?, 1)
                """, (rule_id, user_id, now, expiry, 1 if (force or admin_override) else 0))
                conn.commit()
                logger.debug(f"Rule {rule_id} forcibly locked by user {user_id}.")
                return (True, f"Rule {rule_id} forcibly locked by user {user_id}.")
    else:
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS(
                RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
            )
            VALUES (?, ?, ?, ?, ?, 1)
        """, (rule_id, user_id, now, expiry, 1 if (force or admin_override) else 0))
        conn.commit()
        logger.debug(f"Rule {rule_id} locked by user {user_id}. Force={force or admin_override}")
        return (True, f"Rule {rule_id} locked by user {user_id}.")

def unlock_rule_for_edit(conn, rule_id, user_id=None, force=False, admin_override=False, user_group=None):
    """
    Unlock a rule.
    
    Without admin_override, only the user who holds the lock may unlock.
    """
    info = rule_current_lock_owner(conn, rule_id)
    if not info:
        return
    (locked_by, _, _, _) = info
    if not force and not admin_override:
        if user_id and locked_by != user_id:
            raise ValueError("Cannot unlock: rule is locked by another user.")
    c = conn.cursor()
    c.execute("""
        UPDATE BRM_RULE_LOCKS
        SET ACTIVE_LOCK=0
        WHERE RULE_ID=? AND ACTIVE_LOCK=1
    """, (rule_id,))
    conn.commit()
    logger.debug(f"Rule {rule_id} unlocked. Admin override={admin_override} by user {user_id}.")

# ──────────────────────────────────────────────
# End of PART 1

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 2 of 8 (ADVANCED BFS, CRUD, VALIDATIONS, LOCKS, PERMISSIONS)
---------------------------------------------------------------------------
Builds on Part 1’s classes & functions:
  - Logging, DatabaseConnectionDialog, parse_sql_dependencies, detect_operation_type,
    rule_current_lock_owner, lock_rule_for_edit, unlock_rule_for_edit, auto_unlock_expired_locks,
    fetch_one_dict, fetch_all_dict, insert_audit_log, RULE_LIFECYCLE_STATES,
    and optionally OnboardingWizard.
This part includes:
  - Permission checks on table usage,
  - Data validations,
  - Multi-step approvals,
  - Advanced CRUD (add_rule, update_rule, deactivate_rule, delete_rule, force_activate_rule, force_deactivate_rule),
  - Lock checks during CRUD to ensure the rule is locked by the editor (unless admin override).
"""

import json
import time
from datetime import datetime, timedelta
from collections import deque
import re

# ---------------------------------------------------------------------------
# PERMISSION CHECK
# ---------------------------------------------------------------------------
def user_has_table_permission(conn, user_group, table_name):
    """
    Check if the specified user_group has permission to access table_name (schema.table).
    """
    cursor = conn.cursor()
    normalized_table = table_name.lower()
    cursor.execute("""
        SELECT 1
        FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME=? AND LOWER(TARGET_TABLE)=?
    """, (user_group, normalized_table))
    row = cursor.fetchone()
    return bool(row)

def enforce_table_permissions_for_rule(conn, user_group, rule_sql):
    """
    Parse rule_sql for table dependencies and ensure that user_group has permission for each table.
    Raise ValueError if any permission is missing.
    """
    dependencies = parse_sql_dependencies(rule_sql)
    for (schema, table, alias, is_subselect) in dependencies["tables"]:
        if table and not table.startswith("(CTE)"):
            database_name = schema if schema else "dbo"
            full_table_name = f"{database_name}.{table}".lower()
            if not user_has_table_permission(conn, user_group, full_table_name):
                raise ValueError(f"Group {user_group} has no permission for table '{full_table_name}'. Rule not allowed.")

# ---------------------------------------------------------------------------
# DATA VALIDATIONS
# ---------------------------------------------------------------------------
def load_data_validations_for_table(conn, table_name):
    """
    Return all validation rules for the given table_name from DATA_VALIDATIONS.
    """
    cursor = conn.cursor()
    cursor.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
        WHERE LOWER(TABLE_NAME)=LOWER(?)
    """, (table_name,))
    return fetch_all_dict(cursor)

def run_single_data_validation(validation_rule, conn):
    """
    Execute a single data validation rule.
    Returns True if the validation passes; otherwise, returns False.
    """
    validation_type = (validation_rule["VALIDATION_TYPE"] or "").upper()
    table_name = validation_rule["TABLE_NAME"]
    column_name = validation_rule["COLUMN_NAME"]
    params = validation_rule["PARAMS"] or ""
    cursor = conn.cursor()
    try:
        if validation_type == "NOT NULL":
            query = f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL"
            cursor.execute(query)
            row = cursor.fetchone()
            null_count = row[0]
            return (null_count == 0)
        elif validation_type == "RANGE":
            parts = params.split(",")
            if len(parts) == 2:
                min_val = float(parts[0])
                max_val = float(parts[1])
                query = f"""
                    SELECT COUNT(*) 
                    FROM {table_name}
                    WHERE {column_name} < {min_val} OR {column_name} > {max_val}
                """
                cursor.execute(query)
                row = cursor.fetchone()
                out_of_range = row[0]
                return (out_of_range == 0)
            else:
                return False
        elif validation_type == "REGEX":
            # Stub: In a real implementation, add appropriate regex-based validation.
            return True
        else:
            return False
    except Exception:
        return False

def run_data_validations_for_table(conn, table_name):
    """
    Load and run all data validations for the specified table_name.
    Returns True if all validations pass; otherwise, returns False.
    """
    validations = load_data_validations_for_table(conn, table_name)
    for validation in validations:
        if not run_single_data_validation(validation, conn):
            return False
    return True

# ---------------------------------------------------------------------------
# MULTI-STEP APPROVALS
# ---------------------------------------------------------------------------
def create_multistep_approvals(conn, rule_id):
    """
    Insert an approvals pipeline for a rule.
    For demonstration:
      - Pipeline: BG1 -> (BG2 if required) -> (BG3 if required) -> FINAL.
    """
    impacted_groups = find_impacted_groups_bfs(conn, rule_id)
    cursor = conn.cursor()
    cursor.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
    table_rows = cursor.fetchall()
    require_bg2 = False
    require_bg3 = False
    for (table_name,) in table_rows:
        lower_table = (table_name or "").lower()
        if "finance" in lower_table or "credit" in lower_table:
            require_bg2 = True
        if "sensitive" in lower_table or "personal_info" in lower_table:
            require_bg3 = True
    pipeline = ["BG1"]
    if require_bg2 or ("BG2" in impacted_groups):
        pipeline.append("BG2")
    if require_bg3 or ("BG3" in impacted_groups):
        pipeline.append("BG3")
    pipeline.append("FINAL")
    cursor.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_id,))
    stage = 1
    for group in pipeline:
        if group == "FINAL":
            cursor.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE
                )
                VALUES (?, ?, ?, 0, NULL, ?)
            """, (rule_id, "FINAL", "final_approver", stage))
            stage += 1
        else:
            sub_cursor = conn.cursor()
            sub_cursor.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (group,))
            approver_rows = sub_cursor.fetchall()
            for (username,) in approver_rows:
                cursor.execute("""
                    INSERT INTO BRM_RULE_APPROVALS(
                      RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE
                    )
                    VALUES (?, ?, ?, 0, NULL, ?)
                """, (rule_id, group, username, stage))
            stage += 1
    conn.commit()

def find_impacted_groups_bfs(conn, start_rule_id):
    """
    Perform a BFS starting from start_rule_id and return a set of owner groups.
    """
    visited = set()
    queue = [start_rule_id]
    adjacency, roots, parent_mapping = load_rule_relationships(conn)
    cursor = conn.cursor()
    impacted_groups = set()
    while queue:
        current_rule = queue.pop(0)
        if current_rule in visited:
            continue
        visited.add(current_rule)
        cursor.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (current_rule,))
        row = cursor.fetchone()
        if row:
            impacted_groups.add(row[0])
        if current_rule in adjacency:
            for child_rule in adjacency[current_rule]:
                if child_rule not in visited:
                    queue.append(child_rule)
    return impacted_groups

# ---------------------------------------------------------------------------
# BFS LOGIC AND RULE RELATIONSHIPS
# ---------------------------------------------------------------------------
def load_rule_relationships(conn):
    """
    Build an adjacency dictionary representing rule relationships.
    Returns a tuple: (adjacency_dict, roots_list, parent_mapping).
    """
    cursor = conn.cursor()
    cursor.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = cursor.fetchall()
    adjacency = {}
    parent_mapping = {}
    all_rule_ids = set()
    for (rule_id, parent_id) in rows:
        all_rule_ids.add(rule_id)
        if parent_id:
            adjacency.setdefault(parent_id, set()).add(rule_id)
            parent_mapping[rule_id] = parent_id
    # Global Critical Relationships (GCR)
    cursor.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcr_rows = cursor.fetchall()
    for (gcr_rule, child_rule) in gcr_rows:
        adjacency.setdefault(gcr_rule, set()).add(child_rule)
    # Conflicts (symmetrical)
    cursor.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
    conflict_rows = cursor.fetchall()
    for (r1, r2, priority) in conflict_rows:
        adjacency.setdefault(r1, set()).add(r2)
        adjacency.setdefault(r2, set()).add(r1)
    # Composites: parse LOGIC_EXPR for references such as "RuleX"
    cursor.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    composite_rows = cursor.fetchall()
    pattern = re.compile(r"Rule(\d+)", re.IGNORECASE)
    for (composite_id, expr) in composite_rows:
        if expr:
            matches = pattern.findall(expr)
            for match in matches:
                try:
                    sub_rule = int(match)
                    adjacency.setdefault(sub_rule, set()).add(composite_id)
                except:
                    pass
    child_rule_ids = set(parent_mapping.keys())
    roots = [r for r in all_rule_ids if r not in child_rule_ids]
    return (adjacency, roots, parent_mapping)

def gather_all_related_rule_ids(conn, start_rule_id):
    """
    Perform a BFS from start_rule_id and return all reachable rule IDs.
    """
    adjacency, roots, parent_mapping = load_rule_relationships(conn)
    visited = set()
    queue = [start_rule_id]
    while queue:
        current = queue.pop(0)
        if current in visited:
            continue
        visited.add(current)
        if current in adjacency:
            for next_rule in adjacency[current]:
                if next_rule not in visited:
                    queue.append(next_rule)
    return visited

def execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=None, skip_data_validation=False, measure_perf=False):
    """
    Perform a BFS over the rule relationships (child, GCR, conflict, composite).
    If selected_rule_ids is provided, start from those; otherwise, start from root rules.
    If skip_data_validation is False, perform table-level validations before executing a rule.
    If measure_perf is True, log the execution time.
    
    Returns a tuple: (list of executed rule IDs, set of skipped rule IDs).
    """
    adjacency, roots, parent_mapping = load_rule_relationships(conn)
    rule_map = get_all_rules_map(conn)
    if not selected_rule_ids:
        queue = list(roots)
    else:
        queue = list(selected_rule_ids)
    executed = []
    skipped = set()
    start_time = time.time() if measure_perf else None
    while queue:
        rule_id = queue.pop(0)
        if rule_id in skipped:
            continue
        if rule_id not in rule_map:
            skipped.add(rule_id)
            continue
        rule_info = rule_map[rule_id]
        if not skip_data_validation:
            cursor2 = conn.cursor()
            cursor2.execute("""
                SELECT DATABASE_NAME, TABLE_NAME
                FROM BRM_RULE_TABLE_DEPENDENCIES
                WHERE RULE_ID=?
            """, (rule_id,))
            dependency_rows = cursor2.fetchall()
            validation_failed = False
            for (database_name, table_name) in dependency_rows:
                if not table_name:
                    continue
                full_table_name = (database_name + "." + table_name).lower()
                if not run_data_validations_for_table(conn, full_table_name):
                    validation_failed = True
                    break
            if validation_failed:
                skipped.add(rule_id)
                if rule_id in adjacency:
                    for child_rule in adjacency[rule_id]:
                        skip_descendants(child_rule, adjacency, skipped)
                continue
        (success, message, record_count, elapsed) = run_single_rule(conn, rule_info, is_dry_run=False)
        insert_performance_log(conn, rule_id, success, message, record_count, elapsed)
        if success:
            executed.append(rule_id)
            if rule_id in adjacency:
                for child_rule in adjacency[rule_id]:
                    if child_rule not in skipped:
                        queue.append(child_rule)
        else:
            is_critical = (rule_info["CRITICAL_RULE"] == 1 or rule_info["IS_GLOBAL"] == 1)
            critical_scope = (rule_info["CRITICAL_SCOPE"] or "NONE").upper()
            if is_critical and critical_scope != "NONE":
                if rule_id in adjacency:
                    for child_rule in adjacency[rule_id]:
                        skip_descendants(child_rule, adjacency, skipped)
            skipped.add(rule_id)
    if measure_perf and start_time is not None:
        total_elapsed = time.time() - start_time
        logger.debug(f"BFS performance: total elapsed time {total_elapsed:.4f} s")
    return (executed, skipped)

def skip_descendants(start_id, adjacency, skipped):
    """
    Recursively mark all descendant rules starting from start_id as skipped.
    """
    stack = [start_id]
    while stack:
        current = stack.pop()
        if current in skipped:
            continue
        skipped.add(current)
        if current in adjacency:
            for child in adjacency[current]:
                if child not in skipped:
                    stack.append(child)

def get_all_rules_map(conn):
    """
    Return a dictionary mapping RULE_ID to the full rule record.
    """
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES")
    rows = cursor.fetchall()
    colnames = [desc[0] for desc in cursor.description]
    rule_map = {}
    for row in rows:
        rule_data = dict(zip(colnames, row))
        rule_map[rule_data["RULE_ID"]] = rule_data
    return rule_map

def run_single_rule(conn, rule_info, is_dry_run=False):
    """
    Execute a single rule.
    If the rule returns a row whose first column equals 1, the rule passes.
    Rolls back if the rule fails or in dry-run mode.
    Returns a tuple: (success_flag, message, record_count, elapsed_seconds).
    """
    import time
    sql_statement = (rule_info.get("RULE_SQL", "") or "").strip()
    start_time = time.time()
    cursor = conn.cursor()
    cursor.execute("BEGIN TRANSACTION")
    success = False
    message = ""
    record_count = 0
    try:
        cursor.execute(sql_statement)
        rows = cursor.fetchall()
        if rows:
            record_count = len(rows)
            value = rows[0][0]
            success = (value == 1)
            message = f"Returned: {value}"
        else:
            success = True
            message = "No rows returned => PASS"
        if not success or is_dry_run:
            cursor.execute("ROLLBACK")
        else:
            cursor.execute("COMMIT")
    except Exception as ex:
        cursor.execute("ROLLBACK")
        success = False
        message = str(ex)
    elapsed = round(time.time() - start_time, 4)
    return (success, message, record_count, elapsed)

def insert_performance_log(conn, rule_id, pass_flag, message, record_count, elapsed):
    """
    Insert a performance log entry into RULE_EXECUTION_LOGS.
    """
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO RULE_EXECUTION_LOGS(
          RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS
        )
        VALUES (?, GETDATE(), ?, ?, ?, ?)
    """, (rule_id, 1 if pass_flag else 0, message, record_count, int(elapsed * 1000)))
    conn.commit()

# ---------------------------------------------------------------------------
# ADVANCED CRUD WITH LIFECYCLE + LOCK CHECKS
# ---------------------------------------------------------------------------
def add_rule(conn, rule_data, created_by_user_id, created_by_group):
    """
    Insert a new rule.
    Performs permission checks, parses dependencies, sets lifecycle to DRAFT,
    and triggers multi-step approvals.
    """
    rule_sql = rule_data.get("RULE_SQL", "").strip()
    if rule_sql:
        enforce_table_permissions_for_rule(conn, created_by_group, rule_sql)
    operation_type = detect_operation_type(rule_sql)
    dependencies = parse_sql_dependencies(rule_sql)
    cursor = conn.cursor()
    cursor.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE OWNER_GROUP=? AND RULE_NAME=?
    """, (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if cursor.fetchone():
        raise ValueError("Duplicate rule name in that group.")
    if rule_sql:
        cursor.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?", (rule_sql,))
        if cursor.fetchone():
            raise ValueError("A rule with the exact same SQL already exists.")
    if rule_data.get("IS_GLOBAL", 0) == 1 and created_by_group != "Admin":
        raise ValueError("Only Admin can create a global rule.")
    rule_data["LIFECYCLE_STATE"] = "DRAFT"
    now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    row = cursor.execute("""
        INSERT INTO BRM_RULES(
          GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID,
          RULE_NAME, RULE_SQL,
          EFFECTIVE_START_DATE, EFFECTIVE_END_DATE,
          STATUS, VERSION, CREATED_BY,
          DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
          CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP,
          APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE,
          CRITICAL_SCOPE, CDC_TYPE, LIFECYCLE_STATE
        )
        OUTPUT inserted.RULE_ID
        VALUES (?, ?, ?, ?, ?,
                ?, ?,
                ?, ?, ?,
                ?, ?, ?,
                ?, ?, ?,
                ?, ?, ?,
                ?, ?, ?)
    """, (
       rule_data.get("GROUP_ID"),
       rule_data.get("PARENT_RULE_ID"),
       rule_data["RULE_TYPE_ID"],
       rule_data["RULE_NAME"].strip(),
       rule_sql,
       rule_data["EFFECTIVE_START_DATE"],
       rule_data.get("EFFECTIVE_END_DATE"),
       rule_data.get("STATUS", "INACTIVE"),
       1,
       str(created_by_user_id),
       rule_data.get("DESCRIPTION", ""),
       operation_type,
       rule_data.get("BUSINESS_JUSTIFICATION", ""),
       now_str,
       None,
       rule_data["OWNER_GROUP"],
       "APPROVAL_IN_PROGRESS",
       rule_data.get("IS_GLOBAL", 0),
       rule_data.get("CRITICAL_RULE", 0),
       rule_data.get("CRITICAL_SCOPE", "NONE"),
       rule_data.get("CDC_TYPE", "NONE"),
       rule_data["LIFECYCLE_STATE"]
    )).fetchone()
    if not row:
        raise ValueError("Insert failed: no RULE_ID returned.")
    new_rule_id = row[0]
    column_operation = "READ" if operation_type == "SELECT" else "WRITE"
    for (schema, table, alias, is_subselect) in dependencies["tables"]:
        if table and not table.startswith("(CTE)"):
            database_name = schema if schema else "dbo"
            cursor.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES (?, ?, ?, ?, ?)
            """, (new_rule_id, database_name, table, "AutoCol", column_operation))
    insert_audit_log(conn, "INSERT", "BRM_RULES", new_rule_id, str(created_by_user_id), None, rule_data)
    conn.commit()
    create_multistep_approvals(conn, new_rule_id)
    return new_rule_id

def update_rule(conn, rule_data, updated_by_user_id, updated_by_group):
    """
    Update an existing rule.
    Checks for proper locking, re-parses dependencies, triggers re-approval,
    and increments the version.
    """
    rule_id = rule_data["RULE_ID"]
    lock_info = rule_current_lock_owner(conn, rule_id)
    if lock_info:
        if lock_info[0] != updated_by_user_id and updated_by_group != "Admin":
            raise ValueError(f"Rule {rule_id} is locked by user {lock_info[0]}; update not allowed.")
    else:
        if updated_by_group != "Admin":
            raise ValueError(f"Rule {rule_id} is not locked; update not allowed (unless admin).")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    colnames = [desc[0] for desc in cursor.description]
    old_data = dict(zip(colnames, old_row))
    if old_data["IS_GLOBAL"] == 1 and updated_by_group != "Admin":
        raise ValueError("Only Admin can update a global rule.")
    new_sql = rule_data.get("RULE_SQL", "").strip()
    if new_sql and new_sql != old_data["RULE_SQL"]:
        enforce_table_permissions_for_rule(conn, updated_by_group, new_sql)
        cursor.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?", (new_sql,))
        row2 = cursor.fetchone()
        if row2 and row2[0] != rule_id:
            raise ValueError("Another rule with identical SQL exists; update not allowed.")
    operation_type = detect_operation_type(new_sql)
    dependencies = parse_sql_dependencies(new_sql)
    cursor.execute("""
        UPDATE BRM_RULES
        SET GROUP_ID=?,
            PARENT_RULE_ID=?,
            RULE_TYPE_ID=?,
            RULE_NAME=?,
            RULE_SQL=?,
            EFFECTIVE_START_DATE=?,
            EFFECTIVE_END_DATE=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY=?,
            DESCRIPTION=?,
            OPERATION_TYPE=?,
            BUSINESS_JUSTIFICATION=?,
            OWNER_GROUP=?,
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
            IS_GLOBAL=?,
            CRITICAL_RULE=?,
            CRITICAL_SCOPE=?,
            CDC_TYPE=?,
            LIFECYCLE_STATE='UNDER_APPROVAL'
        WHERE RULE_ID=?
    """, (
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data.get("EFFECTIVE_START_DATE"),
        rule_data.get("EFFECTIVE_END_DATE"),
        str(updated_by_user_id),
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        operation_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rule_id
    ))
    conn.commit()
    cursor.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
    column_operation = "READ" if operation_type == "SELECT" else "WRITE"
    for (schema, table, alias, is_subselect) in dependencies["tables"]:
        if table and not table.startswith("(CTE)"):
            database_name = schema if schema else "dbo"
            cursor.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES (?, ?, ?, ?, ?)
            """, (rule_id, database_name, table, "AutoCol", column_operation))
    conn.commit()
    new_data = dict(old_data)
    new_data.update(rule_data)
    new_data["VERSION"] = old_data["VERSION"] + 1
    new_data["STATUS"] = "INACTIVE"
    new_data["LIFECYCLE_STATE"] = "UNDER_APPROVAL"
    insert_audit_log(conn, "UPDATE", "BRM_RULES", rule_id, str(updated_by_user_id), old_data, new_data)
    create_multistep_approvals(conn, rule_id)

def force_activate_rule(conn, rule_id, user_id, user_group):
    """
    Force-activate a rule by bypassing normal approval.
    Requires Admin or the lock owner.
    """
    if user_group != "Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info:
            raise ValueError(f"Rule {rule_id} is not locked; cannot force activate unless admin.")
        if lock_info[0] != user_id:
            raise ValueError(f"Rule {rule_id} is locked by {lock_info[0]}; force activation not allowed.")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    cursor.execute("""
        UPDATE BRM_RULES
        SET STATUS='ACTIVE',
            LIFECYCLE_STATE='ACTIVE',
            APPROVAL_STATUS='FORCE_ACTIVATED'
        WHERE RULE_ID=?
    """, (rule_id,))
    new_data = dict(old_data)
    new_data["STATUS"] = "ACTIVE"
    new_data["LIFECYCLE_STATE"] = "ACTIVE"
    new_data["APPROVAL_STATUS"] = "FORCE_ACTIVATED"
    insert_audit_log(conn, "FORCE_ACTIVATE", "BRM_RULES", rule_id, str(user_id), old_data, new_data)
    conn.commit()

def force_deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Force-deactivate a rule.
    Requires Admin or the lock owner.
    """
    if user_group != "Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info:
            raise ValueError(f"Rule {rule_id} is not locked; cannot force deactivate unless admin.")
        if lock_info[0] != user_id:
            raise ValueError(f"Rule {rule_id} is locked by {lock_info[0]}; force deactivation not allowed.")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    cursor.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE',
            LIFECYCLE_STATE='INACTIVE',
            APPROVAL_STATUS='FORCE_DEACTIVATED'
        WHERE RULE_ID=?
    """, (rule_id,))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["LIFECYCLE_STATE"] = "INACTIVE"
    new_data["APPROVAL_STATUS"] = "FORCE_DEACTIVATED"
    insert_audit_log(conn, "FORCE_DEACTIVATE", "BRM_RULES", rule_id, str(user_id), old_data, new_data)
    conn.commit()

def deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Deactivate a rule normally.
    Ensures the rule is fully approved, has no active child rules,
    and, for global rules, that the user is Admin.
    """
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    if old_data["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate: rule is not fully approved.")
    if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate a global rule.")
    if user_group != "Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info or lock_info[0] != user_id:
            raise ValueError("Rule is not locked by you; cannot deactivate.")
    cursor.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    if cursor.fetchone():
        raise ValueError("Deactivate child rules first; some are still active.")
    cursor.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE',
            UPDATED_BY=?,
            VERSION=VERSION+1,
            LIFECYCLE_STATE='INACTIVE'
        WHERE RULE_ID=?
    """, (str(user_id), rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old_data["VERSION"] + 1
    new_data["LIFECYCLE_STATE"] = "INACTIVE"
    insert_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, str(user_id), old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Delete a rule.
    The rule must be approved, inactive, and have no active children or references.
    """
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old_data["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete: rule is not fully approved.")
    if old_data["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be inactive before deletion.")
    if user_group != "Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info or lock_info[0] != action_by:
            raise ValueError("Rule is not locked by you; deletion not allowed.")
    cursor.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    if cursor.fetchone():
        raise ValueError("Child rules exist; remove them first.")
    cursor.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    if cursor.fetchone():
        raise ValueError("Remove references from BRM_COLUMN_MAPPING first.")
    cursor.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    insert_audit_log(conn, "DELETE", "BRM_RULES", rule_id, str(action_by), old_data, None)
    conn.commit()
    
# ──────────────────────────────────────────────
# End of PART 2
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 3 of 8 (SCHEDULING, SYNC METADATA, SIMULATIONS, ADVANCED TABS)
---------------------------------------------------------------------------
Builds on Parts 1 & 2:
  - Uses core components (logging, DB connection, SQL parsing, lock/unlock)
  - Uses advanced BFS logic, CRUD, validations, and multi-step approvals
This part includes:
  - sync_metadata_improved: Improved metadata synchronization from sys.tables to BRM_RULE_TABLE_DEPENDENCIES.
  - EnhancedScheduleDialog: UI for scheduling rule executions.
  - ScheduleManagementTab: Manage schedules stored in RULE_SCHEDULES.
  - Simulation functions for single-rule, chain, and custom-group BFS execution.
  - Simulation dialogs: SingleRuleSimulationDialog, ChainSimulationDialog, GroupSimulationDialog.
  - Advanced Feature Tabs:
      * DecisionTablesTab
      * ConflictPriorityManagerTab
      * CompositeRulesTab
      * SnapshotManagerTab
      * TagsManagerTab
      * DataValidationTab
      * WhatIfTestTab
No encryption references remain.
"""

import sys
import os
import json
import math
import csv
import logging
import time
import re
from datetime import datetime

from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QPushButton, QPlainTextEdit, QLineEdit, QCalendarWidget,
    QTableWidget, QTableWidgetItem, QListWidget, QListWidgetItem,
    QMessageBox, QInputDialog, QTextEdit, QFileDialog, QCheckBox
)
from PyQt5.QtCore import Qt, QDate, QTime
import pyqtgraph as pg

# ---------------------------------------------------------------------------
# SYNC METADATA (IMPROVED)
# ---------------------------------------------------------------------------
def sync_metadata_improved(conn):
    """
    Scans sys.tables and sys.columns to compare with BRM_RULE_TABLE_DEPENDENCIES.
    Marks missing dependencies by prepending 'MISSING_' to the table name,
    and updates the DATA_TYPE column if applicable.
    """
    cursor = conn.cursor()
    cursor.execute("""
        SELECT 
            s.name AS schema_name,
            t.name AS table_name,
            c.name AS column_name,
            typ.name AS data_type
        FROM sys.columns c
        JOIN sys.tables t ON c.object_id = t.object_id
        JOIN sys.schemas s ON t.schema_id = s.schema_id
        JOIN sys.types typ ON c.user_type_id = typ.user_type_id
        ORDER BY s.name, t.name, c.column_id
    """)
    actual_columns = []
    for row in cursor.fetchall():
        schema_name, table_name, column_name, data_type = row
        full_table = f"{schema_name}.{table_name}".lower()
        actual_columns.append((full_table, column_name.lower(), data_type.lower()))
    table_columns_map = {}
    for full_table, col_name, data_type in actual_columns:
        table_columns_map.setdefault(full_table, {})[col_name] = data_type

    cursor.execute("SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    dependencies = cursor.fetchall()
    missing_count = 0
    updated_data_type_count = 0
    for dep in dependencies:
        dep_id, db_name, tbl_name, col_name = dep
        full_table = f"{db_name}.{tbl_name}".lower().strip(".")
        if full_table not in table_columns_map:
            if not tbl_name.startswith("MISSING_"):
                cursor.execute("""
                    UPDATE BRM_RULE_TABLE_DEPENDENCIES
                    SET TABLE_NAME = 'MISSING_' + TABLE_NAME
                    WHERE DEPENDENCY_ID = ?
                """, (dep_id,))
                missing_count += 1
        else:
            if col_name:
                col_lower = col_name.lower()
                if col_lower in table_columns_map[full_table]:
                    data_type = table_columns_map[full_table][col_lower]
                    try:
                        cursor.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET DATA_TYPE = ? WHERE DEPENDENCY_ID = ?", (data_type, dep_id))
                        updated_data_type_count += 1
                    except Exception:
                        pass
    conn.commit()
    msg = (f"Metadata sync complete.\nFound {len(table_columns_map)} real tables.\n"
           f"Scanned {len(dependencies)} dependencies.\nMarked {missing_count} as missing.\n"
           f"Updated data type for {updated_data_type_count} dependencies.")
    QMessageBox.information(None, "Sync Metadata", msg)

# ---------------------------------------------------------------------------
# SCHEDULING
# ---------------------------------------------------------------------------
class EnhancedScheduleDialog(QDialog):
    """
    Dialog to schedule a rule execution.
    User selects a rule, date, time, and whether to run data validations.
    Inserts a new schedule into RULE_SCHEDULES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling (Part 3)")
        self.resize(420, 320)
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.rule_combo = QComboBox()
        cursor = self.connection.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_id} - {rule_name}"
            self.rule_combo.addItem(display, rule_id)
        form_layout.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setGridVisible(True)
        self.calendar.setSelectedDate(QDate.currentDate())
        form_layout.addRow("Select Date:", self.calendar)

        self.time_edit = QLineEdit()
        self.time_edit.setPlaceholderText("HH:mm:ss (24-hour format)")
        form_layout.addRow("Select Time:", self.time_edit)

        self.validation_checkbox = QCheckBox("Run Data Validations?")
        form_layout.addRow("Options:", self.validation_checkbox)

        layout.addLayout(form_layout)
        button_layout = QHBoxLayout()
        schedule_button = QPushButton("Schedule")
        schedule_button.clicked.connect(self.schedule_rule)
        button_layout.addWidget(schedule_button)
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close)
        button_layout.addWidget(close_button)
        layout.addLayout(button_layout)
        self.setLayout(layout)

    def schedule_rule(self):
        rule_id = self.rule_combo.currentData()
        selected_date = self.calendar.selectedDate()
        time_text = self.time_edit.text().strip()
        if not time_text:
            time_text = "00:00:00"
        q_time = QTime.fromString(time_text, "HH:mm:ss")
        if not q_time.isValid():
            QMessageBox.warning(self, "Invalid Time", "Please enter time in HH:mm:ss 24-hour format.")
            return
        datetime_str = f"{selected_date.toString('yyyy-MM-dd')} {q_time.toString('HH:mm:ss')}"
        cursor = self.connection.cursor()
        cursor.execute("""
            INSERT INTO RULE_SCHEDULES(
                RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, VALIDATION_FLAG
            )
            VALUES (?, ?, 'Scheduled', GETDATE(), ?)
        """, (rule_id, datetime_str, 1 if self.validation_checkbox.isChecked() else 0))
        self.connection.commit()
        QMessageBox.information(self, "Scheduled", f"Rule {rule_id} scheduled at {datetime_str}.")
        self.close()

class ScheduleManagementTab(QWidget):
    """
    Displays and manages rule schedules.
    Shows the top 1000 schedule entries with options to refresh, add, update, or delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 6)
        self.schedule_table.setHorizontalHeaderLabels(["ScheduleID", "RuleID", "ScheduleTime", "Status", "Validate?", "Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        button_layout = QHBoxLayout()
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_schedules)
        button_layout.addWidget(refresh_button)
        add_button = QPushButton("Add Schedule")
        add_button.clicked.connect(self.add_schedule)
        button_layout.addWidget(add_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT TOP 1000
                SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, VALIDATION_FLAG
            FROM RULE_SCHEDULES
            ORDER BY SCHEDULE_TIME DESC
        """)
        for row in cursor.fetchall():
            row_index = self.schedule_table.rowCount()
            self.schedule_table.insertRow(row_index)
            self.schedule_table.setItem(row_index, 0, QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(row_index, 1, QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(row_index, 2, QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(row_index, 3, QTableWidgetItem(str(row[3])))
            self.schedule_table.setItem(row_index, 4, QTableWidgetItem("Yes" if row[4] == 1 else "No"))
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            action_layout.setContentsMargins(0, 0, 0, 0)
            update_button = QPushButton("Update")
            update_button.clicked.connect(lambda _, r=row_index: self.update_schedule(r))
            action_layout.addWidget(update_button)
            delete_button = QPushButton("Delete")
            delete_button.clicked.connect(lambda _, r=row_index: self.delete_schedule(r))
            action_layout.addWidget(delete_button)
            action_layout.addStretch()
            self.schedule_table.setCellWidget(row_index, 5, action_widget)
        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_index):
        item = self.schedule_table.item(row_index, 0)
        if not item:
            return
        schedule_id = int(item.text())
        new_datetime, ok = QInputDialog.getText(self, "Update Schedule", "Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_datetime.strip():
            return
        cursor = self.connection.cursor()
        try:
            cursor.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?", (new_datetime.strip(), schedule_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {schedule_id} updated to {new_datetime}.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, row_index):
        item = self.schedule_table.item(row_index, 0)
        if not item:
            return
        schedule_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {schedule_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (schedule_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Schedule {schedule_id} removed.")
        self.load_schedules()

# ---------------------------------------------------------------------------
# SIMULATION FUNCTIONS
# ---------------------------------------------------------------------------
def simulate_single_rule_bfs(conn, rule_id, skip_data_validation=False):
    """
    Runs BFS simulation starting from a single rule.
    Relies on the BFS function from Part 2.
    """
    return execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=[rule_id], skip_data_validation=skip_data_validation, measure_perf=False)

def simulate_chain_bfs(conn, parent_rule_id, skip_data_validation=False):
    """
    Runs BFS simulation starting from a parent rule.
    """
    return execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=[parent_rule_id], skip_data_validation=skip_data_validation, measure_perf=False)

def simulate_custom_group_bfs(conn, custom_group_id, skip_data_validation=False):
    """
    Runs BFS simulation for all rules in a custom group.
    """
    cursor = conn.cursor()
    cursor.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rows = cursor.fetchall()
    if not rows:
        return ([], set())
    group_rules = [r[0] for r in rows]
    return execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=group_rules, skip_data_validation=skip_data_validation, measure_perf=False)

# ---------------------------------------------------------------------------
# SIMULATION DIALOGS
# ---------------------------------------------------------------------------
class SingleRuleSimulationDialog(QDialog):
    """
    Dialog to simulate a single rule execution using BFS.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Single Rule Simulation (Part 3)")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        self.rule_combo = QComboBox()
        cursor = self.connection.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_id} - {rule_name}"
            self.rule_combo.addItem(display, rule_id)
        form_layout.addRow("Select Rule:", self.rule_combo)
        self.skip_validation_cb = QCheckBox("Skip Data Validations?")
        form_layout.addRow(self.skip_validation_cb)
        layout.addLayout(form_layout)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        button_layout = QHBoxLayout()
        run_button = QPushButton("Run BFS Simulation")
        run_button.clicked.connect(self.run_simulation)
        button_layout.addWidget(run_button)
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close)
        button_layout.addWidget(close_button)
        layout.addLayout(button_layout)
        self.setLayout(layout)
    def run_simulation(self):
        rule_id = self.rule_combo.currentData()
        skip_validation = self.skip_validation_cb.isChecked()
        executed, skipped = simulate_single_rule_bfs(self.connection, rule_id, skip_validation)
        result = f"Executed: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(result)

class ChainSimulationDialog(QDialog):
    """
    Dialog to simulate BFS starting from a parent rule.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation (Part 3)")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        self.parent_combo = QComboBox()
        cursor = self.connection.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_id} - {rule_name}"
            self.parent_combo.addItem(display, rule_id)
        form_layout.addRow("Parent Rule:", self.parent_combo)
        self.skip_validation_cb = QCheckBox("Skip Data Validations?")
        form_layout.addRow(self.skip_validation_cb)
        layout.addLayout(form_layout)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        button_layout = QHBoxLayout()
        simulate_button = QPushButton("Simulate BFS Chain")
        simulate_button.clicked.connect(self.run_simulation)
        button_layout.addWidget(simulate_button)
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close)
        button_layout.addWidget(close_button)
        layout.addLayout(button_layout)
        self.setLayout(layout)
    def run_simulation(self):
        parent_rule_id = self.parent_combo.currentData()
        skip_validation = self.skip_validation_cb.isChecked()
        executed, skipped = simulate_chain_bfs(self.connection, parent_rule_id, skip_validation)
        result = f"Chain BFS starting from {parent_rule_id}\nExecuted: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(result)

class GroupSimulationDialog(QDialog):
    """
    Dialog to simulate BFS for a custom group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation (Part 3)")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        self.group_combo = QComboBox()
        cursor = self.connection.cursor()
        cursor.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for group_id, group_name in cursor.fetchall():
            display = f"{group_id} - {group_name}"
            self.group_combo.addItem(display, group_id)
        form_layout.addRow("Custom Group:", self.group_combo)
        self.skip_validation_cb = QCheckBox("Skip Data Validations?")
        form_layout.addRow(self.skip_validation_cb)
        layout.addLayout(form_layout)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        button_layout = QHBoxLayout()
        simulate_button = QPushButton("Simulate BFS Group")
        simulate_button.clicked.connect(self.run_simulation)
        button_layout.addWidget(simulate_button)
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close)
        button_layout.addWidget(close_button)
        layout.addLayout(button_layout)
        self.setLayout(layout)
    def run_simulation(self):
        group_id = self.group_combo.currentData()
        skip_validation = self.skip_validation_cb.isChecked()
        executed, skipped = simulate_custom_group_bfs(self.connection, group_id, skip_validation)
        result = f"Group BFS for group {group_id}\nExecuted: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(result)

# ---------------------------------------------------------------------------
# ADVANCED FEATURE TABS
# ---------------------------------------------------------------------------
class DecisionTablesTab(QWidget):
    """
    Manages decision tables.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.decision_table = QTableWidget(0, 3)
        self.decision_table.setHorizontalHeaderLabels(["DecisionTableID", "TableName", "Description"])
        layout.addWidget(self.decision_table)
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add DecisionTable")
        add_button.clicked.connect(self.add_decision_table)
        button_layout.addWidget(add_button)
        delete_button = QPushButton("Delete DecisionTable")
        delete_button.clicked.connect(self.delete_decision_table)
        button_layout.addWidget(delete_button)
        run_button = QPushButton("Run DecisionTable")
        run_button.clicked.connect(self.run_decision_table)
        button_layout.addWidget(run_button)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_decision_tables)
        button_layout.addWidget(refresh_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_decision_tables()
    def load_decision_tables(self):
        self.decision_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in cursor.fetchall():
            row_index = self.decision_table.rowCount()
            self.decision_table.insertRow(row_index)
            for col_index, val in enumerate(row):
                self.decision_table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val else ""))
    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add DecisionTable", "TableName:")
        if not ok or not name.strip():
            return
        description, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            description = ""
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES (?, ?)", (name.strip(), description.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Decision table created.")
        self.load_decision_tables()
    def delete_decision_table(self):
        row = self.decision_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        item = self.decision_table.item(row, 0)
        dt_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete decision table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Decision table removed.")
        self.load_decision_tables()
    def run_decision_table(self):
        row = self.decision_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        item = self.decision_table.item(row, 0)
        dt_id = int(item.text())
        QMessageBox.information(self, "Run DecisionTable", f"DecisionTable {dt_id} executed (stub).")

class ConflictPriorityManagerTab(QWidget):
    """
    Manages rule conflicts.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.conflict_table = QTableWidget(0, 4)
        self.conflict_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.conflict_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.conflict_table)
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add Conflict")
        add_button.clicked.connect(self.add_conflict)
        button_layout.addWidget(add_button)
        set_priority_button = QPushButton("Set Priority")
        set_priority_button.clicked.connect(self.set_conflict_priority)
        button_layout.addWidget(set_priority_button)
        delete_button = QPushButton("Delete Conflict")
        delete_button.clicked.connect(self.delete_conflict)
        button_layout.addWidget(delete_button)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_conflicts)
        button_layout.addWidget(refresh_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_conflicts()
    def load_conflicts(self):
        self.conflict_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        for row in cursor.fetchall():
            row_index = self.conflict_table.rowCount()
            self.conflict_table.insertRow(row_index)
            for col_index, val in enumerate(row):
                self.conflict_table.setItem(row_index, col_index, QTableWidgetItem(str(val)))
    def add_conflict(self):
        rule1, ok = QInputDialog.getInt(self, "Add Conflict", "RuleID1:")
        if not ok:
            return
        rule2, ok2 = QInputDialog.getInt(self, "Add Conflict", "RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Enter integer priority:")
        if not ok3:
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES (?, ?, ?)", (rule1, rule2, priority))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Conflict inserted.")
        self.load_conflicts()
    def set_conflict_priority(self):
        row = self.conflict_table.currentRow()
        if row < 0:
            return
        conflict_item = self.conflict_table.item(row, 0)
        if not conflict_item:
            return
        conflict_id = int(conflict_item.text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {conflict_id}:")
        if not ok:
            return
        cursor = self.connection.cursor()
        cursor.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_priority, conflict_id))
        self.connection.commit()
        QMessageBox.information(self, "Updated", "Conflict priority updated.")
        self.load_conflicts()
    def delete_conflict(self):
        row = self.conflict_table.currentRow()
        if row < 0:
            return
        item = self.conflict_table.item(row, 0)
        if not item:
            return
        conflict_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {conflict_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (conflict_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Conflict removed.")
        self.load_conflicts()

class CompositeRulesTab(QWidget):
    """
    Manages composite rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.composite_table = QTableWidget(0, 4)
        self.composite_table.setHorizontalHeaderLabels(["CompositeRuleID", "CompositeName", "LogicExpr", "ActionOnPass"])
        self.composite_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.composite_table)
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add Composite Rule")
        add_button.clicked.connect(self.add_composite_rule)
        button_layout.addWidget(add_button)
        delete_button = QPushButton("Delete Composite")
        delete_button.clicked.connect(self.delete_composite_rule)
        button_layout.addWidget(delete_button)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_composites)
        button_layout.addWidget(refresh_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_composites()
    def load_composites(self):
        self.composite_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        for row in cursor.fetchall():
            row_index = self.composite_table.rowCount()
            self.composite_table.insertRow(row_index)
            for col_index, val in enumerate(row):
                self.composite_table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val else ""))
    def add_composite_rule(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Composite Name:")
        if not ok or not name.strip():
            return
        logic_expr, ok2 = QInputDialog.getText(self, "Logic Expression", "Enter logic expression (e.g., 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            logic_expr = ""
        action_on_pass, ok3 = QInputDialog.getText(self, "Action On Pass", "Optional action (e.g., 'SendEmail'):")
        if not ok3:
            action_on_pass = ""
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS) VALUES (?, ?, ?)", (name.strip(), logic_expr.strip(), action_on_pass.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Composite rule created.")
        self.load_composites()
    def delete_composite_rule(self):
        row = self.composite_table.currentRow()
        if row < 0:
            return
        item = self.composite_table.item(row, 0)
        if not item:
            return
        composite_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {composite_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (composite_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Composite rule removed.")
        self.load_composites()

class SnapshotManagerTab(QWidget):
    """
    Manages snapshots of the BRM_RULES table stored as JSON.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.snapshot_table = QTableWidget(0, 5)
        self.snapshot_table.setHorizontalHeaderLabels(["SnapshotID", "SnapshotName", "CreatedBy", "CreatedTimestamp", "SnapshotJSON"])
        self.snapshot_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.snapshot_table)
        button_layout = QHBoxLayout()
        take_button = QPushButton("Take Snapshot")
        take_button.clicked.connect(self.take_snapshot)
        button_layout.addWidget(take_button)
        delete_button = QPushButton("Delete Snapshot")
        delete_button.clicked.connect(self.delete_snapshot)
        button_layout.addWidget(delete_button)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_snapshots)
        button_layout.addWidget(refresh_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_snapshots()
    def load_snapshots(self):
        self.snapshot_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
            FROM RULE_SNAPSHOTS
            ORDER BY SNAPSHOT_ID DESC
        """)
        for row in cursor.fetchall():
            row_index = self.snapshot_table.rowCount()
            self.snapshot_table.insertRow(row_index)
            for col_index, val in enumerate(row):
                self.snapshot_table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val else ""))
    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Snapshot Name:")
        if not ok or not name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM BRM_RULES")
        rows = cursor.fetchall()
        columns = [desc[0] for desc in cursor.description]
        snapshot_data = [dict(zip(columns, r)) for r in rows]
        snapshot_json = json.dumps(snapshot_data, indent=2)
        cursor.execute("""
            INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
            VALUES (?, 'SnapshotUser', ?)
        """, (name.strip(), snapshot_json))
        self.connection.commit()
        QMessageBox.information(self, "Snapshot", "Snapshot created.")
        self.load_snapshots()
    def delete_snapshot(self):
        row = self.snapshot_table.currentRow()
        if row < 0:
            return
        item = self.snapshot_table.item(row, 0)
        if not item:
            return
        snapshot_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snapshot_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snapshot_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Snapshot removed.")
        self.load_snapshots()

class TagsManagerTab(QWidget):
    """
    Manages textual tags associated with rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add Tag")
        add_button.clicked.connect(self.add_tag)
        button_layout.addWidget(add_button)
        remove_button = QPushButton("Remove Tag")
        remove_button.clicked.connect(self.remove_tag)
        button_layout.addWidget(remove_button)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_tags)
        button_layout.addWidget(refresh_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_tags()
    def load_tags(self):
        self.tags_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        for row in cursor.fetchall():
            row_index = self.tags_table.rowCount()
            self.tags_table.insertRow(row_index)
            for col_index, val in enumerate(row):
                self.tags_table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val else ""))
    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "Rule ID:")
        if not ok:
            return
        tag_name, ok2 = QInputDialog.getText(self, "Tag", "Tag Name:")
        if not ok2 or not tag_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES (?, ?)", (rule_id, tag_name.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Tag assigned.")
        self.load_tags()
    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            return
        item = self.tags_table.item(row, 0)
        if not item:
            return
        tag_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Tag removed.")
        self.load_tags()

class DataValidationTab(QWidget):
    """
    Manages data validation rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.validation_table = QTableWidget(0, 5)
        self.validation_table.setHorizontalHeaderLabels(["ValidationID", "TableName", "ColumnName", "ValidationType", "Params"])
        self.validation_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.validation_table)
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add Validation")
        add_button.clicked.connect(self.add_validation)
        button_layout.addWidget(add_button)
        remove_button = QPushButton("Remove Validation")
        remove_button.clicked.connect(self.remove_validation)
        button_layout.addWidget(remove_button)
        run_button = QPushButton("Run All Validations")
        run_button.clicked.connect(self.run_all_validations)
        button_layout.addWidget(run_button)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_validations)
        button_layout.addWidget(refresh_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_validations()
    def load_validations(self):
        self.validation_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
            ORDER BY VALIDATION_ID
        """)
        for row in cursor.fetchall():
            row_index = self.validation_table.rowCount()
            self.validation_table.insertRow(row_index)
            for col_index, val in enumerate(row):
                self.validation_table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val else ""))
    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Table Name (e.g., 'dbo.Customers'):")
        if not ok or not table_name.strip():
            return
        column_name, ok2 = QInputDialog.getText(self, "Column", "Column Name:")
        if not ok2 or not column_name.strip():
            return
        validation_type, ok3 = QInputDialog.getText(self, "Validation Type", "Validation Type (e.g., 'NOT NULL', 'RANGE', 'REGEX'):")
        if not ok3 or not validation_type.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "Optional parameters (e.g., '0,100'):")
        if not ok4:
            params = ""
        cursor = self.connection.cursor()
        cursor.execute("""
            INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS)
            VALUES (?, ?, ?, ?)
        """, (table_name.strip(), column_name.strip(), validation_type.strip(), params.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Data validation rule added.")
        self.load_validations()
    def remove_validation(self):
        row = self.validation_table.currentRow()
        if row < 0:
            return
        item = self.validation_table.item(row, 0)
        if not item:
            return
        validation_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation {validation_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (validation_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Validation removed.")
        self.load_validations()
    def run_all_validations(self):
        cursor = self.connection.cursor()
        cursor.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        tables = cursor.fetchall()
        failed_tables = []
        for (table_name,) in tables:
            if table_name:
                passed = run_data_validations_for_table(self.connection, table_name.lower())
                if not passed:
                    failed_tables.append(table_name)
        if failed_tables:
            QMessageBox.warning(self, "Validation Results", f"Validations failed for: {failed_tables}")
        else:
            QMessageBox.information(self, "Validation Results", "All validations passed.")

class WhatIfTestTab(QWidget):
    """
    Provides What-If testing for rules.
    Allows selecting a rule, choosing BFS or single-run execution,
    uploading a CSV (stub), and displays the results.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.csv_path = None
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        cursor = self.connection.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_id} - {rule_name}"
            self.rule_combo.addItem(display, rule_id)
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)
        self.bfs_checkbox = QCheckBox("Use BFS Execution?")
        top_layout.addWidget(self.bfs_checkbox)
        self.skip_validation_checkbox = QCheckBox("Skip Validations?")
        top_layout.addWidget(self.skip_validation_checkbox)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        mid_layout = QHBoxLayout()
        upload_button = QPushButton("Upload CSV")
        upload_button.clicked.connect(self.upload_csv)
        mid_layout.addWidget(upload_button)
        run_button = QPushButton("Run Test")
        run_button.clicked.connect(self.run_test)
        mid_layout.addWidget(run_button)
        mid_layout.addStretch()
        layout.addLayout(mid_layout)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        self.setLayout(layout)
    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        self.csv_path = path
        QMessageBox.information(self, "Uploaded", f"CSV {path} selected (stub).")
    def run_test(self):
        rule_id = self.rule_combo.currentData()
        use_bfs = self.bfs_checkbox.isChecked()
        skip_validation = self.skip_validation_checkbox.isChecked()
        if use_bfs:
            executed, skipped = execute_rules_with_conflicts_composites_bfs(self.connection, selected_rule_ids=[rule_id], skip_data_validation=skip_validation, measure_perf=False)
            result = f"BFS: Executed: {executed}\nSkipped: {list(skipped)}\nCSV: {self.csv_path if self.csv_path else 'None'}"
        else:
            cursor = self.connection.cursor()
            cursor.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = cursor.fetchone()
            if not row:
                self.result_text.setPlainText(f"Rule {rule_id} not found.")
                return
            sql_statement = row[0]
            if not skip_validation:
                cursor2 = self.connection.cursor()
                cursor2.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
                for (db_name, tbl_name) in cursor2.fetchall():
                    if tbl_name:
                        full_table = (db_name + "." + tbl_name).lower()
                        if not run_data_validations_for_table(self.connection, full_table):
                            self.result_text.setPlainText(f"Data validation failed for {full_table}.")
                            return
            from time import perf_counter
            start_time = perf_counter()
            success = False
            message = ""
            record_count = 0
            cursor.execute("BEGIN TRANSACTION")
            try:
                cursor.execute(sql_statement)
                rows = cursor.fetchall()
                if rows:
                    record_count = len(rows)
                    success = (rows[0][0] == 1)
                    message = f"Returned: {rows[0][0]}"
                else:
                    success = True
                    message = "No rows returned => PASS"
                cursor.execute("ROLLBACK")
            except Exception as ex:
                cursor.execute("ROLLBACK")
                success = False
                message = str(ex)
            elapsed_ms = int((perf_counter() - start_time) * 1000)
            result = f"Single Run: Success={success}, Message={message}, Record Count={record_count}, Time={elapsed_ms} ms\nCSV: {self.csv_path if self.csv_path else 'None'}"
        self.result_text.setPlainText(result)

# ──────────────────────────────────────────────
# End of PART 3
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 4 of 8 (AUDIT LOG VIEWER, RULE SEARCH, VERSION HISTORY, RULE DASHBOARD, RULE EDITOR)
---------------------------------------------------------------------------------------------
Builds on:
  - Part 1: Core imports, DB connection, lock/unlock, SQL parsing.
  - Part 2: BFS logic, advanced CRUD, data validations.
  - Part 3: Scheduling, sync metadata, simulations.
Includes:
  - AuditLogViewer: Extended audit log viewer with search and CSV export.
  - RuleSearchDialog: Search rules by name, SQL snippet, or tags.
  - VersionHistoryDialog: Display version history with line-by-line diff and rollback.
  - RuleDashboard: Paginated dashboard showing rule details and performance metrics.
  - RuleEditorDialog: Dialog to add/update rules with integrated lock/unlock support.
"""

import sys
import json
import csv
import difflib
from datetime import datetime

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QLineEdit, QMessageBox, QFileDialog, QPlainTextEdit,
    QInputDialog, QComboBox, QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox,
    QWidget
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

# Note: This part assumes that functions such as fetch_one_dict, fetch_all_dict, insert_audit_log,
# parse_sql_dependencies, detect_operation_type, rule_current_lock_owner, lock_rule_for_edit,
# unlock_rule_for_edit, add_rule, update_rule, delete_rule, and constants like RULE_LIFECYCLE_STATES
# are defined in Part 1 and Part 2.

# ---------------------------------------------------------------------------
# AUDIT LOG VIEWER
# ---------------------------------------------------------------------------
class AuditLogViewer(QDialog):
    """
    Displays audit logs from BRM_AUDIT_LOG with search functionality and CSV export.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs (Part 4)")
        self.resize(900, 600)
        main_layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search in action, table, actor, or old/new data...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        main_layout.addLayout(top_layout)

        self.log_table = QTableWidget(0, 8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID", "Action", "Table", "RecordID", "ActionBy", "OldData", "NewData", "Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.log_table)

        button_layout = QHBoxLayout()
        refresh_button = QPushButton("Refresh Logs")
        refresh_button.clicked.connect(self.load_logs)
        button_layout.addWidget(refresh_button)
        export_button = QPushButton("Export CSV")
        export_button.clicked.connect(self.export_csv)
        button_layout.addWidget(export_button)
        button_layout.addStretch()
        main_layout.addLayout(button_layout)

        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT TOP 1000
                AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
        """)
        for row in cursor.fetchall():
            row_index = self.log_table.rowCount()
            self.log_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                # Parse JSON for old/new data if available
                if col_index in (5, 6) and value:
                    try:
                        parsed_data = json.loads(value)
                        value = json.dumps(parsed_data, indent=2)
                    except Exception:
                        pass
                item = QTableWidgetItem(str(value) if value is not None else "")
                # Highlight certain actions
                if col_index == 1:
                    action_text = (str(value) or "").upper()
                    if action_text in ("DELETE", "REJECT", "FORCE_DEACTIVATE"):
                        item.setBackground(QColor(255, 215, 0))
                self.log_table.setItem(row_index, col_index, item)
        self.log_table.resizeColumnsToContents()

    def perform_search(self, text):
        search_text = text.lower()
        for row in range(self.log_table.rowCount()):
            row_visible = False
            for col in range(self.log_table.columnCount()):
                item = self.log_table.item(row, col)
                if item and search_text in item.text().lower():
                    row_visible = True
                    break
            self.log_table.setRowHidden(row, not row_visible)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Audit Logs CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row):
                    continue
                row_data = []
                for col in range(self.log_table.columnCount()):
                    item = self.log_table.item(row, col)
                    row_data.append(item.text() if item else "")
                writer.writerow(row_data)
        QMessageBox.information(self, "Exported", f"Audit logs exported to {path}.")

# ---------------------------------------------------------------------------
# RULE SEARCH DIALOG
# ---------------------------------------------------------------------------
class RuleSearchDialog(QDialog):
    """
    Dialog for searching rules by name, SQL snippet, or tags.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules (Part 4)")
        self.resize(900, 600)
        main_layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Name, SQL snippet, or tag...")
        self.search_edit.textChanged.connect(self.load_results)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        main_layout.addLayout(top_layout)

        self.result_table = QTableWidget(0, 8)
        self.result_table.setHorizontalHeaderLabels([
            "RuleID", "Name", "SQL", "Status", "Version", "OwnerGroup", "Tags", "CreatedBy"
        ])
        self.result_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.result_table)

        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_results)
        main_layout.addWidget(refresh_button)

        self.setLayout(main_layout)
        self.load_results()

    def load_results(self):
        search_text = self.search_edit.text().strip()
        cursor = self.connection.cursor()
        if search_text:
            cursor.execute("""
                SELECT DISTINCT TOP 1000
                    R.RULE_ID, R.RULE_NAME, R.RULE_SQL, R.STATUS,
                    R.VERSION, R.OWNER_GROUP,
                    (SELECT STRING_AGG(T.TAG_NAME, ',') FROM RULE_TAGS T WHERE T.RULE_ID = R.RULE_ID) AS TAGS,
                    R.CREATED_BY
                FROM BRM_RULES R
                LEFT JOIN RULE_TAGS TT ON TT.RULE_ID = R.RULE_ID
                WHERE (R.RULE_NAME LIKE ? OR R.RULE_SQL LIKE ? OR TT.TAG_NAME LIKE ?)
                ORDER BY R.RULE_ID DESC
            """, (f"%{search_text}%", f"%{search_text}%", f"%{search_text}%"))
        else:
            cursor.execute("""
                SELECT TOP 1000
                    R.RULE_ID, R.RULE_NAME, R.RULE_SQL, R.STATUS,
                    R.VERSION, R.OWNER_GROUP,
                    (SELECT STRING_AGG(T.TAG_NAME, ',') FROM RULE_TAGS T WHERE T.RULE_ID = R.RULE_ID) AS TAGS,
                    R.CREATED_BY
                FROM BRM_RULES R
                ORDER BY R.RULE_ID DESC
            """)
        self.result_table.setRowCount(0)
        for row in cursor.fetchall():
            row_index = self.result_table.rowCount()
            self.result_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                self.result_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value else ""))
        self.result_table.resizeColumnsToContents()

# ---------------------------------------------------------------------------
# VERSION HISTORY DIALOG
# ---------------------------------------------------------------------------
class VersionHistoryDialog(QDialog):
    """
    Displays the version history for a rule with options for diff and rollback.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(900, 500)
        main_layout = QVBoxLayout(self)
        self.history_table = QTableWidget(0, 6)
        self.history_table.setHorizontalHeaderLabels([
            "AuditID", "Action", "Timestamp", "OldData", "NewData", "Compare"
        ])
        self.history_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.history_table)
        button_layout = QHBoxLayout()
        rollback_button = QPushButton("Rollback Selected")
        rollback_button.clicked.connect(self.rollback_version)
        button_layout.addWidget(rollback_button)
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.close)
        button_layout.addWidget(close_button)
        main_layout.addLayout(button_layout)
        self.setLayout(main_layout)
        self.load_history()

    def load_history(self):
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
            FROM BRM_AUDIT_LOG
            WHERE TABLE_NAME = 'BRM_RULES' AND RECORD_ID = ? AND ACTION IN ('INSERT', 'UPDATE')
            ORDER BY ACTION_TIMESTAMP DESC
        """, (self.rule_id,))
        self.history_table.setRowCount(0)
        for row in cursor.fetchall():
            row_index = self.history_table.rowCount()
            self.history_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                if col_index in (3, 4) and value:
                    try:
                        parsed_data = json.loads(value)
                        value = json.dumps(parsed_data, indent=2)
                    except Exception:
                        pass
                self.history_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value else ""))
            compare_button = QPushButton("Diff")
            compare_button.clicked.connect(lambda _, r=row_index: self.show_diff(r))
            self.history_table.setCellWidget(row_index, 5, compare_button)

    def show_diff(self, row_index):
        old_item = self.history_table.item(row_index, 3)
        new_item = self.history_table.item(row_index, 4)
        old_text = old_item.text() if old_item else ""
        new_text = new_item.text() if new_item else ""
        diff_lines = list(difflib.unified_diff(
            old_text.splitlines(), new_text.splitlines(),
            fromfile="old_data", tofile="new_data", lineterm=''
        ))
        diff_text = "\n".join(diff_lines)
        diff_dialog = QDialog(self)
        diff_dialog.setWindowTitle("Line-by-Line Diff")
        diff_dialog.resize(800, 600)
        layout = QVBoxLayout(diff_dialog)
        diff_edit = QPlainTextEdit()
        diff_edit.setReadOnly(True)
        diff_edit.setPlainText(diff_text)
        layout.addWidget(diff_edit)
        close_button = QPushButton("Close")
        close_button.clicked.connect(diff_dialog.close)
        layout.addWidget(close_button)
        diff_dialog.setLayout(layout)
        diff_dialog.exec_()

    def rollback_version(self):
        selected_items = self.history_table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "No row selected for rollback.")
            return
        row_index = selected_items[0].row()
        old_item = self.history_table.item(row_index, 3)
        if not old_item:
            QMessageBox.warning(self, "Missing Data", "No old_data available for rollback.")
            return
        old_data_text = old_item.text().strip()
        if not old_data_text:
            QMessageBox.warning(self, "No Data", "No old_data to rollback to.")
            return
        confirm = QMessageBox.question(self, "Confirm Rollback", "Rollback to this version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_data_text)
        except Exception as ex:
            QMessageBox.critical(self, "JSON Error", str(ex))
            return
        if self.perform_force_rollback(old_data):
            QMessageBox.information(self, "Rolled Back", "Rule successfully rolled back.")
            self.load_history()
        else:
            QMessageBox.warning(self, "Rollback Failed", "Rollback failed or not allowed.")

    def perform_force_rollback(self, old_data):
        rule_id = old_data.get("RULE_ID")
        if not rule_id:
            return False
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = cursor.fetchone()
        if not row:
            return False
        old_sql = old_data.get("RULE_SQL", "")
        operation_type = detect_operation_type(old_sql)
        dependencies = parse_sql_dependencies(old_sql)
        cursor.execute("BEGIN TRANSACTION")
        try:
            cursor.execute("""
                UPDATE BRM_RULES
                SET RULE_NAME = ?,
                    RULE_SQL = ?,
                    OWNER_GROUP = ?,
                    STATUS = 'INACTIVE',
                    VERSION = VERSION + 1,
                    UPDATED_BY = 'Rollback',
                    APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
                    LIFECYCLE_STATE = 'UNDER_APPROVAL'
                WHERE RULE_ID = ?
            """, (old_data.get("RULE_NAME", "RolledBack"), old_sql, old_data.get("OWNER_GROUP", "BG1"), rule_id))
            cursor.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
            col_op = "READ" if operation_type == "SELECT" else "WRITE"
            for (schema, table, alias, is_subselect) in dependencies["tables"]:
                if table and not table.startswith("(CTE)"):
                    db_name = schema if schema else "dbo"
                    cursor.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                            RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                        )
                        VALUES (?, ?, ?, ?, ?)
                    """, (rule_id, db_name, table, "RolledBackCol", col_op))
            cursor.execute("COMMIT")
            return True
        except Exception:
            cursor.execute("ROLLBACK")
            return False

# ---------------------------------------------------------------------------
# RULE DASHBOARD
# ---------------------------------------------------------------------------
class RuleDashboard(QGroupBox):
    """
    Displays a paginated table of rules with filtering, lock status, performance metrics, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        self.search_edit.textChanged.connect(self.load_rules)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_layout.addWidget(QLabel("Status:"))
        top_layout.addWidget(self.status_filter)
        main_layout.addLayout(top_layout)

        self.rule_table = QTableWidget(0, 10)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "Name", "SQL", "Status", "Version", "OwnerGroup",
            "LockStatus", "Perf(ms avg)", "CreatedTS", "ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.rule_table)

        nav_layout = QHBoxLayout()
        self.prev_button = QPushButton("Previous")
        self.prev_button.clicked.connect(self.prev_page)
        self.page_label = QLabel("Page 1/1")
        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.next_page)
        nav_layout.addWidget(self.prev_button)
        nav_layout.addWidget(self.page_label)
        nav_layout.addWidget(self.next_button)
        nav_layout.addStretch()
        main_layout.addLayout(nav_layout)
        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_button.clicked.connect(self.prev_page)
        self.next_button.clicked.connect(self.next_page)
        self.load_rules()

    def build_filter_clause(self):
        filters = []
        parameters = []
        search_text = self.search_edit.text().strip()
        if search_text:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            parameters.extend([f"%{search_text}%", f"%{search_text}%"])
        status_value = self.status_filter.currentData()
        if status_value:
            filters.append("STATUS = ?")
            parameters.append(status_value)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, parameters

    def load_rules(self):
        cursor = self.connection.cursor()
        clause, parameters = self.build_filter_clause()
        count_query = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        cursor.execute(count_query, parameters)
        total_records = cursor.fetchone()[0]
        self.total_pages = max(1, math.ceil(total_records / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        if self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page
        data_query = f"""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
                   LOCK_STATUS, PERF_MS_AVG, CREATED_TIMESTAMP, APPROVAL_STATUS
            FROM BRM_RULES
            WHERE {clause}
            ORDER BY RULE_ID DESC
            OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        cursor.execute(data_query, (*parameters, offset, self.records_per_page))
        self.rule_table.setRowCount(0)
        for row in cursor.fetchall():
            row_index = self.rule_table.rowCount()
            self.rule_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                item = QTableWidgetItem(str(value) if value is not None else "")
                if col_index == 6 and value and str(value).upper() == "LOCKED":
                    item.setBackground(QColor(255, 160, 160))
                self.rule_table.setItem(row_index, col_index, item)
        self.rule_table.resizeColumnsToContents()

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

    def get_selected_rule_ids(self):
        selected_indexes = self.rule_table.selectionModel().selectedRows()
        rule_ids = []
        for index in selected_indexes:
            row = index.row()
            item = self.rule_table.item(row, 0)
            if item:
                rule_ids.append(int(item.text()))
        return rule_ids

# ---------------------------------------------------------------------------
# RULE EDITOR DIALOG
# ---------------------------------------------------------------------------
class RuleEditorDialog(QDialog):
    """
    Dialog for adding or updating a rule.
    Incorporates lock/unlock logic, table permission checks, and multi-step approval triggering.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = (rule_data is not None)
        self.rule_locked = False

        title = "Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(f"{title} (Part 4)")
        self.resize(850, 650)
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.group_combo = QComboBox()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        for group_id, group_name in cursor.fetchall():
            display = f"{group_name} (ID={group_id})"
            self.group_combo.addItem(display, group_id)
        form_layout.addRow("Rule Group:", self.group_combo)

        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_name} (ID={rule_id})"
            self.parent_combo.addItem(display, rule_id)
        form_layout.addRow("Parent Rule:", self.parent_combo)

        self.name_edit = QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        self.rule_type_combo = QComboBox()
        cursor.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for rule_type_id, rule_type_name in cursor.fetchall():
            self.rule_type_combo.addItem(rule_type_name, rule_type_id)
        form_layout.addRow("Rule Type:", self.rule_type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE", "ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        self.start_datetime_edit = QDateTimeEdit()
        self.start_datetime_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_datetime_edit.setCalendarPopup(True)
        form_layout.addRow("Effective Start:", self.start_datetime_edit)

        self.end_datetime_edit = QDateTimeEdit()
        self.end_datetime_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_datetime_edit.setCalendarPopup(True)
        form_layout.addRow("Effective End:", self.end_datetime_edit)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "UPSERT", "INSERT_ONLY"])
        form_layout.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => pass, else 0 => fail.")
        form_layout.addRow("Rule SQL:", self.sql_edit)

        self.description_edit = QTextEdit()
        form_layout.addRow("Description:", self.description_edit)

        self.justification_edit = QTextEdit()
        form_layout.addRow("Business Justification:", self.justification_edit)

        self.global_checkbox = QCheckBox("Global?")
        form_layout.addRow("Global:", self.global_checkbox)

        self.critical_checkbox = QCheckBox("Critical Rule?")
        form_layout.addRow("Critical:", self.critical_checkbox)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        form_layout.addRow("Critical Scope:", self.scope_combo)

        main_layout.addLayout(form_layout)

        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Update" if self.is_update else "Add")
        self.save_button.clicked.connect(self.save_rule)
        button_layout.addWidget(self.save_button)
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(cancel_button)
        if self.is_update:
            self.lock_button = QPushButton("Lock for Edit")
            self.lock_button.clicked.connect(self.lock_rule)
            button_layout.addWidget(self.lock_button)
            self.unlock_button = QPushButton("Unlock")
            self.unlock_button.setEnabled(False)
            self.unlock_button.clicked.connect(self.unlock_rule)
            button_layout.addWidget(self.unlock_button)
        button_layout.addStretch()
        main_layout.addLayout(button_layout)
        self.setLayout(main_layout)

        if self.is_update and self.rule_data:
            self.load_existing_rule()

    def load_existing_rule(self):
        rule = self.rule_data
        group_id = rule.get("GROUP_ID")
        if group_id:
            index = self.group_combo.findData(group_id)
            if index >= 0:
                self.group_combo.setCurrentIndex(index)
        parent_id = rule.get("PARENT_RULE_ID")
        if parent_id:
            index = self.parent_combo.findData(parent_id)
            if index >= 0:
                self.parent_combo.setCurrentIndex(index)
        self.name_edit.setText(rule.get("RULE_NAME", ""))
        rule_type_id = rule.get("RULE_TYPE_ID")
        if rule_type_id:
            index = self.rule_type_combo.findData(rule_type_id)
            if index >= 0:
                self.rule_type_combo.setCurrentIndex(index)
        status = rule.get("STATUS", "INACTIVE")
        index_status = self.status_combo.findText(status)
        if index_status >= 0:
            self.status_combo.setCurrentIndex(index_status)
        fmt = "%Y-%m-%d %H:%M:%S"
        start_date_str = rule.get("EFFECTIVE_START_DATE", "")
        end_date_str = rule.get("EFFECTIVE_END_DATE", "")
        if start_date_str:
            try:
                start_dt = datetime.strptime(start_date_str, fmt)
                self.start_datetime_edit.setDateTime(start_dt)
            except Exception:
                pass
        if end_date_str:
            try:
                end_dt = datetime.strptime(end_date_str, fmt)
                self.end_datetime_edit.setDateTime(end_dt)
            except Exception:
                pass
        cdc_value = rule.get("CDC_TYPE", "NONE").upper()
        index_cdc = self.cdc_combo.findText(cdc_value)
        if index_cdc >= 0:
            self.cdc_combo.setCurrentIndex(index_cdc)
        if rule.get("RULE_SQL"):
            self.sql_edit.setPlainText(rule["RULE_SQL"])
        if rule.get("DESCRIPTION"):
            self.description_edit.setText(rule["DESCRIPTION"])
        if rule.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rule["BUSINESS_JUSTIFICATION"])
        self.global_checkbox.setChecked(bool(rule.get("IS_GLOBAL", 0)))
        self.critical_checkbox.setChecked(bool(rule.get("CRITICAL_RULE", 0)))
        scope_value = rule.get("CRITICAL_SCOPE", "NONE").upper()
        index_scope = self.scope_combo.findText(scope_value)
        if index_scope >= 0:
            self.scope_combo.setCurrentIndex(index_scope)

    def save_rule(self):
        rule_name = self.name_edit.text().strip()
        if not rule_name:
            QMessageBox.warning(self, "Error", "Rule name is required.")
            return
        rule_sql = self.sql_edit.toPlainText().strip()
        group_id = self.group_combo.currentData()
        parent_id = self.parent_combo.currentData()
        rule_type_id = self.rule_type_combo.currentData()
        status = self.status_combo.currentText()
        start_dt_str = self.start_datetime_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_dt_str = self.end_datetime_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_type = self.cdc_combo.currentText().upper()
        description = self.description_edit.toPlainText().strip()
        justification = self.justification_edit.toPlainText().strip()
        is_global = 1 if self.global_checkbox.isChecked() else 0
        is_critical = 1 if self.critical_checkbox.isChecked() else 0
        critical_scope = self.scope_combo.currentText().upper()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?", (group_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Error", "Group not found in BRM_RULE_GROUPS.")
            return
        owner_group = row[0]
        rule_dict = {
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rule_type_id,
            "RULE_NAME": rule_name,
            "RULE_SQL": rule_sql,
            "EFFECTIVE_START_DATE": start_dt_str,
            "EFFECTIVE_END_DATE": end_dt_str,
            "STATUS": status,
            "DESCRIPTION": description,
            "BUSINESS_JUSTIFICATION": justification,
            "IS_GLOBAL": is_global,
            "CRITICAL_RULE": is_critical,
            "CRITICAL_SCOPE": critical_scope,
            "CDC_TYPE": cdc_type,
            "OWNER_GROUP": owner_group
        }
        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm", "Update rule now?")
            if confirm != QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, "CurrentUserID", self.user_group)
                QMessageBox.information(self, "Updated", "Rule updated; re-approval triggered.")
                if self.rule_locked:
                    self.unlock_rule()
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
        else:
            confirm = QMessageBox.question(self, "Confirm", "Add new rule now?")
            if confirm != QMessageBox.Yes:
                return
            try:
                new_rule_id = add_rule(self.connection, rule_dict, "CurrentUserID", self.user_group)
                QMessageBox.information(self, "Created", f"New rule created with ID {new_rule_id}.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))

    def lock_rule(self):
        if not self.is_update or not self.rule_data:
            QMessageBox.warning(self, "Error", "Lock is applicable only for rule updates.")
            return
        rule_id = self.rule_data["RULE_ID"]
        try:
            lock_rule_for_edit(self.connection, rule_id, "CurrentUserID", force=False, user_group=self.user_group)
            QMessageBox.information(self, "Locked", f"Rule {rule_id} locked by you.")
            self.rule_locked = True
            self.lock_button.setEnabled(False)
            self.unlock_button.setEnabled(True)
        except Exception as ex:
            QMessageBox.critical(self, "Lock Error", str(ex))

    def unlock_rule(self):
        if not self.is_update or not self.rule_data:
            return
        rule_id = self.rule_data["RULE_ID"]
        try:
            unlock_rule_for_edit(self.connection, rule_id, "CurrentUserID", force=False, admin_override=False, user_group=self.user_group)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} unlocked.")
            self.rule_locked = False
            self.lock_button.setEnabled(True)
            self.unlock_button.setEnabled(False)
        except Exception as ex:
            QMessageBox.critical(self, "Unlock Error", str(ex))

# ──────────────────────────────────────────────
# End of PART 4
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 5 of 8 (APPROVALS, GLOBAL/CRITICAL ADMIN, HIERARCHY, ENHANCED LINEAGE)
-----------------------------------------------------------------------------
Builds on:
  - Part 1 (core imports, DB connection, lock/unlock, SQL parsing)
  - Part 2 (BFS logic, advanced CRUD, data validations)
  - Part 3 (scheduling, sync metadata, simulations)
Includes:
  - Multi_step_approval_tab: Displays pending approvals with a color-coded pipeline,
    and allows users to approve, reject, or (for admins) force unlock.
  - Global_critical_admin_tab: Allows Admin users to set global/critical flags on rules,
    and to link/unlink child rules in BRM_GLOBAL_CRITICAL_LINKS.
  - Hierarchy_view_tab: Presents a tree view of groups and rules; supports drag & drop
    to update a rule's parent and group, triggering re-approval if needed.
  - Enhanced_lineage_graph_widget: Draws an ER-style diagram of rules and table dependencies,
    with optional search highlighting and context actions.
"""

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QCheckBox, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu, QInputDialog,
    QFileDialog, QGraphicsView, QGraphicsScene, QGraphicsItem, QPlainTextEdit
)
from PyQt5.QtCore import Qt, QPoint, QRectF
from PyQt5.QtGui import QBrush, QColor, QPen, QPainter, QPainterPath

# ---------------------------------------------------------------------------
# MULTI-STEP APPROVAL TAB
# ---------------------------------------------------------------------------
class Multi_step_approval_tab(QWidget):
    """
    Displays pending approvals for the current user with a color-coded approval pipeline.
    Provides buttons for Approve, Reject, and (for Admins) Force Unlock.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.approval_table = QTableWidget(0, 9)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID", "GroupName", "RuleName", "Stage", "Approved?",
            "ApprovalPipeline", "Approve", "Reject", "ForceUnlock"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        self.approval_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.approval_table)

        refresh_button = QPushButton("Refresh Approvals")
        refresh_button.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_button)
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("""
          SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, 
                 A.APPROVAL_STAGE, R.RULE_NAME
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
          WHERE A.USERNAME = ? AND A.APPROVED_FLAG = 0
          ORDER BY A.RULE_ID
        """, (self.logged_in_username,))
        rows = cursor.fetchall()
        # Determine the minimal unapproved stage per rule
        minimal_stage = {}
        rule_groups = {}
        for row in rows:
            rule_id, group_name, username, approved_flag, approval_stage, rule_name = row
            rule_groups.setdefault(rule_id, []).append(row)
        for rule_id, group_rows in rule_groups.items():
            cursor.execute("""
              SELECT MIN(APPROVAL_STAGE)
              FROM BRM_RULE_APPROVALS
              WHERE RULE_ID = ? AND APPROVED_FLAG = 0
            """, (rule_id,))
            min_stage = cursor.fetchone()[0]
            minimal_stage[rule_id] = min_stage

        display_rows = []
        for row in rows:
            rule_id, group_name, username, approved_flag, approval_stage, rule_name = row
            if minimal_stage.get(rule_id) == approval_stage:
                display_rows.append((rule_id, group_name, rule_name, approval_stage, approved_flag, username))

        for row_data in display_rows:
            rule_id, group_name, rule_name, stage, approved_flag, username = row_data
            row_index = self.approval_table.rowCount()
            self.approval_table.insertRow(row_index)
            self.approval_table.setItem(row_index, 0, QTableWidgetItem(str(rule_id)))
            self.approval_table.setItem(row_index, 1, QTableWidgetItem(group_name))
            self.approval_table.setItem(row_index, 2, QTableWidgetItem(rule_name))
            self.approval_table.setItem(row_index, 3, QTableWidgetItem(str(stage)))
            self.approval_table.setItem(row_index, 4, QTableWidgetItem(str(approved_flag)))
            pipeline_text = self.get_pipeline_text(rule_id)
            self.approval_table.setItem(row_index, 5, QTableWidgetItem(pipeline_text))
            approve_button = QPushButton("Approve")
            approve_button.clicked.connect(lambda _, idx=row_index: self.do_approve(idx))
            self.approval_table.setCellWidget(row_index, 6, approve_button)
            reject_button = QPushButton("Reject")
            reject_button.clicked.connect(lambda _, idx=row_index: self.do_reject(idx))
            self.approval_table.setCellWidget(row_index, 7, reject_button)
            force_unlock_button = QPushButton("ForceUnlock")
            if self.user_group != "Admin":
                force_unlock_button.setEnabled(False)
            else:
                force_unlock_button.clicked.connect(lambda _, idx=row_index: self.do_force_unlock(idx))
            self.approval_table.setCellWidget(row_index, 8, force_unlock_button)
        self.approval_table.resizeColumnsToContents()

    def get_pipeline_text(self, rule_id):
        cursor = self.connection.cursor()
        cursor.execute("""
          SELECT GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE
          FROM BRM_RULE_APPROVALS
          WHERE RULE_ID = ?
          ORDER BY APPROVAL_STAGE, USERNAME
        """, (rule_id,))
        rows = cursor.fetchall()
        stage_dict = {}
        for group_name, username, approved_flag, approval_stage in rows:
            stage_dict.setdefault(approval_stage, []).append((group_name, username, approved_flag))
        pipeline_parts = []
        for stage in sorted(stage_dict.keys()):
            group_parts = []
            for group_name, username, approved_flag in stage_dict[stage]:
                status = "OK" if approved_flag == 1 else "PEND"
                group_parts.append(f"{group_name}:{username}({status})")
            stage_text = f"[{stage}] " + " / ".join(group_parts)
            pipeline_parts.append(stage_text)
        return " -> ".join(pipeline_parts)

    def do_approve(self, row_index):
        rule_id_item = self.approval_table.item(row_index, 0)
        group_item = self.approval_table.item(row_index, 1)
        if not rule_id_item or not group_item:
            return
        rule_id = int(rule_id_item.text())
        group_name = group_item.text()
        cursor = self.connection.cursor()
        cursor.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG = 1, APPROVED_TIMESTAMP = GETDATE()
          WHERE RULE_ID = ? AND GROUP_NAME = ? AND USERNAME = ? AND APPROVED_FLAG = 0
        """, (rule_id, group_name, self.logged_in_username))
        # Check if further approvals are needed
        cursor.execute("""
          SELECT MIN(APPROVAL_STAGE)
          FROM BRM_RULE_APPROVALS
          WHERE RULE_ID = ? AND APPROVED_FLAG = 0
        """, (rule_id,))
        next_stage = cursor.fetchone()[0]
        if next_stage is None:
            cursor.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS = 'APPROVED', STATUS = 'ACTIVE', LIFECYCLE_STATE = 'ACTIVE'
              WHERE RULE_ID = ?
            """, (rule_id,))
        else:
            cursor.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS', STATUS = 'INACTIVE'
              WHERE RULE_ID = ?
            """, (rule_id,))
        insert_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, {"approved_flag": 0}, {"approved_flag": 1})
        self.connection.commit()
        QMessageBox.information(self, "Approved", f"Rule {rule_id} approved by you.")
        self.load_approvals()

    def do_reject(self, row_index):
        rule_id_item = self.approval_table.item(row_index, 0)
        group_item = self.approval_table.item(row_index, 1)
        if not rule_id_item or not group_item:
            return
        rule_id = int(rule_id_item.text())
        group_name = group_item.text()
        confirm = QMessageBox.question(self, "Confirm", f"Reject rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG = 2, APPROVED_TIMESTAMP = GETDATE()
          WHERE RULE_ID = ? AND GROUP_NAME = ? AND USERNAME = ? AND APPROVED_FLAG = 0
        """, (rule_id, group_name, self.logged_in_username))
        cursor.execute("""
          UPDATE BRM_RULES
          SET APPROVAL_STATUS = 'REJECTED', STATUS = 'INACTIVE', LIFECYCLE_STATE = 'INACTIVE'
          WHERE RULE_ID = ?
        """, (rule_id,))
        insert_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None, {"rejected": True})
        self.connection.commit()
        QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected by you.")
        self.load_approvals()

    def do_force_unlock(self, row_index):
        rule_id_item = self.approval_table.item(row_index, 0)
        if not rule_id_item:
            return
        rule_id = int(rule_id_item.text())
        confirm = QMessageBox.question(self, "Force Unlock", f"Force unlock rule {rule_id}? (Admin only)")
        if confirm != QMessageBox.Yes:
            return
        try:
            unlock_rule_for_edit(self.connection, rule_id, "AdminOverride", force=True, admin_override=True, user_group=self.user_group)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} forcibly unlocked by admin.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# ---------------------------------------------------------------------------
# GLOBAL/CRITICAL ADMIN TAB
# ---------------------------------------------------------------------------
class Global_critical_admin_tab(QWidget):
    """
    Admin-only tab to manage global and critical rules.
    Allows setting global/critical flags and linking/unlinking child rules.
    """
    def __init__(self, main_window, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_window = main_window
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_layout = QHBoxLayout()
        self.show_only_gcr_checkbox = QCheckBox("Show only GCR rules")
        self.show_only_gcr_checkbox.setChecked(True)
        refresh_button = QPushButton("Refresh")
        refresh_button.clicked.connect(self.load_rule_list)
        top_layout.addWidget(self.show_only_gcr_checkbox)
        top_layout.addWidget(refresh_button)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "RuleName", "OwnerGroup", "IS_GLOBAL", "CRITICAL_RULE",
            "CRITICAL_SCOPE", "STATUS", "LOCK_STATUS", "UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        flags_layout = QHBoxLayout()
        self.global_checkbox = QCheckBox("Set Global?")
        flags_layout.addWidget(self.global_checkbox)
        self.critical_checkbox = QCheckBox("Set Critical?")
        flags_layout.addWidget(self.critical_checkbox)
        flags_layout.addWidget(QLabel("Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        flags_layout.addWidget(self.scope_combo)
        apply_button = QPushButton("Apply to Selected")
        apply_button.clicked.connect(self.apply_flags)
        flags_layout.addWidget(apply_button)
        flags_layout.addStretch()
        layout.addLayout(flags_layout)

        link_layout = QHBoxLayout()
        self.gcr_parent_combo = QComboBox()
        link_layout.addWidget(QLabel("Parent GCR:"))
        link_layout.addWidget(self.gcr_parent_combo)
        self.gcr_child_combo = QComboBox()
        link_layout.addWidget(QLabel("Child:"))
        link_layout.addWidget(self.gcr_child_combo)
        link_button = QPushButton("Link Child")
        link_button.clicked.connect(self.link_child)
        unlink_button = QPushButton("Unlink Child")
        unlink_button.clicked.connect(self.unlink_child)
        link_layout.addWidget(link_button)
        link_layout.addWidget(unlink_button)
        link_layout.addStretch()
        layout.addLayout(link_layout)

        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["ParentGCR", "ChildRule"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        refresh_all_button = QPushButton("Refresh All")
        refresh_all_button.clicked.connect(self.refresh_all)
        layout.addWidget(refresh_all_button)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_parent_combo()
        self.populate_child_combo()
        self.load_links()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        cursor = self.connection.cursor()
        if self.show_only_gcr_checkbox.isChecked():
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       CRITICAL_SCOPE, STATUS, LOCK_STATUS, UPDATED_BY
                FROM BRM_RULES
                WHERE IS_GLOBAL = 1 OR CRITICAL_RULE = 1
                ORDER BY RULE_ID DESC
            """)
        else:
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       CRITICAL_SCOPE, STATUS, LOCK_STATUS, UPDATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
        for row in cursor.fetchall():
            row_index = self.rule_table.rowCount()
            self.rule_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                self.rule_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value else ""))
    def populate_parent_combo(self):
        self.gcr_parent_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT RULE_ID, RULE_NAME
            FROM BRM_RULES
            WHERE IS_GLOBAL = 1 OR CRITICAL_RULE = 1
            ORDER BY RULE_ID
        """)
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_id} - {rule_name}"
            self.gcr_parent_combo.addItem(display, rule_id)
    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            display = f"{rule_id} - {rule_name}"
            self.gcr_child_combo.addItem(display, rule_id)
    def load_links(self):
        self.link_view.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        for row in cursor.fetchall():
            row_index = self.link_view.rowCount()
            self.link_view.insertRow(row_index)
            self.link_view.setItem(row_index, 0, QTableWidgetItem(str(row[0])))
            self.link_view.setItem(row_index, 1, QTableWidgetItem(str(row[1])))
    def get_selected_rules(self):
        indexes = self.rule_table.selectionModel().selectedRows()
        rule_ids = []
        for index in indexes:
            row = index.row()
            item = self.rule_table.item(row, 0)
            if item:
                rule_ids.append(int(item.text()))
        return rule_ids
    def apply_flags(self):
        selected_rules = self.get_selected_rules()
        if not selected_rules:
            QMessageBox.warning(self, "None", "No rules selected.")
            return
        is_global = 1 if self.global_checkbox.isChecked() else 0
        is_critical = 1 if self.critical_checkbox.isChecked() else 0
        scope_value = self.scope_combo.currentText().upper()
        confirm = QMessageBox.question(
            self, "Confirm",
            f"Set IS_GLOBAL={is_global}, CRITICAL_RULE={is_critical}, CRITICAL_SCOPE={scope_value} for {len(selected_rules)} rule(s)?"
        )
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        for rule_id in selected_rules:
            # Force unlock any active lock before updating
            unlock_rule_for_edit(self.connection, rule_id, "AdminOverride", force=True, admin_override=True, user_group=self.user_group)
            cursor.execute("""
                UPDATE BRM_RULES
                SET IS_GLOBAL = ?, CRITICAL_RULE = ?, CRITICAL_SCOPE = ?
                WHERE RULE_ID = ?
            """, (is_global, is_critical, scope_value, rule_id))
        self.connection.commit()
        QMessageBox.information(self, "Updated", f"Flags updated for {len(selected_rules)} rule(s).")
        self.load_rule_list()
    def link_child(self):
        parent_rule_id = self.gcr_parent_combo.currentData()
        child_rule_id = self.gcr_child_combo.currentData()
        if not parent_rule_id or not child_rule_id:
            QMessageBox.warning(self, "Missing", "Please select both parent and child rules.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Link child rule {child_rule_id} to parent rule {parent_rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("""
            INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID)
            VALUES (?, ?)
        """, (parent_rule_id, child_rule_id))
        insert_audit_log(self.connection, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_rule_id}->{child_rule_id}", "Admin", None, {"parent": parent_rule_id, "child": child_rule_id})
        self.connection.commit()
        QMessageBox.information(self, "Linked", f"Child rule {child_rule_id} linked to parent rule {parent_rule_id}.")
        self.load_links()
    def unlink_child(self):
        parent_rule_id = self.gcr_parent_combo.currentData()
        child_rule_id = self.gcr_child_combo.currentData()
        if not parent_rule_id or not child_rule_id:
            QMessageBox.warning(self, "Missing", "Please select both parent and child rules.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Unlink child rule {child_rule_id} from parent rule {parent_rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("""
            DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
            WHERE GCR_RULE_ID = ? AND TARGET_RULE_ID = ?
        """, (parent_rule_id, child_rule_id))
        insert_audit_log(self.connection, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_rule_id}->{child_rule_id}", "Admin", {"parent": parent_rule_id, "child": child_rule_id}, None)
        self.connection.commit()
        QMessageBox.information(self, "Unlinked", f"Child rule {child_rule_id} unlinked from parent rule {parent_rule_id}.")
        self.load_links()

# ---------------------------------------------------------------------------
# HIERARCHY VIEW TAB
# ---------------------------------------------------------------------------
class Hierarchy_view_tab(QTreeWidget):
    """
    Displays a tree view of groups and rules.
    Allows drag-and-drop to move a rule under a new parent or group.
    Updates the BRM_RULES table accordingly and triggers re-approval.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setHeaderLabels(["Group / Rule (Hierarchy View)"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        groups = cursor.fetchall()
        group_item_map = {}
        for group_id, group_name in groups:
            top_item = QTreeWidgetItem([f"{group_name} (ID={group_id})"])
            top_item.setData(0, Qt.UserRole, ("group", group_id))
            self.addTopLevelItem(top_item)
            group_item_map[group_id] = top_item
        cursor.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rule_map = {}
        for rule_id, rule_name, group_id, parent_rule_id in cursor.fetchall():
            rule_map[rule_id] = (rule_name, group_id, parent_rule_id)
        for rule_id, (rule_name, group_id, parent_rule_id) in rule_map.items():
            if not parent_rule_id:
                if group_id in group_item_map:
                    parent_item = group_item_map[group_id]
                    child_item = QTreeWidgetItem([f"Rule {rule_id}: {rule_name}"])
                    child_item.setData(0, Qt.UserRole, ("rule", rule_id))
                    parent_item.addChild(child_item)
        self.expandAll()

    def dropEvent(self, event):
        source_item = self.currentItem()
        if not source_item:
            super().dropEvent(event)
            return
        source_data = source_item.data(0, Qt.UserRole)
        if not source_data or source_data[0] != "rule":
            super().dropEvent(event)
            return
        super().dropEvent(event)  # Let Qt handle the reordering
        new_parent_item = source_item.parent()
        if not new_parent_item:
            QMessageBox.information(self, "Invalid", "Cannot move rule to top-level without a group. Reverting.")
            self.load_hierarchy()
            return
        parent_data = new_parent_item.data(0, Qt.UserRole)
        rule_id = source_data[1]
        if parent_data[0] == "group":
            new_group_id = parent_data[1]
            unlock_rule_for_edit(self.connection, rule_id, "HierarchyDrag", force=True, admin_override=True, user_group="Admin")
            cursor = self.connection.cursor()
            old_rule_data = self.get_rule_dict(rule_id)
            cursor.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID = ?, PARENT_RULE_ID = NULL,
                    STATUS = 'INACTIVE', APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
                    VERSION = VERSION + 1, UPDATED_BY = 'HierarchyView'
                WHERE RULE_ID = ?
            """, (new_group_id, rule_id))
            new_rule_data = dict(old_rule_data)
            new_rule_data["GROUP_ID"] = new_group_id
            new_rule_data["PARENT_RULE_ID"] = None
            new_rule_data["STATUS"] = "INACTIVE"
            new_rule_data["APPROVAL_STATUS"] = "APPROVAL_IN_PROGRESS"
            insert_audit_log(self.connection, "HIERARCHY_MOVE", "BRM_RULES", rule_id, "HierarchyDrag", old_rule_data, new_rule_data)
            self.connection.commit()
        elif parent_data[0] == "rule":
            parent_rule_id = parent_data[1]
            unlock_rule_for_edit(self.connection, rule_id, "HierarchyDrag", force=True, admin_override=True, user_group="Admin")
            parent_info = self.get_rule_dict(parent_rule_id)
            if not parent_info:
                self.load_hierarchy()
                return
            new_group_id = parent_info["GROUP_ID"]
            old_rule_data = self.get_rule_dict(rule_id)
            cursor = self.connection.cursor()
            cursor.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID = ?, PARENT_RULE_ID = ?,
                    STATUS = 'INACTIVE', APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
                    VERSION = VERSION + 1, UPDATED_BY = 'HierarchyView'
                WHERE RULE_ID = ?
            """, (new_group_id, parent_rule_id, rule_id))
            new_rule_data = dict(old_rule_data)
            new_rule_data["GROUP_ID"] = new_group_id
            new_rule_data["PARENT_RULE_ID"] = parent_rule_id
            new_rule_data["STATUS"] = "INACTIVE"
            new_rule_data["APPROVAL_STATUS"] = "APPROVAL_IN_PROGRESS"
            insert_audit_log(self.connection, "HIERARCHY_MOVE", "BRM_RULES", rule_id, "HierarchyDrag", old_rule_data, new_rule_data)
            self.connection.commit()
        else:
            QMessageBox.warning(self, "Invalid", "Cannot move under the selected item. Reverting.")
            self.load_hierarchy()

    def get_rule_dict(self, rule_id):
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = cursor.fetchone()
        if not row:
            return None
        columns = [d[0] for d in cursor.description]
        return dict(zip(columns, row))

# ---------------------------------------------------------------------------
# ENHANCED LINEAGE GRAPH WIDGET
# ---------------------------------------------------------------------------
class Enhanced_lineage_graph_widget(QGraphicsView):
    """
    Draws an ER-style diagram of rules and table dependencies.
    Nodes represent rules (and tables), with color coding and connecting lines.
    Supports search highlighting and context actions.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.node_map = {}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, CRITICAL_RULE,
                   IS_GLOBAL, CRITICAL_SCOPE, LOCK_STATUS
            FROM BRM_RULES
            ORDER BY RULE_ID
        """)
        rules = cursor.fetchall()
        # Build adjacency based on parent relationships
        children_map = {}
        parent_map = {}
        all_rule_ids = set()
        for rule_id, rule_name, parent_rule_id, status, critical_rule, is_global, critical_scope, lock_status in rules:
            all_rule_ids.add(rule_id)
            if parent_rule_id:
                children_map.setdefault(parent_rule_id, []).append(rule_id)
                parent_map[rule_id] = parent_rule_id
        roots = [r for r in all_rule_ids if r not in parent_map]
        # BFS layering for node placement
        from collections import deque
        queue = deque()
        for root_rule in roots:
            queue.append((root_rule, 0))
        level_count = {}
        rule_data_map = {}
        for rule_id, rule_name, parent_rule_id, status, critical_rule, is_global, critical_scope, lock_status in rules:
            rule_data_map[rule_id] = {
                "RULE_ID": rule_id,
                "RULE_NAME": rule_name,
                "PARENT_RULE_ID": parent_rule_id,
                "STATUS": status,
                "CRITICAL_RULE": critical_rule,
                "IS_GLOBAL": is_global,
                "CRITICAL_SCOPE": critical_scope,
                "LOCK_STATUS": lock_status
            }
        while queue:
            current_rule, depth = queue.popleft()
            level_count[depth] = level_count.get(depth, 0) + 1
            x = depth * 220
            y = (level_count[depth] - 1) * 160
            node_item = Rule_node_item(rule_data_map[current_rule])
            node_item.setPos(x, y)
            self.scene.addItem(node_item)
            self.node_map[current_rule] = node_item
            if current_rule in children_map:
                for child in children_map[current_rule]:
                    queue.append((child, depth + 1))
        # Draw edges for parent-child relationships
        for rule_id in all_rule_ids:
            parent_id = rule_data_map[rule_id]["PARENT_RULE_ID"]
            if parent_id and parent_id in self.node_map and rule_id in self.node_map:
                self.draw_edge(self.node_map[parent_id], self.node_map[rule_id], color=QColor("darkGray"))
        # Draw Global Critical Relationships (GCR)
        cursor.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        for parent_rule, child_rule in cursor.fetchall():
            if parent_rule in self.node_map and child_rule in self.node_map:
                self.draw_edge(self.node_map[parent_rule], self.node_map[child_rule], color=QColor("blue"))
        # Draw Conflicts as dotted lines
        cursor.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
        for rule1, rule2, priority in cursor.fetchall():
            if rule1 in self.node_map and rule2 in self.node_map:
                self.draw_edge(self.node_map[rule1], self.node_map[rule2], color=QColor("magenta"), dashed=True)
        # Draw Composite relationships: parse LOGIC_EXPR for references like "RuleX"
        cursor.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
        pattern = re.compile(r"Rule(\d+)", re.IGNORECASE)
        for composite_id, expr in cursor.fetchall():
            if expr:
                matches = pattern.findall(expr)
                for match in matches:
                    try:
                        sub_rule = int(match)
                        if sub_rule in self.node_map and composite_id in self.node_map:
                            self.draw_edge(self.node_map[sub_rule], self.node_map[composite_id], color=QColor("green"))
                    except Exception:
                        pass
        # Draw table dependencies as nodes (placed to the side)
        cursor.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        table_map = {}
        table_x = 1000
        table_y = 0
        for rule_id, db_name, table_name, column_op in cursor.fetchall():
            if not table_name:
                continue
            key = f"{db_name}.{table_name}".lower()
            if key not in table_map:
                table_node = Table_node_item(key)
                table_node.setPos(table_x, table_y)
                table_y += 120
                self.scene.addItem(table_node)
                table_map[key] = table_node
            if rule_id in self.node_map:
                edge_color = QColor("red") if column_op.upper() == "WRITE" else QColor("blue")
                self.draw_edge(self.node_map[rule_id], table_map[key], color=edge_color)
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.reset_view()

    def draw_edge(self, item1, item2, color=QColor("black"), dashed=False):
        rect1 = item1.sceneBoundingRect()
        rect2 = item2.sceneBoundingRect()
        point1 = rect1.center()
        point2 = rect2.center()
        edge_item = Lineage_edge_item(point1, point2, color, dashed)
        self.scene.addItem(edge_item)

    def reset_view(self):
        bounding_rect = self.scene.itemsBoundingRect()
        if bounding_rect.isValid():
            self.fitInView(bounding_rect, Qt.KeepAspectRatio)

    def mouseDoubleClickEvent(self, event):
        clicked_item = self.itemAt(event.pos())
        if isinstance(clicked_item, Rule_node_item):
            rule_info = clicked_item.rule_data
            rule_id = rule_info["RULE_ID"]
            detail = (f"Rule {rule_id}:\nName: {rule_info['RULE_NAME']}\nStatus: {rule_info['STATUS']}\n"
                      f"Lock: {rule_info['LOCK_STATUS']}\nGlobal: {rule_info['IS_GLOBAL']}, "
                      f"Critical: {rule_info['CRITICAL_RULE']}\nScope: {rule_info['CRITICAL_SCOPE']}")
            QMessageBox.information(self, "Rule Details", detail)
        elif isinstance(clicked_item, Table_node_item):
            table_key = clicked_item.table_key
            dlg = QMessageBox(self)
            dlg.setWindowTitle("Table Node")
            dlg.setText(f"Table: {table_key}\nClick 'Run Validation' to validate this table.")
            run_button = dlg.addButton("Run Validation", QMessageBox.AcceptRole)
            dlg.addButton("Close", QMessageBox.RejectRole)
            dlg.exec_()
            if dlg.clickedButton() == run_button:
                if run_data_validations_for_table(self.connection, table_key.lower()):
                    QMessageBox.information(self, "Validation", "All validations passed.")
                else:
                    QMessageBox.warning(self, "Validation", "Validation failed.")
        super().mouseDoubleClickEvent(event)

    def search_and_highlight(self, search_text):
        search_lower = search_text.lower()
        for item in self.scene.items():
            item.setOpacity(0.3)
        for item in self.scene.items():
            if isinstance(item, Rule_node_item):
                if search_lower in item.rule_data["RULE_NAME"].lower() or search_lower in (item.rule_data["STATUS"] or "").lower():
                    item.setOpacity(1.0)
            elif isinstance(item, Table_node_item):
                if search_lower in item.table_key.lower():
                    item.setOpacity(1.0)

# ---------------------------------------------------------------------------
# GRAPHICS ITEMS FOR LINEAGE
# ---------------------------------------------------------------------------
class Rule_node_item(QGraphicsItem):
    """
    Represents a rule as a rectangular node with color coding based on status and lock.
    """
    def __init__(self, rule_data, width=150, height=80):
        super().__init__()
        self.rule_data = rule_data
        self.width = width
        self.height = height
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)

    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)

    def paint(self, painter, option, widget=None):
        status = (self.rule_data["STATUS"] or "").upper()
        if status == "ACTIVE":
            fill_color = QColor("palegreen")
        elif status == "INACTIVE":
            fill_color = QColor("lightpink")
        else:
            fill_color = QColor("lightgray")
        pen = QPen(Qt.black, 2)
        if (self.rule_data["LOCK_STATUS"] or "").upper() == "LOCKED":
            pen.setColor(QColor("red"))
            pen.setWidth(3)
        if self.rule_data["CRITICAL_RULE"] == 1 or self.rule_data["IS_GLOBAL"] == 1:
            pen.setStyle(Qt.DashLine)
        painter.setPen(pen)
        painter.setBrush(QBrush(fill_color))
        painter.drawRect(0, 0, self.width, self.height)
        text = f"R{self.rule_data['RULE_ID']} : {self.rule_data['RULE_NAME']}"
        painter.drawText(0, 0, self.width, self.height, Qt.AlignCenter, text)

class Table_node_item(QGraphicsItem):
    """
    Represents a table dependency as a rectangular node.
    """
    def __init__(self, table_key, width=180, height=60):
        super().__init__()
        self.table_key = table_key
        self.width = width
        self.height = height
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)

    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)

    def paint(self, painter, option, widget=None):
        pen = QPen(Qt.darkBlue, 2)
        painter.setPen(pen)
        painter.setBrush(QBrush(QColor("lightblue")))
        painter.drawRect(0, 0, self.width, self.height)
        painter.drawText(0, 0, self.width, self.height, Qt.AlignCenter, self.table_key)

class Lineage_edge_item(QGraphicsItem):
    """
    Represents an edge between two nodes in the lineage graph.
    Supports solid or dashed lines.
    """
    def __init__(self, point1, point2, color=QColor("black"), dashed=False):
        super().__init__()
        self.point1 = point1
        self.point2 = point2
        self.color = color
        self.dashed = dashed

    def boundingRect(self):
        min_x = min(self.point1.x(), self.point2.x())
        min_y = min(self.point1.y(), self.point2.y())
        width = abs(self.point2.x() - self.point1.x())
        height = abs(self.point2.y() - self.point1.y())
        return QRectF(min_x, min_y, width, height)

    def paint(self, painter, option, widget=None):
        pen = QPen(self.color, 2)
        if self.dashed:
            pen.setStyle(Qt.DashLine)
        painter.setPen(pen)
        painter.drawLine(self.point1, self.point2)

# ──────────────────────────────────────────────
# End of PART 5
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 6 of 8 (METRICS, CONTROL TABLES, GROUPS, USERS)
----------------------------------------------------------------
Builds on previous parts (1–5) including core DB connection, BFS, CRUD, validations,
scheduling, and advanced features.
This part includes:
  - Metrics_dashboard_tab: Displays performance/usage metrics with bar and line charts.
  - ctrl_tables_tab: UI to view and (if Admin) edit control tables.
  - group_management_tab: Manages business groups, membership, group permissions, and group approvers.
  - user_management_tab: Manages user accounts (plain-text passwords for demonstration only).
"""

import sys
import math
import csv
import logging
import json
from datetime import datetime, timedelta
from collections import defaultdict

import pyodbc

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget, QFileDialog
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

import pyqtgraph as pg

# ---------------------------------------------------------------------------
# METRICS DASHBOARD TAB
# ---------------------------------------------------------------------------
class Metrics_dashboard_tab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        # Plot for rule counts by status
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        layout.addWidget(self.status_chart)

        # Plot for daily execution counts (last 7 days)
        self.execution_chart = pg.PlotWidget(title="Executions per Day (Last 7 Days)")
        self.execution_chart.setBackground('w')
        layout.addWidget(self.execution_chart)

        # Plot for data validation pass/fail ratio (last 30 days)
        self.validation_chart = pg.PlotWidget(title="Data Validation Pass/Fail (Last 30 Days)")
        self.validation_chart.setBackground('w')
        layout.addWidget(self.validation_chart)

        button_layout = QHBoxLayout()
        refresh_button = QPushButton("Refresh Metrics")
        refresh_button.clicked.connect(self.load_metrics)
        button_layout.addWidget(refresh_button)
        export_button = QPushButton("Export Metrics CSV")
        export_button.clicked.connect(self.export_metrics_csv)
        button_layout.addWidget(export_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        self.load_status_bar()
        self.load_execution_line()
        self.load_validation_ratio()

    def load_status_bar(self):
        cursor = self.connection.cursor()
        cursor.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        rows = cursor.fetchall()
        statuses = [row[0] for row in rows]
        counts = [row[1] for row in rows]
        self.status_chart.clear()
        if statuses:
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left", "Count")
            self.status_chart.setLabel("bottom", "Status")
            self.status_chart.showGrid(x=True, y=True)

    def load_execution_line(self):
        self.execution_chart.clear()
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120) AS exec_date,
                   COUNT(*) AS exec_count
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(day, -7, GETDATE())
            GROUP BY CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120)
            ORDER BY exec_date
        """)
        rows = cursor.fetchall()
        if not rows:
            return
        x_labels = [row[0] for row in rows]
        y_counts = [row[1] for row in rows]
        x_vals = list(range(len(x_labels)))
        self.execution_chart.plot(x_vals, y_counts, pen='b', symbol='o')
        self.execution_chart.getAxis("bottom").setTicks([list(zip(x_vals, x_labels))])
        self.execution_chart.setLabel("left", "Executions")
        self.execution_chart.setLabel("bottom", "Date")
        self.execution_chart.showGrid(x=True, y=True)

    def load_validation_ratio(self):
        self.validation_chart.clear()
        cursor = self.connection.cursor()
        try:
            cursor.execute("""
                SELECT RESULT_FLAG, COUNT(*)
                FROM DATA_VALIDATION_LOGS
                WHERE VALIDATION_TIMESTAMP >= DATEADD(day, -30, GETDATE())
                GROUP BY RESULT_FLAG
            """)
            rows = cursor.fetchall()
            pass_count = 0
            fail_count = 0
            for result_flag, count in rows:
                if str(result_flag).upper() == "PASS":
                    pass_count += count
                else:
                    fail_count += count
            if (pass_count + fail_count) > 0:
                x_vals = [0, 1]
                y_vals = [pass_count, fail_count]
                colors = ["green", "red"]
                bar_item = pg.BarGraphItem(x=x_vals, height=y_vals, width=0.6, brushes=colors)
                self.validation_chart.addItem(bar_item)
                self.validation_chart.getAxis("bottom").setTicks([[(0, "Pass"), (1, "Fail")]])
                self.validation_chart.setLabel("left", "Count")
                self.validation_chart.showGrid(x=True, y=True)
        except Exception:
            pass

    def export_metrics_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Metrics", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["Metric", "Value"])
                # Rule statuses
                cursor = self.connection.cursor()
                cursor.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
                for status, count in cursor.fetchall():
                    writer.writerow([f"RuleStatus_{status}", count])
                # Daily executions
                cursor.execute("""
                    SELECT CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120), COUNT(*)
                    FROM RULE_EXECUTION_LOGS
                    WHERE EXECUTION_TIMESTAMP >= DATEADD(day, -7, GETDATE())
                    GROUP BY CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120)
                    ORDER BY 1
                """)
                for exec_date, count in cursor.fetchall():
                    writer.writerow([f"Execution_{exec_date}", count])
                # Data validation logs
                try:
                    cursor.execute("""
                        SELECT RESULT_FLAG, COUNT(*)
                        FROM DATA_VALIDATION_LOGS
                        WHERE VALIDATION_TIMESTAMP >= DATEADD(day, -30, GETDATE())
                        GROUP BY RESULT_FLAG
                    """)
                    for result_flag, count in cursor.fetchall():
                        writer.writerow([f"DataValidation_{result_flag}", count])
                except Exception:
                    pass
            QMessageBox.information(self, "Exported", f"Metrics exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# ---------------------------------------------------------------------------
# CTRL TABLES TAB
# ---------------------------------------------------------------------------
class Ctrl_tables_tab(QWidget):
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS", "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE", "BRM_GROUP_BACKUPS", "BRM_COLUMN_MAPPING", "BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS", "BUSINESS_GROUP_APPROVERS", "BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS", "BRM_GLOBAL_CRITICAL_LINKS", "RULE_SCHEDULES",
            "BRM_RULE_COMMENTS", "DECISION_TABLES", "RULE_CONFLICTS", "COMPOSITE_RULES",
            "RULE_SNAPSHOTS", "RULE_TAGS", "DATA_VALIDATIONS", "RULE_EXECUTION_LOGS",
            "DATA_VALIDATION_LOGS"
        ]
        top_layout = QHBoxLayout()
        self.table_combo = QComboBox()
        for table_name in self.table_list:
            self.table_combo.addItem(table_name)
        top_layout.addWidget(QLabel("Select Admin Table:"))
        top_layout.addWidget(self.table_combo)
        load_button = QPushButton("Load Data")
        load_button.clicked.connect(self.load_table_data)
        top_layout.addWidget(load_button)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.data_table = QTableWidget(0, 0)
        if self.user_group == "Admin":
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.data_table)
        self.setLayout(layout)
        self.columns = []
        self.current_table = None

    def load_table_data(self):
        table_name = self.table_combo.currentText()
        self.current_table = table_name
        self.data_table.setRowCount(0)
        cursor = self.connection.cursor()
        try:
            cursor.execute(f"SELECT TOP 1 * FROM {table_name}")
            self.columns = [desc[0] for desc in cursor.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error retrieving columns", str(ex))
            return
        try:
            cursor.execute(f"SELECT TOP 500 * FROM {table_name}")
            rows = cursor.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error retrieving data", str(ex))
            return
        self.data_table.setColumnCount(len(self.columns))
        self.data_table.setHorizontalHeaderLabels(self.columns)
        for row in rows:
            row_index = self.data_table.rowCount()
            self.data_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                self.data_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value is not None else ""))
        self.data_table.resizeColumnsToContents()

# ---------------------------------------------------------------------------
# GROUP MANAGEMENT TAB
# ---------------------------------------------------------------------------
class Group_management_tab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)
        if user_group.lower() != "admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Groups & Membership Tab
        groups_tab = QWidget()
        groups_layout = QVBoxLayout(groups_tab)
        groups_box = QGroupBox("Groups")
        groups_box_layout = QVBoxLayout(groups_box)
        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName", "Description", "Email"])
        groups_box_layout.addWidget(self.groups_table)
        group_buttons_layout = QHBoxLayout()
        add_group_button = QPushButton("Add Group")
        add_group_button.clicked.connect(self.add_group)
        group_buttons_layout.addWidget(add_group_button)
        rename_group_button = QPushButton("Rename Group")
        rename_group_button.clicked.connect(self.rename_group)
        group_buttons_layout.addWidget(rename_group_button)
        delete_group_button = QPushButton("Delete Group")
        delete_group_button.clicked.connect(self.delete_group)
        group_buttons_layout.addWidget(delete_group_button)
        group_buttons_layout.addStretch()
        groups_box_layout.addLayout(group_buttons_layout)
        groups_layout.addWidget(groups_box)

        membership_box = QGroupBox("Membership")
        membership_layout = QVBoxLayout(membership_box)
        self.users_table = QTableWidget(0, 3)
        self.users_table.setHorizontalHeaderLabels(["UserID", "Username", "Group"])
        membership_layout.addWidget(self.users_table)
        membership_buttons_layout = QHBoxLayout()
        add_user_button = QPushButton("Add User to Group")
        add_user_button.clicked.connect(self.add_user_to_group)
        membership_buttons_layout.addWidget(add_user_button)
        remove_user_button = QPushButton("Remove User from Group")
        remove_user_button.clicked.connect(self.remove_user_from_group)
        membership_buttons_layout.addWidget(remove_user_button)
        membership_buttons_layout.addStretch()
        membership_layout.addLayout(membership_buttons_layout)
        groups_layout.addWidget(membership_box)
        groups_tab.setLayout(groups_layout)
        self.tabs.addTab(groups_tab, "Groups & Membership")

        # Permissions Tab
        permissions_tab = QWidget()
        permissions_layout = QVBoxLayout(permissions_tab)
        permissions_box = QGroupBox("Group Permissions")
        permissions_box_layout = QVBoxLayout(permissions_box)
        top_perm_layout = QHBoxLayout()
        self.permissions_group_combo = QComboBox()
        self.permissions_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_perm_layout.addWidget(QLabel("Select Group:"))
        top_perm_layout.addWidget(self.permissions_group_combo)
        top_perm_layout.addStretch()
        permissions_box_layout.addLayout(top_perm_layout)
        self.permissions_table = QTableWidget(0, 1)
        self.permissions_table.setHorizontalHeaderLabels(["TargetTable"])
        permissions_box_layout.addWidget(self.permissions_table)
        perm_buttons_layout = QHBoxLayout()
        add_perm_button = QPushButton("Add Permission")
        add_perm_button.clicked.connect(self.add_permission)
        perm_buttons_layout.addWidget(add_perm_button)
        remove_perm_button = QPushButton("Remove Permission")
        remove_perm_button.clicked.connect(self.remove_permission)
        perm_buttons_layout.addWidget(remove_perm_button)
        perm_buttons_layout.addStretch()
        permissions_box_layout.addLayout(perm_buttons_layout)
        permissions_layout.addWidget(permissions_box)
        permissions_tab.setLayout(permissions_layout)
        self.tabs.addTab(permissions_tab, "Permissions")

        # Approvers Tab
        approvers_tab = QWidget()
        approvers_layout = QVBoxLayout(approvers_tab)
        top_appr_layout = QHBoxLayout()
        self.approvers_group_combo = QComboBox()
        self.approvers_group_combo.currentIndexChanged.connect(self.load_approvers)
        top_appr_layout.addWidget(QLabel("Group:"))
        top_appr_layout.addWidget(self.approvers_group_combo)
        top_appr_layout.addStretch()
        approvers_layout.addLayout(top_appr_layout)
        self.approvers_table = QTableWidget(0, 2)
        self.approvers_table.setHorizontalHeaderLabels(["ApproverID", "Username"])
        approvers_layout.addWidget(self.approvers_table)
        approvers_buttons_layout = QHBoxLayout()
        add_appr_button = QPushButton("Add Approver")
        add_appr_button.clicked.connect(self.add_approver)
        approvers_buttons_layout.addWidget(add_appr_button)
        remove_appr_button = QPushButton("Remove Approver")
        remove_appr_button.clicked.connect(self.remove_approver)
        approvers_buttons_layout.addWidget(remove_appr_button)
        approvers_buttons_layout.addStretch()
        approvers_layout.addLayout(approvers_buttons_layout)
        approvers_tab.setLayout(approvers_layout)
        self.tabs.addTab(approvers_tab, "Approvers")

        refresh_all_button = QPushButton("Refresh All")
        refresh_all_button.clicked.connect(self.load_all_group_data)
        layout.addWidget(refresh_all_button)
        self.setLayout(layout)
        self.load_all_group_data()

    def load_all_group_data(self):
        self.load_groups()
        self.load_users()
        self.load_permissions_group_combo()
        self.load_approvers_group_combo()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in cursor.fetchall():
            row_index = self.groups_table.rowCount()
            self.groups_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                self.groups_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value else ""))
    def get_selected_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            return None
        item = self.groups_table.item(row, 0)
        return item.text().strip() if item else None
    def add_group(self):
        group_name, ok = QInputDialog.getText(self, "Add Group", "Group Name:")
        if not ok or not group_name.strip():
            return
        description, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            description = ""
        email, ok3 = QInputDialog.getText(self, "Email", "Optional:")
        if not ok3:
            email = ""
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (group_name.strip(),))
        if cursor.fetchone():
            QMessageBox.warning(self, "Error", "Group already exists.")
            return
        cursor.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES (?, ?, ?)", (group_name.strip(), description.strip(), email.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Group created.")
        self.load_all_group_data()
    def rename_group(self):
        group_name = self.get_selected_group()
        if not group_name:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for '{group_name}':")
        if not ok or not new_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
        if cursor.fetchone():
            QMessageBox.warning(self, "Error", "Another group with that name already exists.")
            return
        old_data = {"GROUP_NAME": group_name}
        new_data = {"GROUP_NAME": new_name.strip()}
        try:
            cursor.execute("BEGIN TRANSACTION")
            cursor.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), group_name))
            cursor.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), group_name))
            cursor.execute("COMMIT")
            insert_audit_log(self.connection, "RENAME_GROUP", "BUSINESS_GROUPS", group_name, self.user_id, old_data, new_data)
            QMessageBox.information(self, "Renamed", f"Group '{group_name}' renamed to '{new_name}'.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.load_all_group_data()
    def delete_group(self):
        group_name = self.get_selected_group()
        if not group_name:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{group_name}'?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        try:
            old_data = {"GROUP_NAME": group_name}
            cursor.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (group_name,))
            cursor.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (group_name,))
            cursor.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (group_name,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE_GROUP", "BUSINESS_GROUPS", group_name, self.user_id, old_data, None)
            QMessageBox.information(self, "Deleted", f"Group '{group_name}' deleted.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.load_all_group_data()
    def load_users(self):
        self.users_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in cursor.fetchall():
            row_index = self.users_table.rowCount()
            self.users_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                self.users_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value else ""))
    def get_selected_user_id(self):
        row = self.users_table.currentRow()
        if row < 0:
            return None
        item = self.users_table.item(row, 0)
        return int(item.text()) if item else None
    def add_user_to_group(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        group_name, ok = QInputDialog.getText(self, "Assign Group", "Group name (existing):")
        if not ok or not group_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (group_name.strip(),))
        if not cursor.fetchone():
            QMessageBox.warning(self, "Error", "Group not found.")
            return
        cursor.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?", (group_name.strip(), user_id))
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"User {user_id} assigned to group {group_name}.")
        self.load_all_group_data()
    def remove_user_from_group(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Remove user {user_id} from group (assign to BG1)?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?", (user_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", f"User {user_id} reassigned to BG1.")
        self.load_all_group_data()
    def load_permissions_group_combo(self):
        self.permissions_group_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for (group_name,) in cursor.fetchall():
            self.permissions_group_combo.addItem(group_name, group_name)
    def load_approvers_group_combo(self):
        self.approvers_group_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for (group_name,) in cursor.fetchall():
            self.approvers_group_combo.addItem(group_name, group_name)
    def load_permissions(self):
        group_name = self.permissions_group_combo.currentData()
        self.permissions_table.setRowCount(0)
        if not group_name:
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (group_name,))
        for row in cursor.fetchall():
            row_index = self.permissions_table.rowCount()
            self.permissions_table.insertRow(row_index)
            self.permissions_table.setItem(row_index, 0, QTableWidgetItem(str(row[0])))
    def add_permission(self):
        group_name = self.permissions_group_combo.currentData()
        if not group_name:
            return
        table_name, ok = QInputDialog.getText(self, "Add Permission", "Table name (e.g., 'dbo.Customers'):")
        if not ok or not table_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME, TARGET_TABLE) VALUES (?, ?)", (group_name, table_name.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", f"Permission added: {group_name} -> {table_name}.")
        self.load_permissions()
    def remove_permission(self):
        group_name = self.permissions_group_combo.currentData()
        row = self.permissions_table.currentRow()
        if row < 0 or not group_name:
            return
        item = self.permissions_table.item(row, 0)
        table_name = item.text().strip()
        confirm = QMessageBox.question(self, "Confirm", f"Remove permission for {group_name} on {table_name}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?", (group_name, table_name))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Permission removed.")
        self.load_permissions()
    def load_approvers(self):
        group_name = self.approvers_group_combo.currentData()
        self.approvers_table.setRowCount(0)
        if not group_name:
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT APPROVER_ID, USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (group_name,))
        for row in cursor.fetchall():
            row_index = self.approvers_table.rowCount()
            self.approvers_table.insertRow(row_index)
            self.approvers_table.setItem(row_index, 0, QTableWidgetItem(str(row[0])))
            self.approvers_table.setItem(row_index, 1, QTableWidgetItem(str(row[1])))
    def add_approver(self):
        group_name = self.approvers_group_combo.currentData()
        if not group_name:
            return
        username, ok = QInputDialog.getText(self, "Add Approver", f"Username for group {group_name}:")
        if not ok or not username.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES (?, ?)", (group_name, username.strip()))
        self.connection.commit()
        insert_audit_log(self.connection, "ADD_APPROVER", "BUSINESS_GROUP_APPROVERS", group_name, self.user_id, None, {"approver": username})
        QMessageBox.information(self, "Added", f"Approver {username} added to group {group_name}.")
        self.load_approvers()
    def remove_approver(self):
        group_name = self.approvers_group_combo.currentData()
        row = self.approvers_table.currentRow()
        if row < 0:
            return
        item = self.approvers_table.item(row, 0)
        approver_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove approver {approver_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?", (approver_id,))
        self.connection.commit()
        insert_audit_log(self.connection, "REMOVE_APPROVER", "BUSINESS_GROUP_APPROVERS", approver_id, self.user_id, {"approver_id": approver_id}, None)
        QMessageBox.information(self, "Removed", "Approver removed.")
        self.load_approvers()

# ---------------------------------------------------------------------------
# USER MANAGEMENT TAB
# ---------------------------------------------------------------------------
class User_management_tab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["UserID", "Username", "Password", "Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add User")
        add_button.clicked.connect(self.add_user)
        button_layout.addWidget(add_button)
        delete_button = QPushButton("Delete User")
        delete_button.clicked.connect(self.delete_user)
        button_layout.addWidget(delete_button)
        change_password_button = QPushButton("Change Password")
        change_password_button.clicked.connect(self.change_password)
        button_layout.addWidget(change_password_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in cursor.fetchall():
            row_index = self.user_table.rowCount()
            self.user_table.insertRow(row_index)
            for col_index, value in enumerate(row):
                self.user_table.setItem(row_index, col_index, QTableWidgetItem(str(value) if value else ""))
    def get_selected_user_id(self):
        row = self.user_table.currentRow()
        if row < 0:
            return None
        item = self.user_table.item(row, 0)
        return int(item.text()) if item else None
    def add_user(self):
        username, ok = QInputDialog.getText(self, "Add User", "Username:")
        if not ok or not username.strip():
            return
        password, ok2 = QInputDialog.getText(self, "Password", "Plain text password:")
        if not ok2 or not password.strip():
            return
        group, ok3 = QInputDialog.getText(self, "Group", "Group (e.g., BG1 or Admin):")
        if not ok3 or not group.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM USERS WHERE USERNAME=?", (username.strip(),))
        if cursor.fetchone():
            QMessageBox.warning(self, "Error", "Username already exists.")
            return
        cursor.execute("INSERT INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES (?, ?, ?)", (username.strip(), password.strip(), group.strip()))
        self.connection.commit()
        insert_audit_log(self.connection, "ADD_USER", "USERS", username, "AdminUser", None, {"username": username})
        QMessageBox.information(self, "Added", "User created with plain-text password.")
        self.load_users()
    def delete_user(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete user {user_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME, PASSWORD, USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", "User not found.")
            return
        old_data = {"USERNAME": row[0], "PASSWORD": row[1], "GROUP": row[2]}
        cursor.execute("DELETE FROM USERS WHERE USER_ID=?", (user_id,))
        self.connection.commit()
        insert_audit_log(self.connection, "DELETE_USER", "USERS", user_id, "AdminUser", old_data, None)
        QMessageBox.information(self, "Deleted", f"User {user_id} deleted.")
        self.load_users()
    def change_password(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        new_password, ok = QInputDialog.getText(self, "Change Password", "New plain-text password:")
        if not ok or not new_password.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME, PASSWORD, USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", "User not found.")
            return
        old_data = {"PASSWORD": row[1]}
        cursor.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?", (new_password.strip(), user_id))
        self.connection.commit()
        insert_audit_log(self.connection, "CHANGE_PASSWORD", "USERS", user_id, "AdminUser", old_data, {"PASSWORD": new_password.strip()})
        QMessageBox.information(self, "Updated", "Password changed.")
        self.load_users()

# ──────────────────────────────────────────────
# End of PART 6
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 7 of 8 (CUSTOM GROUPS + ALERTS)
----------------------------------------------
Builds on previous parts (1–6) to provide:
  - custom_rule_group_enhanced_tab: Manage custom groups, perform BFS on group memberships,
    handle backups, and assign/unassign rules.
  - alerts_and_dashboards_tab: Display alerts for old approvals, stale locks, upcoming schedules,
    and performance outliers.
"""

import sys
import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox,
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QMenu, QSplitter
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor

# ---------------------------------------------------------------------------
# CUSTOM RULE GROUP ENHANCED TAB
# ---------------------------------------------------------------------------
class Custom_rule_group_enhanced_tab(QWidget):
    """
    Manages custom rule groups:
      - Create, rename, delete custom groups.
      - Backup and restore group membership.
      - Assign or remove rules from groups.
      - Search among available unassigned rules.
      - Prevent assignment if a rule is locked.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)

        # Top controls for group management.
        top_layout = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name...")
        top_layout.addWidget(self.new_group_edit)
        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_layout.addWidget(create_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_layout.addWidget(rename_btn)
        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        top_layout.addWidget(delete_btn)
        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_layout.addWidget(backup_btn)
        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_layout.addWidget(restore_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        # Main splitter: left tree for groups and assigned rules; right list for available rules.
        splitter = QSplitter(Qt.Horizontal)
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.group_tree)

        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search available rules (by name/SQL)...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)
        assign_btn = QPushButton("Assign Selected ⇒ Group")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        right_layout.addStretch()
        right_widget.setLayout(right_layout)
        splitter.addWidget(right_widget)

        layout.addWidget(splitter)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.group_tree.clear()
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
            FROM BRM_CUSTOM_RULE_GROUPS
            ORDER BY CUSTOM_GROUP_ID DESC
        """)
        for group_id, group_name, owner_bg in cursor.fetchall():
            display = f"{group_name} (Owner={owner_bg})"
            group_item = QTreeWidgetItem([display])
            group_item.setData(0, Qt.UserRole, group_id)
            group_item.setBackground(0, QBrush(QColor("lightgray")))
            self.group_tree.addTopLevelItem(group_item)
            cursor2 = self.connection.cursor()
            cursor2.execute("""
                SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE, L.LOCKED_BY
                FROM BRM_CUSTOM_GROUP_MEMBERS M
                JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
                LEFT JOIN BRM_RULE_LOCKS L ON R.RULE_ID = L.RULE_ID AND L.ACTIVE_LOCK = 1
                WHERE M.CUSTOM_GROUP_ID = ?
            """, (group_id,))
            for rule_id, rule_name, is_global, critical_rule, locked_by in cursor2.fetchall():
                rule_display = f"Rule {rule_id}: {rule_name}"
                if locked_by:
                    rule_display += f" [LOCKED by {locked_by}]"
                rule_item = QTreeWidgetItem([rule_display])
                rule_item.setData(0, Qt.UserRole, rule_id)
                if is_global == 1:
                    rule_item.setBackground(0, QBrush(QColor("lightblue")))
                if critical_rule == 1:
                    rule_item.setBackground(0, QBrush(QColor("lightcoral")))
                group_item.addChild(rule_item)
        self.group_tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        search_text = self.rule_search_edit.text().strip()
        cursor = self.connection.cursor()
        cursor.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned_ids = {r[0] for r in cursor.fetchall()}
        if search_text:
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """, (f"%{search_text}%", f"%{search_text}%"))
        else:
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        for rule_id, rule_name, owner_group in cursor.fetchall():
            if rule_id in assigned_ids:
                continue
            display = f"Rule {rule_id}: {rule_name} (Owner={owner_group})"
            item = QListWidgetItem(display)
            item.setData(Qt.UserRole, rule_id)
            self.rule_list.addItem(item)

    def create_group(self):
        name = self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Error", "No custom group name provided.")
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP) VALUES (?, ?, ?, GETDATE())", (name, self.user_group, self.user_id))
        self.connection.commit()
        QMessageBox.information(self, "Created", f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def rename_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for group ID {group_id}:")
        if not ok or not new_name.strip():
            return
        cursor = self.connection.cursor()
        try:
            cursor.execute("BEGIN TRANSACTION")
            cursor.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME = ? WHERE CUSTOM_GROUP_ID = ?", (new_name.strip(), group_id))
            cursor.execute("COMMIT")
            insert_audit_log(self.connection, "RENAME_CUSTOM_GROUP", "BRM_CUSTOM_RULE_GROUPS", group_id, str(self.user_id), None, {"new_name": new_name})
            QMessageBox.information(self, "Renamed", f"Group {group_id} renamed to '{new_name}'.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.refresh_all()

    def delete_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        confirm = QMessageBox.question(self, "Confirm", f"Delete custom group {group_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        try:
            cursor.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            cursor.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE_CUSTOM_GROUP", "BRM_CUSTOM_RULE_GROUPS", group_id, str(self.user_id), None, None)
            QMessageBox.information(self, "Deleted", f"Custom group {group_id} deleted.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.refresh_all()

    def backup_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        cursor = self.connection.cursor()
        cursor.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", "Group not found.")
            return
        group_name = row[0]
        cursor.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
        assigned = [r[0] for r in cursor.fetchall()]
        backup_data = {
            "group_name": group_name,
            "members": assigned,
            "backup_user": self.user_id,
            "backup_timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        cursor.execute("SELECT ISNULL(MAX(BACKUP_VERSION), 0) + 1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
        new_version = cursor.fetchone()[0]
        cursor.execute("""
            INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON)
            VALUES (?, GETDATE(), ?, ?)
        """, (group_id, new_version, json.dumps(backup_data)))
        self.connection.commit()
        insert_audit_log(self.connection, "BACKUP_CUSTOM_GROUP", "BRM_CUSTOM_GROUP_BACKUPS", group_id, str(self.user_id), None, {"version": new_version})
        QMessageBox.information(self, "Backup", f"Backup version {new_version} for group {group_id} saved.")
        self.refresh_all()

    def restore_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
            FROM BRM_CUSTOM_GROUP_BACKUPS
            WHERE CUSTOM_GROUP_ID = ?
            ORDER BY BACKUP_VERSION DESC
        """, (group_id,))
        backups = cursor.fetchall()
        if not backups:
            QMessageBox.information(self, "None", "No backups for that group.")
            return
        items = [f"Version {r[0]} (ts={r[1]})" for r in backups]
        selected, ok = QInputDialog.getItem(self, "Restore Backup", "Select version:", items, 0, False)
        if not ok or not selected:
            return
        m = re.search(r"Version\s+(\d+)", selected)
        if not m:
            return
        version = int(m.group(1))
        confirm = QMessageBox.question(self, "Confirm", f"Restore group {group_id} to version {version}? This will overwrite current membership.")
        if confirm != QMessageBox.Yes:
            return
        backup_json = None
        for r in backups:
            if r[0] == version:
                backup_json = r[2]
                break
        if not backup_json:
            QMessageBox.warning(self, "Missing", "Backup for that version not found.")
            return
        try:
            data = json.loads(backup_json)
            new_group_name = data["group_name"]
            members = data["members"]
            cursor.execute("BEGIN TRANSACTION")
            cursor.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME = ? WHERE CUSTOM_GROUP_ID = ?", (new_group_name, group_id))
            cursor.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            for member_rule in members:
                if self.is_rule_locked(member_rule):
                    continue
                cursor.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES (?, ?)", (group_id, member_rule))
            cursor.execute("COMMIT")
            insert_audit_log(self.connection, "RESTORE_CUSTOM_GROUP", "BRM_CUSTOM_GROUP_BACKUPS", group_id, str(self.user_id), {"version": version}, data)
            QMessageBox.information(self, "Restored", f"Group {group_id} restored to version {version}.")
            self.refresh_all()
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))

    def is_rule_locked(self, rule_id):
        cursor = self.connection.cursor()
        cursor.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
        row = cursor.fetchone()
        return True if row and row[0] else False

    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent_item = item.parent()
        if parent_item:
            menu = QMenu()
            remove_action = menu.addAction("Remove Rule from Group")
            selected_action = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if selected_action == remove_action:
                group_id = parent_item.data(0, Qt.UserRole)
                rule_id = item.data(0, Qt.UserRole)
                self.remove_rule_from_group(group_id, rule_id)

    def remove_rule_from_group(self, group_id, rule_id):
        if self.is_rule_locked(rule_id):
            QMessageBox.warning(self, "Locked", f"Rule {rule_id} is locked; cannot remove.")
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ? AND RULE_ID = ?", (group_id, rule_id))
        self.connection.commit()
        QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
        self.refresh_all()

    def assign_rules(self):
        selected_tree = self.group_tree.selectedItems()
        if not selected_tree:
            QMessageBox.warning(self, "None", "No group selected on the left.")
            return
        group_item = selected_tree[0]
        if group_item.parent():
            group_item = group_item.parent()
        group_id = group_item.data(0, Qt.UserRole)
        if not group_id:
            QMessageBox.warning(self, "Error", "Selected item does not have a valid group ID.")
            return
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "None", "No rules selected on the right.")
            return
        cursor = self.connection.cursor()
        assigned_count = 0
        for item in selected_rules:
            rule_id = item.data(Qt.UserRole)
            if self.is_rule_locked(rule_id):
                continue
            try:
                cursor.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES (?, ?)", (group_id, rule_id))
                assigned_count += 1
            except Exception:
                pass
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"{assigned_count} rule(s) assigned to group {group_id}.")
        self.refresh_all()

# ---------------------------------------------------------------------------
# ALERTS & DASHBOARDS TAB
# ---------------------------------------------------------------------------
class Alerts_and_dashboards_tab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        main_layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        main_layout.addWidget(self.alert_text)
        check_button = QPushButton("Check Alerts")
        check_button.clicked.connect(self.check_alerts)
        main_layout.addWidget(check_button)
        self.setLayout(main_layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        cursor = self.connection.cursor()
        # Old approvals (> 3 days)
        cursor.execute("""
            SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                   DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) AS age
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
            WHERE A.APPROVED_FLAG = 0
              AND A.APPROVAL_STAGE = (
                  SELECT MIN(APPROVAL_STAGE)
                  FROM BRM_RULE_APPROVALS
                  WHERE RULE_ID = A.RULE_ID AND APPROVED_FLAG = 0
              )
              AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) > 3
        """)
        old_approvals = cursor.fetchall()
        if old_approvals:
            lines.append("** Old Approvals (> 3 days) **")
            for rule_id, stage, rule_name, age in old_approvals:
                lines.append(f"   - Rule {rule_id} '{rule_name}', stage {stage}, age {age} days")
        else:
            lines.append("No old approvals (> 3 days) found.")
        lines.append("")
        # Stale locks (> 6 hours)
        cursor.execute("""
            SELECT L.RULE_ID, L.LOCKED_BY, R.RULE_NAME,
                   DATEDIFF(HOUR, L.LOCK_TIMESTAMP, GETDATE()) AS locked_hours
            FROM BRM_RULE_LOCKS L
            JOIN BRM_RULES R ON L.RULE_ID = R.RULE_ID
            WHERE L.ACTIVE_LOCK = 1
              AND DATEDIFF(HOUR, L.LOCK_TIMESTAMP, GETDATE()) > 6
        """)
        stale_locks = cursor.fetchall()
        if stale_locks:
            lines.append("** Stale Locks (> 6 hours) **")
            for rule_id, locked_by, rule_name, locked_hours in stale_locks:
                lines.append(f"   - Rule {rule_id} '{rule_name}' locked by {locked_by} for {locked_hours} hours")
        else:
            lines.append("No stale locks (> 6 hours) found.")
        lines.append("")
        # Upcoming schedules (next 24 hours)
        cursor.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
            FROM RULE_SCHEDULES
            WHERE STATUS = 'Scheduled'
              AND SCHEDULE_TIME >= GETDATE()
              AND SCHEDULE_TIME <= DATEADD(HOUR, 24, GETDATE())
            ORDER BY SCHEDULE_TIME
        """)
        upcoming = cursor.fetchall()
        if upcoming:
            lines.append("** Upcoming Schedules (next 24 hours) **")
            for schedule_id, rule_id, schedule_time in upcoming:
                lines.append(f"   - Schedule {schedule_id}, Rule {rule_id}, Time: {schedule_time}")
        else:
            lines.append("No upcoming schedules in next 24 hours.")
        lines.append("")
        # Performance outliers (> 5s in last 7 days)
        cursor.execute("""
            SELECT LOG_ID, RULE_ID, EXECUTION_TIME_MS, EXECUTION_TIMESTAMP
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIME_MS > 5000
              AND EXECUTION_TIMESTAMP >= DATEADD(day, -7, GETDATE())
            ORDER BY EXECUTION_TIMESTAMP DESC
        """)
        perf_outliers = cursor.fetchall()
        if perf_outliers:
            lines.append("** Performance Outliers (> 5s in last 7 days) **")
            for log_id, rule_id, exec_time_ms, exec_timestamp in perf_outliers:
                lines.append(f"   - ExecLog {log_id}, Rule {rule_id}, {exec_time_ms} ms at {exec_timestamp}")
        else:
            lines.append("No performance outliers (> 5s in last 7 days) found.")
        self.alert_text.setPlainText("\n".join(lines))

# ──────────────────────────────────────────────
# End of PART 7
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 8 of 8 (MAIN WINDOW, FULL INTEGRATION)
------------------------------------------------------
This final part integrates all previous parts (1–7) into a single QMainWindow.
It includes:
  - Database connection and user login.
  - BFS execution, advanced CRUD, locks, and multi-step approvals.
  - Scheduling, metadata synchronization, and simulation dialogs.
  - Audit log viewer, rule search, version history, dashboard, and rule editor.
  - Approvals tab, global/critical administration, hierarchy view, and enhanced lineage graph.
  - Metrics dashboard, control tables, group management, and user management.
  - Custom groups and alerts/dashboards.
No encryption references remain.
"""

import sys
import json
import logging
from datetime import datetime

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QComboBox,
    QPushButton, QLabel, QMessageBox, QDialog, QLineEdit, QAction
)
from PyQt5.QtCore import QTimer, Qt

# For simplicity, we assume that all functions and classes from Parts 1–7 have been imported:
# For example:
#   - DatabaseConnectionDialog, LoginDialog, OnboardingWizard (optional)
#   - auto_unlock_expired_locks, sync_metadata_improved
#   - detect_operation_type, parse_sql_dependencies
#   - add_rule, update_rule, deactivate_rule, delete_rule, force_activate_rule, force_deactivate_rule
#   - lock_rule_for_edit, unlock_rule_for_edit
#   - create_multistep_approvals, user_has_table_permission
#   - execute_rules_with_conflicts_composites_bfs
#   - Single_rule_simulation_dialog, Chain_simulation_dialog, Group_simulation_dialog, Enhanced_schedule_dialog
#   - Audit_log_viewer, Rule_search_dialog, Version_history_dialog, Rule_dashboard, Rule_editor_dialog
#   - Multi_step_approval_tab, Global_critical_admin_tab, Hierarchy_view_tab, Enhanced_lineage_graph_widget
#   - Metrics_dashboard_tab, Ctrl_tables_tab, Group_management_tab, User_management_tab
#   - Custom_rule_group_enhanced_tab, Alerts_and_dashboards_tab
#   - Data_validation_tab, Decision_tables_tab, Conflict_priority_manager_tab, Composite_rules_tab,
#     Snapshot_manager_tab, Tags_manager_tab, What_if_test_tab, Schedule_management_tab
#
# Ensure these components are available in your project.

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Final Production Build")
        self.resize(1350, 900)

        self.connection = None
        self.user_id = None
        self.user_group = None
        self.logged_in_username = None

        # Step 1: Database connection
        db_dialog = DatabaseConnectionDialog()
        if db_dialog.exec_() == QDialog.Accepted:
            conn = db_dialog.get_connection()
            if not conn:
                sys.exit(1)
            self.connection = conn
        else:
            sys.exit(0)

        # Step 2: User login
        login_dialog = LoginDialog(self.connection)
        if login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dialog.user_id
        self.user_group = login_dialog.user_group
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = cursor.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            QMessageBox.critical(self, "Error", "User not found in DB after login.")
            sys.exit(1)

        # Optionally, run the onboarding wizard
        # onboarding_wizard = OnboardingWizard(self.connection)
        # onboarding_wizard.exec_()

        self.init_ui()

    def init_ui(self):
        # Build the menu bar
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu("File")

        sync_metadata_action = QAction("Sync Metadata", self)
        sync_metadata_action.triggered.connect(self.handle_sync_metadata)
        file_menu.addAction(sync_metadata_action)

        metrics_action = QAction("View Metrics Dashboard", self)
        metrics_action.triggered.connect(self.launch_metrics_dashboard)
        file_menu.addAction(metrics_action)

        schedule_action = QAction("New Schedule Dialog", self)
        schedule_action.triggered.connect(self.launch_schedule_dialog)
        file_menu.addAction(schedule_action)

        chain_sim_action = QAction("Simulate Parent Chain BFS", self)
        chain_sim_action.triggered.connect(self.launch_chain_simulation)
        file_menu.addAction(chain_sim_action)

        group_sim_action = QAction("Simulate Custom Group BFS", self)
        group_sim_action.triggered.connect(self.launch_group_simulation)
        file_menu.addAction(group_sim_action)

        # Help menu
        help_menu = menubar.addMenu("Help")
        about_action = QAction("About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

        # Tools menu
        tools_menu = menubar.addMenu("Tools")
        audit_log_action = QAction("View Audit Logs", self)
        audit_log_action.triggered.connect(self.launch_audit_log_viewer)
        tools_menu.addAction(audit_log_action)

        rule_search_action = QAction("Search Rules", self)
        rule_search_action.triggered.connect(self.launch_rule_search_dialog)
        tools_menu.addAction(rule_search_action)

        version_history_action = QAction("Version History", self)
        version_history_action.triggered.connect(self.launch_version_history_dialog)
        tools_menu.addAction(version_history_action)

        data_validation_action = QAction("Run Data Validations", self)
        data_validation_action.triggered.connect(self.run_all_data_validations)
        tools_menu.addAction(data_validation_action)

        # Central widget with tabbed interface
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # Admin impersonation (if user is admin)
        if self.user_group.lower() == "admin":
            impersonation_layout = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_button = QPushButton("Switch User")
            self.switch_button.clicked.connect(self.handle_switch_user)
            impersonation_layout.addWidget(QLabel("Impersonate:"))
            impersonation_layout.addWidget(self.switch_combo)
            impersonation_layout.addWidget(self.switch_button)
            impersonation_layout.addStretch()
            main_layout.addLayout(impersonation_layout)
            self.populate_switch_combo()

        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # Business Rules tab (Dashboard and CRUD)
        business_rules_widget = QWidget()
        br_layout = QVBoxLayout(business_rules_widget)
        crud_button_layout = QHBoxLayout()
        add_rule_button = QPushButton("Add Rule")
        add_rule_button.clicked.connect(self.add_rule)
        crud_button_layout.addWidget(add_rule_button)
        update_rule_button = QPushButton("Update Rule")
        update_rule_button.clicked.connect(self.update_rule)
        crud_button_layout.addWidget(update_rule_button)
        force_activate_button = QPushButton("Force Activate")
        force_activate_button.clicked.connect(self.force_activate_rule)
        crud_button_layout.addWidget(force_activate_button)
        force_deactivate_button = QPushButton("Force Deactivate")
        force_deactivate_button.clicked.connect(self.force_deactivate_rule)
        crud_button_layout.addWidget(force_deactivate_button)
        delete_rule_button = QPushButton("Delete Rule")
        delete_rule_button.clicked.connect(self.delete_rule)
        crud_button_layout.addWidget(delete_rule_button)
        run_bfs_button = QPushButton("Run ETL BFS")
        run_bfs_button.clicked.connect(self.run_bfs_etl)
        crud_button_layout.addWidget(run_bfs_button)
        simulate_single_button = QPushButton("Simulate Single Rule")
        simulate_single_button.clicked.connect(self.simulate_single_rule)
        crud_button_layout.addWidget(simulate_single_button)
        crud_button_layout.addStretch()
        br_layout.addLayout(crud_button_layout)
        self.rule_dashboard = Rule_dashboard(self.connection, self.user_id, self.user_group)
        br_layout.addWidget(self.rule_dashboard)
        business_rules_widget.setLayout(br_layout)
        self.tabs.addTab(business_rules_widget, "Business Rules")

        # Approvals tab
        approvals_tab = Multi_step_approval_tab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(approvals_tab, "Approvals")

        # Global/Critical Admin tab (Admin only)
        if self.user_group.lower() == "admin":
            gcr_admin_tab = Global_critical_admin_tab(self, self.connection, self.user_group)
            self.tabs.addTab(gcr_admin_tab, "Global/Critical Admin")

        # Hierarchy view tab
        hierarchy_tab = Hierarchy_view_tab(self.connection)
        self.tabs.addTab(hierarchy_tab, "Hierarchy")

        # Enhanced Lineage Graph tab
        lineage_widget = QWidget()
        lineage_layout = QVBoxLayout(lineage_widget)
        lineage_label = QLabel("Enhanced Lineage Graph")
        lineage_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        lineage_layout.addWidget(lineage_label)
        self.lineage_graph = Enhanced_lineage_graph_widget(self.connection)
        lineage_layout.addWidget(self.lineage_graph)
        search_layout = QHBoxLayout()
        self.lineage_search_edit = QLineEdit()
        self.lineage_search_edit.setPlaceholderText("Search rule/table/column...")
        search_layout.addWidget(self.lineage_search_edit)
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.lineage_search)
        search_layout.addWidget(search_button)
        reset_button = QPushButton("Reset View")
        reset_button.clicked.connect(self.lineage_graph.reset_view)
        search_layout.addWidget(reset_button)
        refresh_lineage_button = QPushButton("Refresh Graph")
        refresh_lineage_button.clicked.connect(self.lineage_graph.populate_graph)
        search_layout.addWidget(refresh_lineage_button)
        search_layout.addStretch()
        lineage_layout.addLayout(search_layout)
        lineage_widget.setLayout(lineage_layout)
        self.tabs.addTab(lineage_widget, "Lineage")

        # Custom Groups tab
        custom_groups_tab = Custom_rule_group_enhanced_tab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(custom_groups_tab, "Custom Groups")

        # Scheduling tab
        schedule_management_tab = Schedule_management_tab(self.connection)
        self.tabs.addTab(schedule_management_tab, "Scheduling")

        # Control Tables tab
        ctrl_tables_tab = Ctrl_tables_tab(self.connection, self.user_group)
        self.tabs.addTab(ctrl_tables_tab, "Control Tables")

        # Metrics Dashboard tab
        metrics_tab = Metrics_dashboard_tab(self.connection)
        self.tabs.addTab(metrics_tab, "Metrics")

        # Alerts & Dashboards tab
        alerts_tab = Alerts_and_dashboards_tab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(alerts_tab, "Alerts & Dashboard")

        # Group Management tab
        group_mgmt_tab = Group_management_tab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(group_mgmt_tab, "Group Management")

        # User Management tab (Admin only)
        if self.user_group.lower() == "admin":
            user_mgmt_tab = User_management_tab(self.connection)
            self.tabs.addTab(user_mgmt_tab, "User Management")

        self.setCentralWidget(central_widget)

        # Set up timers for automatic refresh
        self.approval_timer = QTimer(self)
        self.approval_timer.timeout.connect(lambda: self.tabs.widget(1).load_approvals())
        self.approval_timer.start(4000)  # every 4 seconds

        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)  # every minute

        self.alerts_timer = QTimer(self)
        self.alerts_timer.timeout.connect(lambda: self.tabs.widget(7).check_alerts())
        self.alerts_timer.start(120000)  # every 2 minutes

        # Timer for auto unlocking expired locks (every 5 minutes)
        self.unlock_timer = QTimer(self)
        self.unlock_timer.timeout.connect(lambda: auto_unlock_expired_locks(self.connection))
        self.unlock_timer.start(300000)

        self.show()

    # ----------------------------------------------------------------------
    # Menu Handlers
    # ----------------------------------------------------------------------
    def handle_sync_metadata(self):
        try:
            sync_metadata_improved(self.connection)
        except Exception as ex:
            QMessageBox.critical(self, "Sync Error", str(ex))

    def launch_metrics_dashboard(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800, 600)
        layout = QVBoxLayout(dlg)
        metrics_widget = Metrics_dashboard_tab(self.connection, dlg)
        layout.addWidget(metrics_widget)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        layout.addWidget(close_btn)
        dlg.exec_()

    def launch_schedule_dialog(self):
        dlg = Enhanced_schedule_dialog(self.connection, self)
        dlg.exec_()

    def launch_chain_simulation(self):
        dlg = Chain_simulation_dialog(self.connection, self)
        dlg.exec_()

    def launch_group_simulation(self):
        dlg = Group_simulation_dialog(self.connection, self)
        dlg.exec_()

    def show_about(self):
        about_text = (
            "BRM Tool – Final Integrated Version\n"
            "Includes BFS, advanced CRUD, data validations, multi-step approvals, scheduling, metadata sync, and more.\n"
            "No encryption references remain. Enjoy!"
        )
        QMessageBox.information(self, "About", about_text)

    def launch_audit_log_viewer(self):
        dlg = Audit_log_viewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_rule_search_dialog(self):
        dlg = Rule_search_dialog(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_version_history_dialog(self):
        rule_id, ok = QInputDialog.getInt(self, "Version History", "Enter Rule ID for version history:")
        if not ok:
            return
        dlg = Version_history_dialog(self.connection, rule_id, self)
        dlg.exec_()

    def run_all_data_validations(self):
        cursor = self.connection.cursor()
        cursor.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        tables = cursor.fetchall()
        failed_tables = []
        for (table_name,) in tables:
            if table_name:
                passed = run_data_validations_for_table(self.connection, table_name.lower())
                if not passed:
                    failed_tables.append(table_name)
        if failed_tables:
            QMessageBox.warning(self, "Data Validations", "Validations failed for: " + ", ".join(failed_tables))
        else:
            QMessageBox.information(self, "Data Validations", "All validations passed.")

    # ----------------------------------------------------------------------
    # Impersonation (Admin only)
    # ----------------------------------------------------------------------
    def populate_switch_combo(self):
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for user_id, username, user_group in cursor.fetchall():
            display = f"{username} ({user_group})"
            self.switch_combo.addItem(display, (user_id, user_group))

    def handle_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_user_id, new_user_group = data
        if new_user_id == self.user_id and new_user_group == self.user_group:
            return
        self.user_id = new_user_id
        self.user_group = new_user_group
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = cursor.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "Unknown"
        QMessageBox.information(self, "Switched", f"Now impersonating user {self.user_id} ({self.user_group}).")
        # Refresh components that rely on user identity
        self.tabs.widget(1).logged_in_username = self.logged_in_username
        self.tabs.widget(1).user_group = self.user_group
        self.tabs.widget(1).load_approvals()
        self.rule_dashboard.user_id = self.user_id
        self.rule_dashboard.user_group = self.user_group
        self.rule_dashboard.load_rules()
        self.tabs.widget(7).user_id = self.user_id
        self.tabs.widget(7).user_group = self.user_group
        self.tabs.widget(7).check_alerts()

    # ----------------------------------------------------------------------
    # Business Rules CRUD Actions
    # ----------------------------------------------------------------------
    def add_rule(self):
        dlg = Rule_editor_dialog(self.connection, self.user_group, None, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dashboard.load_rules()

    def update_rule(self):
        selected_ids = self.rule_dashboard.get_selected_rule_ids()
        if len(selected_ids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to update.")
            return
        rule_id = selected_ids[0]
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", f"Rule {rule_id} not found.")
            return
        columns = [desc[0] for desc in cursor.description]
        rule_data = dict(zip(columns, row))
        dlg = Rule_editor_dialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dashboard.load_rules()

    def force_activate_rule(self):
        selected_ids = self.rule_dashboard.get_selected_rule_ids()
        if not selected_ids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Force activate {len(selected_ids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success_count = 0
        fails = []
        for rule_id in selected_ids:
            try:
                force_activate_rule(self.connection, rule_id, self.user_id, self.user_group)
                success_count += 1
            except Exception as ex:
                fails.append(str(ex))
        QMessageBox.information(self, "Force Activate", f"Force activation: {success_count} succeeded, failures: {fails}")
        self.rule_dashboard.load_rules()

    def force_deactivate_rule(self):
        selected_ids = self.rule_dashboard.get_selected_rule_ids()
        if not selected_ids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Force deactivate {len(selected_ids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success_count = 0
        fails = []
        for rule_id in selected_ids:
            try:
                force_deactivate_rule(self.connection, rule_id, self.user_id, self.user_group)
                success_count += 1
            except Exception as ex:
                fails.append(str(ex))
        QMessageBox.information(self, "Force Deactivate", f"Force deactivation: {success_count} succeeded, failures: {fails}")
        self.rule_dashboard.load_rules()

    def delete_rule(self):
        selected_ids = self.rule_dashboard.get_selected_rule_ids()
        if not selected_ids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(selected_ids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success_count = 0
        fails = []
        for rule_id in selected_ids:
            try:
                delete_rule(self.connection, rule_id, self.user_id, self.user_group)
                success_count += 1
            except Exception as ex:
                fails.append(str(ex))
        QMessageBox.information(self, "Delete", f"Deletion: {success_count} succeeded, failures: {fails}")
        self.rule_dashboard.load_rules()

    def run_bfs_etl(self):
        from time import perf_counter
        start_time = perf_counter()
        executed, skipped = execute_rules_with_conflicts_composites_bfs(self.connection, measure_perf=True)
        elapsed_ms = (perf_counter() - start_time) * 1000
        QMessageBox.information(self, "ETL BFS", f"BFS executed: {executed}\nSkipped: {list(skipped)}\nElapsed: {elapsed_ms:.2f} ms")
        self.rule_dashboard.load_rules()

    def simulate_single_rule(self):
        selected_ids = self.rule_dashboard.get_selected_rule_ids()
        if len(selected_ids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule for single simulation.")
            return
        rule_id = selected_ids[0]
        dlg = Single_rule_simulation_dialog(self.connection, self)
        dlg.rule_combo.setCurrentIndex(dlg.rule_combo.findData(rule_id))
        dlg.exec_()

    def lineage_search(self):
        search_text = self.lineage_search_edit.text().strip()
        self.lineage_graph.search_and_highlight(search_text)

    def check_due_schedules(self):
        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, VALIDATION_FLAG
            FROM RULE_SCHEDULES
            WHERE STATUS = 'Scheduled'
              AND SCHEDULE_TIME <= ?
        """, (now_str,))
        due_schedules = cursor.fetchall()
        for schedule_id, rule_id, schedule_time, validation_flag in due_schedules:
            cursor2 = self.connection.cursor()
            cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'InProgress' WHERE SCHEDULE_ID = ?", (schedule_id,))
            self.connection.commit()
            cursor2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
            row = cursor2.fetchone()
            if not row:
                cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (schedule_id,))
                self.connection.commit()
                continue
            rule_sql = row[0]
            from time import perf_counter
            start = perf_counter()
            success = False
            message = ""
            record_count = 0
            cursor2.execute("BEGIN TRANSACTION")
            try:
                if validation_flag:
                    cursor3 = self.connection.cursor()
                    cursor3.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
                    validation_failed = False
                    for db_name, tbl_name in cursor3.fetchall():
                        if tbl_name:
                            full_table = (db_name + "." + tbl_name).lower()
                            if not run_data_validations_for_table(self.connection, full_table):
                                validation_failed = True
                                break
                    if validation_failed:
                        cursor2.execute("ROLLBACK")
                        cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (schedule_id,))
                        self.connection.commit()
                        continue
                cursor2.execute(rule_sql)
                rows = cursor2.fetchall()
                if rows:
                    record_count = len(rows)
                    success = (rows[0][0] == 1)
                    message = f"Returned: {rows[0][0]}"
                else:
                    success = True
                    message = "No rows returned => PASS"
                if success:
                    cursor2.execute("COMMIT")
                else:
                    cursor2.execute("ROLLBACK")
            except Exception as ex:
                cursor2.execute("ROLLBACK")
                success = False
                message = str(ex)
            elapsed_ms = int((perf_counter() - start) * 1000)
            if success:
                cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Executed' WHERE SCHEDULE_ID = ?", (schedule_id,))
            else:
                cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (schedule_id,))
            cursor2.execute("""
                INSERT INTO RULE_EXECUTION_LOGS(
                    RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS
                )
                VALUES (?, GETDATE(), ?, ?, ?, ?)
            """, (rule_id, 1 if success else 0, message, record_count, int(elapsed_ms)))
            self.connection.commit()
        # Refresh schedule tab if present
        for i in range(self.tabs.count()):
            widget = self.tabs.widget(i)
            if hasattr(widget, "load_schedules"):
                widget.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except Exception:
                pass
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    tool = BRMTool()
    sys.exit(app.exec_())