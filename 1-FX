#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
EnhancedLineageGraphWidget – Advanced End‑to‑End Lineage Visualization

Features:
  • Advanced force‑directed layout with repulsion and spring forces.
  • Table‑like node visualization: each node displays the rule name (header), followed by owner,
    operation type, and summaries of source and target tables.
  • Directional edges with arrowheads and an edge label (showing the linking table name).
  • Public method setSearchQuery(query) that filters nodes by any attribute (rule name, owner,
    operation type, source table, target table, etc.).
  • Constructs lineage based on BRM_RULES and BRM_RULE_TABLE_DEPENDENCIES.
  • Colors and text indicate special types of rules (e.g. if CRITICAL_RULE is set or if OPERATION_TYPE is DATA_VALIDATION).

This code expects a valid pyodbc (or similar) database connection object and that your DB tables
are defined as in your DDL.
"""

import math, json
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QBrush, QPen, QColor, QPolygonF
from PyQt5.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsItem

# ---------------------- RuleNodeItem Class ----------------------
class RuleNodeItem(QtWidgets.QGraphicsItem):
    def __init__(self, rule_data, width=220, height=90):
        """
        rule_data: dict with keys:
            - RULE_ID, RULE_NAME, OWNER_GROUP, OPERATION_TYPE, CRITICAL_RULE,
            - source_tables: set of tuples (dbname, tblname, column)
            - target_tables: set of tuples (dbname, tblname, column)
        """
        super().__init__()
        self.rule_data = rule_data
        self.width = width
        self.height = height
        self.force = QPointF(0, 0)
        self.velocity = QPointF(0, 0)
        # Color-code based on rule type:
        if rule_data.get("CRITICAL_RULE") == 1:
            self.bg_color = QColor("#FFCCCC")  # Light red for critical
        elif (rule_data.get("OPERATION_TYPE") or "").upper() == "DATA_VALIDATION":
            self.bg_color = QColor("#CCFFCC")  # Light green for data validation
        else:
            self.bg_color = QColor("#CCCCFF")  # Light blue otherwise
        # Enable moving and notify when position changes.
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | 
                      QtWidgets.QGraphicsItem.ItemSendsGeometryChanges)
    
    def boundingRect(self):
        return QtCore.QRectF(0, 0, self.width, self.height)
    
    def paint(self, painter, option, widget):
        rect = self.boundingRect()
        # Draw rounded rectangle for the node
        painter.setPen(QPen(Qt.black))
        painter.setBrush(QBrush(self.bg_color))
        painter.drawRoundedRect(rect, 5, 5)
        # Draw header with rule name
        header_rect = QtCore.QRectF(0, 0, self.width, 25)
        painter.setBrush(QBrush(Qt.darkGray))
        painter.drawRoundedRect(header_rect, 5, 5)
        painter.setPen(Qt.white)
        painter.drawText(header_rect, Qt.AlignCenter, self.rule_data.get("RULE_NAME", ""))
        # Draw body text with details
        painter.setPen(Qt.black)
        body_rect = QtCore.QRectF(5, 30, self.width - 10, self.height - 35)
        owner = self.rule_data.get("OWNER_GROUP", "Unknown")
        op_type = self.rule_data.get("OPERATION_TYPE", "N/A")
        # Extract unique source and target table names
        src_tables = sorted({tbl for db, tbl, col in self.rule_data.get("source_tables", set())})
        tgt_tables = sorted({tbl for db, tbl, col in self.rule_data.get("target_tables", set())})
        text = f"Owner: {owner}\nType: {op_type}"
        if src_tables:
            text += f"\nSrc: {', '.join(src_tables)}"
        if tgt_tables:
            text += f"\nTgt: {', '.join(tgt_tables)}"
        painter.drawText(body_rect, Qt.AlignLeft | Qt.AlignTop, text)
    
    def itemChange(self, change, value):
        # Notify connected edges to update when node moves
        if change == QtWidgets.QGraphicsItem.ItemPositionChange:
            for item in self.scene().items():
                if isinstance(item, EdgeItem):
                    if item.source == self or item.dest == self:
                        item.updatePosition()
        return super().itemChange(change, value)

# ---------------------- EdgeItem Class ----------------------
class EdgeItem(QtWidgets.QGraphicsLineItem):
    def __init__(self, source, dest, table_info):
        """
        source, dest: RuleNodeItem instances
        table_info: Tuple (dbname, table_name) used as label for the edge.
        """
        super().__init__()
        self.source = source
        self.dest = dest
        self.table_info = table_info  # e.g., ("dbo", "Customers")
        self._pen = QPen(Qt.gray, 2)
        self.setPen(self._pen)
        self.arrow_head = None
        self.label_item = None
        self.setZValue(-1)  # Ensure edges appear behind nodes
    
    def updatePosition(self):
        # Calculate center positions of source and destination nodes
        src_center = self.source.pos() + QPointF(self.source.width / 2, self.source.height / 2)
        dst_center = self.dest.pos() + QPointF(self.dest.width / 2, self.dest.height / 2)
        line = QtCore.QLineF(src_center, dst_center)
        self.setLine(line)
        self.update_arrowhead(line)
    
    def update_arrowhead(self, line):
        scene = self.scene()
        # Remove existing arrow head if present
        if self.arrow_head:
            scene.removeItem(self.arrow_head)
            self.arrow_head = None
        # Calculate angle of the line
        angle = math.atan2(-line.dy(), line.dx())
        arrow_size = 10.0
        # Compute two points for the arrowhead polygon
        p1 = line.p2() - QPointF(math.cos(angle - math.pi/6) * arrow_size,
                                 -math.sin(angle - math.pi/6) * arrow_size)
        p2 = line.p2() - QPointF(math.cos(angle + math.pi/6) * arrow_size,
                                 -math.sin(angle + math.pi/6) * arrow_size)
        polygon = QtGui.QPolygonF([line.p2(), p1, p2])
        self.arrow_head = scene.addPolygon(polygon, self._pen, QBrush(Qt.gray))
        self.arrow_head.setZValue(10)
        # Update or create label at the midpoint
        mid_point = (line.p1() + line.p2()) / 2
        if self.label_item is None:
            self.label_item = scene.addText("")
            self.label_item.setDefaultTextColor(Qt.darkGray)
            self.label_item.setZValue(10)
        self.label_item.setPlainText(f"{self.table_info[1]}")
        self.label_item.setPos(mid_point)

# ---------------------- EnhancedLineageGraphWidget Class ----------------------
class EnhancedLineageGraphWidget(QGraphicsView):
    def __init__(self, connection, parent=None):
        """
        connection: An active database connection.
        """
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.nodes = {}   # Dictionary: rule_id -> RuleNodeItem
        self.edges = []   # List of EdgeItem
        self.search_query = ""
        self.load_data()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_forces)
        self.timer.start(30)
    
    def load_data(self):
        """
        Load rule data and dependencies from the database.
        Expects BRM_RULES with fields: RULE_ID, RULE_NAME, OWNER_GROUP, OPERATION_TYPE, CRITICAL_RULE.
        Expects BRM_RULE_TABLE_DEPENDENCIES with fields: RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP.
        """
        c = self.connection.cursor()
        # Load rules
        c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, OPERATION_TYPE, CRITICAL_RULE 
            FROM BRM_RULES
        """)
        rules = c.fetchall()
        self.rule_data = {}
        for row in rules:
            rid, rname, owner, op_type, critical = row
            self.rule_data[rid] = {
                "RULE_ID": rid,
                "RULE_NAME": rname,
                "OWNER_GROUP": owner,
                "OPERATION_TYPE": op_type,
                "CRITICAL_RULE": critical,
                "source_tables": set(),  # Set of tuples (dbname, table_name, column)
                "target_tables": set()
            }
        # Load table dependencies
        c.execute("""
            SELECT RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP 
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps = c.fetchall()
        for dep in deps:
            rid, dbname, tblname, colname, col_op = dep
            if rid in self.rule_data:
                if col_op.upper() == "READ":
                    self.rule_data[rid]["source_tables"].add((dbname.strip(), tblname.strip(), colname.strip()))
                elif col_op.upper() == "WRITE":
                    self.rule_data[rid]["target_tables"].add((dbname.strip(), tblname.strip(), colname.strip()))
        # Create nodes
        for rid, data in self.rule_data.items():
            node = RuleNodeItem(data)
            # Place nodes in a grid layout initially
            x = 50 + (rid % 10) * 80
            y = 50 + (rid // 10) * 90
            node.setPos(x, y)
            self.scene.addItem(node)
            self.nodes[rid] = node
        # Build edges based on dependencies:
        # For every rule A, if a table it writes to is read by rule B, create an edge A -> B.
        added_edges = set()
        for rid_a, data_a in self.rule_data.items():
            targets = { (db, tbl) for db, tbl, col in data_a["target_tables"] }
            for rid_b, data_b in self.rule_data.items():
                if rid_a == rid_b:
                    continue
                sources = { (db, tbl) for db, tbl, col in data_b["source_tables"] }
                common = targets & sources
                if common:
                    for table in common:
                        edge_key = (rid_a, rid_b, table)
                        if edge_key in added_edges:
                            continue
                        edge = EdgeItem(self.nodes[rid_a], self.nodes[rid_b], table)
                        self.scene.addItem(edge)
                        self.edges.append(edge)
                        added_edges.add(edge_key)
    
    def update_forces(self):
        """
        Apply a simple force-directed layout:
         - Nodes repel each other.
         - Connected nodes are pulled together by a spring force.
        """
        repulsion = 1000.0
        spring_length = 150.0
        spring_strength = 0.05
        damping = 0.85
        # Reset forces for all nodes
        for node in self.nodes.values():
            node.force = QPointF(0, 0)
        node_list = list(self.nodes.values())
        for i in range(len(node_list)):
            for j in range(i + 1, len(node_list)):
                node_a = node_list[i]
                node_b = node_list[j]
                delta = node_a.pos() - node_b.pos()
                distance = max(1.0, math.hypot(delta.x(), delta.y()))
                force_mag = repulsion / (distance * distance)
                force = (delta / distance) * force_mag
                node_a.force += force
                node_b.force -= force
        # Spring forces along edges
        for edge in self.edges:
            delta = edge.source.pos() - edge.dest.pos()
            distance = max(1.0, math.hypot(delta.x(), delta.y()))
            displacement = distance - spring_length
            force = (delta / distance) * (spring_strength * displacement)
            edge.source.force -= force
            edge.dest.force += force
        # Update node positions
        for node in self.nodes.values():
            velocity = node.velocity + node.force * 0.1
            velocity *= damping
            node.velocity = velocity
            node.setPos(node.pos() + velocity)
        # Update edges positions
        for edge in self.edges:
            edge.updatePosition()
        # Apply search filter after forces update
        self.apply_search_filter()
    
    def setSearchQuery(self, query):
        """
        Public method: set the search query and apply filter.
        The search is performed on:
          - RULE_NAME, OWNER_GROUP, OPERATION_TYPE,
          - All source table names, and target table names.
        """
        self.search_query = query.lower().strip()
        self.apply_search_filter()
    
    def apply_search_filter(self):
        """
        Hide or show nodes (and associated edges) based on whether the search query is found.
        """
        for node in self.nodes.values():
            data = node.rule_data
            searchable = " ".join([
                str(data.get("RULE_NAME", "")),
                str(data.get("OWNER_GROUP", "")),
                str(data.get("OPERATION_TYPE", "")),
                " ".join([tbl for db, tbl, col in data.get("source_tables", set())]),
                " ".join([tbl for db, tbl, col in data.get("target_tables", set())])
            ]).lower()
            node_visible = self.search_query in searchable
            node.setVisible(node_visible)
        # For edges, show only if both source and dest nodes are visible
        for edge in self.edges:
            if edge.source.isVisible() and edge.dest.isVisible():
                edge.setVisible(True)
                if edge.label_item:
                    edge.label_item.setVisible(True)
            else:
                edge.setVisible(False)
                if edge.label_item:
                    edge.label_item.setVisible(False)
    
    def refresh(self):
        """Public method to completely reload the graph from the database."""
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()
        self.load_data()
        self.update_forces()

# ---------------------- Example Integration Code ----------------------
# In your main application code you would instantiate EnhancedLineageGraphWidget and a search field.
#
# Example:
#
#   self.searchField = QLineEdit()
#   self.searchField.setPlaceholderText("Search lineage (rule, table, DB, user group)...")
#   self.searchField.textChanged.connect(lambda text: self.lineageWidget.setSearchQuery(text))
#   layout.addWidget(self.searchField)
#
#   self.lineageWidget = EnhancedLineageGraphWidget(db_connection)
#   layout.addWidget(self.lineageWidget)
#
# This widget will now show end-to-end lineage (source table → target table) with table-like nodes and connected
# directional edges (with arrowheads and labels), and will filter based on any text entered in the search field.