#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 8 (FINAL, BEST IN CLASS UI/UX, FULLY ENHANCED)
This module integrates all functionalities from Parts 1–7 and adds advanced features:
  • Enhanced Audit Log Analysis with full‑text search, version diff, export (CSV/JSON/Excel) and trend charts.
  • Predictive Analytics for rule performance forecasting and anomaly detection with advanced filtering.
  • Enhanced Lineage Analysis with an interactive force‑directed, MANTA‑like, drill‑down, searchable lineage graph.
       → Now supports advanced filters by column, table, database, user group, and user.
  • Admin UI for control table updates with role‑based access.
  • Integrated Help & Feedback tab with dynamic, database‑backed help.
  • Data Validation tab that allows adding, updating, deleting, and running validations.
  • A unified main window with a modern flat UI, wizard‑based flows, real‑time notifications, and admin impersonation.

Assumptions:
  - All helper functions and classes (insert_audit_log, LockManager, detect_operation_type,
    parse_sql_dependencies, run_data_validations, create_multistep_approvals, load_rule_relationships,
    etc.) are defined here.
  - A HELP_CONTENT table exists in the database with appropriate schema.
  - Other referenced tabs (BusinessRulesTab, ApprovalsTab, SchedulingTab, etc.) are implemented as shown.
"""

import sys, os, json, csv, math, logging, difflib
from datetime import datetime, timedelta
import numpy as np
from sklearn.linear_model import LinearRegression

import pyqtgraph as pg

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime, QPointF
from PyQt5.QtGui import QIcon, QPen, QBrush, QColor, QFont, QPalette
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QLabel, QPushButton, QDockWidget, QLineEdit, QMessageBox, QComboBox, QTableWidget,
    QTableWidgetItem, QPlainTextEdit, QInputDialog, QFileDialog, QTreeWidget, QTreeWidgetItem,
    QGraphicsView, QGraphicsScene, QGraphicsEllipseItem, QGraphicsLineItem, QProgressDialog,
    QSplitter, QMenu, QCalendarWidget, QTimeEdit, QFormLayout, QGroupBox, QCheckBox, QListWidget, QListWidgetItem
)

# ---------------------- Logging & Helper Functions ----------------------
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
logger = logging.getLogger("BRM_TOOL")

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG (ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
            VALUES (?, ?, ?, ?, ?, ?, GETDATE())
        """, (action, table_name, str(record_id) if record_id else None, actor,
              json.dumps(old_data) if old_data else None,
              json.dumps(new_data) if new_data else None))
        conn.commit()
        logger.debug(f"Audit log inserted: {action} on {table_name} (Record: {record_id})")
    except Exception as e:
        logger.error(f"Error inserting audit log: {e}")

class LockManager:
    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < ?", (now,))
            conn.commit()
            logger.info("Expired locks auto-unlocked.")
        except Exception as e:
            logger.error(f"Error auto unlocking locks: {e}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("SELECT LOCKED_BY, EXPIRY_TIMESTAMP FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        row = c.fetchone()
        if row:
            if datetime.now() > row[1]:
                c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
                conn.commit()
                return None
            return row[0]
        return None

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        owner = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if owner and owner != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {owner}.")
        elif owner and owner != user_id and force:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
            VALUES (?, ?, ?, ?, ?, 1)
        """, (rule_id, user_id, now, expiry, 1 if force else 0))
        conn.commit()
        logger.info(f"Rule {rule_id} locked by {user_id} (force={force}).")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        current_owner = LockManager.rule_current_lock_owner(conn, rule_id)
        if current_owner and current_owner != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {current_owner}. Cannot unlock.")
        c = conn.cursor()
        c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        conn.commit()
        logger.info(f"Rule {rule_id} unlocked by {user_id} (force={force}).")

def detect_operation_type(sql_text: str) -> str:
    import re
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or "", flags=re.MULTILINE | re.DOTALL).lstrip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text: str):
    try:
        import sqlparse
        statements = sqlparse.parse(sql_text)
        tables = []
        for stmt in statements:
            for token in stmt.tokens:
                if token.ttype is None and token.is_group:
                    for subtoken in token.tokens:
                        if subtoken.ttype is None and subtoken.is_group:
                            continue
                        if subtoken.ttype is sqlparse.tokens.Name:
                            tables.append(subtoken.value)
        return {"tables": list(set(tables))}
    except Exception as e:
        logger.error(f"Error parsing SQL dependencies: {e}")
        return {"tables": []}

def run_data_validations(conn):
    c = conn.cursor()
    try:
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS")
        validations = c.fetchall()
        for vid, tbl, col, vtype, params in validations:
            if vtype.upper() == "NOT NULL":
                query = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(query)
                count = c.fetchone()[0]
                result = "PASS" if count == 0 else "FAIL"
                details = f"{count} null values found" if count else "All non-null"
            elif vtype.upper() == "RANGE":
                min_val = max_val = None
                if params:
                    for part in params.split(";"):
                        part = part.strip()
                        if part.lower().startswith("min="):
                            min_val = float(part.split("=")[1])
                        elif part.lower().startswith("max="):
                            max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result = "FAIL"
                    details = "Invalid RANGE parameters"
                else:
                    query = f"SELECT COUNT(*) FROM {tbl} WHERE TRY_CAST({col} AS FLOAT) IS NOT NULL AND (TRY_CAST({col} AS FLOAT) < {min_val} OR TRY_CAST({col} AS FLOAT) > {max_val})"
                    c.execute(query)
                    count = c.fetchone()[0]
                    result = "PASS" if count == 0 else "FAIL"
                    details = f"{count} rows out of range [{min_val}, {max_val}]" if count else "All values in range"
            elif vtype.upper() == "UNIQUE":
                query = f"SELECT COUNT(*) FROM (SELECT {col}, COUNT(*) AS cnt FROM {tbl} GROUP BY {col} HAVING COUNT(*) > 1) AS dup"
                c.execute(query)
                count = c.fetchone()[0]
                result = "PASS" if count == 0 else "FAIL"
                details = f"{count} duplicate groups" if count else "All unique"
            else:
                result = "FAIL"
                details = f"Validation type '{vtype}' not implemented."
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS (VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP)
                VALUES (?, ?, ?, GETDATE())
            """, (vid, result, details))
        conn.commit()
        logger.info("Data validations executed.")
    except Exception as e:
        logger.error(f"Error running data validations: {e}")
        raise

def create_multistep_approvals(conn, rule_id, initiated_by):
    c = conn.cursor()
    try:
        for step in [1, 2]:
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
                VALUES (?, ?, ?, 0, ?)
            """, (rule_id, "BusinessGroup", initiated_by, step))
        conn.commit()
        logger.info(f"Multi‑step approvals created for rule {rule_id}.")
    except Exception as e:
        logger.error(f"Error creating approvals: {e}")

def load_rule_relationships(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for rid, pid in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid
    child_ids = set(parent_map.keys())
    roots = [rid for rid in all_ids if rid not in child_ids]
    return (adjacency, roots, parent_map)

# ---------------------- Enhanced Data Validation Tab ----------------------
class DataValidationTabEnhanced(QWidget):
    """
    Data Validation Tab with full add, update, delete, and run validations functionality.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.dv_table = QTableWidget(0, 6)
        self.dv_table.setHorizontalHeaderLabels(["ValidationID", "Table", "Column", "Type", "Params", "LastResult"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_layout.addWidget(add_btn)
        update_btn = QPushButton("Update Validation")
        update_btn.clicked.connect(self.update_validation)
        btn_layout.addWidget(update_btn)
        delete_btn = QPushButton("Delete Validation")
        delete_btn.clicked.connect(self.delete_validation)
        btn_layout.addWidget(delete_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        btn_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.dv_table.insertRow(i)
                for j, val in enumerate(row):
                    self.dv_table.setItem(i, j, QTableWidgetItem(str(val)))
        except Exception as e:
            QMessageBox.critical(self, "Load Validations Error", str(e))

    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Enter table name:")
        if not ok or not table_name.strip():
            return
        column_name, ok = QInputDialog.getText(self, "Add Validation", "Enter column name:")
        if not ok or not column_name.strip():
            return
        vtype, ok = QInputDialog.getText(self, "Add Validation", "Enter validation type (NOT NULL, RANGE, UNIQUE):")
        if not ok or not vtype.strip():
            return
        params, ok = QInputDialog.getText(self, "Add Validation", "Enter parameters (if any):")
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO DATA_VALIDATIONS (TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP) VALUES (?, ?, ?, ?, GETDATE())",
                      (table_name.strip(), column_name.strip(), vtype.strip(), params.strip() if params else ""))
            self.connection.commit()
            insert_audit_log(self.connection, "INSERT", "DATA_VALIDATIONS", None, "CurrentUser", None,
                             {"table": table_name, "column": column_name})
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Add Validation Error", str(e))

    def update_validation(self):
        selected = self.dv_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a validation to update.")
            return
        vid = int(selected[0].text())
        new_table, ok = QInputDialog.getText(self, "Update Validation", "Enter new table name:")
        if not ok or not new_table.strip():
            return
        new_column, ok = QInputDialog.getText(self, "Update Validation", "Enter new column name:")
        if not ok or not new_column.strip():
            return
        new_vtype, ok = QInputDialog.getText(self, "Update Validation", "Enter new validation type:")
        if not ok or not new_vtype.strip():
            return
        new_params, ok = QInputDialog.getText(self, "Update Validation", "Enter new parameters:")
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE DATA_VALIDATIONS
                SET TABLE_NAME=?, COLUMN_NAME=?, VALIDATION_TYPE=?, PARAMS=?
                WHERE VALIDATION_ID=?
            """, (new_table.strip(), new_column.strip(), new_vtype.strip(), new_params.strip() if new_params else "", vid))
            self.connection.commit()
            insert_audit_log(self.connection, "UPDATE", "DATA_VALIDATIONS", vid, "CurrentUser", None,
                             {"table": new_table, "column": new_column})
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Update Validation Error", str(e))

    def delete_validation(self):
        selected = self.dv_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a validation to delete.")
            return
        vid = int(selected[0].text())
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "DATA_VALIDATIONS", vid, "CurrentUser")
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Delete Validation Error", str(e))

    def run_all_validations(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Validations Run", "Data validations executed successfully.")
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Run Validations Error", str(e))

# ---------------------- Enhanced Lineage Graph Widget with Filters ----------------------
class EnhancedLineageGraphWidgetEnhanced(QGraphicsView):
    """
    An advanced, interactive, MANTA‑like lineage graph.
    This version supports advanced filtering based on provided criteria.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene()
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.zoom_factor = 1.15
        self.nodes = {}  # rule_id -> NodeItem
        self.edges = []  # list of EdgeItem
        self.filters = {}  # advanced filter dict
        self.load_data()  # load all data initially
        self.setup_force_directed()
        self.setMinimumSize(600, 400)

    def load_data(self):
        """
        Loads node and edge data from BRM_RULES and BRM_RULE_LINEAGE.
        Applies filtering based on self.filters if provided.
        """
        self.rule_info = {}  # rule_id -> dict with 'name' and 'status'
        self.adjacency = {}  # rule_id -> list of child rule_ids
        c = self.connection.cursor()
        try:
            # For simplicity, assume BRM_RULES contains columns: RULE_ID, RULE_NAME, STATUS, OWNER_GROUP, CREATED_BY
            query = "SELECT RULE_ID, RULE_NAME, STATUS, OWNER_GROUP, CREATED_BY FROM BRM_RULES"
            params = []
            # Apply filtering on rule name (if provided in filters under 'user')
            if 'user' in self.filters and self.filters['user']:
                query += " WHERE CREATED_BY LIKE ?"
                params.append(f"%{self.filters['user']}%")
            c.execute(query, params)
            for row in c.fetchall():
                rid, name, status, owner_group, created_by = row
                # Apply additional filtering if set (simulate filtering by table, column, database, usergroup)
                passes = True
                for key in ['table', 'column', 'database', 'usergroup']:
                    if key in self.filters and self.filters[key]:
                        # In a real scenario, you might join with BRM_RULE_TABLE_DEPENDENCIES etc.
                        # Here we simply check if the filter string is in the rule name (for demo purposes)
                        if self.filters[key].lower() not in name.lower():
                            passes = False
                            break
                if passes:
                    self.rule_info[rid] = {"name": name, "status": status}
            # Load lineage information from BRM_RULE_LINEAGE
            c.execute("SELECT RULE_ID, PARENT_ID FROM BRM_RULE_LINEAGE")
            for row in c.fetchall():
                rid, parent_id = row
                if parent_id:
                    self.adjacency.setdefault(parent_id, []).append(rid)
        except Exception as e:
            QMessageBox.critical(self, "Lineage Data Error", str(e))

    def setup_force_directed(self):
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()
        # Create nodes
        for rid, info in self.rule_info.items():
            node = NodeItem(rid, info["name"], info["status"])
            node.setPos(50 + (rid % 10) * 80, 50 + (rid // 10) * 80)
            self.scene.addItem(node)
            self.nodes[rid] = node
        # Create edges
        for parent, children in self.adjacency.items():
            if parent not in self.nodes:
                continue
            for child in children:
                if child in self.nodes:
                    edge = EdgeItem(self.nodes[parent], self.nodes[child])
                    self.scene.addItem(edge)
                    self.edges.append(edge)
        # Start timer for force-directed layout
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_forces)
        self.timer.start(30)

    def apply_filters(self, filters):
        """
        Accepts a dict with possible keys: 'column', 'table', 'database', 'usergroup', 'user'
        and then reloads the data and refreshes the graph.
        """
        self.filters = filters
        self.load_data()
        self.setup_force_directed()

    def update_forces(self):
        repulsion = 5000.0
        spring_length = 150.0
        spring_strength = 0.1
        damping = 0.85

        for node in self.nodes.values():
            node.force = QtCore.QPointF(0, 0)
        node_list = list(self.nodes.values())
        for i in range(len(node_list)):
            for j in range(i+1, len(node_list)):
                node_a = node_list[i]
                node_b = node_list[j]
                delta = node_a.pos() - node_b.pos()
                distance = max(1.0, math.hypot(delta.x(), delta.y()))
                force_magnitude = repulsion / (distance * distance)
                force = delta / distance * force_magnitude
                node_a.force += force
                node_b.force -= force
        for edge in self.edges:
            delta = edge.source.pos() - edge.dest.pos()
            distance = max(1.0, math.hypot(delta.x(), delta.y()))
            displacement = distance - spring_length
            force = (delta / distance) * (spring_strength * displacement)
            edge.source.force -= force
            edge.dest.force += force
        for node in self.nodes.values():
            velocity = node.velocity + node.force * 0.1
            velocity *= damping
            node.velocity = velocity
            new_pos = node.pos() + velocity
            node.setPos(new_pos)
        for edge in self.edges:
            edge.updatePosition()

    def wheelEvent(self, event):
        if event.angleDelta().y() > 0:
            factor = self.zoom_factor
        else:
            factor = 1.0 / self.zoom_factor
        self.scale(factor, factor)

# ---------------------- Node and Edge Items for the Graph ----------------------
class NodeItem(QGraphicsEllipseItem):
    def __init__(self, rule_id, name, status, radius=30):
        super().__init__(-radius, -radius, radius*2, radius*2)
        self.rule_id = rule_id
        self.name = name
        self.status = status.upper()
        self.radius = radius
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemSendsGeometryChanges)
        self.setBrush(self.get_brush())
        self.setPen(QPen(Qt.black))
        self.force = QtCore.QPointF(0, 0)
        self.velocity = QtCore.QPointF(0, 0)
        self.text_item = QGraphicsTextItem(self.name, self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setPos(-radius, -radius - 20)

    def get_brush(self):
        if self.status == "ACTIVE":
            return QBrush(QColor(144, 238, 144))
        elif self.status == "INACTIVE":
            return QBrush(QColor(255, 182, 193))
        else:
            return QBrush(QColor(255, 255, 153))

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange:
            for edge in self.scene().items():
                if isinstance(edge, EdgeItem) and (edge.source == self or edge.dest == self):
                    edge.updatePosition()
        return super().itemChange(change, value)

class EdgeItem(QGraphicsLineItem):
    def __init__(self, source, dest):
        super().__init__()
        self.source = source
        self.dest = dest
        self.setPen(QPen(Qt.gray, 2))
    def updatePosition(self):
        line = QtCore.QLineF(self.source.pos(), self.dest.pos())
        self.setLine(line)

# ---------------------- Enhanced Lineage Analysis Tab with Advanced Filters ----------------------
class EnhancedLineageAnalysisTabEnhanced(QWidget):
    """
    Displays an interactive lineage graph with advanced search/filter options.
    The user can filter by column, table, database, user group, and user.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        filter_layout = QHBoxLayout()
        self.column_filter = QLineEdit()
        self.column_filter.setPlaceholderText("Column...")
        filter_layout.addWidget(QLabel("Column:"))
        filter_layout.addWidget(self.column_filter)
        self.table_filter = QLineEdit()
        self.table_filter.setPlaceholderText("Table...")
        filter_layout.addWidget(QLabel("Table:"))
        filter_layout.addWidget(self.table_filter)
        self.database_filter = QLineEdit()
        self.database_filter.setPlaceholderText("Database...")
        filter_layout.addWidget(QLabel("Database:"))
        filter_layout.addWidget(self.database_filter)
        self.ug_filter = QLineEdit()
        self.ug_filter.setPlaceholderText("User Group...")
        filter_layout.addWidget(QLabel("User Group:"))
        filter_layout.addWidget(self.ug_filter)
        self.user_filter = QLineEdit()
        self.user_filter.setPlaceholderText("User...")
        filter_layout.addWidget(QLabel("User:"))
        filter_layout.addWidget(self.user_filter)
        apply_filter_btn = QPushButton("Apply Filters")
        apply_filter_btn.clicked.connect(self.apply_filters)
        filter_layout.addWidget(apply_filter_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)
        # Place the enhanced lineage graph widget below:
        self.lineage_graph = EnhancedLineageGraphWidgetEnhanced(self.connection)
        layout.addWidget(self.lineage_graph)
        self.setLayout(layout)

    def apply_filters(self):
        filters = {
            "column": self.column_filter.text().strip(),
            "table": self.table_filter.text().strip(),
            "database": self.database_filter.text().strip(),
            "usergroup": self.ug_filter.text().strip(),
            "user": self.user_filter.text().strip()
        }
        self.lineage_graph.apply_filters(filters)

# ---------------------- Other Tabs (Predictive Analytics, Data Validation, etc.) ----------------------
class PredictiveAnalyticsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        filter_layout = QHBoxLayout()
        self.rule_filter_edit = QLineEdit()
        self.rule_filter_edit.setPlaceholderText("Filter by rule name...")
        filter_layout.addWidget(QLabel("Rule:"))
        filter_layout.addWidget(self.rule_filter_edit)
        self.table_filter_edit = QLineEdit()
        self.table_filter_edit.setPlaceholderText("Filter by table...")
        filter_layout.addWidget(QLabel("Table:"))
        filter_layout.addWidget(self.table_filter_edit)
        self.column_filter_edit = QLineEdit()
        self.column_filter_edit.setPlaceholderText("Filter by column...")
        filter_layout.addWidget(QLabel("Column:"))
        filter_layout.addWidget(self.column_filter_edit)
        self.database_filter_edit = QLineEdit()
        self.database_filter_edit.setPlaceholderText("Filter by database...")
        filter_layout.addWidget(QLabel("Database:"))
        filter_layout.addWidget(self.database_filter_edit)
        self.ug_filter_edit = QLineEdit()
        self.ug_filter_edit.setPlaceholderText("Filter by user group...")
        filter_layout.addWidget(QLabel("User Group:"))
        filter_layout.addWidget(self.ug_filter_edit)
        layout.addLayout(filter_layout)
        self.chart = pg.PlotWidget(title="Forecast: Average Execution Time")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        forecast_btn = QPushButton("Run Forecast")
        forecast_btn.clicked.connect(self.run_forecast)
        layout.addWidget(forecast_btn)
        self.result_label = QLabel("")
        layout.addWidget(self.result_label)
        self.setLayout(layout)
        self.run_forecast()

    def run_forecast(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(date, ACTION_TIMESTAMP) as LogDate, AVG(EXEC_TIME_MS) as AvgTime
                FROM RULE_PERF_STATS
                WHERE ACTION_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
                GROUP BY CONVERT(date, ACTION_TIMESTAMP)
                ORDER BY LogDate
            """)
            rows = c.fetchall()
            if not rows:
                self.result_label.setText("Insufficient performance data.")
                return
            dates = [row[0] for row in rows]
            avg_times = [row[1] for row in rows]
            X = np.array([[i] for i in range(len(avg_times))])
            y = np.array(avg_times)
            model = LinearRegression()
            model.fit(X, y)
            forecast_index = len(avg_times)
            forecast = model.predict(np.array([[forecast_index]]))[0]
            anomaly = forecast > 2000
            self.chart.clear()
            x_vals = list(range(len(avg_times)))
            self.chart.plot(x_vals, avg_times, pen=pg.mkPen('b', width=2), symbol='o')
            self.chart.plot([forecast_index], [forecast], pen=pg.mkPen('r', width=2), symbol='x', symbolSize=14)
            self.chart.getAxis("bottom").setLabel("Day Index (Last 30 Days)")
            self.chart.getAxis("left").setLabel("Average Execution Time (ms)")
            if anomaly:
                self.result_label.setText(f"Anomaly: Forecast avg time {forecast:.1f} ms exceeds threshold.")
            else:
                self.result_label.setText(f"Forecast: Avg time = {forecast:.1f} ms.")
        except Exception as e:
            QMessageBox.critical(self, "Forecast Error", str(e))

# ---------------------- Help & Feedback Tab ----------------------
class HelpFeedbackTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        title = QLabel("BRM Tool Help & Documentation")
        title.setStyleSheet("font-size: 16px; font-weight: bold;")
        layout.addWidget(title)
        search_layout = QHBoxLayout()
        self.help_search = QLineEdit()
        self.help_search.setPlaceholderText("Search help topics...")
        self.help_search.textChanged.connect(self.filter_help)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.help_search)
        layout.addLayout(search_layout)
        self.help_tabs = QTabWidget()
        self.faq_widget = QTreeWidget()
        self.faq_widget.setHeaderLabels(["FAQ", "Answer"])
        self.guides_widget = QTreeWidget()
        self.guides_widget.setHeaderLabels(["Guide Title", "Content"])
        self.help_tabs.addTab(self.faq_widget, "FAQs")
        self.help_tabs.addTab(self.guides_widget, "Guides")
        layout.addWidget(self.help_tabs)
        self.setLayout(layout)
        self.populate_help_content()

    def populate_help_content(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT CATEGORY, TITLE, CONTENT FROM HELP_CONTENT ORDER BY CATEGORY, LAST_UPDATED DESC")
            rows = c.fetchall()
            self.faq_widget.clear()
            self.guides_widget.clear()
            for category, title, content in rows:
                item = QTreeWidgetItem([title, content])
                if category.upper() == "FAQ":
                    self.faq_widget.addTopLevelItem(item)
                else:
                    self.guides_widget.addTopLevelItem(item)
        except Exception as e:
            QMessageBox.critical(self, "Help Content Error", str(e))

    def filter_help(self):
        text = self.help_search.text().lower()
        for tree in [self.faq_widget, self.guides_widget]:
            for i in range(tree.topLevelItemCount()):
                item = tree.topLevelItem(i)
                visible = text in item.text(0).lower() or text in item.text(1).lower()
                item.setHidden(not visible)

# ---------------------- Alerts & Dashboards Tab ----------------------
class AlertsAndDashboardsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)
        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)
        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, APPROVAL_STAGE, DATEDIFF(DAY, COALESCE(APPROVED_TIMESTAMP, CREATED_TIMESTAMP), GETDATE()) AS Age
                FROM BRM_RULE_APPROVALS
                WHERE APPROVED_FLAG=0 AND DATEDIFF(DAY, COALESCE(APPROVED_TIMESTAMP, GETDATE()), GETDATE()) > 3
            """)
            approvals = c.fetchall()
            if approvals:
                lines.append("Approvals older than 3 days:")
                for rid, stage, age in approvals:
                    lines.append(f" - Rule {rid}, Stage {stage}, Age: {age} days")
            else:
                lines.append("No approvals older than 3 days.")
        except Exception as e:
            lines.append(f"Approval check error: {e}")
        lines.append("")
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled' AND SCHEDULE_TIME BETWEEN GETDATE() AND DATEADD(HOUR, 24, GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules = c.fetchall()
            if schedules:
                lines.append("Upcoming schedules (next 24h):")
                for sid, rid, stime in schedules:
                    lines.append(f" - Schedule {sid}: Rule {rid} at {stime}")
            else:
                lines.append("No upcoming schedules within 24h.")
        except Exception as e:
            lines.append(f"Schedule check error: {e}")
        lines.append("")
        try:
            c.execute("""
                SELECT RULE_ID, AVG(EXEC_TIME_MS), AVG(MEM_USAGE)
                FROM RULE_PERF_STATS
                WHERE ACTION_TIMESTAMP >= DATEADD(DAY, -7, GETDATE())
                GROUP BY RULE_ID
                HAVING AVG(EXEC_TIME_MS) > 2000 OR AVG(MEM_USAGE) > 50000
            """)
            perf_alerts = c.fetchall()
            if perf_alerts:
                lines.append("Performance alerts (last 7 days):")
                for rid, avg_time, avg_mem in perf_alerts:
                    lines.append(f" - Rule {rid}: Avg Exec Time = {avg_time:.1f} ms, Avg Memory = {avg_mem:.1f} KB")
            else:
                lines.append("No performance alerts in last 7 days.")
        except Exception as e:
            lines.append(f"Performance check error: {e}")
        lines.append("")
        try:
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, EXPIRY_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < GETDATE()
            """)
            stale = c.fetchall()
            if stale:
                lines.append("Stale locks detected:")
                for rid, owner, expiry in stale:
                    lines.append(f" - Rule {rid}: Locked by {owner}, expired at {expiry}")
            else:
                lines.append("No stale locks detected.")
        except Exception as e:
            lines.append(f"Stale lock check error: {e}")
        self.alert_text.setPlainText("\n".join(lines))
        logger.info("Alerts updated.")

# ---------------------- Admin Tab ----------------------
class AdminTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        self.inner_tabs = QTabWidget()
        layout.addWidget(self.inner_tabs)
        # Assume UserManagementTab, GroupManagementTab, GroupPermissionsTab, and CtrlTablesTab are defined elsewhere.
        self.user_mgmt_tab = UserManagementTab(self.connection)
        self.inner_tabs.addTab(self.user_mgmt_tab, "User Management")
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.inner_tabs.addTab(self.group_mgmt_tab, "Group Management")
        self.group_perm_tab = GroupPermissionsTab(self.connection)
        self.inner_tabs.addTab(self.group_perm_tab, "Group Permissions")
        self.ctrl_tables_tab = CtrlTablesTab(self.connection, self.user_group)
        self.inner_tabs.addTab(self.ctrl_tables_tab, "Control Tables")
        self.setLayout(layout)

# ---------------------- Main Window ----------------------
class MainWindow(QMainWindow):
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.setWindowTitle("BRM Tool – Ultimate Production Ready Edition")
        self.resize(2200, 1300)
        self.setStyleSheet("""
            QWidget { font-family: 'Segoe UI'; font-size: 13px; }
            QTabWidget::pane { border: 0; }
            QHeaderView::section { background-color: #E8E8E8; padding: 6px; border: 1px solid #C0C0C0; }
            QTableWidget { background-color: #FFFFFF; alternate-background-color: #F5F5F5; }
            QPushButton { background-color: #0078D7; color: white; border: none; padding: 6px; }
            QPushButton:hover { background-color: #005A9E; }
            QPushButton:pressed { background-color: #004578; }
            QLineEdit, QPlainTextEdit { border: 1px solid #C0C0C0; padding: 4px; }
        """)
        self.create_menu_bar()
        self.create_tool_bar()
        self.create_status_bar()
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)
        # Impersonation panel for Admins
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            self.impersonation_combo = QComboBox()
            self.load_impersonation_options()
            imp_layout.addWidget(QLabel("Impersonate:"))
            imp_layout.addWidget(self.impersonation_combo)
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.switch_user)
            imp_layout.addWidget(imp_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)
        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)
        # Admin Tab
        self.admin_tab = AdminTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.admin_tab, "Admin")
        # Dashboard
        self.dashboard_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.dashboard_tab, "Dashboard")
        # Business Rules Tab and Details
        self.biz_rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        biz_container = QWidget()
        biz_layout = QVBoxLayout(biz_container)
        biz_layout.addWidget(self.biz_rules_tab)
        self.br_details = BRDetailsWidget(self.connection, self.user_id, self.user_group)
        biz_layout.addWidget(self.br_details)
        biz_container.setLayout(biz_layout)
        self.tabs.addTab(biz_container, "Business Rules")
        # Approvals
        self.approvals_tab = ApprovalsTab(self.connection, self.get_username(), self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")
        # Defects
        self.defects_tab = DefectManagementTab(self.connection)
        self.tabs.addTab(self.defects_tab, "Defects")
        # Collaboration
        self.collaboration_tab = CollaborationTab(self.connection, self.create_collaboration_manager())
        self.tabs.addTab(self.collaboration_tab, "Collaboration")
        # Audit Log Analysis
        self.audit_log_tab = EnhancedAuditLogAnalysisTab(self.connection)
        self.tabs.addTab(self.audit_log_tab, "Audit Log Analysis")
        # Predictive Analytics
        self.predictive_tab = PredictiveAnalyticsTab(self.connection)
        self.tabs.addTab(self.predictive_tab, "Predictive Analytics")
        # Enhanced Lineage Analysis with advanced search
        self.lineage_tab = EnhancedLineageAnalysisTabEnhanced(self.connection)
        self.tabs.addTab(self.lineage_tab, "Enhanced Lineage")
        # Data Validation Tab with full CRUD
        self.data_validation_tab = DataValidationTabEnhanced(self.connection)
        self.tabs.addTab(self.data_validation_tab, "Data Validation")
        # Help & Feedback
        self.help_tab = HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab, "Help & Feedback")
        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)
        self.notifications_dock = QDockWidget("Real-Time Notifications", self)
        self.notifications_widget = AlertsAndDashboardsTab(self.connection)
        self.notifications_dock.setWidget(self.notifications_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, self.notifications_dock)
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_tabs)
        self.refresh_timer.start(30000)

    def create_menu_bar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        help_menu = menubar.addMenu("Help")
        doc_action = help_menu.addAction("Documentation")
        doc_action.triggered.connect(self.open_help)

    def create_tool_bar(self):
        toolbar = self.addToolBar("Main Toolbar")
        refresh_action = toolbar.addAction(QIcon.fromTheme("view-refresh"), "Refresh")
        refresh_action.triggered.connect(self.refresh_tabs)

    def create_status_bar(self):
        status = self.statusBar()
        status.showMessage(f"Connected | User: {self.get_username()} | Group: {self.user_group}")

    def logout(self):
        self.close()

    def open_help(self):
        index = self.tabs.indexOf(self.help_tab)
        if index != -1:
            self.tabs.setCurrentIndex(index)

    def get_username(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except Exception:
            return "Unknown"

    def load_impersonation_options(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for uid, uname, ugroup in c.fetchall():
                self.impersonation_combo.addItem(f"{uname} ({ugroup})", (uid, ugroup))
        except Exception as ex:
            QMessageBox.critical(self, "Impersonation Error", str(ex))

    def switch_user(self):
        data = self.impersonation_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        QMessageBox.information(self, "Switched", f"Now impersonating {self.get_username()} ({self.user_group}).")
        self.approvals_tab.logged_in_username = self.get_username()
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.biz_rules_tab.user_id = self.user_id
        self.biz_rules_tab.user_group = self.user_group
        self.biz_rules_tab.load_rules()
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i) == "Admin":
                self.tabs.setTabVisible(i, self.user_group == "Admin")
                break
        self.create_status_bar()

    def create_collaboration_manager(self):
        from CollaborationManager import CollaborationManager  # Ensure this module is available
        return CollaborationManager(self.connection, poll_ms=5000)

    def refresh_tabs(self):
        try:
            self.approvals_tab.load_approvals()
            self.biz_rules_tab.load_rules()
            self.notifications_widget.check_alerts()
            self.statusBar().showMessage(f"Refreshed at {datetime.now().strftime('%H:%M:%S')}")
        except Exception as ex:
            logger.error(f"Error refreshing tabs: {ex}")

# ---------------------- Main Application Launcher ----------------------
def main():
    app = QApplication(sys.argv)
    from DatabaseConnectionDialog import DatabaseConnectionDialog  # Ensure this module is available
    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    conn = db_dialog.connection
    if not conn:
        sys.exit(1)
    from LoginDialog import LoginDialog  # Ensure this module is available
    login_dialog = LoginDialog(conn)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dialog.user_id
    user_group = login_dialog.user_group
    main_window = MainWindow(conn, user_id, user_group)
    main_window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()