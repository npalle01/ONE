#!/usr/bin/env python
# -*- coding: utf-8 -*-
# =======================
# Module: brm_core_foundation.py
# =======================

import os, sys, json, logging, logging.config, smtplib, pyodbc, sqlparse, re
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout,
    QMessageBox, QComboBox, QPlainTextEdit, QCalendarWidget, QTimeEdit,
    QFormLayout, QWidget, QCheckBox
)

LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_core.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}
logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")

class EmailNotifier:
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")
    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("No recipients provided for email.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)
            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email to {recipients}: {e}")
            raise

class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – BRM Tool")
        self.resize(400, 200)
        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select an ODBC DSN or enter a custom connection string:")
        main_layout.addWidget(lbl)
        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)
        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)
    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None
    def accept(self):
        if self.get_connection():
            self.connection = self.get_connection()
            super().accept()

class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – BRM Tool")
        self.resize(300, 150)
        main_layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)
        self.setLayout(main_layout)
    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password required.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (un, pw))
        row = c.fetchone()
        if row:
            self.user_id, self.user_group = row[0], row[1]
            logger.info(f"User {un} logged in. user_id={self.user_id}, group={self.user_group}")
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")

# =======================
# Module: brm_rule_engine.py
# =======================
# (For brevity, this module includes key functions and helper methods)
def detect_operation_type(sql_text: str) -> str:
    stripped = sql_text.strip().upper()
    if stripped.startswith("INSERT"):
        return "INSERT"
    elif stripped.startswith("UPDATE"):
        return "UPDATE"
    elif stripped.startswith("DELETE"):
        return "DELETE"
    elif stripped.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text: str):
    # A simplified version using sqlparse to extract table names.
    statements = sqlparse.parse(sql_text)
    all_tables = []
    for stmt in statements:
        for token in stmt.tokens:
            if token.ttype is None and hasattr(token, "get_real_name"):
                real_name = token.get_real_name()
                if real_name:
                    all_tables.append((None, real_name, token.get_alias(), False))
    return {"tables": all_tables, "cte_tables": [], "alias_map": {}, "columns": []}

# BusinessRulesTab is assumed to provide CRUD and BFS simulation UI.
class BusinessRulesTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
    def init_ui(self):
        layout = QVBoxLayout(self)
        label = QLabel("Business Rules Module (CRUD, BFS Simulation)")
        layout.addWidget(label)
        self.setLayout(layout)
    def set_user(self, user_id, user_group):
        self.user_id = user_id
        self.user_group = user_group

# =======================
# Module: brm_simulation_scheduler.py
# =======================
class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_schedules()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 6)
        self.schedule_table.setHorizontalHeaderLabels(["ScheduleID", "RuleID", "ScheduleTime", "Status", "RunValidations?", "Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        btn_layout = QHBoxLayout()
        ref_btn = QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(ref_btn)
        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT TOP 1000 SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, VALIDATION_FLAG FROM RULE_SCHEDULES ORDER BY SCHEDULE_TIME DESC")
        for row in c.fetchall():
            r_i = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            for col in range(5):
                self.schedule_table.setItem(r_i, col, QTableWidgetItem(str(row[col])))
        self.schedule_table.resizeColumnsToContents()
    def add_schedule(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Advanced Scheduling")
        dlg.resize(420, 300)
        layout = QVBoxLayout(dlg)
        rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rid, rn in c.fetchall():
            rule_combo.addItem(f"{rid} - {rn}", rid)
        layout.addWidget(rule_combo)
        calendar = QtWidgets.QCalendarWidget()
        calendar.setSelectedDate(QtCore.QDate.currentDate())
        calendar.setGridVisible(True)
        layout.addWidget(calendar)
        time_edit = QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        time_edit.setDisplayFormat("HH:mm:ss")
        layout.addWidget(time_edit)
        run_val_cb = QCheckBox("Run Data Validations before execution?")
        layout.addWidget(run_val_cb)
        btn_h = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        def do_schedule():
            rid = rule_combo.currentData()
            date_str = calendar.selectedDate().toString("yyyy-MM-dd")
            time_str = time_edit.time().toString("HH:mm:ss")
            dt_str = f"{date_str} {time_str}"
            val_flag = 1 if run_val_cb.isChecked() else 0
            try:
                c.execute("INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, VALIDATION_FLAG) VALUES(?, ?, 'Scheduled', GETDATE(), ?)", (rid, dt_str, val_flag))
                self.connection.commit()
                QMessageBox.information(dlg, "Scheduled", f"Rule {rid} scheduled at {dt_str}.")
                dlg.accept()
                self.load_schedules()
            except Exception as ex:
                QMessageBox.critical(dlg, "Error", f"Scheduling failed: {ex}")
        sch_btn.clicked.connect(do_schedule)
        btn_h.addWidget(sch_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.reject)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)
        dlg.exec_()

class ChainSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation – BFS")
        self.resize(550, 400)
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Parent Rule:"))
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rid, rn in c.fetchall():
            self.rule_combo.addItem(f"{rid} - {rn}", rid)
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)
        self.skip_val_cb = QCheckBox("Skip Data Validations?")
        layout.addWidget(self.skip_val_cb)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_h = QHBoxLayout()
        run_btn = QPushButton("Run Chain BFS")
        run_btn.clicked.connect(self.do_sim)
        btn_h.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
    def do_sim(self):
        rid = self.rule_combo.currentData()
        skip_val = self.skip_val_cb.isChecked()
        # Here, you would call your execute_rules_bfs function.
        # For demonstration, we simulate a result:
        executed = [rid]
        skipped = [rid + 1]
        msg = f"Chain BFS from rule {rid}:\nExecuted: {executed}\nSkipped: {skipped}"
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Chain Simulation", msg)

class GroupSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation – BFS")
        self.resize(600, 450)
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Custom Group:"))
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for cid, gn in c.fetchall():
            self.group_combo.addItem(f"{cid} - {gn}", cid)
        top_h.addWidget(self.group_combo)
        layout.addLayout(top_h)
        self.skip_val_cb = QCheckBox("Skip Data Validations?")
        layout.addWidget(self.skip_val_cb)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_h = QHBoxLayout()
        run_btn = QPushButton("Run Group BFS")
        run_btn.clicked.connect(self.do_sim)
        btn_h.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
    def do_sim(self):
        cg_id = self.group_combo.currentData()
        skip_val = self.skip_val_cb.isChecked()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (cg_id,))
        rules = [r[0] for r in c.fetchall()]
        if not rules:
            QMessageBox.warning(self, "Empty", "No rules in that custom group.")
            return
        # Simulate BFS execution
        executed = rules[:1]
        skipped = rules[1:]
        msg = f"Group BFS for group {cg_id}:\nExecuted: {executed}\nSkipped: {skipped}"
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Group Simulation", msg)

# =======================
# Module: brm_advanced_decision_tables.py
# =======================
import time
def execute_decision_table(conn, dt_id, dry_run=True):
    c = conn.cursor()
    c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c.fetchone()
    if not row or not row[0]:
        msg = f"Decision table {dt_id} has no query."
        logger.warning(msg)
        return (False, msg, 0)
    decision_query = row[0]
    start_time = time.time()
    c.execute("BEGIN TRANSACTION")
    try:
        c.execute(decision_query)
        try:
            rows = c.fetchall()
            rec_count = len(rows)
            if rows:
                val = rows[0][0]
                pass_flag = (val == 1)
                msg = f"Returned: {val}"
            else:
                pass_flag = True
                msg = "No rows => pass"
        except:
            pass_flag = True
            msg = "Executed without result set"
        if dry_run or not pass_flag:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        c.execute("ROLLBACK")
        pass_flag = False
        msg = str(ex)
        rec_count = 0
    elapsed_ms = int((time.time() - start_time) * 1000)
    c2 = conn.cursor()
    c2.execute("INSERT INTO DECISION_TABLE_EXEC_LOGS(DECISION_TABLE_ID, EXEC_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS, DRY_RUN) VALUES(?, GETDATE(), ?, ?, ?, ?, ?)",
               (dt_id, 1 if pass_flag else 0, msg, rec_count, elapsed_ms, 1 if dry_run else 0))
    conn.commit()
    logger.info(f"Decision Table {dt_id} executed => pass={pass_flag}, message={msg}, records={rec_count}.")
    return (pass_flag, msg, rec_count)

class DecisionTableExecutionDialog(QDialog):
    def __init__(self, connection, dt_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.dt_id = dt_id
        self.setWindowTitle(f"Execute Decision Table {dt_id}")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        self.info_label = QLabel("Click to run decision table in a dry-run transaction.")
        layout.addWidget(self.info_label)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        run_btn = QPushButton("Run Decision Table (Dry-Run)")
        run_btn.clicked.connect(self.run_decision_table)
        layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)
    def run_decision_table(self):
        pf, msg, rc = execute_decision_table(self.connection, self.dt_id, dry_run=True)
        text = f"Decision Table {self.dt_id} => pass={pf}, message={msg}, records={rc}"
        self.result_text.setPlainText(text)
        QMessageBox.information(self, "Execution Complete", text)

class AdvancedDecisionTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_decision_tables()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0, 4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID", "Table Name", "Description", "Query"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        btn_h.addWidget(add_btn)
        edit_btn = QPushButton("Edit Decision Table")
        edit_btn.clicked.connect(self.edit_dt)
        btn_h.addWidget(edit_btn)
        del_btn = QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.delete_dt)
        btn_h.addWidget(del_btn)
        exec_btn = QPushButton("Execute Decision Table")
        exec_btn.clicked.connect(self.execute_dt)
        btn_h.addWidget(exec_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_decision_tables)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        logs_btn = QPushButton("View Exec Logs")
        logs_btn.clicked.connect(self.view_exec_logs)
        layout.addWidget(logs_btn)
        self.setLayout(layout)
    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in c.fetchall():
            r_i = self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            for col in range(4):
                self.dt_table.setItem(r_i, col, QTableWidgetItem(str(row[col]) if row[col] is not None else ""))
    def get_selected_dt_id(self):
        row = self.dt_table.currentRow()
        if row < 0:
            return None
        it = self.dt_table.item(row, 0)
        return int(it.text()) if it else None
    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Add Decision Table", "Description:")
        if not ok2:
            desc = ""
        query, ok3 = QInputDialog.getMultiLineText(self, "Add Decision Table", "Decision Query (SQL):")
        if not ok3 or not query.strip():
            QMessageBox.warning(self, "Input Error", "Decision Query is required.")
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION, DECISION_QUERY, CREATED_TIMESTAMP) VALUES(?,?,?,GETDATE())", (name.strip(), desc.strip(), query.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Success", "Decision Table added.")
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def edit_dt(self):
        dt_id = self.get_selected_dt_id()
        if not dt_id:
            QMessageBox.warning(self, "Error", "No decision table selected.")
            return
        c = self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Decision Table {dt_id} not found.")
            return
        old_name = row[1] or ""
        old_desc = row[2] or ""
        old_query = row[3] or ""
        new_name, ok = QInputDialog.getText(self, "Edit Table Name", "Table Name:", text=old_name)
        if not ok or not new_name.strip():
            return
        new_desc, ok2 = QInputDialog.getMultiLineText(self, "Edit Description", "Description:", text=old_desc)
        if not ok2:
            new_desc = old_desc
        new_query, ok3 = QInputDialog.getMultiLineText(self, "Edit Query", "Query:", text=old_query)
        if not ok3 or not new_query.strip():
            QMessageBox.warning(self, "Input Error", "Query is required.")
            return
        try:
            c.execute("UPDATE DECISION_TABLES SET TABLE_NAME=?, DESCRIPTION=?, DECISION_QUERY=?, UPDATED_TIMESTAMP=GETDATE() WHERE DECISION_TABLE_ID=?", (new_name.strip(), new_desc.strip(), new_query.strip(), dt_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Decision Table {dt_id} updated.")
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def delete_dt(self):
        dt_id = self.get_selected_dt_id()
        if not dt_id:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        if QMessageBox.question(self, "Confirm", f"Delete Decision Table {dt_id}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision Table removed.")
            self.load_decision_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def execute_dt(self):
        dt_id = self.get_selected_dt_id()
        if not dt_id:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        dlg = DecisionTableExecutionDialog(self.connection, dt_id, self)
        dlg.exec_()
    def view_exec_logs(self):
        logs_dlg = QDialog(self)
        logs_dlg.setWindowTitle("Decision Table Execution Logs")
        logs_dlg.resize(700, 400)
        layout = QVBoxLayout(logs_dlg)
        tbl = QTableWidget(0, 7)
        tbl.setHorizontalHeaderLabels(["ExecID", "DT_ID", "Timestamp", "PassFlag", "Message", "RecordCount", "TimeMS"])
        tbl.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(tbl)
        c = self.connection.cursor()
        c.execute("SELECT TOP 200 EXEC_ID, DECISION_TABLE_ID, EXEC_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS FROM DECISION_TABLE_EXEC_LOGS ORDER BY EXEC_ID DESC")
        for row in c.fetchall():
            r_i = tbl.rowCount()
            tbl.insertRow(r_i)
            for col in range(7):
                tbl.setItem(r_i, col, QTableWidgetItem(str(row[col]) if row[col] is not None else ""))
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(logs_dlg.close)
        layout.addWidget(close_btn)
        logs_dlg.setLayout(layout)
        logs_dlg.exec_()

# =======================
# Module: brm_advanced_approvals_and_lineage.py
# =======================
class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        self.init_ui()
        self.load_approvals()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.approval_table = QTableWidget(0, 8)
        self.approval_table.setHorizontalHeaderLabels(["RuleID", "Group", "RuleName", "Stage", "Approved?", "Approve", "Reject", "ForceUnlock"])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approval_table)
        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE,
                   A.APPROVED_FLAG, R.LOCK_STATUS, R.LOCKED_BY
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
            WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
            ORDER BY A.RULE_ID
        """, (self.logged_in_username,))
        rows = c.fetchall()
        def get_min_stage(rid):
            c2 = self.connection.cursor()
            c2.execute("SELECT MIN(APPROVAL_STAGE) FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND APPROVED_FLAG=0", (rid,))
            r = c2.fetchone()
            return r[0] if r and r[0] else None
        filtered = []
        for row in rows:
            rid = row[0]
            stg = row[3]
            if get_min_stage(rid) == stg:
                filtered.append(row)
        self.approval_table.setRowCount(len(filtered))
        for r_i, row in enumerate(filtered):
            rule_id, grp, rname, stage, ap_flag, lock_status, locked_by = row
            self.approval_table.setItem(r_i, 0, QTableWidgetItem(str(rule_id)))
            self.approval_table.setItem(r_i, 1, QTableWidgetItem(str(grp)))
            self.approval_table.setItem(r_i, 2, QTableWidgetItem(str(rname)))
            self.approval_table.setItem(r_i, 3, QTableWidgetItem(str(stage)))
            self.approval_table.setItem(r_i, 4, QTableWidgetItem(str(ap_flag)))
            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, idx=r_i: self.approve_rule(idx))
            self.approval_table.setCellWidget(r_i, 5, approve_btn)
            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, idx=r_i: self.reject_rule(idx))
            self.approval_table.setCellWidget(r_i, 6, reject_btn)
            force_unlock_btn = QPushButton("Force Unlock")
            force_unlock_btn.clicked.connect(lambda _, idx=r_i: self.force_unlock(idx))
            force_unlock_btn.setEnabled(self.user_group=="Admin")
            self.approval_table.setCellWidget(r_i, 7, force_unlock_btn)
        self.approval_table.resizeColumnsToContents()
    def approve_rule(self, row_idx):
        rule_id = int(self.approval_table.item(row_idx, 0).text())
        grp = self.approval_table.item(row_idx, 1).text()
        c = self.connection.cursor()
        c.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
            WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rule_id, grp, self.logged_in_username))
        def get_min_stage(rid):
            c2 = self.connection.cursor()
            c2.execute("SELECT MIN(APPROVAL_STAGE) FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND APPROVED_FLAG=0", (rid,))
            r = c2.fetchone()
            return r[0] if r and r[0] else None
        next_stage = get_min_stage(rule_id)
        if next_stage is None:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE' WHERE RULE_ID=?", (rule_id,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?", (rule_id,))
        insert_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, {"old": "approved_flag=0"}, {"new": "approved=1"})
        self.connection.commit()
        QMessageBox.information(self, "Approved", f"Rule {rule_id} approved at group {grp}.")
        self.load_approvals()
    def reject_rule(self, row_idx):
        rule_id = int(self.approval_table.item(row_idx, 0).text())
        grp = self.approval_table.item(row_idx, 1).text()
        if QMessageBox.question(self, "Reject", f"Reject rule {rule_id} at group {grp}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
            WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rule_id, grp, self.logged_in_username))
        c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE' WHERE RULE_ID=?", (rule_id,))
        insert_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None, {"rejected": True})
        self.connection.commit()
        QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
        self.load_approvals()
    def force_unlock(self, row_idx):
        if self.user_group != "Admin":
            QMessageBox.warning(self, "Denied", "Only Admin can force unlock.")
            return
        rule_id = int(self.approval_table.item(row_idx, 0).text())
        c = self.connection.cursor()
        c.execute("UPDATE BRM_RULES SET LOCK_STATUS='UNLOCKED', LOCKED_BY=NULL, LOCKED_AT=NULL WHERE RULE_ID=?", (rule_id,))
        insert_audit_log(self.connection, "FORCE_UNLOCK", "BRM_RULES", rule_id, self.logged_in_username, {"locked": True}, {"locked": False})
        self.connection.commit()
        QMessageBox.information(self, "Forced", "Rule unlocked forcibly.")
        self.load_approvals()

# =======================
# Module: brm_defect_management.py
# =======================
def add_defect_log(conn, rule_id, description, severity, reporter, status="Open", resolution=None):
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_DEFECT_LOGS(RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, RESOLUTION, TIMESTAMP)
            VALUES(?,?,?,?,?,? ,GETDATE())
        """, (rule_id, description, severity, reporter, status, resolution))
        conn.commit()
        logger.info(f"Defect log added for rule {rule_id}, reported by {reporter}.")
    except Exception as ex:
        logger.error(f"Error adding defect log: {ex}")
        raise

class DefectDialog(QDialog):
    def __init__(self, connection, defect_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.defect_data = defect_data
        self.is_edit = defect_data is not None
        self.init_ui()
    def init_ui(self):
        self.setWindowTitle("Edit Defect" if self.is_edit else "Add Defect")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form_layout = QtWidgets.QFormLayout()
        self.rule_id_edit = QLineEdit()
        self.rule_id_edit.setPlaceholderText("Optional rule ID")
        form_layout.addRow("Rule ID:", self.rule_id_edit)
        self.desc_edit = QTextEdit()
        form_layout.addRow("Description:", self.desc_edit)
        self.severity_combo = QComboBox()
        self.severity_combo.addItems(["Low", "Medium", "High", "Critical"])
        form_layout.addRow("Severity:", self.severity_combo)
        self.reporter_edit = QLineEdit()
        form_layout.addRow("Reporter:", self.reporter_edit)
        self.status_combo = QComboBox()
        self.status_combo.addItems(["Open", "In Progress", "Resolved", "Closed"])
        form_layout.addRow("Status:", self.status_combo)
        self.resolution_edit = QTextEdit()
        form_layout.addRow("Resolution:", self.resolution_edit)
        layout.addLayout(form_layout)
        btn_layout = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_defect)
        btn_layout.addWidget(save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        if self.is_edit and self.defect_data:
            self.load_existing_data()
        self.setLayout(layout)
    def load_existing_data(self):
        d = self.defect_data
        if d.get("RULE_ID"):
            self.rule_id_edit.setText(str(d["RULE_ID"]))
        self.desc_edit.setPlainText(d.get("DESCRIPTION", ""))
        sev = d.get("SEVERITY", "Low")
        idx = self.severity_combo.findText(sev, Qt.MatchFixedString)
        if idx >= 0:
            self.severity_combo.setCurrentIndex(idx)
        self.reporter_edit.setText(d.get("REPORTER", ""))
        st = d.get("STATUS", "Open")
        idx = self.status_combo.findText(st, Qt.MatchFixedString)
        if idx >= 0:
            self.status_combo.setCurrentIndex(idx)
        self.resolution_edit.setPlainText(d.get("RESOLUTION", ""))
    def save_defect(self):
        try:
            rule_id_text = self.rule_id_edit.text().strip()
            rule_id = int(rule_id_text) if rule_id_text else None
        except:
            QMessageBox.warning(self, "Error", "Rule ID must be an integer or blank.")
            return
        description = self.desc_edit.toPlainText().strip()
        if not description:
            QMessageBox.warning(self, "Error", "Description is required.")
            return
        severity = self.severity_combo.currentText()
        reporter = self.reporter_edit.text().strip()
        if not reporter:
            QMessageBox.warning(self, "Error", "Reporter is required.")
            return
        status_ = self.status_combo.currentText()
        resolution = self.resolution_edit.toPlainText().strip() or None
        c = self.connection.cursor()
        if self.is_edit and self.defect_data:
            defect_id = self.defect_data["DEFECT_ID"]
            try:
                c.execute("""
                    UPDATE BRM_DEFECT_LOGS
                    SET RULE_ID=?, DESCRIPTION=?, SEVERITY=?, REPORTER=?, STATUS=?, RESOLUTION=?, TIMESTAMP=GETDATE()
                    WHERE DEFECT_ID=?
                """, (rule_id, description, severity, reporter, status_, resolution, defect_id))
                self.connection.commit()
                logger.info(f"Defect {defect_id} updated by {reporter}.")
            except Exception as ex:
                logger.error(f"Error updating defect {defect_id}: {ex}")
                QMessageBox.critical(self, "Error", str(ex))
                return
        else:
            try:
                add_defect_log(self.connection, rule_id, description, severity, reporter, status_, resolution)
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
                return
        self.accept()

class DefectManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.last_defect_count = 0
        self.init_ui()
        self.load_defects()
        self.start_auto_refresh()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by description, severity, reporter, or status...")
        self.search_edit.textChanged.connect(self.search_defects)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)
        self.defect_table = QTableWidget(0, 7)
        self.defect_table.setHorizontalHeaderLabels(["DefectID", "RuleID", "Description", "Severity", "Reporter", "Status", "Timestamp"])
        self.defect_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.defect_table)
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Defect")
        add_btn.clicked.connect(self.add_defect)
        btn_h.addWidget(add_btn)
        edit_btn = QPushButton("Edit Defect")
        edit_btn.clicked.connect(self.edit_defect)
        btn_h.addWidget(edit_btn)
        del_btn = QPushButton("Delete Defect")
        del_btn.clicked.connect(self.delete_defect)
        btn_h.addWidget(del_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_defects)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.notification_label = QLabel("")
        self.notification_label.setStyleSheet("color: green; font-weight: bold;")
        layout.addWidget(self.notification_label)
        self.setLayout(layout)
    def load_defects(self):
        self.defect_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT DEFECT_ID, RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, TIMESTAMP FROM BRM_DEFECT_LOGS ORDER BY TIMESTAMP DESC")
        rows = c.fetchall()
        current_count = len(rows)
        for row in rows:
            r_i = self.defect_table.rowCount()
            self.defect_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.defect_table.setItem(r_i, col, QTableWidgetItem(str(val) if val is not None else ""))
        if self.last_defect_count and current_count > self.last_defect_count:
            new_ct = current_count - self.last_defect_count
            self.notification_label.setText(f"{new_ct} new defect(s) logged.")
            QtWidgets.QTimer.singleShot(5000, lambda: self.notification_label.setText(""))
        self.last_defect_count = current_count
        self.defect_table.resizeColumnsToContents()
    def search_defects(self, text):
        txt = text.lower().strip()
        for row in range(self.defect_table.rowCount()):
            row_visible = any(txt in (self.defect_table.item(row, col).text().lower() if self.defect_table.item(row, col) else "") for col in range(self.defect_table.columnCount()))
            self.defect_table.setRowHidden(row, not row_visible)
    def start_auto_refresh(self):
        self.refresh_timer = QtWidgets.QTimer(self)
        self.refresh_timer.timeout.connect(self.load_defects)
        self.refresh_timer.start(30000)
    def get_selected_defect_id(self):
        row = self.defect_table.currentRow()
        if row < 0:
            return None
        it = self.defect_table.item(row, 0)
        return int(it.text()) if it else None
    def add_defect(self):
        dlg = DefectDialog(self.connection, None, self)
        if dlg.exec_() == QDialog.Accepted:
            self.load_defects()
    def edit_defect(self):
        did = self.get_selected_defect_id()
        if not did:
            QMessageBox.warning(self, "None", "No defect selected.")
            return
        c = self.connection.cursor()
        c.execute("SELECT DEFECT_ID, RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, RESOLUTION FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?", (did,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Defect {did} not found.")
            return
        colnames = [desc[0] for desc in c.description]
        defect_data = dict(zip(colnames, row))
        dlg = DefectDialog(self.connection, defect_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.load_defects()
    def delete_defect(self):
        did = self.get_selected_defect_id()
        if not did:
            QMessageBox.warning(self, "None", "No defect selected.")
            return
        if QMessageBox.question(self, "Confirm", f"Delete defect {did}?") != QMessageBox.Yes:
            return
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?", (did,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Defect {did} removed.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# =======================
# Module: brm_metrics_and_control_management.py
# =======================
import math, csv
import pyqtgraph as pg
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import QAbstractItemView, QGroupBox, QTabWidget
def encrypt_password(plain_text):
    return "enc_" + plain_text[::-1]

class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_metrics()
        self.start_auto_refresh()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        layout.addWidget(self.status_chart)
        self.exec_chart = pg.PlotWidget(title="Execution Trends (Last 7 Days)")
        self.exec_chart.setBackground('w')
        layout.addWidget(self.exec_chart)
        self.val_chart = pg.PlotWidget(title="Validation Pass/Fail Ratio (30 Days)")
        self.val_chart.setBackground('w')
        layout.addWidget(self.val_chart)
        btn_layout = QHBoxLayout()
        ref_btn = QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        btn_layout.addWidget(ref_btn)
        export_btn = QPushButton("Export CSV")
        export_btn.clicked.connect(self.export_metrics_csv)
        btn_layout.addWidget(export_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    def load_metrics(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE STATUS='ACTIVE'")
            self.card_active_rules_count = c.fetchone()[0]
        except:
            self.card_active_rules_count = "N/A"
        try:
            c.execute("SELECT COUNT(DISTINCT RULE_ID) FROM BRM_RULE_APPROVALS WHERE APPROVED_FLAG=0")
            self.card_approvals_count = c.fetchone()[0]
        except:
            self.card_approvals_count = "N/A"
        try:
            c.execute("SELECT COUNT(*) FROM BRM_DEFECT_LOGS WHERE STATUS IN ('Open','In Progress')")
            self.card_defects_count = c.fetchone()[0]
        except:
            self.card_defects_count = "N/A"
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE CRITICAL_RULE=1 OR IS_GLOBAL=1")
            self.card_critical_count = c.fetchone()[0]
        except:
            self.card_critical_count = "N/A"
        try:
            c.execute("""
                SELECT COUNT(*) FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled' AND SCHEDULE_TIME>=GETDATE() AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
            """)
            self.card_schedules_count = c.fetchone()[0]
        except:
            self.card_schedules_count = "N/A"
        # For demonstration, we update a simple label for each card
        # In a real application, you would update individual card widgets.
    def export_metrics_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Metrics CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["Metric", "Value"])
                writer.writerow(["Active Rules", self.card_active_rules_count])
                writer.writerow(["Approvals Pending", self.card_approvals_count])
                writer.writerow(["Open Defects", self.card_defects_count])
                writer.writerow(["Critical Rules", self.card_critical_count])
                writer.writerow(["Schedules <24h", self.card_schedules_count])
            QMessageBox.information(self, "Exported", f"Metrics exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def start_auto_refresh(self, interval_ms=30000):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.load_metrics)
        self.timer.start(interval_ms)

class ControlTablesTab(QWidget):
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.table_list = ["USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES", "BRM_RULE_GROUPS",
                           "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG", "BRM_GLOBAL_CRITICAL_LINKS", "RULE_SCHEDULES",
                           "DECISION_TABLES", "RULE_CONFLICTS", "COMPOSITE_RULES", "RULE_TAGS", "DATA_VALIDATIONS",
                           "RULE_EXECUTION_LOGS", "DATA_VALIDATION_LOGS"]
        self.current_table = None
        self.columns = []
        self.init_ui()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.tbl_combo = QComboBox()
        for t in self.table_list:
            self.tbl_combo.addItem(t)
        layout.addWidget(QLabel("Select Control Table:"))
        layout.addWidget(self.tbl_combo)
        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_table_data)
        layout.addWidget(load_btn)
        self.data_table = QTableWidget(0, 0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        if self.user_group == "Admin":
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)
        save_btn = QPushButton("Save Changes (Admin Only)")
        if self.user_group != "Admin":
            save_btn.setEnabled(False)
        save_btn.clicked.connect(self.save_changes)
        layout.addWidget(save_btn)
        self.setLayout(layout)
    def load_table_data(self):
        tbl = self.tbl_combo.currentText()
        if not tbl:
            return
        self.current_table = tbl
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            self.columns = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error reading columns from {tbl}: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {tbl}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error reading data from {tbl}: {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(self.columns))
        self.data_table.setHorizontalHeaderLabels(self.columns)
        for row in rows:
            r_i = self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.data_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val is not None else ""))
        self.data_table.resizeColumnsToContents()
    def save_changes(self):
        if self.user_group != "Admin":
            QMessageBox.warning(self, "Not Admin", "You do not have permission to save changes.")
            return
        if not self.current_table:
            QMessageBox.warning(self, "None", "No table loaded.")
            return
        if QMessageBox.question(self, "Confirm", "This will overwrite the table. Proceed?") != QMessageBox.Yes:
            return
        rowcount = self.data_table.rowCount()
        colcount = self.data_table.columnCount()
        c = self.connection.cursor()
        try:
            try:
                c.execute(f"TRUNCATE TABLE {self.current_table}")
            except:
                c.execute(f"DELETE FROM {self.current_table}")
            for r in range(rowcount):
                vals = [self.data_table.item(r, col).text() if self.data_table.item(r, col) else "" for col in range(colcount)]
                placeholders = ",".join("?" * colcount)
                colnames = ",".join(self.columns)
                q = f"INSERT INTO {self.current_table}({colnames}) VALUES({placeholders})"
                c.execute(q, vals)
            self.connection.commit()
            QMessageBox.information(self, "Saved", f"Overwrote {self.current_table} with {rowcount} rows.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class GroupManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
        if self.user_group == "Admin":
            self.load_data()
    def init_ui(self):
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin Only"))
            self.setLayout(layout)
            return
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)
        gm_tab = QWidget()
        gm_layout = QVBoxLayout(gm_tab)
        grp_box = QGroupBox("Business Groups")
        grp_layout = QVBoxLayout(grp_box)
        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name", "Description", "Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)
        grp_btn_l = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.add_group)
        grp_btn_l.addWidget(add_grp_btn)
        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.rename_group)
        grp_btn_l.addWidget(rename_grp_btn)
        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.delete_group)
        grp_btn_l.addWidget(del_grp_btn)
        grp_btn_l.addStretch()
        grp_layout.addLayout(grp_btn_l)
        gm_layout.addWidget(grp_box)
        memb_box = QGroupBox("User Membership")
        memb_layout = QVBoxLayout(memb_box)
        self.users_table = QTableWidget(0, 3)
        self.users_table.setHorizontalHeaderLabels(["UserID", "Username", "Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        memb_layout.addWidget(self.users_table)
        memb_btns = QHBoxLayout()
        add_usr_btn = QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.add_user_to_group)
        memb_btns.addWidget(add_usr_btn)
        rem_usr_btn = QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.remove_user_from_group)
        memb_btns.addWidget(rem_usr_btn)
        memb_btns.addStretch()
        memb_layout.addLayout(memb_btns)
        gm_layout.addWidget(memb_box)
        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab, "Groups & Membership")
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        top_perm_h = QHBoxLayout()
        self.perm_group_combo = QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_perm_h.addWidget(QLabel("Select Group:"))
        top_perm_h.addWidget(self.perm_group_combo)
        top_perm_h.addStretch()
        perm_layout.addLayout(top_perm_h)
        self.perm_table = QTableWidget(0, 1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_layout.addWidget(self.perm_table)
        perm_btns = QHBoxLayout()
        addp_btn = QPushButton("Add Permission")
        addp_btn.clicked.connect(self.add_permission)
        perm_btns.addWidget(addp_btn)
        remp_btn = QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.remove_permission)
        perm_btns.addWidget(remp_btn)
        perm_btns.addStretch()
        perm_layout.addLayout(perm_btns)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab, "Permissions")
        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        appr_top_h = QHBoxLayout()
        self.appr_group_combo = QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        appr_top_h.addWidget(QLabel("Select Group:"))
        appr_top_h.addWidget(self.appr_group_combo)
        appr_top_h.addStretch()
        appr_layout.addLayout(appr_top_h)
        self.approvers_table = QTableWidget(0, 2)
        self.approvers_table.setHorizontalHeaderLabels(["ApproverID", "Username"])
        self.approvers_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.approvers_table)
        appr_btns = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.add_approver)
        appr_btns.addWidget(add_appr_btn)
        rem_appr_btn = QPushButton("Remove Approver")
        rem_appr_btn.clicked.connect(self.remove_approver)
        appr_btns.addWidget(rem_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab, "Approvers")
        ref_btn = QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        gm_layout.addWidget(ref_btn)
        self.setLayout(layout)
    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_groups()
        self.load_appr_groups()
    def load_groups(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        self.groups_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.groups_table.setItem(r_i, col, QTableWidgetItem(str(val) if val else ""))
    def load_users(self):
        self.users_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            r_i = self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.users_table.setItem(r_i, col, QTableWidgetItem(str(val) if val else ""))
    def add_group(self):
        gname, ok = QInputDialog.getText(self, "Add Group", "Group name:")
        if not ok or not gname.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional description:")
        desc = desc.strip() if ok2 else ""
        email, ok3 = QInputDialog.getText(self, "Email", "Optional email:")
        email = email.strip() if ok3 else ""
        c = self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (gname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self, "Error", "Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)", (gname.strip(), desc, email))
        self.connection.commit()
        QMessageBox.information(self, "Added", f"Group {gname} created.")
        self.load_data()
    def rename_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        old_name = self.groups_table.item(row, 0).text().strip()
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for '{old_name}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self, "Error", "New group name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), old_name))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), old_name))
            c.execute("COMMIT")
            QMessageBox.information(self, "Renamed", f"Group '{old_name}' renamed to '{new_name.strip()}'.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.load_data()
    def delete_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        grp_name = self.groups_table.item(row, 0).text().strip()
        if QMessageBox.question(self, "Confirm", f"Delete group '{grp_name}'?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (grp_name,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group '{grp_name}' removed.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_data()
    def add_user_to_group(self):
        row = self.users_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        user_id = self.users_table.item(row, 0).text().strip()
        target_grp, ok = QInputDialog.getText(self, "Add User to Group", "Target group name:")
        if not ok or not target_grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (target_grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self, "Error", "Specified group does not exist.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?", (target_grp.strip(), user_id))
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"User {user_id} assigned to {target_grp}.")
        self.load_data()
    def remove_user_from_group(self):
        row = self.users_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        user_id = self.users_table.item(row, 0).text().strip()
        if QMessageBox.question(self, "Confirm", f"Remove user {user_id} from group (move to 'BG1')?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?", (user_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", f"User {user_id} moved to BG1.")
        self.load_data()
    def load_perm_groups(self):
        self.perm_group_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for (gn,) in c.fetchall():
            self.perm_group_combo.addItem(gn, gn)
    def load_permissions(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (grp,))
        for row in c.fetchall():
            r_i = self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
    def add_permission(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            return
        table_, ok = QInputDialog.getText(self, "Add Permission", "Enter table (e.g., 'dbo.MyTable'):")
        if not ok or not table_.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME, TARGET_TABLE) VALUES(?,?)", (grp.strip(), table_.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Permission added.")
        self.load_permissions()
    def remove_permission(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            return
        row = self.perm_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No permission selected.")
            return
        table_name = self.perm_table.item(row, 0).text().strip()
        if QMessageBox.question(self, "Confirm", f"Remove permission '{table_name}' from group {grp}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?", (grp, table_name))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Permission removed.")
        self.load_permissions()
    def load_appr_groups(self):
        self.appr_group_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for (gn,) in c.fetchall():
            self.appr_group_combo.addItem(gn, gn)
    def load_approvers(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        self.approvers_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT APPROVER_ID, USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (grp,))
        for row in c.fetchall():
            r_i = self.approvers_table.rowCount()
            self.approvers_table.insertRow(r_i)
            self.approvers_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.approvers_table.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
    def add_approver(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        usern, ok = QInputDialog.getText(self, "Add Approver", "Username:")
        if not ok or not usern.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES(?,?)", (grp.strip(), usern.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", f"Approver {usern} added to group {grp}.")
        self.load_approvers()
    def remove_approver(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        row = self.approvers_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No approver selected.")
            return
        appr_id = int(self.approvers_table.item(row, 0).text())
        if QMessageBox.question(self, "Confirm", f"Remove approver ID={appr_id}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?", (appr_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Approver removed.")
        self.load_approvers()

# =======================
# Module: brm_audit_activity_tracking.py
# =======================
def record_activity_event(conn, event_type, user_id_or_name, details=None, rule_id=None):
    details = details or ""
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_ACTIVITY_LOG(EVENT_TYPE, USERNAME, TIMESTAMP, DETAILS, RULE_ID)
            VALUES(?, ?, GETDATE(), ?, ?)
        """, (event_type, str(user_id_or_name), details, rule_id))
        conn.commit()
        logger.debug(f"Activity event recorded: {event_type}, user={user_id_or_name}, rule={rule_id}")
    except Exception as ex:
        logger.error(f"Error recording activity event {event_type}: {ex}")

class ActivityTrackingTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_logs()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.user_search = QLineEdit()
        self.user_search.setPlaceholderText("Filter by Username")
        top_h.addWidget(QLabel("User:"))
        top_h.addWidget(self.user_search)
        self.event_combo = QComboBox()
        self.event_combo.addItem("All Events", "")
        known_events = ["LOGIN", "LOGOFF", "BFS_RUN", "SCHEDULE_TRIGGER", "RULE_SIM", "DEFECT", "OTHER"]
        for ev in known_events:
            self.event_combo.addItem(ev, ev)
        top_h.addWidget(QLabel("Event Type:"))
        top_h.addWidget(self.event_combo)
        self.text_search = QLineEdit()
        self.text_search.setPlaceholderText("Search in details...")
        top_h.addWidget(self.text_search)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_logs)
        top_h.addWidget(refresh_btn)
        export_btn = QPushButton("Export CSV")
        export_btn.clicked.connect(self.export_csv)
        top_h.addWidget(export_btn)
        top_h.addStretch()
        layout.addLayout(top_h)
        self.log_table = QTableWidget(0, 5)
        self.log_table.setHorizontalHeaderLabels(["ActivityID", "EventType", "Username", "Timestamp", "Details"])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)
        self.setLayout(layout)
    def load_logs(self):
        user_filter = self.user_search.text().strip().lower()
        event_filter = self.event_combo.currentData().strip().lower()
        text_filter = self.text_search.text().strip().lower()
        c = self.connection.cursor()
        c.execute("""
            SELECT TOP 1000 ACTIVITY_ID, EVENT_TYPE, USERNAME, TIMESTAMP, DETAILS
            FROM BRM_ACTIVITY_LOG
            ORDER BY ACTIVITY_ID DESC
        """)
        rows = c.fetchall()
        self.log_table.setRowCount(0)
        for row in rows:
            if user_filter and user_filter not in (row[2] or "").lower():
                continue
            if event_filter and event_filter not in (row[1] or "").lower():
                continue
            if text_filter and text_filter not in (row[4] or "").lower():
                continue
            r_i = self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.log_table.setItem(r_i, col, QTableWidgetItem(str(val) if val is not None else ""))
        self.log_table.resizeColumnsToContents()
    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Activity Logs CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            import csv
            with open(path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
                writer.writerow(headers)
                for r in range(self.log_table.rowCount()):
                    rowdata = []
                    for c in range(self.log_table.columnCount()):
                        item = self.log_table.item(r, c)
                        rowdata.append(item.text() if item else "")
                    writer.writerow(rowdata)
            QMessageBox.information(self, "Exported", f"Activity logs exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# =======================
# Module: brm_dashboard_cards.py
# =======================
from PyQt5.QtWidgets import QFrame
class DashboardCard(QFrame):
    def __init__(self, title, count=0, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.StyledPanel)
        self.setStyleSheet("QFrame { background-color: #F0F0F0; border-radius: 6px; }")
        layout = QVBoxLayout(self)
        self.title_label = QLabel(title)
        self.title_label.setStyleSheet("font-weight: bold; font-size: 14pt;")
        layout.addWidget(self.title_label)
        self.count_label = QLabel(str(count))
        self.count_label.setStyleSheet("font-size: 24pt; font-weight: bold; color: #007ACC;")
        self.count_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.count_label)
        self.detail_button = QPushButton("View Details")
        layout.addWidget(self.detail_button)
        layout.addStretch()
    def set_count(self, value):
        self.count_label.setText(str(value))

class DashboardCardsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_metrics()
        self.start_auto_refresh()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_label = QLabel("Dashboard – Key Metrics")
        top_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(top_label)
        self.cards_layout = QVBoxLayout()
        # For simplicity, add cards vertically; adjust layout as needed.
        self.card_active_rules = DashboardCard("Active Rules", 0)
        self.card_approvals = DashboardCard("Approvals Pending", 0)
        self.card_defects = DashboardCard("Open Defects", 0)
        self.card_critical = DashboardCard("Critical Rules", 0)
        self.card_schedules = DashboardCard("Schedules <24h", 0)
        layout.addWidget(self.card_active_rules)
        layout.addWidget(self.card_approvals)
        layout.addWidget(self.card_defects)
        layout.addWidget(self.card_critical)
        layout.addWidget(self.card_schedules)
        self.card_active_rules.detail_button.clicked.connect(self.show_active_rules_details)
        self.card_approvals.detail_button.clicked.connect(self.show_approvals_details)
        self.card_defects.detail_button.clicked.connect(self.show_defects_details)
        self.card_critical.detail_button.clicked.connect(self.show_critical_details)
        self.card_schedules.detail_button.clicked.connect(self.show_schedules_details)
        layout.addStretch()
        self.setLayout(layout)
    def load_metrics(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE STATUS='ACTIVE'")
            self.card_active_rules.set_count(c.fetchone()[0])
        except:
            self.card_active_rules.set_count("N/A")
        try:
            c.execute("SELECT COUNT(DISTINCT RULE_ID) FROM BRM_RULE_APPROVALS WHERE APPROVED_FLAG=0")
            self.card_approvals.set_count(c.fetchone()[0])
        except:
            self.card_approvals.set_count("N/A")
        try:
            c.execute("SELECT COUNT(*) FROM BRM_DEFECT_LOGS WHERE STATUS IN ('Open','In Progress')")
            self.card_defects.set_count(c.fetchone()[0])
        except:
            self.card_defects.set_count("N/A")
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE CRITICAL_RULE=1 OR IS_GLOBAL=1")
            self.card_critical.set_count(c.fetchone()[0])
        except:
            self.card_critical.set_count("N/A")
        try:
            c.execute("""
                SELECT COUNT(*) FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled' AND SCHEDULE_TIME>=GETDATE() AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
            """)
            self.card_schedules.set_count(c.fetchone()[0])
        except:
            self.card_schedules.set_count("N/A")
    def start_auto_refresh(self, interval_ms=30000):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.load_metrics)
        self.timer.start(interval_ms)
    def show_active_rules_details(self):
        QMessageBox.information(self, "Active Rules", "Open the 'Business Rules' tab filtered by active status.")
    def show_approvals_details(self):
        QMessageBox.information(self, "Approvals Pending", "Switch to the 'Approvals' tab for details.")
    def show_defects_details(self):
        QMessageBox.information(self, "Open Defects", "Open the 'Defects' tab for details.")
    def show_critical_details(self):
        QMessageBox.information(self, "Critical Rules", "Open the 'Business Rules' or GCR Admin tab filtered by critical rules.")
    def show_schedules_details(self):
        QMessageBox.information(self, "Schedules <24h", "Open the 'Scheduling' tab for upcoming schedules.")

# =======================
# Module: brm_live_collaboration.py
# =======================
class CollaborationManager(QtCore.QObject):
    locks_updated = QtCore.pyqtSignal(list)
    def __init__(self, connection, poll_interval_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_locks)
        self.timer.start(poll_interval_ms)
    def poll_locks(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK FROM BRM_RULE_LOCKS WHERE ACTIVE_LOCK=1")
            rows = c.fetchall()
            self.locks_updated.emit(rows)
        except Exception as ex:
            logger.error(f"Error polling locks: {ex}")

class CollaborationTab(QWidget):
    def __init__(self, connection, collab_manager, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.collab_manager = collab_manager
        self.init_ui()
        self.collab_manager.locks_updated.connect(self.update_lock_table)
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.title_label = QLabel("Live Collaboration: Current Locked Rules")
        layout.addWidget(self.title_label)
        self.lock_table = QTableWidget(0, 5)
        self.lock_table.setHorizontalHeaderLabels(["RuleID", "LockedBy", "LockTimestamp", "Expiry", "ForceLock"])
        self.lock_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.lock_table)
        btn_layout = QHBoxLayout()
        self.force_unlock_btn = QPushButton("Force Unlock Selected")
        self.force_unlock_btn.clicked.connect(self.force_unlock_selected)
        btn_layout.addWidget(self.force_unlock_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    def update_lock_table(self, lock_list):
        self.lock_table.setRowCount(0)
        for row in lock_list:
            r_i = self.lock_table.rowCount()
            self.lock_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.lock_table.setItem(r_i, col, QTableWidgetItem(str(val) if val is not None else ""))
        self.lock_table.resizeColumnsToContents()
    def get_selected_rule_id(self):
        row = self.lock_table.currentRow()
        if row < 0:
            return None
        it = self.lock_table.item(row, 0)
        return int(it.text()) if it else None
    def force_unlock_selected(self):
        rid = self.get_selected_rule_id()
        if not rid:
            QMessageBox.warning(self, "None", "No locked rule selected.")
            return
        if QMessageBox.question(self, "Confirm", f"Force unlock rule {rid}?") != QMessageBox.Yes:
            return
        try:
            from brm_rule_engine import unlock_rule_for_edit
            unlock_rule_for_edit(self.connection, rid, locked_by="AdminOverride", force=True)
            QMessageBox.information(self, "Forced", "Rule forcibly unlocked.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# =======================
# Module: brm_sql_to_business_converter.py
# =======================
class SqlToBusinessConverterTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.populate_rule_selector()
    def init_ui(self):
        layout = QVBoxLayout(self)
        rule_layout = QHBoxLayout()
        rule_layout.addWidget(QLabel("Select Rule:"))
        self.rule_combo = QComboBox()
        rule_layout.addWidget(self.rule_combo)
        layout.addLayout(rule_layout)
        map_layout = QHBoxLayout()
        map_layout.addWidget(QLabel("Business Mapping (JSON):"))
        self.mapping_input = QPlainTextEdit()
        self.mapping_input.setPlaceholderText('{"dbo.Customers": "Customers", "dbo.Orders": "Orders"}')
        map_layout.addWidget(self.mapping_input)
        layout.addLayout(map_layout)
        self.convert_button = QPushButton("Convert SQL to Business Language")
        self.convert_button.clicked.connect(self.convert_sql)
        layout.addWidget(self.convert_button)
        layout.addWidget(QLabel("Converted SQL:"))
        self.output_display = QPlainTextEdit()
        self.output_display.setReadOnly(True)
        layout.addWidget(self.output_display)
        self.setLayout(layout)
    def populate_rule_selector(self):
        self.rule_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rid, rn in c.fetchall():
                self.rule_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            logger.error(f"Error populating rule selector: {ex}")
            QMessageBox.critical(self, "Error", f"Could not load rules: {ex}")
    def convert_sql(self):
        rule_id = self.rule_combo.currentData()
        if rule_id is None:
            QMessageBox.warning(self, "No Rule", "Please select a rule.")
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row or not row[0]:
                QMessageBox.warning(self, "No SQL", "Selected rule has no SQL.")
                return
            sql_text = row[0]
            parse_info = parse_sql_dependencies(sql_text)
        except Exception as ex:
            logger.error(f"Error fetching/parsing SQL: {ex}")
            QMessageBox.critical(self, "Error", f"Error fetching/parsing SQL: {ex}")
            return
        try:
            mapping_text = self.mapping_input.toPlainText().strip()
            business_mapping = json.loads(mapping_text) if mapping_text else {}
        except Exception as ex:
            QMessageBox.warning(self, "Mapping Error", f"Invalid JSON mapping: {ex}")
            return
        converted_sql = self.apply_business_mapping(sql_text, parse_info, business_mapping)
        self.output_display.setPlainText(converted_sql)
        count_replacements = self.count_replacements(parse_info, business_mapping)
        QMessageBox.information(self, "Conversion Complete", f"Conversion done. Replaced {count_replacements} table references.")
    def apply_business_mapping(self, sql_text, parse_info, mapping):
        converted = sql_text
        for (schema, table, alias, is_sub) in parse_info.get("tables", []):
            if table and not table.startswith("(CTE)"):
                key = f"{schema}.{table}" if schema else table
                key = key.strip(".")
                if key in mapping:
                    biz_name = mapping[key]
                    converted = self._replace_identifier(converted, table, biz_name)
        return converted
    def _replace_identifier(self, text, identifier, replacement):
        import re
        pattern = r'\b' + re.escape(identifier) + r'\b'
        return re.sub(pattern, replacement, text)
    def count_replacements(self, parse_info, mapping):
        count = 0
        for (schema, table, alias, is_sub) in parse_info.get("tables", []):
            if table and not table.startswith("(CTE)"):
                key = f"{schema}.{table}" if schema else table
                key = key.strip(".")
                if key in mapping:
                    count += 1
        return count

# =======================
# Module: brm_contextual_inline_editing.py
# =======================
from PyQt5.QtCore import QAbstractTableModel, QModelIndex
from PyQt5.QtWidgets import QTableView
class InlineEditModel(QAbstractTableModel):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.columns = ["RULE_ID", "RULE_NAME", "STATUS", "OWNER_GROUP"]
        self.data_rows = []
        self.fetch_data()
    def fetch_data(self):
        self.beginResetModel()
        try:
            c = self.connection.cursor()
            c.execute("SELECT TOP 200 RULE_ID, RULE_NAME, STATUS, OWNER_GROUP FROM BRM_RULES ORDER BY RULE_ID DESC")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            self.data_rows = [dict(zip(colnames, row)) for row in rows]
        except Exception as ex:
            logger.error(f"Error fetching data: {ex}")
            self.data_rows = []
        self.endResetModel()
    def rowCount(self, parent=QModelIndex()):
        return len(self.data_rows)
    def columnCount(self, parent=QModelIndex()):
        return len(self.columns)
    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role in (Qt.DisplayRole, Qt.EditRole):
            row = index.row()
            col = index.column()
            colname = self.columns[col]
            return str(self.data_rows[row].get(colname, ""))
        return None
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.columns[section]
        return super().headerData(section, orientation, role)
    def flags(self, index):
        if not index.isValid():
            return Qt.ItemIsEnabled
        if self.columns[index.column()] == "RULE_ID":
            return Qt.ItemIsEnabled | Qt.ItemIsSelectable
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsEditable
    def setData(self, index, value, role=Qt.EditRole):
        if role == Qt.EditRole and index.isValid():
            row = index.row()
            col = index.column()
            colname = self.columns[col]
            new_val = value.strip() if isinstance(value, str) else value
            old_val = self.data_rows[row].get(colname)
            if new_val == old_val:
                return True
            rule_id = self.data_rows[row]["RULE_ID"]
            try:
                self.attempt_lock(rule_id)
            except Exception as ex:
                QMessageBox.warning(None, "Lock Error", f"Cannot lock rule {rule_id}: {ex}")
                return False
            if colname == "OWNER_GROUP" and not self.user_can_assign_group(new_val):
                QMessageBox.warning(None, "Permission Denied", f"You cannot assign rule to group {new_val}.")
                return False
            if not self.update_rule_in_db(rule_id, colname, new_val):
                return False
            self.data_rows[row][colname] = new_val
            try:
                self.unlock_rule(rule_id)
            except Exception:
                pass
            self.dataChanged.emit(index, index, [Qt.DisplayRole, Qt.EditRole])
            return True
        return False
    def user_can_assign_group(self, group_name):
        if self.user_group == "Admin":
            return True
        return group_name == self.user_group
    def attempt_lock(self, rule_id):
        from brm_rule_engine import LockManager
        current_lock = LockManager.rule_current_lock_owner(self.connection, rule_id)
        if current_lock and str(current_lock[0]) != str(self.user_id) and self.user_group != "Admin":
            raise Exception(f"Rule locked by user {current_lock[0]}.")
        LockManager.lock_rule_for_edit(self.connection, rule_id, self.user_id, force=False)
    def unlock_rule(self, rule_id):
        from brm_rule_engine import LockManager
        LockManager.unlock_rule_for_edit(self.connection, rule_id, self.user_id)
    def update_rule_in_db(self, rule_id, colname, new_val):
        c = self.connection.cursor()
        try:
            if colname == "RULE_NAME":
                c.execute("UPDATE BRM_RULES SET RULE_NAME=?, UPDATED_BY=?, VERSION=VERSION+1 WHERE RULE_ID=?", (new_val, str(self.user_id), rule_id))
            elif colname == "STATUS":
                if new_val.upper() not in ("ACTIVE", "INACTIVE"):
                    QMessageBox.warning(None, "Invalid Value", "Status must be ACTIVE or INACTIVE.")
                    return False
                c.execute("UPDATE BRM_RULES SET STATUS=?, UPDATED_BY=?, VERSION=VERSION+1 WHERE RULE_ID=?", (new_val.upper(), str(self.user_id), rule_id))
            elif colname == "OWNER_GROUP":
                c.execute("UPDATE BRM_RULES SET OWNER_GROUP=?, UPDATED_BY=?, VERSION=VERSION+1 WHERE RULE_ID=?", (new_val, str(self.user_id), rule_id))
            else:
                return False
            self.connection.commit()
            return True
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(None, "DB Error", str(ex))
            return False

class InlineEditingTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.table = QTableView()
        self.model = InlineEditModel(self.connection, self.user_id, self.user_group, self)
        self.table.setModel(self.model)
        layout.addWidget(self.table)
        btn_layout = QHBoxLayout()
        ref_btn = QPushButton("Refresh Data")
        ref_btn.clicked.connect(self.refresh_data)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    def refresh_data(self):
        self.model.fetch_data()

# =======================
# Module: brm_performance_alerting_and_trends.py
# =======================
class PerformanceAlertingTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.populate_rule_list()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)
        self.threshold_edit = QLineEdit()
        self.threshold_edit.setPlaceholderText("Enter threshold ms (e.g., 2000)")
        top_layout.addWidget(QLabel("Alert Threshold:"))
        top_layout.addWidget(self.threshold_edit)
        apply_btn = QPushButton("Apply")
        apply_btn.clicked.connect(self.load_data)
        top_layout.addWidget(apply_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.chart = pg.PlotWidget(title="Performance Trend")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        self.alerts_label = QLabel("")
        self.alerts_label.setStyleSheet("color:red; font-weight:bold;")
        layout.addWidget(self.alerts_label)
        self.setLayout(layout)
    def populate_rule_list(self):
        self.rule_combo.clear()
        self.rule_combo.addItem("All Rules", None)
        try:
            c = self.connection.cursor()
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rid, rn in c.fetchall():
                self.rule_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading rules: {ex}")
    def load_data(self):
        sel_rid = self.rule_combo.currentData()
        try:
            threshold_ms = float(self.threshold_edit.text().strip())
        except:
            threshold_ms = 2000.0
        c = self.connection.cursor()
        if sel_rid:
            c.execute("""
                SELECT CONVERT(varchar(10), EXECUTION_TIMESTAMP, 120) as d, AVG(EXECUTION_TIME_MS) as avg_ms
                FROM RULE_EXECUTION_LOGS
                WHERE RULE_ID=? AND EXECUTION_TIMESTAMP>=DATEADD(day, -30, GETDATE())
                GROUP BY CONVERT(varchar(10), EXECUTION_TIMESTAMP, 120)
                ORDER BY d
            """, (sel_rid,))
        else:
            c.execute("""
                SELECT CONVERT(varchar(10), EXECUTION_TIMESTAMP, 120) as d, AVG(EXECUTION_TIME_MS) as avg_ms
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP>=DATEADD(day, -30, GETDATE())
                GROUP BY CONVERT(varchar(10), EXECUTION_TIMESTAMP, 120)
                ORDER BY d
            """)
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self, "No Data", "No execution data found in the last 30 days.")
            self.chart.clear()
            self.alerts_label.setText("")
            return
        dates = [r[0] for r in rows]
        avg_times = [float(r[1] or 0) for r in rows]
        xvals = list(range(len(dates)))
        self.chart.clear()
        self.chart.setLabel("left", "Avg Execution Time (ms)")
        self.chart.plot(xvals, avg_times, pen='b', symbol='o', symbolBrush='r')
        self.chart.setLabel("bottom", "Day Index")
        ticks = [(i, str(dates[i])) for i in range(len(dates))]
        self.chart.getAxis("bottom").setTicks([ticks])
        self.chart.showGrid(x=True, y=True)
        consecutive = 0
        max_consecutive = 0
        for t in avg_times:
            if t > threshold_ms:
                consecutive += 1
                max_consecutive = max(max_consecutive, consecutive)
            else:
                consecutive = 0
        if max_consecutive > 1:
            self.alerts_label.setText(f"ALERT: {max_consecutive} consecutive day(s) above {threshold_ms} ms!")
        else:
            self.alerts_label.setText("")

# =======================
# Module: brm_data_validations.py
# =======================
def run_single_validation(conn, validation_id):
    c = conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?
    """, (validation_id,))
    row = c.fetchone()
    if not row:
        logger.error(f"Validation rule not found (ID={validation_id}).")
        return (False, f"Validation rule not found (ID={validation_id}).")
    vid, tbl, col, vtype, params = row
    try:
        result = _execute_validation_check(conn, tbl, col, vtype, params)
    except Exception as ex:
        result = (False, str(ex))
    c2 = conn.cursor()
    res_flag = "PASS" if result[0] else "FAIL"
    c2.execute("""
        INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP, TABLE_NAME, COLUMN_NAME)
        VALUES(?, ?, ?, GETDATE(), ?, ?)
    """, (vid, res_flag, result[1], tbl, col))
    conn.commit()
    return result

def _execute_validation_check(conn, table_name, column_name, validation_type, params):
    vtype = validation_type.upper().strip()
    c = conn.cursor()
    if not table_name or not column_name:
        return (False, "Invalid table/column.")
    if vtype == "NOT NULL":
        c.execute(f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL")
        cnt = c.fetchone()[0]
        return (cnt == 0, f"{cnt} NULL values found in {table_name}.{column_name}" if cnt > 0 else "No NULLs found.")
    elif vtype == "RANGE":
        parts = (params or "").split(",")
        if len(parts) != 2:
            return (False, "Invalid range parameters; expected format 'min,max'.")
        try:
            min_val, max_val = float(parts[0]), float(parts[1])
        except:
            return (False, "Range parameters must be numeric.")
        c.execute(f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} < {min_val} OR {column_name} > {max_val}")
        out_of_range = c.fetchone()[0]
        return (out_of_range == 0, f"{out_of_range} values out of range [{min_val}, {max_val}]." if out_of_range > 0 else "All values within range.")
    elif vtype == "REGEX":
        import re
        pattern = re.compile(params or ".*")
        c.execute(f"SELECT {column_name} FROM {table_name}")
        rows = c.fetchall()
        mismatch = 0
        for (val,) in rows:
            if val is None or not pattern.match(str(val)):
                mismatch += 1
        return (mismatch == 0, f"{mismatch} rows did not match regex '{params}'." if mismatch > 0 else "All rows matched regex.")
    else:
        return (False, f"Unknown validation type '{validation_type}'.")
def run_validations_for_table(conn, table_name):
    c = conn.cursor()
    c.execute("SELECT VALIDATION_ID FROM DATA_VALIDATIONS WHERE LOWER(TABLE_NAME)=LOWER(?)", (table_name,))
    results = []
    for (vid,) in c.fetchall():
        results.append(run_single_validation(conn, vid))
    return results
def run_all_validations(conn):
    c = conn.cursor()
    c.execute("SELECT VALIDATION_ID FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
    results = []
    for (vid,) in c.fetchall():
        pf, dt = run_single_validation(conn, vid)
        c2 = conn.cursor()
        c2.execute("SELECT TABLE_NAME, COLUMN_NAME FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
        row = c2.fetchone()
        tbl, col = (row[0], row[1]) if row else ("?", "?")
        results.append((vid, tbl, col, pf, dt))
    return results
def run_validations_for_rule(conn, rule_id):
    c = conn.cursor()
    c.execute("SELECT DISTINCT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
    all_pass = True
    fail_details = []
    for (dbn, tbn) in c.fetchall():
        if not tbn:
            continue
        fulltbl = f"{dbn}.{tbn}".lower()
        table_results = run_validations_for_table(conn, fulltbl)
        for (vid, pf, dt) in [(r[0], r[3], r[4]) for r in run_all_validations(conn) if r[1].lower() == fulltbl]:
            if not pf:
                all_pass = False
                fail_details.append((vid, dt))
    return (all_pass, fail_details)

class DataValidationManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_validations()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.val_table = QTableWidget(0, 5)
        self.val_table.setHorizontalHeaderLabels(["ValidationID", "TableName", "ColumnName", "Type", "Params"])
        self.val_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.val_table)
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_h.addWidget(add_btn)
        del_btn = QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_validation)
        btn_h.addWidget(del_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all)
        btn_h.addWidget(run_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_validations)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
    def load_validations(self):
        self.val_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        for row in c.fetchall():
            r_i = self.val_table.rowCount()
            self.val_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.val_table.setItem(r_i, col, QTableWidgetItem(str(val) if val is not None else ""))
    def add_validation(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Table name (e.g., 'dbo.Customers'):")
        if not ok or not tbl.strip():
            return
        col, ok2 = QInputDialog.getText(self, "Column", "Column name:")
        if not ok2 or not col.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "(NOT NULL, RANGE, REGEX, ...)")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Params", "Example for RANGE: '0,100' / for REGEX: '^[A-Z]+$'")
        params = params.strip() if ok4 else ""
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP) VALUES(?,?,?,?,GETDATE())",
                      (tbl.strip(), col.strip(), vtype.strip(), params))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Validation rule added.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def remove_validation(self):
        row = self.val_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        vid_item = self.val_table.item(row, 0)
        if not vid_item:
            return
        vid = int(vid_item.text())
        if QMessageBox.question(self, "Confirm", f"Remove validation ID={vid}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Validation rule removed.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def run_all(self):
        results = run_all_validations(self.connection)
        fails = [r for r in results if not r[3]]
        if fails:
            fail_str = "\n".join([f"ID={f[0]} => {f[4]}" for f in fails])
            QMessageBox.warning(self, "Validation Results", f"Some validations failed:\n{fail_str}")
        else:
            QMessageBox.information(self, "Validation Results", "All validations passed.")

# =======================
# Module: brm_enhanced_workflow_pipeline.py
# =======================
def find_downstream_impact_on_update(conn, rule_id):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    for rid, pid in rows:
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
    visited = set()
    queue = [rule_id]
    while queue:
        current = queue.pop(0)
        if current in visited:
            continue
        visited.add(current)
        if current in adjacency:
            queue.extend(adjacency[current])
    visited.discard(rule_id)
    schedules = []
    if visited:
        placeholders = ",".join("?" for _ in visited)
        c.execute(f"SELECT SCHEDULE_ID FROM RULE_SCHEDULES WHERE RULE_ID IN ({placeholders})", tuple(visited))
        schedules = [r[0] for r in c.fetchall()]
    return {"child_rules": list(visited), "schedules": schedules}

def display_impact_warning_if_any(conn, rule_id):
    impact = find_downstream_impact_on_update(conn, rule_id)
    child_count = len(impact["child_rules"])
    sched_count = len(impact["schedules"])
    if child_count == 0 and sched_count == 0:
        return True
    msg = f"Updating rule {rule_id} will impact {child_count} child rule(s) and {sched_count} schedule(s). Continue?"
    return (QMessageBox.question(None, "Impact Analysis", msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes)

def fork_rule_approvals(conn, rule_id, fork_labels):
    c = conn.cursor()
    for label in fork_labels:
        c.execute("INSERT INTO BRM_RULE_FORKS(RULE_ID, FORK_LABEL, CREATED_TIMESTAMP) VALUES(?, ?, GETDATE())", (rule_id, label))
    conn.commit()

def mark_rule_fork_failed(conn, rule_id, fork_label):
    c = conn.cursor()
    c.execute("UPDATE BRM_RULE_FORKS SET FORK_STATUS='FAILED' WHERE RULE_ID=? AND FORK_LABEL=?", (rule_id, fork_label))
    conn.commit()

class PipelineNodeItem(QtWidgets.QGraphicsItem):
    def __init__(self, node_id, node_type, label):
        super().__init__()
        self.node_id = node_id
        self.node_type = node_type
        self.label = label
        self.rect = QtCore.QRectF(0, 0, 120, 60)
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | QtWidgets.QGraphicsItem.ItemIsSelectable)
    def boundingRect(self):
        return self.rect.adjusted(-2, -2, 2, 2)
    def paint(self, painter, option, widget=None):
        painter.setPen(QtGui.QPen(Qt.black, 2))
        painter.setBrush(QtGui.QBrush(QtGui.QColor("#E0E0E0")))
        painter.drawRoundedRect(self.rect, 8, 8)
        painter.drawText(self.rect, Qt.AlignCenter, f"{self.node_type}\n{self.label}")

class PipelineEdgeItem(QtWidgets.QGraphicsLineItem):
    def __init__(self, source, target, condition=None):
        super().__init__()
        self.source = source
        self.target = target
        self.condition = condition
        self.setPen(QtGui.QPen(Qt.darkGray, 2))
        self.adjust()
    def adjust(self):
        sp = self.source.sceneBoundingRect().center()
        tp = self.target.sceneBoundingRect().center()
        self.setLine(sp.x(), sp.y(), tp.x(), tp.y())
    def paint(self, painter, option, widget=None):
        self.adjust()
        super().paint(painter, option, widget)
        if self.condition:
            mid_x = (self.line().x1() + self.line().x2()) / 2
            mid_y = (self.line().y1() + self.line().y2()) / 2
            painter.setPen(QtGui.QPen(Qt.darkGray, 1))
            painter.drawText(mid_x, mid_y, self.condition)

class PipelineDesignerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.pipeline_id = None
        self.init_ui()
        self.load_pipeline_list()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.pipeline_combo = QComboBox()
        top_h.addWidget(QLabel("Select Pipeline:"))
        top_h.addWidget(self.pipeline_combo)
        load_btn = QPushButton("Load Pipeline")
        load_btn.clicked.connect(self.load_pipeline)
        top_h.addWidget(load_btn)
        new_btn = QPushButton("New Pipeline")
        new_btn.clicked.connect(self.create_pipeline)
        top_h.addWidget(new_btn)
        del_btn = QPushButton("Delete Pipeline")
        del_btn.clicked.connect(self.delete_pipeline)
        top_h.addWidget(del_btn)
        top_h.addStretch()
        layout.addLayout(top_h)
        self.scene = QtWidgets.QGraphicsScene(self)
        self.view = QtWidgets.QGraphicsView(self.scene)
        self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        layout.addWidget(self.view)
        bot_h = QHBoxLayout()
        node_btn = QPushButton("Add BFS Node")
        node_btn.clicked.connect(self.add_bfs_node)
        bot_h.addWidget(node_btn)
        run_btn = QPushButton("Run Pipeline")
        run_btn.clicked.connect(self.run_pipeline)
        bot_h.addWidget(run_btn)
        bot_h.addStretch()
        layout.addLayout(bot_h)
        self.setLayout(layout)
    def load_pipeline_list(self):
        self.pipeline_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT PIPELINE_ID, PIPELINE_NAME FROM BRM_PIPELINES ORDER BY PIPELINE_ID")
        for pid, pnm in c.fetchall():
            self.pipeline_combo.addItem(f"{pnm} (ID={pid})", pid)
    def load_pipeline(self):
        pid = self.pipeline_combo.currentData()
        if not pid:
            return
        self.pipeline_id = pid
        self.scene.clear()
        c = self.connection.cursor()
        c.execute("SELECT NODE_ID, NODE_TYPE, NODE_LABEL, POS_X, POS_Y FROM BRM_PIPELINE_NODES WHERE PIPELINE_ID=?", (pid,))
        node_map = {}
        for nid, ntype, nlabel, px, py in c.fetchall():
            item = PipelineNodeItem(nid, ntype, nlabel)
            item.setPos(px or 50, py or 50)
            self.scene.addItem(item)
            node_map[nid] = item
        c.execute("SELECT EDGE_ID, SOURCE_NODE_ID, TARGET_NODE_ID, CONDITION_LABEL FROM BRM_PIPELINE_EDGES WHERE PIPELINE_ID=?", (pid,))
        for eid, snid, tnid, cond in c.fetchall():
            if snid in node_map and tnid in node_map:
                edge = PipelineEdgeItem(node_map[snid], node_map[tnid], cond)
                self.scene.addItem(edge)
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.view.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)
    def create_pipeline(self):
        name, ok = QInputDialog.getText(self, "New Pipeline", "Pipeline name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BRM_PIPELINES(PIPELINE_NAME, CREATED_TIMESTAMP) VALUES(?, GETDATE())", (name.strip(),))
        self.connection.commit()
        QMessageBox.information(self, "Created", f"Pipeline '{name.strip()}' created.")
        self.load_pipeline_list()
    def delete_pipeline(self):
        pid = self.pipeline_combo.currentData()
        if not pid:
            return
        if QMessageBox.question(self, "Confirm", f"Delete pipeline ID={pid}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BRM_PIPELINE_EDGES WHERE PIPELINE_ID=?", (pid,))
        c.execute("DELETE FROM BRM_PIPELINE_NODES WHERE PIPELINE_ID=?", (pid,))
        c.execute("DELETE FROM BRM_PIPELINES WHERE PIPELINE_ID=?", (pid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Pipeline {pid} removed.")
        self.load_pipeline_list()
        self.scene.clear()
        self.pipeline_id = None
    def add_bfs_node(self):
        if not self.pipeline_id:
            QMessageBox.warning(self, "None", "No pipeline loaded.")
            return
        node_type = "BFS"
        node_label, ok = QInputDialog.getText(self, "Node Label", "Enter BFS node label:")
        if not ok or not node_label.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BRM_PIPELINE_NODES(PIPELINE_ID, NODE_TYPE, NODE_LABEL, POS_X, POS_Y) OUTPUT INSERTED.NODE_ID VALUES(?,?,?,?,?)",
                  (self.pipeline_id, node_type, node_label, 100, 100))
        nid = c.fetchone()[0]
        self.connection.commit()
        item = PipelineNodeItem(nid, node_type, node_label)
        item.setPos(100, 100)
        self.scene.addItem(item)
    def run_pipeline(self):
        QMessageBox.information(self, "Pipeline", "Pipeline run initiated. (Stub)")

# =======================
# Module: brm_custom_rule_groups_and_alerts.py
# =======================
class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
        self.refresh_all()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)
        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)
        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)
        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)
        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)
        self.splitter = QtWidgets.QSplitter(Qt.Horizontal)
        layout.addWidget(self.splitter)
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["CustomGroup / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        self.splitter.addWidget(self.group_tree)
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search rules by name/SQL ...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)
        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        right_layout.addStretch()
        right_widget.setLayout(right_layout)
        self.splitter.addWidget(right_widget)
        self.setLayout(layout)
    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()
    def load_group_tree(self):
        self.group_tree.clear()
        try:
            c = self.connection.cursor()
            c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID DESC")
            for (gid, gname, owner) in c.fetchall():
                group_item = QTreeWidgetItem([f"{gname} (Owner={owner})"])
                group_item.setData(0, Qt.UserRole, gid)
                group_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightgray")))
                self.group_tree.addTopLevelItem(group_item)
                c2 = self.connection.cursor()
                c2.execute("""
                    SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE, R.OPERATION_TYPE, R.LOCK_STATUS
                    FROM BRM_CUSTOM_GROUP_MEMBERS M
                    JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
                    WHERE M.CUSTOM_GROUP_ID=?
                """, (gid,))
                for (rid, rnm, isg, iscrit, optype, lck_st) in c2.fetchall():
                    rule_item = QTreeWidgetItem([f"Rule {rid}: {rnm}"])
                    rule_item.setData(0, Qt.UserRole, rid)
                    if isg == 1:
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#D5EEFF")))
                    if iscrit == 1:
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#FFD1D1")))
                    if str(optype).upper() == "DECISION_TABLE":
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#FFFFCC")))
                    if str(lck_st).upper() == "LOCKED":
                        rule_item.setToolTip(0, "Locked by another user or yourself.")
                    group_item.addChild(rule_item)
            self.group_tree.expandAll()
        except Exception as ex:
            logger.error(f"Error loading group tree: {ex}")
            QMessageBox.critical(self, "Group Tree Error", str(ex))
    def load_available_rules(self):
        self.rule_list.clear()
        txt = self.rule_search_edit.text().strip()
        try:
            c = self.connection.cursor()
            if txt:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                    FROM BRM_RULES
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """, (f"%{txt}%", f"%{txt}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """)
            rows = c.fetchall()
            c2 = self.connection.cursor()
            c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
            assigned_set = {r[0] for r in c2.fetchall()}
            for (rid, rn, og) in rows:
                if rid in assigned_set:
                    continue
                item = QListWidgetItem(f"Rule {rid}: {rn} (Owner={og})")
                item.setData(Qt.UserRole, rid)
                self.rule_list.addItem(item)
        except Exception as ex:
            logger.error(f"Error loading available rules: {ex}")
            QMessageBox.critical(self, "Available Rules Error", str(ex))
    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            menu = QMenu()
            rem_act = menu.addAction("Remove Rule from Group")
            chosen = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if chosen == rem_act:
                self.remove_rule_from_group(parent.data(0, Qt.UserRole), item.data(0, Qt.UserRole))
    def remove_rule_from_group(self, group_id, rule_id):
        if self.is_rule_locked(rule_id):
            if self.user_group != "Admin":
                QMessageBox.warning(self, "Locked", "Rule is locked. Only admin can forcibly remove.")
                return
            self.force_unlock_rule(rule_id)
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?", (group_id, rule_id))
            self.connection.commit()
            QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Removal error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))
    def is_rule_locked(self, rule_id):
        c = self.connection.cursor()
        c.execute("SELECT LOCK_STATUS FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        return row and str(row[0]).upper() == "LOCKED"
    def force_unlock_rule(self, rule_id):
        c = self.connection.cursor()
        c.execute("UPDATE BRM_RULES SET LOCK_STATUS='UNLOCKED', LOCKED_BY=NULL, LOCKED_AT=NULL WHERE RULE_ID=?", (rule_id,))
        from brm_core_foundation import insert_audit_log
        insert_audit_log(self.connection, "FORCE_UNLOCK", "BRM_RULES", rule_id, "CustomGroupAdmin", {"locked": True}, {"locked": False})
        self.connection.commit()
    def create_group(self):
        gname = self.new_group_edit.text().strip()
        if not gname:
            QMessageBox.warning(self, "Error", "No group name provided.")
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP) VALUES(?, ?, ?, GETDATE())",
                  (gname, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self, "Created", f"Custom group '{gname}' created.")
        self.new_group_edit.clear()
        self.refresh_all()
    def rename_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        old_text = group_item.text(0)
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for group '{old_text}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?", (new_name.strip(), gid))
            self.connection.commit()
            QMessageBox.information(self, "Renamed", f"Group {gid} renamed to '{new_name.strip()}'.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Rename error: {ex}")
            QMessageBox.critical(self, "Rename Error", str(ex))
    def delete_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        if QMessageBox.question(self, "Confirm", f"Delete custom group {gid}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (gid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Delete group error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))
    def backup_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (gid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", "Group not found.")
            return
        gname = row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (gid,))
        assigned = [r[0] for r in c.fetchall()]
        backup_data = {"group_name": gname, "members": assigned, "backup_user": self.user_id, "ts": datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
        c.execute("SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=?", (gid,))
        rowv = c.fetchone()
        new_ver = rowv[0] if rowv else 1
        c.execute("INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON) VALUES(?, GETDATE(), ?, ?)",
                  (gid, new_ver, json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self, "Backup", f"Backup version {new_ver} created for group {gid}.")
        self.refresh_all()
    def restore_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        c.execute("SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=? ORDER BY BACKUP_VERSION DESC", (gid,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self, "None", "No backups found for that group.")
            return
        items = [f"Version {r[0]} (ts={r[1]})" for r in rows]
        selver, ok = QInputDialog.getItem(self, "Restore Backup", "Select a backup version:", items, 0, False)
        if not ok or not selver:
            return
        m = re.search(r"Version\s+(\d+)", selver)
        if not m:
            return
        ver = int(m.group(1))
        backup_json = None
        for r in rows:
            if r[0] == ver:
                backup_json = r[2]
                break
        if not backup_json:
            QMessageBox.warning(self, "Not Found", "Backup not found.")
            return
        if QMessageBox.question(self, "Confirm", f"Restore group {gid} to version {ver}?") != QMessageBox.Yes:
            return
        try:
            data = json.loads(backup_json)
            new_gname = data.get("group_name", "RestoredGroup")
            members = data.get("members", [])
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?", (new_gname, gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (gid,))
            for mid in members:
                if self.is_rule_locked(mid):
                    if self.user_group == "Admin":
                        self.force_unlock_rule(mid)
                    else:
                        continue
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?,?)", (gid, mid))
            c.execute("COMMIT")
            QMessageBox.information(self, "Restored", f"Group {gid} restored to version {ver}.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            logger.error(f"Restore error: {ex}")
            QMessageBox.critical(self, "Restore Error", str(ex))
    def assign_rules(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected in tree.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        if not gid:
            QMessageBox.warning(self, "Error", "No valid group selected.")
            return
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "None", "No rules selected on the right panel.")
            return
        c = self.connection.cursor()
        assigned_count = 0
        for item in selected_rules:
            rid = item.data(Qt.UserRole)
            if self.is_rule_locked(rid):
                if self.user_group == "Admin":
                    self.force_unlock_rule(rid)
                else:
                    continue
            try:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?,?)", (gid, rid))
                assigned_count += 1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"Assigned {assigned_count} rule(s) to group {gid}.")
        self.refresh_all()
# =======================
# Module: brm_audit_activity_tracking.py ends here
# ------------------------------

# =======================
# Part 1 ends here.
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# =======================
# Module: brm_dashboard_cards.py
# =======================

import sys
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QGridLayout, QFrame, QLabel, QPushButton, QMessageBox
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QColor

class DashboardCard(QFrame):
    def __init__(self, title, count=0, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.StyledPanel)
        self.setStyleSheet("QFrame { background-color: #F0F0F0; border-radius: 6px; }")
        layout = QVBoxLayout(self)
        self.title_label = QLabel(title)
        self.title_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        layout.addWidget(self.title_label)
        self.count_label = QLabel(str(count))
        self.count_label.setStyleSheet("font-size: 24px; font-weight: bold; color: #007ACC;")
        self.count_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.count_label)
        self.detail_button = QPushButton("View Details")
        layout.addWidget(self.detail_button)
        layout.addStretch()
    def set_count(self, value):
        self.count_label.setText(str(value))

class DashboardCardsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_metrics()
        self.start_auto_refresh()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_label = QLabel("Dashboard – Key Metrics")
        top_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(top_label)
        self.cards_layout = QGridLayout()
        layout.addLayout(self.cards_layout)
        self.card_active_rules = DashboardCard("Active Rules", 0)
        self.card_approvals = DashboardCard("Approvals Pending", 0)
        self.card_defects = DashboardCard("Open Defects", 0)
        self.card_critical = DashboardCard("Critical Rules", 0)
        self.card_schedules = DashboardCard("Schedules <24h", 0)
        self.cards_layout.addWidget(self.card_active_rules, 0, 0)
        self.cards_layout.addWidget(self.card_approvals, 0, 1)
        self.cards_layout.addWidget(self.card_defects, 1, 0)
        self.cards_layout.addWidget(self.card_critical, 1, 1)
        self.cards_layout.addWidget(self.card_schedules, 2, 0)
        self.card_active_rules.detail_button.clicked.connect(self.show_active_rules_details)
        self.card_approvals.detail_button.clicked.connect(self.show_approvals_details)
        self.card_defects.detail_button.clicked.connect(self.show_defects_details)
        self.card_critical.detail_button.clicked.connect(self.show_critical_details)
        self.card_schedules.detail_button.clicked.connect(self.show_schedules_details)
        layout.addStretch()
        self.setLayout(layout)
    def load_metrics(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE STATUS='ACTIVE'")
            self.card_active_rules.set_count(c.fetchone()[0])
        except:
            self.card_active_rules.set_count("N/A")
        try:
            c.execute("SELECT COUNT(DISTINCT RULE_ID) FROM BRM_RULE_APPROVALS WHERE APPROVED_FLAG=0")
            self.card_approvals.set_count(c.fetchone()[0])
        except:
            self.card_approvals.set_count("N/A")
        try:
            c.execute("SELECT COUNT(*) FROM BRM_DEFECT_LOGS WHERE STATUS IN ('Open','In Progress')")
            self.card_defects.set_count(c.fetchone()[0])
        except:
            self.card_defects.set_count("N/A")
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE CRITICAL_RULE=1 OR IS_GLOBAL=1")
            self.card_critical.set_count(c.fetchone()[0])
        except:
            self.card_critical.set_count("N/A")
        try:
            c.execute("""
                SELECT COUNT(*) FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled' AND SCHEDULE_TIME>=GETDATE() AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
            """)
            self.card_schedules.set_count(c.fetchone()[0])
        except:
            self.card_schedules.set_count("N/A")
    def start_auto_refresh(self, interval_ms=30000):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.load_metrics)
        self.timer.start(interval_ms)
    def show_active_rules_details(self):
        QMessageBox.information(self, "Active Rules", "Filter Business Rules tab by active status.")
    def show_approvals_details(self):
        QMessageBox.information(self, "Approvals Pending", "Switch to the Approvals tab for details.")
    def show_defects_details(self):
        QMessageBox.information(self, "Open Defects", "Open the Defect Management tab filtered by open defects.")
    def show_critical_details(self):
        QMessageBox.information(self, "Critical Rules", "Open the Business Rules or GCR Admin tab filtered by critical rules.")
    def show_schedules_details(self):
        QMessageBox.information(self, "Schedules <24h", "Open the Scheduling tab for upcoming schedules.")

# =======================
# Module: brm_live_collaboration.py
# =======================
class CollaborationManager(QtCore.QObject):
    locks_updated = QtCore.pyqtSignal(list)
    def __init__(self, connection, poll_interval_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_locks)
        self.timer.start(poll_interval_ms)
    def poll_locks(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK FROM BRM_RULE_LOCKS WHERE ACTIVE_LOCK=1")
            rows = c.fetchall()
            self.locks_updated.emit(rows)
        except Exception as ex:
            logger.error(f"Error polling locks: {ex}")

class CollaborationTab(QWidget):
    def __init__(self, connection, collab_manager, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.collab_manager = collab_manager
        self.init_ui()
        self.collab_manager.locks_updated.connect(self.update_lock_table)
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.title_label = QLabel("Live Collaboration: Who is editing rules")
        layout.addWidget(self.title_label)
        self.lock_table = QTableWidget(0, 5)
        self.lock_table.setHorizontalHeaderLabels(["RuleID", "LockedBy", "LockTimestamp", "Expiry", "ForceLock?"])
        self.lock_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.lock_table)
        btn_layout = QHBoxLayout()
        self.force_unlock_btn = QPushButton("Force Unlock Selected")
        self.force_unlock_btn.clicked.connect(self.force_unlock_selected)
        btn_layout.addWidget(self.force_unlock_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    def update_lock_table(self, lock_list):
        self.lock_table.setRowCount(0)
        for row in lock_list:
            r_i = self.lock_table.rowCount()
            self.lock_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.lock_table.setItem(r_i, col, QTableWidgetItem(str(val) if val is not None else ""))
        self.lock_table.resizeColumnsToContents()
    def get_selected_rule_id(self):
        row = self.lock_table.currentRow()
        if row < 0:
            return None
        it = self.lock_table.item(row, 0)
        return int(it.text()) if it else None
    def force_unlock_selected(self):
        rid = self.get_selected_rule_id()
        if not rid:
            QMessageBox.warning(self, "None", "No locked rule selected.")
            return
        if QMessageBox.question(self, "Confirm", f"Force unlock rule {rid}?") != QMessageBox.Yes:
            return
        try:
            from brm_rule_engine import unlock_rule_for_edit
            unlock_rule_for_edit(self.connection, rid, locked_by="AdminOverride", force=True)
            QMessageBox.information(self, "Forced", "Rule forcibly unlocked.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# =======================
# Module: brm_data_validations.py
# (Already defined in Part 1)
# =======================

# =======================
# Module: brm_enhanced_workflow_pipeline.py
# =======================
def find_downstream_impact_on_update(conn, rule_id):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    for rid, pid in rows:
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
    visited = set()
    queue = [rule_id]
    while queue:
        current = queue.pop(0)
        if current in visited:
            continue
        visited.add(current)
        if current in adjacency:
            queue.extend(adjacency[current])
    visited.discard(rule_id)
    schedules = []
    if visited:
        placeholders = ",".join("?" for _ in visited)
        c.execute(f"SELECT SCHEDULE_ID FROM RULE_SCHEDULES WHERE RULE_ID IN ({placeholders})", tuple(visited))
        schedules = [r[0] for r in c.fetchall()]
    return {"child_rules": list(visited), "schedules": schedules}

def display_impact_warning_if_any(conn, rule_id):
    impact = find_downstream_impact_on_update(conn, rule_id)
    child_count = len(impact["child_rules"])
    sched_count = len(impact["schedules"])
    if child_count == 0 and sched_count == 0:
        return True
    msg = f"Rule {rule_id} update will impact {child_count} child rule(s) and {sched_count} schedule(s). Continue?"
    return (QMessageBox.question(None, "Impact Analysis", msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes)

def fork_rule_approvals(conn, rule_id, fork_labels):
    c = conn.cursor()
    for label in fork_labels:
        c.execute("INSERT INTO BRM_RULE_FORKS(RULE_ID, FORK_LABEL, CREATED_TIMESTAMP) VALUES(?, ?, GETDATE())", (rule_id, label))
    conn.commit()

def mark_rule_fork_failed(conn, rule_id, fork_label):
    c = conn.cursor()
    c.execute("UPDATE BRM_RULE_FORKS SET FORK_STATUS='FAILED' WHERE RULE_ID=? AND FORK_LABEL=?", (rule_id, fork_label))
    conn.commit()

# =======================
# Module: brm_custom_rule_groups_and_alerts.py
# =======================
class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()
        self.refresh_all()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)
        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)
        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)
        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)
        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)
        self.splitter = QtWidgets.QSplitter(Qt.Horizontal)
        layout.addWidget(self.splitter)
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["CustomGroup / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        self.splitter.addWidget(self.group_tree)
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search rules by name/SQL ...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)
        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        right_layout.addStretch()
        right_widget.setLayout(right_layout)
        self.splitter.addWidget(right_widget)
        self.setLayout(layout)
    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()
    def load_group_tree(self):
        self.group_tree.clear()
        try:
            c = self.connection.cursor()
            c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID DESC")
            for (gid, gname, owner) in c.fetchall():
                group_item = QTreeWidgetItem([f"{gname} (Owner={owner})"])
                group_item.setData(0, Qt.UserRole, gid)
                group_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightgray")))
                self.group_tree.addTopLevelItem(group_item)
                c2 = self.connection.cursor()
                c2.execute("""
                    SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE, R.OPERATION_TYPE, R.LOCK_STATUS
                    FROM BRM_CUSTOM_GROUP_MEMBERS M
                    JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
                    WHERE M.CUSTOM_GROUP_ID=?
                """, (gid,))
                for (rid, rnm, isg, iscrit, optype, lck_st) in c2.fetchall():
                    rule_item = QTreeWidgetItem([f"Rule {rid}: {rnm}"])
                    rule_item.setData(0, Qt.UserRole, rid)
                    if isg == 1:
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#D5EEFF")))
                    if iscrit == 1:
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#FFD1D1")))
                    if str(optype).upper() == "DECISION_TABLE":
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#FFFFCC")))
                    if str(lck_st).upper() == "LOCKED":
                        rule_item.setToolTip(0, "Locked by another user or yourself.")
                    group_item.addChild(rule_item)
            self.group_tree.expandAll()
        except Exception as ex:
            logger.error(f"Error loading group tree: {ex}")
            QMessageBox.critical(self, "Group Tree Error", str(ex))
    def load_available_rules(self):
        self.rule_list.clear()
        txt = self.rule_search_edit.text().strip()
        try:
            c = self.connection.cursor()
            if txt:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                    FROM BRM_RULES
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """, (f"%{txt}%", f"%{txt}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
                """)
            rows = c.fetchall()
            c2 = self.connection.cursor()
            c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
            assigned_set = {r[0] for r in c2.fetchall()}
            for (rid, rn, og) in rows:
                if rid in assigned_set:
                    continue
                item = QListWidgetItem(f"Rule {rid}: {rn} (Owner={og})")
                item.setData(Qt.UserRole, rid)
                self.rule_list.addItem(item)
        except Exception as ex:
            logger.error(f"Error loading available rules: {ex}")
            QMessageBox.critical(self, "Available Rules Error", str(ex))
    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            menu = QMenu()
            rem_act = menu.addAction("Remove Rule from Group")
            chosen = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if chosen == rem_act:
                self.remove_rule_from_group(parent.data(0, Qt.UserRole), item.data(0, Qt.UserRole))
    def remove_rule_from_group(self, group_id, rule_id):
        if self.is_rule_locked(rule_id):
            if self.user_group != "Admin":
                QMessageBox.warning(self, "Locked", "Rule is locked. Only admin can forcibly remove.")
                return
            self.force_unlock_rule(rule_id)
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?", (group_id, rule_id))
            self.connection.commit()
            QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Removal error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))
    def is_rule_locked(self, rule_id):
        c = self.connection.cursor()
        c.execute("SELECT LOCK_STATUS FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        return row and str(row[0]).upper() == "LOCKED"
    def force_unlock_rule(self, rule_id):
        c = self.connection.cursor()
        c.execute("UPDATE BRM_RULES SET LOCK_STATUS='UNLOCKED', LOCKED_BY=NULL, LOCKED_AT=NULL WHERE RULE_ID=?", (rule_id,))
        from brm_core_foundation import insert_audit_log
        insert_audit_log(self.connection, "FORCE_UNLOCK", "BRM_RULES", rule_id, "CustomGroupAdmin", {"locked": True}, {"locked": False})
        self.connection.commit()
    def create_group(self):
        gname = self.new_group_edit.text().strip()
        if not gname:
            QMessageBox.warning(self, "Error", "No group name provided.")
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP) VALUES(?, ?, ?, GETDATE())",
                  (gname, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self, "Created", f"Custom group '{gname}' created.")
        self.new_group_edit.clear()
        self.refresh_all()
    def rename_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        old_text = group_item.text(0)
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for group '{old_text}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?", (new_name.strip(), gid))
            self.connection.commit()
            QMessageBox.information(self, "Renamed", f"Group {gid} renamed to '{new_name.strip()}'.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Error renaming: {ex}")
            QMessageBox.critical(self, "Rename Error", str(ex))
    def delete_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        if QMessageBox.question(self, "Confirm", f"Delete custom group {gid}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (gid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            logger.error(f"Delete group error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))
    def backup_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (gid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", "Group not found.")
            return
        gname = row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (gid,))
        assigned = [r[0] for r in c.fetchall()]
        backup_data = {"group_name": gname, "members": assigned, "backup_user": self.user_id, "ts": datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
        c.execute("SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=?", (gid,))
        rowv = c.fetchone()
        new_ver = rowv[0] if rowv else 1
        c.execute("INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON) VALUES(?, GETDATE(), ?, ?)", (gid, new_ver, json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self, "Backup", f"Backup version {new_ver} created for group {gid}.")
        self.refresh_all()
    def restore_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        c.execute("SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=? ORDER BY BACKUP_VERSION DESC", (gid,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self, "None", "No backups found for that group.")
            return
        items = [f"Version {r[0]} (ts={r[1]})" for r in rows]
        selver, ok = QInputDialog.getItem(self, "Restore Backup", "Select a backup version:", items, 0, False)
        if not ok or not selver:
            return
        m = re.search(r"Version\s+(\d+)", selver)
        if not m:
            return
        ver = int(m.group(1))
        backup_json = None
        for r in rows:
            if r[0] == ver:
                backup_json = r[2]
                break
        if not backup_json:
            QMessageBox.warning(self, "Not Found", "Backup not found.")
            return
        if QMessageBox.question(self, "Confirm", f"Restore group {gid} to version {ver}?") != QMessageBox.Yes:
            return
        try:
            data = json.loads(backup_json)
            new_gname = data.get("group_name", "RestoredGroup")
            members = data.get("members", [])
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?", (new_gname, gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (gid,))
            for mid in members:
                if self.is_rule_locked(mid):
                    if self.user_group == "Admin":
                        self.force_unlock_rule(mid)
                    else:
                        continue
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?,?)", (gid, mid))
            c.execute("COMMIT")
            QMessageBox.information(self, "Restored", f"Group {gid} restored to version {ver}.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            logger.error(f"Restore error: {ex}")
            QMessageBox.critical(self, "Restore Error", str(ex))
    def assign_rules(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No group selected in tree.")
            return
        group_item = sel[0]
        if group_item.parent():
            group_item = group_item.parent()
        gid = group_item.data(0, Qt.UserRole)
        if not gid:
            QMessageBox.warning(self, "Error", "No valid group selected.")
            return
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "None", "No rules selected on the right panel.")
            return
        c = self.connection.cursor()
        assigned_count = 0
        for item in selected_rules:
            rid = item.data(Qt.UserRole)
            if self.is_rule_locked(rid):
                if self.user_group == "Admin":
                    self.force_unlock_rule(rid)
                else:
                    continue
            try:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?,?)", (gid, rid))
                assigned_count += 1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"Assigned {assigned_count} rule(s) to group {gid}.")
        self.refresh_all()

# =======================
# Module: brm_activity_tracking.py ends here.
# =======================

# =======================
# Module: brm_pipeline_workflow.py (from brm_enhanced_workflow_pipeline.py, theme applied)
# =======================
class PipelineNodeItem(QtWidgets.QGraphicsItem):
    def __init__(self, node_id, node_type, label):
        super().__init__()
        self.node_id = node_id
        self.node_type = node_type
        self.label = label
        self.rect = QtCore.QRectF(0, 0, 120, 60)
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | QtWidgets.QGraphicsItem.ItemIsSelectable)
    def boundingRect(self):
        return self.rect.adjusted(-2, -2, 2, 2)
    def paint(self, painter, option, widget=None):
        painter.setPen(QtGui.QPen(Qt.black, 2))
        painter.setBrush(QtGui.QBrush(QtGui.QColor("#E0E0E0")))
        painter.drawRoundedRect(self.rect, 8, 8)
        painter.drawText(self.rect, Qt.AlignCenter, f"{self.node_type}\n{self.label}")

class PipelineEdgeItem(QtWidgets.QGraphicsLineItem):
    def __init__(self, source, target, label=None):
        super().__init__()
        self.source = source
        self.target = target
        self.label = label
        self.setPen(QtGui.QPen(Qt.darkGray, 2))
        self.adjust()
    def adjust(self):
        sp = self.source.sceneBoundingRect().center()
        tp = self.target.sceneBoundingRect().center()
        self.setLine(sp.x(), sp.y(), tp.x(), tp.y())
    def paint(self, painter, option, widget=None):
        self.adjust()
        super().paint(painter, option, widget)
        if self.label:
            mid_x = (self.line().x1() + self.line().x2()) / 2
            mid_y = (self.line().y1() + self.line().y2()) / 2
            painter.setPen(QtGui.QPen(Qt.darkGray, 1))
            painter.drawText(mid_x, mid_y, self.label)

class PipelineDesignerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.pipeline_id = None
        self.init_ui()
        self.load_pipeline_list()
    def init_ui(self):
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.pipeline_combo = QComboBox()
        top_h.addWidget(QLabel("Select Pipeline:"))
        top_h.addWidget(self.pipeline_combo)
        load_btn = QPushButton("Load Pipeline")
        load_btn.clicked.connect(self.load_pipeline)
        top_h.addWidget(load_btn)
        new_btn = QPushButton("New Pipeline")
        new_btn.clicked.connect(self.create_pipeline)
        top_h.addWidget(new_btn)
        del_btn = QPushButton("Delete Pipeline")
        del_btn.clicked.connect(self.delete_pipeline)
        top_h.addWidget(del_btn)
        top_h.addStretch()
        layout.addLayout(top_h)
        self.scene = QtWidgets.QGraphicsScene(self)
        self.view = QtWidgets.QGraphicsView(self.scene)
        self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.view.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        layout.addWidget(self.view)
        bot_h = QHBoxLayout()
        node_btn = QPushButton("Add BFS Node")
        node_btn.clicked.connect(self.add_bfs_node)
        bot_h.addWidget(node_btn)
        run_btn = QPushButton("Run Pipeline")
        run_btn.clicked.connect(self.run_pipeline)
        bot_h.addWidget(run_btn)
        bot_h.addStretch()
        layout.addLayout(bot_h)
        self.setLayout(layout)
    def load_pipeline_list(self):
        self.pipeline_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT PIPELINE_ID, PIPELINE_NAME FROM BRM_PIPELINES ORDER BY PIPELINE_ID")
        for pid, pnm in c.fetchall():
            self.pipeline_combo.addItem(f"{pnm} (ID={pid})", pid)
    def load_pipeline(self):
        pid = self.pipeline_combo.currentData()
        if not pid:
            return
        self.pipeline_id = pid
        self.scene.clear()
        c = self.connection.cursor()
        c.execute("SELECT NODE_ID, NODE_TYPE, NODE_LABEL, POS_X, POS_Y FROM BRM_PIPELINE_NODES WHERE PIPELINE_ID=?", (pid,))
        node_map = {}
        for nid, ntype, nlabel, px, py in c.fetchall():
            item = PipelineNodeItem(nid, ntype, nlabel)
            item.setPos(px or 50, py or 50)
            self.scene.addItem(item)
            node_map[nid] = item
        c.execute("SELECT EDGE_ID, SOURCE_NODE_ID, TARGET_NODE_ID, CONDITION_LABEL FROM BRM_PIPELINE_EDGES WHERE PIPELINE_ID=?", (pid,))
        for eid, snid, tnid, cond in c.fetchall():
            if snid in node_map and tnid in node_map:
                edge = PipelineEdgeItem(node_map[snid], node_map[tnid], cond)
                self.scene.addItem(edge)
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.view.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)
    def create_pipeline(self):
        name, ok = QInputDialog.getText(self, "New Pipeline", "Pipeline name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BRM_PIPELINES(PIPELINE_NAME, CREATED_TIMESTAMP) VALUES(?, GETDATE())", (name.strip(),))
        self.connection.commit()
        QMessageBox.information(self, "Created", f"Pipeline '{name.strip()}' created.")
        self.load_pipeline_list()
    def delete_pipeline(self):
        pid = self.pipeline_combo.currentData()
        if not pid:
            return
        if QMessageBox.question(self, "Confirm", f"Delete pipeline ID={pid}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BRM_PIPELINE_EDGES WHERE PIPELINE_ID=?", (pid,))
        c.execute("DELETE FROM BRM_PIPELINE_NODES WHERE PIPELINE_ID=?", (pid,))
        c.execute("DELETE FROM BRM_PIPELINES WHERE PIPELINE_ID=?", (pid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Pipeline {pid} removed.")
        self.load_pipeline_list()
        self.scene.clear()
        self.pipeline_id = None
    def add_bfs_node(self):
        if not self.pipeline_id:
            QMessageBox.warning(self, "None", "No pipeline loaded.")
            return
        node_type = "BFS"
        node_label, ok = QInputDialog.getText(self, "Node Label", "Enter BFS node label:")
        if not ok or not node_label.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BRM_PIPELINE_NODES(PIPELINE_ID, NODE_TYPE, NODE_LABEL, POS_X, POS_Y) OUTPUT INSERTED.NODE_ID VALUES(?,?,?,?,?)",
                  (self.pipeline_id, node_type, node_label, 100, 100))
        nid = c.fetchone()[0]
        self.connection.commit()
        item = PipelineNodeItem(nid, node_type, node_label)
        item.setPos(100, 100)
        self.scene.addItem(item)
    def run_pipeline(self):
        QMessageBox.information(self, "Pipeline", "Pipeline run initiated. (Stub)")

def apply_modern_theme(app):
    qss = """
    QWidget { font-family: "Segoe UI", Arial; font-size: 10pt; background-color: #F0F0F0; }
    QLineEdit, QPlainTextEdit, QTextEdit, QComboBox, QTableWidget, QTreeWidget { background-color: #FFFFFF; border: 1px solid #C8C8C8; border-radius: 4px; }
    QPushButton { background-color: #007ACC; color: white; border: none; padding: 5px 12px; border-radius: 4px; }
    QPushButton:hover { background-color: #005A9E; }
    QTabWidget::pane { border: 1px solid #CCCCCC; }
    QTabBar::tab:selected { background-color: #FFFFFF; font-weight: bold; }
    """
    app.setStyleSheet(qss)

# =======================
# Module: brm_tool_main.py
# =======================
from PyQt5.QtWidgets import QApplication, QMainWindow
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool Aggregator")
        self.resize(1500, 900)
        self.connection = None
        self.user_id = None
        self.user_group = None
        self.logged_in_username = None
        self.init_db_and_login()
        self.init_ui()
    def init_db_and_login(self):
        db_dialog = DatabaseConnectionDialog()
        if db_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        conn = db_dialog.get_connection()
        if not conn:
            sys.exit(1)
        self.connection = conn
        login_dialog = LoginDialog(self.connection)
        if login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dialog.user_id
        self.user_group = login_dialog.user_group
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = c.fetchone()
        self.logged_in_username = row[0] if row else "Unknown"
    def init_ui(self):
        from brm_core_foundation import sync_metadata_improved
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        sync_act = QAction("Sync Metadata", self)
        sync_act.triggered.connect(self.sync_metadata)
        file_menu.addAction(sync_act)
        chain_sim_act = QAction("Chain BFS Simulation", self)
        chain_sim_act.triggered.connect(self.launch_chain_sim)
        file_menu.addAction(chain_sim_act)
        group_sim_act = QAction("Group BFS Simulation", self)
        group_sim_act.triggered.connect(self.launch_group_sim)
        file_menu.addAction(group_sim_act)
        tools_menu = menubar.addMenu("Tools")
        audit_act = QAction("Activity Logs", self)
        audit_act.triggered.connect(self.launch_activity_logs)
        tools_menu.addAction(audit_act)
        search_act = QAction("Search Rules", self)
        search_act.triggered.connect(self.launch_rule_search)
        tools_menu.addAction(search_act)
        help_menu = menubar.addMenu("Help")
        about_act = QAction("About", self)
        about_act.triggered.connect(self.show_about)
        help_menu.addAction(about_act)
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        if self.user_group == "Admin":
            top_h = QHBoxLayout()
            self.impersonate_combo = QComboBox()
            self.impersonate_btn = QPushButton("Switch User")
            self.impersonate_btn.clicked.connect(self.switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.impersonate_combo)
            top_h.addStretch()
            main_layout.addLayout(top_h)
            self.load_impersonation_options()
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)
        from brm_dashboard_cards import DashboardCardsTab
        self.tabs.addTab(DashboardCardsTab(self.connection), "Dashboard")
        self.tabs.addTab(BusinessRulesTab(self.connection, self.user_id, self.user_group), "Business Rules")
        from brm_advanced_approvals_and_lineage import MultiStepApprovalTab
        self.tabs.addTab(MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group), "Approvals")
        if self.user_group == "Admin":
            from brm_advanced_approvals_and_lineage import GlobalCriticalAdminTab
            self.tabs.addTab(GlobalCriticalAdminTab(self, self.connection, self.user_group), "GCR Admin")
        from brm_advanced_approvals_and_lineage import HierarchyViewTab, EnhancedLineageGraphWidget
        self.tabs.addTab(HierarchyViewTab(self.connection), "Hierarchy")
        lineage_wrapper = QWidget()
        lw_layout = QVBoxLayout(lineage_wrapper)
        lw_layout.addWidget(EnhancedLineageGraphWidget(self.connection))
        lineage_wrapper.setLayout(lw_layout)
        self.tabs.addTab(lineage_wrapper, "Lineage")
        from brm_simulation_scheduler import ScheduleManagementTab
        self.tabs.addTab(ScheduleManagementTab(self.connection), "Scheduling")
        from brm_defect_management import DefectManagementTab
        self.tabs.addTab(DefectManagementTab(self.connection), "Defects")
        from brm_metrics_and_control_management import ControlTablesTab
        self.tabs.addTab(ControlTablesTab(self.connection, self.user_group), "Control Tables")
        from brm_metrics_and_control_management import MetricsDashboardTab
        self.tabs.addTab(MetricsDashboardTab(self.connection), "Metrics")
        from brm_advanced_approvals_and_lineage import GroupManagementTab
        self.tabs.addTab(GroupManagementTab(self.connection, self.user_id, self.user_group), "Group Management")
        if self.user_group == "Admin":
            from brm_metrics_and_control_management import UserManagementTab
            self.tabs.addTab(UserManagementTab(self.connection), "User Management")
        from brm_advanced_decision_tables import AdvancedDecisionTablesTab
        self.tabs.addTab(AdvancedDecisionTablesTab(self.connection), "Decision Tables")
        from brm_performance_alerting_and_trends import PerformanceAlertingTab
        self.tabs.addTab(PerformanceAlertingTab(self.connection), "Perf Trends")
        from brm_audit_activity_tracking import ActivityTrackingTab
        self.tabs.addTab(ActivityTrackingTab(self.connection), "Activity Logs")
        from brm_data_validations import DataValidationManagerTab
        self.tabs.addTab(DataValidationManagerTab(self.connection), "Data Validations")
        from brm_contextual_inline_editing import InlineEditingTab
        self.tabs.addTab(InlineEditingTab(self.connection, self.user_id, self.user_group), "Inline Editing")
        from brm_sql_to_business_converter import SqlToBusinessConverterTab
        self.tabs.addTab(SqlToBusinessConverterTab(self.connection), "SQL→Business")
        from brm_live_collaboration import CollaborationManager, CollaborationTab
        self.collab_manager = CollaborationManager(self.connection, poll_interval_ms=5000, parent=self)
        self.tabs.addTab(CollaborationTab(self.connection, self.collab_manager), "Collaboration")
        from brm_enhanced_workflow_pipeline import PipelineDesignerTab, apply_modern_theme
        self.tabs.addTab(PipelineDesignerTab(self.connection), "Pipeline Workflow")
        from brm_custom_rule_groups_and_alerts import CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab
        self.tabs.addTab(CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group), "Custom Groups")
        self.tabs.addTab(AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group), "Alerts")
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(lambda: self.tabs.widget(2).load_approvals())
        self.approvals_timer.start(4000)
        self.sched_timer = QTimer(self)
        self.sched_timer.timeout.connect(self.check_due_schedules)
        self.sched_timer.start(60000)
        self.alerts_timer = QTimer(self)
        self.alerts_timer.timeout.connect(lambda: self.tabs.widget(11).check_alerts())
        self.alerts_timer.start(120000)
        apply_modern_theme(QApplication.instance())
        self.show()
    def load_impersonation_options(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for uid, uname, grp in c.fetchall():
            self.impersonate_combo.addItem(f"{uname} ({grp})", (uid, grp))
    def switch_user(self):
        data = self.impersonate_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid == self.user_id and new_grp == self.user_group:
            return
        self.user_id, self.user_group = new_uid, new_grp
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (new_uid,))
        row = c.fetchone()
        self.logged_in_username = row[0] if row else "Unknown"
        QMessageBox.information(self, "Switched", f"Now impersonating {self.logged_in_username} ({new_grp}).")
        self.tabs.widget(2).logged_in_username = self.logged_in_username
        self.tabs.widget(2).user_group = self.user_group
        self.tabs.widget(2).load_approvals()
        self.tabs.widget(1).set_user(self.user_id, self.user_group)
        self.tabs.widget(11).user_id = self.user_id
        self.tabs.widget(11).user_group = self.user_group
        self.tabs.widget(11).check_alerts()
        self.tabs.widget(10).load_data()
        self.tabs.widget(9).load_users()
        self.tabs.widget(12).user_id = self.user_id
        self.tabs.widget(12).user_group = self.user_group
        self.tabs.widget(13).user_id = self.user_id
        self.tabs.widget(13).user_group = self.user_group
        self.tabs.widget(14).refresh_data()
    def sync_metadata(self):
        try:
            from brm_core_foundation import sync_metadata_improved
            msg = sync_metadata_improved(self.connection)
            QMessageBox.information(self, "Sync Metadata", msg)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def launch_chain_sim(self):
        from brm_simulation_scheduler import ChainSimulationDialog
        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()
    def launch_group_sim(self):
        from brm_simulation_scheduler import GroupSimulationDialog
        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()
    def launch_activity_logs(self):
        self.tabs.setCurrentWidget(self.tabs.widget(11))
    def launch_rule_search(self):
        QMessageBox.information(self, "Rule Search", "Open advanced rule search.")
    def show_about(self):
        QMessageBox.information(self, "About", "BRM Tool Aggregator\nIntegrated modules: Business Rules, Approvals, Scheduling, Defects, Metrics, and more.")
    def check_due_schedules(self):
        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c = self.connection.cursor()
        c.execute("SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME FROM RULE_SCHEDULES WHERE STATUS='Scheduled' AND SCHEDULE_TIME<=?", (now_str,))
        for row in c.fetchall():
            pass
        self.tabs.widget(4).load_schedules()

def main():
    app = QApplication(sys.argv)
    tool = BRMTool()
    tool.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
