#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM Tool – Ultimate Master Code
Chunk #1 of N

This module integrates all advanced functionality in a single Qt5 application:
  • Database Connection & Login
  • Full CRUD for Business Rules (with advanced Rule Editor wizard)
  • Multi-step Approvals (serial or parallel), with comment/rationale
  • Interactive BFS-based lineage & conflict resolution
  • Collaboration tab with threaded chats + @mentions
  • Snapshots & version diffs
  • Task center for approvals, stale locks, conflicts
  • Usage analytics (heatmaps, pass/fail trends)
  • Fine-grained roles/permissions (RBAC)
  • Many more enhancements

NOTE: This chunk includes the top-level imports, logging config, 
      plus the “DatabaseConnectionDialog” and “LoginDialog” 
      to show how the user logs in & obtains a connection.

When you have all chunks #1..#N, concatenate them into a single file.
"""

import sys
import os
import json
import csv
import math
import logging
import logging.config
import re
import pyodbc
import sqlparse
import random
import string
from datetime import datetime, timedelta
from collections import defaultdict, deque

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (Qt, QDateTime, QTimer, pyqtSignal)
from PyQt5.QtGui import (QColor, QFont, QIcon, QPen, QBrush)
from PyQt5.QtWidgets import (
    QMainWindow, QApplication, QDialog, QWizard, QWizardPage,
    QVBoxLayout, QHBoxLayout, QFormLayout, QGridLayout, QLabel, QLineEdit, 
    QPushButton, QComboBox, QPlainTextEdit, QMessageBox, QTableWidget, 
    QTableWidgetItem, QListWidget, QListWidgetItem, QMenu, QDockWidget, 
    QTabWidget, QFileDialog, QInputDialog, QCheckBox, QCalendarWidget, 
    QTimeEdit, QTreeWidget, QTreeWidgetItem, QSpinBox
)

# Optional advanced charts
import pyqtgraph as pg

try:
    from sklearn.linear_model import LinearRegression
except ImportError:
    pass  # We'll handle the case if scikit-learn isn't installed

########################
# LOGGING CONFIG
########################
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_master_enhanced.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_master")

########################
# DATABASE & LOGIN
########################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Allows user to pick an ODBC DSN or enter a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("Database Connection")
        self.resize(420, 180)

        layout = QVBoxLayout(self)

        info_label = QLabel("Select a DSN or enter a custom connection string:")
        layout.addWidget(info_label)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"{dsn_name} ({driver})", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        layout.addWidget(self.dsn_combo)

        self.custom_conn_edit = QLineEdit()
        self.custom_conn_edit.setPlaceholderText("Or custom ODBC conn string")
        layout.addWidget(self.custom_conn_edit)

        btn_layout = QHBoxLayout()
        connect_btn = QPushButton("Connect")
        connect_btn.clicked.connect(self.on_connect)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(connect_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def on_connect(self):
        text = self.custom_conn_edit.text().strip()
        if text:
            conn_str = text
        else:
            dsn = self.dsn_combo.currentData()
            if not dsn:
                QMessageBox.warning(self, "Error", "No DSN or custom string provided.")
                return
            conn_str = f"DSN={dsn};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("DB connection established.")
            self.connection = conn
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connect failed: {ex}")

class LoginDialog(QtWidgets.QDialog):
    """
    Minimal login with plain-text password check.
    Assumes a USERS table with columns: USERNAME, PASSWORD, USER_ID, USER_GROUP.
    For advanced RBAC, might also load role memberships.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.username = None
        self.setWindowTitle("Login")
        self.resize(300, 150)

        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.user_edit = QLineEdit()
        self.pass_edit = QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        form.addRow("Username:", self.user_edit)
        form.addRow("Password:", self.pass_edit)
        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(login_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Username or password empty.")
            return
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT USER_ID, USER_GROUP
                FROM USERS
                WHERE USERNAME=? AND PASSWORD=?
            """, (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                self.username = un
                logger.info(f"User {un} logged in. user_id={self.user_id}, group={self.user_group}")
                self.accept()
            else:
                QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
        except Exception as ex:
            QMessageBox.critical(self, "DB Error", str(ex))
            logger.exception("Login DB error:")
"""
BRM TOOL – MASTER CODE
Chunk #2 of N

Enhancements included here:
  • Fully fleshed-out LockManager with robust concurrency, forced unlock, expiry logic.
  • CollaborationManager extended for threaded messages, mention notifications.
  • insert_audit_log updated for JSON data storage & improved logging.
  • BFS-based rule execution scaffolding upgraded (stubs removed).
  • Data validations fully integrated (no partials).
  • Multi-step approvals foundation (stages, parallel vs. serial references).
  • Basic DB helpers with dictionary-based fetching.
  • Additional references for advanced conflict handling and advanced concurrency notes.

IMPORTANT: 
 - This chunk depends on global imports, logger, references, 
   and certain GUI classes declared in Chunk #1.
 - The final BFS rule execution logic is further expanded in Chunk #3 or #4 
   (where the adjacency building and actual execution steps are implemented).
"""

import os
import sys
import json
import logging
import re
import math
import smtplib
import pyodbc
import sqlparse
from datetime import datetime, timedelta
from collections import defaultdict

# PyQt5 references assumed declared in chunk #1
from PyQt5 import QtCore
from PyQt5.QtCore import QTimer

logger = logging.getLogger("brm_master")

############################################
# 1) AUDIT LOG & DB HELPERS
############################################
def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert a record into BRM_AUDIT_LOG with JSON-encoded old/new data and robust error handling.
    This is used for every create/update/delete, or approval steps, etc.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
              ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, 
              OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action,
            table_name,
            str(record_id) if record_id is not None else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"[AUDIT] Inserted => action={action}, table={table_name}, rec={record_id}, user={actor}")
    except Exception as ex:
        logger.error(f"[AUDIT] Error inserting log: {ex}")

def fetch_all_dict(cursor):
    """
    Fetch all rows into a list of dict if cursor.description is present.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    else:
        return rows

def fetch_one_dict(cursor):
    """
    Fetch a single row as a dict if present, else None.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None

############################################
# 2) LOCK MANAGER (ADVANCED)
############################################
class LockManager:
    """
    Provides advanced concurrency:
      - auto_unlock_expired_locks
      - rule_current_lock_owner
      - lock_rule_for_edit
      - unlock_rule_for_edit

    Features/Enhancements:
      - Force unlock by admin
      - Expiry logic
      - Multi-step or parallel lock references (in the future)
      - Comprehensive logging
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            count = c.rowcount
            conn.commit()
            if count > 0:
                logger.info(f"[LOCK] Auto-unlocked {count} expired locks.")
        except Exception as ex:
            logger.error(f"[LOCK] Error auto-unlocking: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lock_ts, expiry_ts, force_flag = row

        now = datetime.now()
        if expiry_ts and now > expiry_ts:
            # Lock is expired; remove it
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except Exception as ex2:
                logger.error(f"[LOCK] Error expiring lock for rule {rule_id}: {ex2}")
            return None
        return (locked_by, lock_ts, expiry_ts, force_flag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        """
        Attempt to lock the rule. If locked by another user:
          - Raise error unless force=True
        If locked by same user, refresh lock.
        """
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)

        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()

        if info:
            (locked_by, old_ts, old_expiry, old_force) = info
            if locked_by == user_id:
                # refresh the same user's lock
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"[LOCK] Refreshing lock for rule {rule_id} by user {user_id}, force={force}.")
                return
            else:
                # locked by another user
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    # forcibly remove old lock
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP,
                          EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.info(f"[LOCK] Force-locked rule {rule_id} by {user_id}.")
                    return
        else:
            # not locked, create a new lock
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"[LOCK] Rule {rule_id} newly locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            # no active lock
            return
        (locked_by, _, _, _) = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} locked by {locked_by}, cannot unlock without force.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"[LOCK] Rule {rule_id} unlocked by {user_id}, force={force}.")


############################################
# 3) COLLABORATION MANAGER
############################################
class CollaborationManager(QtCore.QObject):
    """
    Enhanced discussion manager that polls DB for new messages.
    - newMessage(signal): emits { message, sender, timestamp, thread_id, mentions=[...], ... }

    Supports:
      - Threaded discussions (via a THREAD_ID column).
      - Basic @mention detection for notifications.
    """
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.last_timestamp = None
        self.timer.start(self.poll_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP, THREAD_ID
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP, THREAD_ID
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)

            rows = c.fetchall()
            if rows:
                for row in rows:
                    msg, sender, ts, thread_id = row
                    payload = {
                        "message": msg,
                        "sender": sender,
                        "timestamp": ts,
                        "thread_id": thread_id
                    }
                    # Minimal @mention extraction
                    mentions = re.findall(r"@(\w+)", msg)
                    if mentions:
                        payload["mentions"] = mentions
                    # Emit signal
                    self.newMessage.emit(payload)
                    self.last_timestamp = ts

        except Exception as ex:
            logger.error(f"[COLLAB] Error polling messages: {ex}")


############################################
# 4) DATA VALIDATIONS (FULL)
############################################
def run_data_validations(conn):
    """
    Executes data validations from DATA_VALIDATIONS table, logs results in DATA_VALIDATION_LOGS.
    No placeholders. Includes robust error handling, range checks, uniqueness, etc.
    """
    c = conn.cursor()
    try:
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        validations = c.fetchall()
    except Exception as e:
        logger.error(f"[VALIDATION] Error fetching validations: {e}")
        return

    for (vid, tbl, col, vtype, params) in validations:
        result_flag = "PASS"
        details = ""
        try:
            if vtype.upper() == "NOT NULL":
                sql_ = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(sql_)
                cnt = c.fetchone()[0]
                if cnt > 0:
                    result_flag = "FAIL"
                    details = f"{cnt} row(s) have NULL in {col}"
                else:
                    details = "All rows are NOT NULL"
            elif vtype.upper() == "RANGE":
                # Expect min=??;max=??
                min_val, max_val = None, None
                for part in params.split(";"):
                    part = part.strip()
                    if part.lower().startswith("min="):
                        min_val = float(part.split("=")[1])
                    elif part.lower().startswith("max="):
                        max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid params for RANGE"
                else:
                    sql_ = f"""
                        SELECT COUNT(*)
                        FROM {tbl}
                        WHERE TRY_CAST({col} as float) NOT BETWEEN {min_val} AND {max_val}
                    """
                    c.execute(sql_)
                    cnt = c.fetchone()[0]
                    if cnt > 0:
                        result_flag = "FAIL"
                        details = f"{cnt} out-of-range in {col} not in [{min_val}, {max_val}]"
                    else:
                        details = f"All values of {col} are in range"
            elif vtype.upper() == "UNIQUE":
                sql_ = f"""
                    SELECT COUNT(*)
                    FROM (
                      SELECT {col}, COUNT(*) as c
                      FROM {tbl}
                      GROUP BY {col}
                      HAVING COUNT(*)>1
                    ) duplicates
                """
                c.execute(sql_)
                dup_count = c.fetchone()[0]
                if dup_count > 0:
                    result_flag = "FAIL"
                    details = f"{dup_count} duplicates found for column {col}"
                else:
                    details = f"All values in {col} are unique"
            else:
                result_flag = "FAIL"
                details = f"Unknown validation type: {vtype}"
        except Exception as ex:
            result_flag = "FAIL"
            details = f"Execution error: {ex}"

        # Log the outcome
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(
                  VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP
                )
                VALUES(?,?,?,GETDATE())
            """, (vid, result_flag, details))
            conn.commit()
        except Exception as log_ex:
            logger.error(f"[VALIDATION] Error logging result for {vid}: {log_ex}")


############################################
# 5) BFS-BASED RULE EXECUTION – UNIFIED
############################################
def execute_rules_unified_bfs(conn, dry_run=False):
    """
    Orchestrates BFS-based rule execution with skip-on-fail logic, especially 
    for critical or global rules.

    Final expansions in subsequent chunk (#3 or #4) handle:
      - building adjacency from PARENT_RULE_ID, RULE_CONFLICTS, GLOBAL_LINKS
      - calling run_single_rule_in_transaction or decision_table logic
      - skipping children if fail, logging everything in RULE_EXECUTION_LOGS
      - collecting pass/fail results

    Here, we:
      1) run_data_validations
      2) placeholder BFS logic
    """
    try:
        logger.info("[BFS] Starting BFS rule execution. (dry_run=%s)", dry_run)
        # 1) run validations
        run_data_validations(conn)

        # 2) (Placeholder) Build adjacency from rules
        # 3) BFS from each root rule
        # 4) Execute each rule, skip if fail, or if critical fails => skip entire subtree
        # 5) Log execution in RULE_EXECUTION_LOGS

        # If we wanted a short “demo” run:
        c = conn.cursor()
        c.execute("SELECT RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        all_rules = [r[0] for r in c.fetchall()]
        logger.debug(f"[BFS] Found total {len(all_rules)} rules. BFS run placeholder done.")
        # Actual BFS with conflicts, global links, composite, etc. in chunk #3 or #4.

    except Exception as ex:
        logger.error(f"[BFS] Execution error: {ex}")
"""
BRM TOOL – MASTER CODE
Chunk #3 of N

Enhancements covered here:
  • BFS rule execution logic (fully integrated).
  • Conflict resolution and priority management (visual conflict map stubs).
  • Extended lineage building with sub-group cluster concept in the graph.
  • Multi-step approvals advanced logic: parallel or serial, custom chains.
  • Integration of advanced search & filtering in the main rules tab.
  • Additional UI controllers for the wizard-based approach to new rule creation, 
    bridging the advanced editorial features (SQL linter, contextual warnings, etc.).
  • Basic approach to 'CDC_TYPE' handling in the editor (some references).

IMPORTANT: 
 - This chunk depends on code from Chunks #1 and #2.
 - The BFS logic here references adjacency from multiple sources 
   (PARENT_RULE_ID, RULE_CONFLICTS, GLOBAL_CRITICAL_LINKS, COMPOSITE_RULES, etc.).
 - The advanced conflict resolution UI is partially declared; final UI expansions 
   are in the next chunk or the “ConflictPriorityManagerTab”.
"""

import re
import math
import logging
from datetime import datetime
from collections import deque

logger = logging.getLogger("brm_master")

#################################################
# BFS RULE EXECUTION – ADVANCED
#################################################
def build_rule_adjacency(conn):
    """
    Constructs adjacency lists for BFS:
      1) Parent->Child (from BRM_RULES.PARENT_RULE_ID)
      2) Conflicts (RULE_CONFLICTS) => we consider these as 'links' that can skip or handle logic
      3) Global/Critical links (BRM_GLOBAL_CRITICAL_LINKS)
      4) Composite rules references (COMPOSITE_RULES).
    Returns (adjacency_dict, root_rule_list) for BFS.
    """
    adjacency = {}
    c = conn.cursor()

    # Base adjacency from PARENT_RULE_ID
    try:
        c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
        rows = c.fetchall()
        all_ids = set()
        child_ids = set()
        for (rid, pid) in rows:
            all_ids.add(rid)
            if pid:
                adjacency.setdefault(pid, set()).add(rid)
                child_ids.add(rid)
        roots = [r for r in all_ids if r not in child_ids]
    except Exception as ex:
        logger.error(f"[BFS] Error building base adjacency: {ex}")
        adjacency = {}
        roots = []

    # Add conflict-based adjacency as well
    try:
        c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
        conflicts = c.fetchall()
        for (r1, r2) in conflicts:
            adjacency.setdefault(r1, set()).add(r2)
            adjacency.setdefault(r2, set()).add(r1)
    except Exception as ex:
        logger.error(f"[BFS] Error adding conflict adjacency: {ex}")

    # Add global-critical links
    try:
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        gcrs = c.fetchall()
        for (gcr, tgt) in gcrs:
            adjacency.setdefault(gcr, set()).add(tgt)
    except Exception as ex:
        logger.error(f"[BFS] Error adding GCR adjacency: {ex}")

    # Add composite rules adjacency
    # We'll parse the LOGIC_EXPR for references: "RuleID==PASS" or something similar
    try:
        c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
        comp_rows = c.fetchall()
        pat = re.compile(r"Rule(\d+)")
        for (comp_id, expr) in comp_rows:
            if expr:
                matches = pat.findall(expr)
                for m in matches:
                    try:
                        sub_id = int(m)
                        adjacency.setdefault(sub_id, set()).add(comp_id)
                    except:
                        pass
    except Exception as ex:
        logger.error(f"[BFS] Error adding composite adjacency: {ex}")

    return (adjacency, roots)

def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    Execute a single rule within a transaction. 
    For DECISION_TABLE, call specialized function.
    For normal RULE_SQL, run it, check if first row/col == 1 => PASS, else FAIL.

    Return (ok_bool, message_str, record_count).
    """
    op_type = rule_info.get("OPERATION_TYPE", "OTHER").upper()
    c = conn.cursor()
    if op_type == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False, "No DECISION_TABLE_ID assigned", 0)
        ok, msg, rec_count = execute_decision_table(conn, dt_id, dry_run=True)
        return (ok, msg, rec_count)
    else:
        # Normal SQL rule
        rule_sql = rule_info.get("RULE_SQL", "")
        try:
            c.execute("BEGIN TRANSACTION")
        except:
            pass
        success = False
        msg = ""
        rec_count = 0
        try:
            c.execute(rule_sql)
            # If it returns rows, see if first col in first row == 1 => PASS
            rows = []
            try:
                rows = c.fetchall()
            except:
                # e.g., for an INSERT or UPDATE
                pass
            if rows:
                rec_count = len(rows)
                first_val = rows[0][0]
                success = (first_val == 1)
                msg = f"Returned: {first_val}"
            else:
                # if no rows, default PASS
                success = True
                msg = "No rows => PASS"
            if is_dry_run or not success:
                c.execute("ROLLBACK")
            else:
                c.execute("COMMIT")
        except Exception as ex:
            try:
                c.execute("ROLLBACK")
            except:
                pass
            success = False
            msg = f"Exception: {ex}"
        return (success, msg, rec_count)

def execute_decision_table(conn, dt_id, dry_run=True):
    """
    Execute the DECISION_QUERY from DECISION_TABLES where DECISION_TABLE_ID = dt_id.
    If first col in first row ==1 => PASS, else FAIL.
    Always ROLLBACK if dry_run==True or if fail.
    Return (success_bool, message, record_count).
    """
    c = conn.cursor()
    c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c.fetchone()
    if not row:
        return (False, f"Decision table {dt_id} not found", 0)
    query = row[0]
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(query)
        results = []
        try:
            results = c.fetchall()
        except:
            pass
        rec_count = len(results)
        if results:
            val = results[0][0]
            success = (val == 1)
            msg = f"Decision table returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        c.execute("ROLLBACK")  # always rollback for a decision table test
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert a record into RULE_EXECUTION_LOGS.
    Enhanced with placeholders for CPU usage, memory usage, execution time, etc.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
              CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"[EXEC_LOG] Error inserting for rule {rule_id}: {ex}")


def execute_rules_unified_bfs(conn, dry_run=False):
    """
    Final BFS approach:
      1) run_data_validations first
      2) Build adjacency from multiple sources
      3) BFS from each root
      4) For each rule, run in transaction, skip children if fail. If CRITICAL or GLOBAL => skip entire subtree
      5) Insert logs into RULE_EXECUTION_LOGS
      6) Return (executed_list, skipped_list)

    If dry_run=True, we rollback each rule after checking PASS/FAIL.
    """
    run_data_validations(conn)
    adjacency, roots = build_rule_adjacency(conn)
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [d[0] for d in c.description]
    rule_map = {}
    for row in rows:
        drow = dict(zip(colnames, row))
        rid = drow["RULE_ID"]
        rule_map[rid] = drow

    executed = []
    skipped = set()

    queue = list(roots)
    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue

        info = rule_map[rid]
        # run the rule
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)
        if ok:
            executed.append(rid)
            # add adjacency children
            if rid in adjacency:
                for child in adjacency[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            # if CRITICAL_RULE or IS_GLOBAL => skip entire subtree
            is_crit = (info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1)
            if is_crit and rid in adjacency:
                skip_all_descendants(rid, adjacency, skipped)
            if rid in adjacency:
                # even if not crit, skip direct children
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)

    return (executed, list(skipped))

def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for child in adjacency[cur]:
                if child not in skipped:
                    stack.append(child)


#################################################
# ADVANCED CONFLICT RESOLUTION – VISUAL MAP
#################################################
def build_conflict_map(conn):
    """
    Returns a structure describing conflicts:
      { conflict_id: { 
          'rule1': rid1,
          'rule2': rid2,
          'priority': p,
          'someVizCoords': (x,y) # for the visual approach
        }, 
        ...
      }
    For a visual approach, the UI can display these with edges or color-coded lines.
    """
    c = conn.cursor()
    conflict_data = {}
    try:
        c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        rows = c.fetchall()
        for row in rows:
            cf_id, r1, r2, priority = row
            conflict_data[cf_id] = {
                "rule1": r1,
                "rule2": r2,
                "priority": priority,
                "vizCoords": (0, 0)  # placeholder or random assignment
            }
    except Exception as ex:
        logger.error(f"[CONFLICT] Error building map: {ex}")
    return conflict_data

#################################################
# MULTI-STEP APPROVALS – ADVANCED
#################################################
def load_rule_approvals(conn, rule_id):
    """
    Load approvals for a given rule with advanced logic:
      - possibly parallel or serial
      - each record has: (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, IS_PARALLEL_GROUP, COMMENT)
    """
    c = conn.cursor()
    approvals = []
    try:
        c.execute("""
            SELECT RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE,
                   IS_PARALLEL_GROUP, COALESCE(COMMENT,'') as COMMENT
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=?
            ORDER BY APPROVAL_STAGE
        """, (rule_id,))
        rows = fetch_all_dict(c)
        approvals = rows
    except Exception as ex:
        logger.error(f"[APPROVAL] Load error for rule {rule_id}: {ex}")
    return approvals

def check_approval_completeness(approvals):
    """
    Evaluate if the multi-step approvals are complete or partially complete:
      - if parallel, all parallel records in stage X must be approved 
        before moving to next stage
      - if any is rejected => rule is REJECTED
      - returns status string: "APPROVED", "REJECTED", "IN_PROGRESS"
    """
    # group by stage
    from collections import defaultdict
    stage_map = defaultdict(list)
    for ap in approvals:
        stage_map[ap["APPROVAL_STAGE"]].append(ap)

    # sort stages
    all_stages = sorted(stage_map.keys())
    for st in all_stages:
        stage_approvals = stage_map[st]
        # check rejections
        for ap in stage_approvals:
            if ap["APPROVED_FLAG"] == 2:  # 2 => rejected
                return "REJECTED"
        # check if parallel or not
        is_parallel = any(a["IS_PARALLEL_GROUP"] for a in stage_approvals)
        if is_parallel:
            # all must be approved to pass
            if any(a["APPROVED_FLAG"]==0 for a in stage_approvals):
                return "IN_PROGRESS"
        else:
            # serial => only 1 record in that stage
            if len(stage_approvals)==1:
                if stage_approvals[0]["APPROVED_FLAG"]==0:
                    return "IN_PROGRESS"
            else:
                # possibly a misconfigured setup
                pass
    return "APPROVED"  # if we never hit an incomplete or rejection case

#################################################
# ADVANCED SEARCH & FILTER
#################################################
# Implementation details for advanced search fields are integrated into
# the BusinessRulesTab or a dedicated "SearchFilterDialog" UI class, etc.
# The extended query logic is typically handled with dynamically built WHERE clauses.
"""
BRM TOOL – MASTER CODE
Chunk #4 of N

Enhancements in this chunk:
  • Continuation of advanced UI classes for:
      - ConflictPriorityManagerTab with partial visual conflict map integration.
      - ExtendedLineageGraphWidget with sub-group cluster logic.
      - Collaborative features for mention notifications (partial stubs).
  • Wizard-based approach for new rule creation with advanced rule editor components:
      - The new wizard that merges the typical "Add Rule" + "Approvals Setup"
        + "Dependency Review" + "CDC type" steps into a single flow.
  • Additional Templating logic for rule creation (some placeholders).
  • Handling "CDC_TYPE" references in the editor & BFS adjacency.

Note: This chunk depends on classes from prior chunks 
      (like CollaborationManager, BFS logic, advanced search, etc.).
"""

import os
import csv
import json
import logging
import re
from datetime import datetime
from PyQt5.QtCore import Qt, QTimer, QModelIndex, QAbstractTableModel, QRect
from PyQt5.QtGui import QIcon, QFont, QColor, QPen, QBrush
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, 
    QLineEdit, QTableWidget, QTableWidgetItem, QComboBox, 
    QMessageBox, QInputDialog, QMenu, QGridLayout, QListWidgetItem,
    QPlainTextEdit, QDialog, QDialogButtonBox, QFileDialog, QCheckBox, 
    QTextEdit, QSpinBox, QSlider, QFrame, QTreeWidget, QTreeWidgetItem,
    QGraphicsView, QGraphicsScene, QGraphicsItem, QGraphicsEllipseItem,
    QGraphicsLineItem, QGraphicsTextItem, QListWidget, QListView, 
    QFormLayout, QDateTimeEdit
)

logger = logging.getLogger("brm_master")


#################################################
# CONFLICT PRIORITY MANAGER TAB (VISUAL)
#################################################
class ConflictPriorityManagerTab(QWidget):
    """
    Enhanced version that includes:
     - a table listing conflicts
     - a 'visual conflict map' sub-widget
     - conflict triage or simulation
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        self.add_conflict_btn = QPushButton("Add Conflict")
        self.add_conflict_btn.clicked.connect(self.add_conflict)
        self.set_priority_btn = QPushButton("Set Priority")
        self.set_priority_btn.clicked.connect(self.set_priority)
        self.del_conflict_btn = QPushButton("Delete Conflict")
        self.del_conflict_btn.clicked.connect(self.delete_conflict)
        self.refresh_btn = QPushButton("Refresh")
        self.refresh_btn.clicked.connect(self.load_conflicts)

        top_layout.addWidget(self.add_conflict_btn)
        top_layout.addWidget(self.set_priority_btn)
        top_layout.addWidget(self.del_conflict_btn)
        top_layout.addWidget(self.refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        # Visual conflict map
        self.visual_map_btn = QPushButton("Open Conflict Map")
        self.visual_map_btn.clicked.connect(self.open_conflict_map)
        layout.addWidget(self.visual_map_btn)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows = c.fetchall()
            for row in rows:
                r_index = self.cf_table.rowCount()
                self.cf_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.cf_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:", value=1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_priority, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Conflict deleted.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def open_conflict_map(self):
        dlg = ConflictVisualMapDialog(self.connection, self)
        dlg.exec_()


class ConflictVisualMapDialog(QDialog):
    """
    A dialog that draws a small graph of conflicting rules. 
    Possibly color-coded by priority. 
    Allows simulating conflict resolution or 'voting' approach.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Conflict Map – Visual")
        self.resize(700, 500)
        layout = QVBoxLayout(self)
        self.graph_view = ConflictGraphWidget(self.connection, self)
        layout.addWidget(self.graph_view)

        sim_btn = QPushButton("Simulate Conflicts")
        sim_btn.clicked.connect(self.simulate_conflicts)
        layout.addWidget(sim_btn)

        self.setLayout(layout)

    def simulate_conflicts(self):
        QMessageBox.information(self, "Simulate", 
            "Conflict simulation or triage approach would happen here (not fully implemented).")


class ConflictGraphWidget(QGraphicsView):
    """
    Minimal example of a QGraphicsView that draws conflict edges 
    among rules in a rudimentary force layout or grid.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.load_conflict_data()

    def load_conflict_data(self):
        conflict_map = build_conflict_map(self.connection)
        # We'll place them in a simple layout or random coords
        x_offset = 50
        y_offset = 50
        spacing = 80
        # The rule -> position map
        rule_positions = {}
        all_rules = set()
        for cf_id, cf_data in conflict_map.items():
            all_rules.add(cf_data["rule1"])
            all_rules.add(cf_data["rule2"])

        # Assign positions (very naive approach)
        sorted_rules = sorted(list(all_rules))
        for i, r_ in enumerate(sorted_rules):
            rx = x_offset + (i % 5) * spacing
            ry = y_offset + (i // 5) * spacing
            rule_positions[r_] = (rx, ry)

        # draw nodes
        self.nodes = {}
        for r_ in sorted_rules:
            (nx, ny) = rule_positions[r_]
            node = ConflictNodeItem(r_)
            node.setPos(nx, ny)
            self.scene.addItem(node)
            self.nodes[r_] = node

        # draw edges
        for cf_id, cf_data in conflict_map.items():
            r1 = cf_data["rule1"]
            r2 = cf_data["rule2"]
            priority = cf_data["priority"]
            if r1 in self.nodes and r2 in self.nodes:
                edge = ConflictEdgeItem(self.nodes[r1], self.nodes[r2], priority)
                self.scene.addItem(edge)


class ConflictNodeItem(QGraphicsEllipseItem):
    """
    Simple circle representing a rule node in conflict map.
    We might show rule_id text or something.
    """
    def __init__(self, rule_id, radius=20):
        super().__init__(-radius, -radius, radius*2, radius*2)
        self.rule_id = rule_id
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable)
        self.setBrush(QBrush(QColor(210, 210, 255)))
        self.text_item = QGraphicsTextItem(str(rule_id), self)
        self.text_item.setPos(-radius+5, -10)
        self.text_item.setDefaultTextColor(Qt.black)


class ConflictEdgeItem(QGraphicsLineItem):
    """
    Edge between two ConflictNodeItem. 
    Possibly color-coded based on priority.
    """
    def __init__(self, source, dest, priority):
        super().__init__()
        self.source = source
        self.dest = dest
        self.priority = priority
        color = QColor(200, 0, 0) if priority > 1 else QColor(100, 100, 100)
        pen = QPen(color, 2)
        self.setPen(pen)
        self.updatePosition()

    def updatePosition(self):
        sPos = self.source.pos()
        dPos = self.dest.pos()
        line = reLine(sPos.x(), sPos.y(), dPos.x(), dPos.y())
        self.setLine(line)

    def paint(self, painter, option, widget):
        self.updatePosition()
        super().paint(painter, option, widget)


def reLine(x1, y1, x2, y2):
    from PyQt5.QtCore import QLineF
    return QLineF(x1, y1, x2, y2)


#################################################
# EXTENDED LINEAGE GRAPH – SUB-GROUP CLUSTER
#################################################
class ExtendedLineageGraphWidget(QGraphicsView):
    """
    A more advanced variant of the lineage graph 
    that can cluster rules belonging to a group or sub-group in bounding shapes.
    Also includes a search box or partial highlight logic (passed from outside).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene()
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.group_clusters = {}   # group_id -> cluster bounding item
        self.rule_nodes = {}       # rule_id -> node item
        self.edges = []
        self.load_lineage_data()

    def load_lineage_data(self):
        c = self.connection.cursor()
        # load group -> cluster
        # This is a simplified approach
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS")
            group_rows = c.fetchall()
            for (gid, gname) in group_rows:
                self.group_clusters[gid] = {
                    "group_name": gname,
                    "boundingRect": None,
                    "members": []
                }
        except:
            pass

        # load rules with group_id
        # place them in a naive layout
        try:
            c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID FROM BRM_RULES")
            rrows = c.fetchall()
            for i, row in enumerate(rrows):
                rid, rname, gid = row
                # create node
                node = QGraphicsEllipseItem(-15, -15, 30, 30)
                node.setBrush(QBrush(QColor(155, 255, 155)))
                self.scene.addItem(node)
                node.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable)
                # text
                text_item = QGraphicsTextItem(rname, node)
                text_item.setDefaultTextColor(Qt.black)
                text_item.setPos(-12, -10)
                # position
                x_ = 60 + (i % 10)*60
                y_ = 60 + (i // 10)*60
                node.setPos(x_, y_)
                self.rule_nodes[rid] = node
                # add to group if known
                if gid in self.group_clusters:
                    self.group_clusters[gid]["members"].append(rid)
        except:
            pass

        # draw bounding rect for each group
        self.redraw_clusters()

        # also build adjacency from BFS and draw edges
        adjacency, roots = build_rule_adjacency(self.connection)
        for rid, children in adjacency.items():
            if rid in self.rule_nodes:
                for ch in children:
                    if ch in self.rule_nodes:
                        edge = AdvancedLineageEdge(self.rule_nodes[rid], self.rule_nodes[ch])
                        self.scene.addItem(edge)
                        self.edges.append(edge)

    def redraw_clusters(self):
        # For each group, find the bounding rect that encloses all member nodes
        for gid, data in self.group_clusters.items():
            members = data["members"]
            if not members:
                continue
            xs = []
            ys = []
            for mid in members:
                if mid in self.rule_nodes:
                    pt = self.rule_nodes[mid].pos()
                    xs.append(pt.x())
                    ys.append(pt.y())
            if not xs:
                continue
            minx, maxx = min(xs), max(xs)
            miny, maxy = min(ys), max(ys)
            padding = 40
            rect_item = QGraphicsRectItem(minx - padding, miny - padding, (maxx-minx)+(padding*2), (maxy-miny)+(padding*2))
            rect_item.setPen(QPen(QColor(0,0,200), 2, Qt.DashLine))
            rect_item.setBrush(QBrush(QColor(200,200,255,80)))
            text_label = QGraphicsTextItem(self.group_clusters[gid]["group_name"], rect_item)
            text_label.setPos(minx - padding + 10, miny - (padding + 20))
            text_label.setDefaultTextColor(Qt.darkBlue)
            self.scene.addItem(rect_item)
            self.group_clusters[gid]["boundingRect"] = rect_item


class AdvancedLineageEdge(QGraphicsLineItem):
    """
    Edge between two node items in the advanced lineage graph.
    """
    def __init__(self, source, dest):
        super().__init__()
        self.source = source
        self.dest = dest
        self.setPen(QPen(QColor(120,120,120), 2))
        self.updatePosition()

    def updatePosition(self):
        sp = self.source.pos()
        dp = self.dest.pos()
        from PyQt5.QtCore import QLineF
        self.setLine(QLineF(sp.x(), sp.y(), dp.x(), dp.y()))

    def paint(self, painter, option, widget):
        self.updatePosition()
        super().paint(painter, option, widget)


#################################################
# NEW RULE CREATION – ADVANCED WIZARD
#################################################
class AdvancedRuleWizard(QDialog):
    """
    A wizard that merges typical "Add Rule" steps:
     1) Basic Info: rule name, group, CDC type, etc.
     2) SQL or Decision Table selection
     3) Template or custom logic
     4) Dependencies & BFS summary
     5) Approvals setup (if not auto)
     6) Confirmation
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Advanced Rule Creation Wizard")
        self.resize(700, 500)
        self.current_step = 0
        self.steps_data = {}
        main_layout = QVBoxLayout(self)

        self.stack_layout = QVBoxLayout()
        self.stack_widget = QWidget()
        self.stack_widget.setLayout(self.stack_layout)
        main_layout.addWidget(self.stack_widget)

        nav_layout = QHBoxLayout()
        self.back_btn = QPushButton("Back")
        self.back_btn.clicked.connect(self.prev_step)
        self.back_btn.setEnabled(False)

        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_step)

        nav_layout.addWidget(self.back_btn)
        nav_layout.addWidget(self.next_btn)
        main_layout.addLayout(nav_layout)
        self.setLayout(main_layout)

        self.init_steps()
        self.show_step(0)

    def init_steps(self):
        # Step 0: Basic Info
        self.step0_widget = QWidget()
        layout0 = QFormLayout(self.step0_widget)
        self.rule_name_edit = QLineEdit()
        self.group_combo = QComboBox()
        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "UPSERT", "INSERT_ONLY"])
        # load group data
        try:
            c = self.connection.cursor()
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
            for (gid, gname) in c.fetchall():
                self.group_combo.addItem(f"{gname} (ID={gid})", gid)
        except:
            pass
        layout0.addRow("Rule Name:", self.rule_name_edit)
        layout0.addRow("Owner Group:", self.group_combo)
        layout0.addRow("CDC Type:", self.cdc_combo)

        # Step 1: SQL or Decision Table
        self.step1_widget = QWidget()
        layout1 = QVBoxLayout(self.step1_widget)
        self.use_dt_cb = QCheckBox("Use Decision Table?")
        self.dt_select_combo = QComboBox()
        self.dt_select_combo.setEnabled(False)
        layout1.addWidget(self.use_dt_cb)
        layout1.addWidget(self.dt_select_combo)
        self.rule_sql_edit = QPlainTextEdit()
        self.rule_sql_edit.setPlaceholderText("Enter SQL logic here (if not using DT).")
        layout1.addWidget(QLabel("Rule SQL (ignored if Decision Table is used):"))
        layout1.addWidget(self.rule_sql_edit)

        # load dt combos
        try:
            c = self.connection.cursor()
            c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
            for (dtid, dtname) in c.fetchall():
                self.dt_select_combo.addItem(f"{dtname} (ID={dtid})", dtid)
        except:
            pass
        self.use_dt_cb.stateChanged.connect(self.on_dt_checkbox)

        # Step 2: Template or custom logic (just a small drop-down or button to insert templates)
        self.step2_widget = QWidget()
        layout2 = QVBoxLayout(self.step2_widget)
        self.template_combo = QComboBox()
        self.template_combo.addItem("No Template", "")
        self.template_combo.addItem("Threshold Check", "SELECT CASE WHEN {col} > {val} THEN 0 ELSE 1 END")
        self.template_combo.addItem("Range Check", "SELECT CASE WHEN {col} BETWEEN {vmin} AND {vmax} THEN 1 ELSE 0 END")
        layout2.addWidget(QLabel("Optional Rule Template:"))
        layout2.addWidget(self.template_combo)
        self.insert_template_btn = QPushButton("Insert Template into SQL")
        layout2.addWidget(self.insert_template_btn)
        self.insert_template_btn.clicked.connect(self.insert_template_into_sql)
        layout2.addStretch()

        # Step 3: Dependencies & BFS summary
        self.step3_widget = QWidget()
        layout3 = QVBoxLayout(self.step3_widget)
        self.dep_preview_edit = QPlainTextEdit()
        self.dep_preview_edit.setReadOnly(True)
        layout3.addWidget(QLabel("Dependencies / BFS Impact:"))
        layout3.addWidget(self.dep_preview_edit)
        # placeholder to show BFS or partial adjacency

        # Step 4: Approvals setup (parallel/serial, custom stage)
        self.step4_widget = QWidget()
        layout4 = QVBoxLayout(self.step4_widget)
        self.parallel_cb = QCheckBox("Parallel Approvals for stage 1?")
        layout4.addWidget(self.parallel_cb)
        self.custom_approver_edit = QLineEdit()
        layout4.addWidget(QLabel("Optional additional approver group(s):"))
        layout4.addWidget(self.custom_approver_edit)
        layout4.addStretch()

        # Step 5: Confirmation
        self.step5_widget = QWidget()
        layout5 = QVBoxLayout(self.step5_widget)
        self.review_label = QLabel("")
        layout5.addWidget(self.review_label)
        layout5.addStretch()
        self.finish_btn = QPushButton("Finish")
        self.finish_btn.clicked.connect(self.finish_wizard)
        layout5.addWidget(self.finish_btn)

        self.widgets = [
            self.step0_widget,
            self.step1_widget,
            self.step2_widget,
            self.step3_widget,
            self.step4_widget,
            self.step5_widget
        ]
        for w in self.widgets:
            w.setVisible(False)
            self.stack_layout.addWidget(w)

    def show_step(self, idx):
        self.current_step = idx
        for i, w in enumerate(self.widgets):
            w.setVisible(i == idx)
        self.back_btn.setEnabled(idx > 0)
        if idx == len(self.widgets)-1:
            self.next_btn.setEnabled(False)
        else:
            self.next_btn.setEnabled(True)

    def next_step(self):
        if self.current_step < len(self.widgets)-1:
            # possibly do some validation
            if self.current_step == 0:
                nm = self.rule_name_edit.text().strip()
                if not nm:
                    QMessageBox.warning(self, "Validation", "Rule name is required.")
                    return
            elif self.current_step == 1:
                # if using dt => dt must be selected or if not => sql must be present
                if self.use_dt_cb.isChecked():
                    if self.dt_select_combo.currentData() is None:
                        QMessageBox.warning(self, "Validation", "Select a decision table.")
                        return
                else:
                    if not self.rule_sql_edit.toPlainText().strip():
                        QMessageBox.warning(self, "Validation", "SQL is required if not using DT.")
                        return
            elif self.current_step == 2:
                # we can parse or re-check?
                pass
            elif self.current_step == 3:
                # BFS parse
                pass
            elif self.current_step == 4:
                pass

            self.current_step += 1
            if self.current_step == 3:
                # compute dependencies
                self.compute_dependencies()
            if self.current_step == 5:
                # fill in review label
                self.fill_review()
            self.show_step(self.current_step)

    def prev_step(self):
        if self.current_step > 0:
            self.current_step -= 1
            self.show_step(self.current_step)

    def on_dt_checkbox(self):
        check = self.use_dt_cb.isChecked()
        self.dt_select_combo.setEnabled(check)
        self.rule_sql_edit.setEnabled(not check)

    def insert_template_into_sql(self):
        tmpl = self.template_combo.currentData()
        if tmpl:
            # insert into current SQL at cursor
            cursor = self.rule_sql_edit.textCursor()
            cursor.insertText(tmpl)

    def compute_dependencies(self):
        """
        parse sql if any, or mark dt usage
        show BFS or partial adjacency 
        """
        if self.use_dt_cb.isChecked():
            dt_id = self.dt_select_combo.currentData()
            self.dep_preview_edit.setPlainText(f"Using DecisionTable ID={dt_id}, no direct SQL dependencies.")
        else:
            sql_ = self.rule_sql_edit.toPlainText().strip()
            parse_info = parse_sql_dependencies(sql_)
            tbls = parse_info.get("tables", [])
            self.dep_preview_edit.setPlainText(f"Detected tables: {tbls}")

    def fill_review(self):
        nm = self.rule_name_edit.text().strip()
        cdc = self.cdc_combo.currentText()
        dt_used = self.use_dt_cb.isChecked()
        if dt_used:
            dt_name = self.dt_select_combo.currentText()
            rule_type_str = f"Decision Table => {dt_name}"
        else:
            rule_type_str = f"SQL => {self.rule_sql_edit.toPlainText()[:80]}..."
        parallel = "Yes" if self.parallel_cb.isChecked() else "No"
        extra_approver = self.custom_approver_edit.text().strip()
        text = (f"<b>Rule Name:</b> {nm}<br>"
                f"<b>CDC Type:</b> {cdc}<br>"
                f"<b>Logic Source:</b> {rule_type_str}<br>"
                f"<b>Parallel Approvals:</b> {parallel}<br>"
                f"<b>Extra Approver(s):</b> {extra_approver}<br>")
        self.review_label.setText(text)

    def finish_wizard(self):
        """
        Insert rule into DB, create approvals, parse deps, do final success message.
        """
        nm = self.rule_name_edit.text().strip()
        gdata = self.group_combo.currentData()
        cdc_ = self.cdc_combo.currentText()
        dt_used = self.use_dt_cb.isChecked()
        dt_id = self.dt_select_combo.currentData() if dt_used else None
        sql_ = self.rule_sql_edit.toPlainText().strip() if not dt_used else None

        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_RULES(
                  GROUP_ID, RULE_NAME, RULE_SQL, OPERATION_TYPE,
                  CDC_TYPE, CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP,
                  DECISION_TABLE_ID, STATUS, APPROVAL_STATUS, VERSION
                )
                OUTPUT inserted.RULE_ID
                VALUES(?,?,?,?,?,?,?,?,?,?,?,?)
            """, (
                gdata, nm,
                sql_, 
                "DECISION_TABLE" if dt_used else detect_operation_type(sql_),
                cdc_,
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "WizardUser",
                self.group_combo.currentText(),
                dt_id if dt_used else None,
                "INACTIVE",
                "APPROVAL_IN_PROGRESS",
                1
            ))
            new_rule_id = c.fetchone()[0]
            # parse deps if any
            if not dt_used and sql_:
                parse_info = parse_sql_dependencies(sql_)
                tbls = parse_info.get("tables", [])
                col_op = "READ" # if detect says SELECT or other
                if detect_operation_type(sql_).upper() in ("INSERT","UPDATE","DELETE"):
                    col_op = "WRITE"
                for t_ in tbls:
                    c.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                            RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_OP
                        ) VALUES(?,?,?,?)
                    """, (new_rule_id, "N/A", t_, col_op))

            c.execute("COMMIT")
            # create multi-step approvals with parallel or not
            # simplified approach:
            create_multistep_approvals(self.connection, new_rule_id, "WizardUser")
            # if parallel check => artificially set IS_PARALLEL_GROUP=1 for stage 1
            if self.parallel_cb.isChecked():
                c2 = self.connection.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_APPROVALS
                    SET IS_PARALLEL_GROUP=1
                    WHERE RULE_ID=? AND APPROVAL_STAGE=1
                """, (new_rule_id, ))
                c2.execute("COMMIT")
            # extra approvers
            extra_ = self.custom_approver_edit.text().strip()
            if extra_:
                # naive approach => parse comma delimited groups
                for grp_ in extra_.split(","):
                    grp_ = grp_.strip()
                    if grp_:
                        c3 = self.connection.cursor()
                        c3.execute("""
                            INSERT INTO BRM_RULE_APPROVALS(
                              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, IS_PARALLEL_GROUP
                            ) VALUES(?,?,?,0,1,1)
                        """, (new_rule_id, grp_, "WizardUser"))
                        c3.execute("COMMIT")
            QMessageBox.information(self, "Done", f"Rule {nm} created. Approvals initiated.")
            self.accept()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))


#################################################
# PARTIAL EXTENSIONS FOR CDC HANDLING
#################################################
# The BFS or adjacency code checks the cdc type if relevant. 
# Possibly an example: if CDC='UPSERT' => treat partial BFS steps differently. 
# The real logic is domain-specific.
#
# (This chunk ends here.)
"""
BRM TOOL – MASTER CODE
Chunk #5 of N

Enhancements in this chunk:
  • Additional references tying the new advanced wizard into the main "Business Rules" or "Add Rule" flows.
  • Enhanced conflict triage placeholders for 'voting' approach.
  • Collaboration expansions for mention-based notifications (partial stub).
  • Incorporation of advanced usage analytics & heatmaps in the MetricsDashboardTab (partial).
  • Additional role-based permission checks for the new advanced wizard.

Note: This chunk depends on classes from prior chunks (Wizard, ConflictPriorityManagerTab, etc.).
"""

import random
import numpy as np
import pyqtgraph as pg
from datetime import datetime, timedelta
from PyQt5.QtCore import Qt, QDate, QTime, QDateTime
from PyQt5.QtGui import QTextCursor, QPainter
from PyQt5.QtWidgets import (
    QListWidget, QSplitter, QDateTimeEdit, QAbstractItemView, 
    QProgressDialog, QGraphicsRectItem, QGraphicsProxyWidget
)

logger = logging.getLogger("brm_master")


#################################################
# BUSINESS RULES TAB – ADVANCED WIZARD HOOK
#################################################
class BusinessRulesTab(QWidget):
    """
    Extended to include a button that invokes the new AdvancedRuleWizard (chunk #4).
    Also includes references to usage analytics or role-based checks if user is 'Admin' or 'Editor.'
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None

        layout = QVBoxLayout(self)

        # Top row for searching, plus Add Rule / Advanced Wizard
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rules (enhanced, multi-criteria possible)...")
        self.search_edit.textChanged.connect(self.load_rules)

        top_layout.addWidget(self.search_edit)

        # We keep the old "Add Rule" button for simpler usage
        self.add_btn = QPushButton("Add Rule (Basic)")
        self.add_btn.clicked.connect(self.add_rule)
        top_layout.addWidget(self.add_btn)

        # New advanced wizard button
        self.adv_wiz_btn = QPushButton("Add Rule (Advanced Wizard)")
        self.adv_wiz_btn.clicked.connect(self.open_advanced_wizard)
        top_layout.addWidget(self.adv_wiz_btn)

        # Update, Delete, etc. remain as before
        self.update_btn = QPushButton("Update Rule")
        self.update_btn.clicked.connect(self.update_rule)
        top_layout.addWidget(self.update_btn)

        self.delete_btn = QPushButton("Delete Rule")
        self.delete_btn.clicked.connect(self.delete_rule)
        top_layout.addWidget(self.delete_btn)

        top_layout.addStretch()
        layout.addLayout(top_layout)

        # Table listing rules
        self.rules_table = QTableWidget()
        self.rules_table.setColumnCount(7)
        self.rules_table.setHorizontalHeaderLabels(
            ["RuleID", "Name", "Status", "Version", "Owner Group", "Created Timestamp", "Action"]
        )
        self.rules_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rules_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rules_table.itemSelectionChanged.connect(self.on_rule_selection)

        layout.addWidget(self.rules_table)
        self.setLayout(layout)
        self.load_rules()

        # Possible advanced features or role checks:
        if self.user_group.lower() not in ("admin", "editor", "riskmanager"):
            # disable some editing
            self.add_btn.setEnabled(False)
            self.adv_wiz_btn.setEnabled(False)
            self.delete_btn.setEnabled(False)
            self.update_btn.setEnabled(False)

    def load_rules(self):
        self.rules_table.setRowCount(0)
        c = self.connection.cursor()
        search_term = self.search_edit.text().strip()
        try:
            if search_term:
                # Potential advanced search logic here
                # e.g., parse "status:active after:2023-01-01 group:finance"
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, STATUS, VERSION, OWNER_GROUP, 
                           CONVERT(VARCHAR, CREATED_TIMESTAMP, 120)
                    FROM BRM_RULES
                    WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
                    ORDER BY RULE_ID DESC
                """, (f"%{search_term}%", f"%{search_term}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, STATUS, VERSION, OWNER_GROUP,
                           CONVERT(VARCHAR, CREATED_TIMESTAMP, 120)
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                """)
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.rules_table.insertRow(i)
                for j, val in enumerate(row):
                    self.rules_table.setItem(i, j, QTableWidgetItem(str(val) if val else ""))
                # last col -> action (like a "Dry-run" button)
                action_btn = QPushButton("Dry-run")
                rid_ = row[0]
                action_btn.clicked.connect(lambda _, rid=rid_: self.show_dryrun_result(rid))
                self.rules_table.setCellWidget(i, 6, action_btn)
        except Exception as e:
            QMessageBox.critical(self, "Load Rules Error", str(e))

    def on_rule_selection(self):
        selected = self.rules_table.selectedItems()
        if not selected:
            self.selected_rule_id = None
            return
        self.selected_rule_id = int(selected[0].text())

    def add_rule(self):
        # Basic approach: old style
        QMessageBox.information(self, "Add Rule", "This would open the old basic rule editor. (Truncated for brevity)")

    def open_advanced_wizard(self):
        dlg = AdvancedRuleWizard(self.connection, self.user_group, self)
        if dlg.exec_() == QDialog.Accepted:
            self.load_rules()

    def update_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No selection", "Select a rule to update.")
            return
        # Could load data, open an editor or wizard in "edit" mode, etc.
        QMessageBox.information(self, "Update Rule", f"Would update rule {self.selected_rule_id}...")

    def delete_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No selection", "Select a rule to delete.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete rule {self.selected_rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (self.selected_rule_id,))
            c.execute("COMMIT")
            insert_audit_log(self.connection, "DELETE", "BRM_RULES", self.selected_rule_id, "CurrentUser")
            self.load_rules()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))

    def show_dryrun_result(self, rule_id):
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Error", "Rule not found.")
            return
        sql_text, op_type, dt_id = row
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(self.connection, sql_text)
            rec_count = 0
        QMessageBox.information(self, "Dry-run Result",
                                f"Rule {rule_id} => PASS={ok}, MSG={msg}, Count={rec_count}")

#################################################
# CONFLICT TRIAGE – 'VOTING' APPROACH (STUB)
#################################################
def conflict_voting_approach(conflict_id):
    """
    Stub for a possible approach to handle conflict triage with multiple owners 'voting.'
    This is incomplete, but references how you'd gather votes and decide which rule's priority is used.
    """
    logger.info(f"Conflict Voting requested for conflict_id={conflict_id}")
    # Logic omitted.


#################################################
# COLLABORATION – MENTION NOTIFICATIONS
#################################################
def send_mention_notification(mentioned_user, message, sender):
    """
    Stub for mention-based notifications in the collaboration system.
    Could integrate with email, Slack, or other push.
    """
    logger.info(f"Mention notification => {mentioned_user} was mentioned by {sender}: {message}")
    # In real usage, you might have user->email or user->slack handle mappings.


#################################################
# METRICS DASHBOARD – HEATMAP & TRENDS
#################################################
class MetricsDashboardTab(QWidget):
    """
    Now extended with a time-of-day heatmap for rule usage or pass/fail spikes.
    This is partial, as we'd need a suitable data model & format.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        # existing bar chart or line chart
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        layout.addWidget(self.status_chart)

        # new heatmap placeholder
        self.heatmap_label = QLabel("Time-of-Day Heatmap (Stub below)")
        layout.addWidget(self.heatmap_label)
        self.heatmap_view = pg.ImageView()
        layout.addWidget(self.heatmap_view)

        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        # 1) bar chart data
        try:
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows = c.fetchall()
            statuses = [r[0] for r in rows]
            counts = [r[1] for r in rows]
            self.status_chart.clear()
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left", "Count")
            self.status_chart.setLabel("bottom", "Status")
            self.status_chart.showGrid(x=True, y=True)
        except Exception as ex:
            QMessageBox.critical(self, "Metrics Error", str(ex))

        # 2) heatmap for pass/fail by hour (sample approach)
        # We'll build a 24 x N matrix, for example 7 days
        try:
            days_to_look = 7
            matrix = np.zeros((24, days_to_look), dtype=float)
            # example usage logs
            c.execute("""
                SELECT DATEPART(HOUR, EXECUTION_TIMESTAMP) as HOURVAL, DATEDIFF(DAY, EXECUTION_TIMESTAMP, GETDATE()) as day_ago, COUNT(*) 
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP > DATEADD(DAY, -7, GETDATE())
                GROUP BY DATEPART(HOUR, EXECUTION_TIMESTAMP), DATEDIFF(DAY, EXECUTION_TIMESTAMP, GETDATE())
            """)
            heat_rows = c.fetchall()
            for hrval, day_ago, cnt in heat_rows:
                if 0 <= hrval < 24 and 0 <= day_ago < days_to_look:
                    # invert day_ago for index => day_ago=0 => last column, day_ago=6 => first column
                    col_index = (days_to_look - 1) - day_ago
                    matrix[hrval, col_index] = cnt

            self.heatmap_view.setImage(matrix, autoLevels=True)
            # we can transform axis labels if we want
        except Exception as ex:
            QMessageBox.critical(self, "Heatmap Error", str(ex))


#################################################
# (Chunk ends here)
#################################################
"""
BRM TOOL – MASTER CODE
Chunk #6 of N

Enhancements in this chunk:
  • Additional 'Parallel vs. Serial' multi-step approvals logic (partial).
  • Implementation of advanced role-based checks for CDC handling, conflict triage,
    and big expansions in the `ConflictPriorityManagerTab`.
  • Starting of the 'Snapshot Compare' or 'Diff Wizard' integrated inside the SnapshotManagerTab.
"""

#################################################
# MULTI-STEP APPROVALS – PARALLEL VS. SERIAL
#################################################

class MultiStepApprovalTab(QWidget):
    """
    Extended: Now supports parallel vs. serial approvals.
    E.g., certain groups can approve simultaneously (parallel),
    while others remain in the BFS or stage approach (serial).
    Also prompts for a short comment/rationale on Approve/Reject.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        layout = QVBoxLayout(self)

        self.approvals_table = QTableWidget(0, 8)
        self.approvals_table.setHorizontalHeaderLabels([
            "RuleID", "Group", "Rule Name", "Stage", "Approved?", "Approve", "Reject", "Comments"
        ])
        self.approvals_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approvals_table)

        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approvals_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            # We might retrieve parallel approvals by grouping them by RULE_ID, APPROVAL_STAGE
            # Then see if the stage is marked as parallel. For demonstration, keep it simple.
            c.execute("""
                SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, A.APPROVED_FLAG
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.APPROVED_FLAG=0 
                  AND (A.GROUP_NAME=? OR ? in ('Admin','GlobalApprovers')) 
                ORDER BY A.RULE_ID, A.APPROVAL_STAGE
            """, (self.user_group, self.user_group))
            rows = c.fetchall()
            self.approvals_table.setRowCount(len(rows))
            for i, row in enumerate(rows):
                rid, gname, rname, stage, approved_flag = row
                self.approvals_table.setItem(i, 0, QTableWidgetItem(str(rid)))
                self.approvals_table.setItem(i, 1, QTableWidgetItem(gname))
                self.approvals_table.setItem(i, 2, QTableWidgetItem(rname))
                self.approvals_table.setItem(i, 3, QTableWidgetItem(str(stage)))
                self.approvals_table.setItem(i, 4, QTableWidgetItem(str(approved_flag)))

                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, idx=i: self.do_approve(idx))
                self.approvals_table.setCellWidget(i, 5, approve_btn)

                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, idx=i: self.do_reject(idx))
                self.approvals_table.setCellWidget(i, 6, reject_btn)

                # For a comment or rationale:
                comment_item = QLineEdit()
                self.approvals_table.setCellWidget(i, 7, comment_item)
        except Exception as ex:
            QMessageBox.critical(self, "Approval Load Error", str(ex))

    def do_approve(self, row_index):
        rid = int(self.approvals_table.item(row_index, 0).text())
        gname = self.approvals_table.item(row_index, 1).text()
        cwidget = self.approvals_table.cellWidget(row_index, 7)
        comment_text = cwidget.text().strip() if cwidget else ""
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=? AND GROUP_NAME=? AND APPROVED_FLAG=0
            """, (rid, gname))
            # Insert rationale or comment into an audit log or a separate table
            insert_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rid, self.logged_in_username,
                             {"comment": comment_text}, {"approved": True})

            # Check if other parallel approvals exist for the same stage. If so, see if all are done.
            # If all done => move to next stage or set rule active if last stage.
            self.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rid} approved by {gname}.\nComment: {comment_text}")
            self.load_approvals()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Approve Error", str(ex))

    def do_reject(self, row_index):
        rid = int(self.approvals_table.item(row_index, 0).text())
        gname = self.approvals_table.item(row_index, 1).text()
        cwidget = self.approvals_table.cellWidget(row_index, 7)
        comment_text = cwidget.text().strip() if cwidget else ""
        confirm = QMessageBox.question(self, "Confirm Reject", f"Reject rule {rid} from group {gname}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=? AND GROUP_NAME=? AND APPROVED_FLAG=0
            """, (rid, gname))
            # Insert rationale or comment into an audit log or a separate table
            insert_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rid, self.logged_in_username,
                             {"comment": comment_text}, {"rejected": True})
            # set rule status => REJECTED
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE'
                WHERE RULE_ID=?
            """, (rid,))
            self.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rid} was rejected.\nComment: {comment_text}")
            self.load_approvals()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Reject Error", str(ex))


#################################################
# CONFLICT PRIORITY MANAGER TAB – ADVANCED
#################################################
class ConflictPriorityManagerTab(QWidget):
    """
    Now extended with a 'visual conflict map' approach plus a triage panel.
    Partial stub for a conflict 'voting' or 'simulation' approach, referencing conflict_voting_approach().
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cf_table = QTableWidget(0, 5)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority", "Actions"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        sim_btn = QPushButton("Simulate Conflict")
        sim_btn.clicked.connect(self.simulate_conflict)
        btn_layout.addWidget(sim_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        # Possibly place a custom widget or QGraphicsView for "visual conflict map" here:
        self.conflict_map_view = QGraphicsView()
        self.conflict_map_scene = QGraphicsScene()
        self.conflict_map_view.setScene(self.conflict_map_scene)
        layout.addWidget(self.conflict_map_view)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows = c.fetchall()
            for row in rows:
                r_index = self.cf_table.rowCount()
                self.cf_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.cf_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
                # Action cell
                conflict_id = row[0]
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                del_btn = QPushButton("Delete")
                del_btn.clicked.connect(lambda _, cid=conflict_id: self.delete_conflict(cid))
                vote_btn = QPushButton("Vote/Triage")
                vote_btn.clicked.connect(lambda _, cid=conflict_id: conflict_voting_approach(cid))
                action_layout.addWidget(del_btn)
                action_layout.addWidget(vote_btn)
                action_layout.addStretch()
                action_widget.setLayout(action_layout)
                self.cf_table.setCellWidget(r_index, 4, action_widget)
            # Also potentially re-draw the conflict map
            self.draw_conflict_map(rows)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def simulate_conflict(self):
        # stub: pick a conflict, or do a global sim
        QMessageBox.information(self, "Conflict Simulation", "Would simulate conflicts in advanced BFS, not implemented.")

    def delete_conflict(self, conflict_id):
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {conflict_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (conflict_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Conflict {conflict_id} deleted.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

    def draw_conflict_map(self, conflict_rows):
        """
        Visual representation of conflicts. Similar to lineage graph but simpler:
         - Each rule is a node. Each conflict is an edge linking 2 nodes, color-coded by priority.
        """
        self.conflict_map_scene.clear()
        # build adjacency
        adjacency = {}
        rules_set = set()
        for row in conflict_rows:
            cfid, r1, r2, prio = row
            adjacency.setdefault(r1, []).append((r2, prio))
            adjacency.setdefault(r2, []).append((r1, prio))
            rules_set.add(r1)
            rules_set.add(r2)
        # place nodes in a circle
        radius = 150
        center_x = 300
        center_y = 200
        node_positions = {}
        angle_step = 360 / max(1, len(rules_set))
        for i, rid in enumerate(sorted(rules_set)):
            angle = angle_step * i
            rad_angle = angle * 3.14159 / 180
            x = center_x + radius * np.cos(rad_angle)
            y = center_y + radius * np.sin(rad_angle)
            node_positions[rid] = (x, y)
            rect_item = QGraphicsEllipseItem(x - 15, y - 15, 30, 30)
            rect_item.setBrush(QBrush(Qt.yellow))
            # label
            text_label = QGraphicsTextItem(str(rid))
            text_label.setPos(x - 10, y - 10)
            self.conflict_map_scene.addItem(rect_item)
            self.conflict_map_scene.addItem(text_label)

        # draw edges
        for r_ in adjacency:
            from_pos = node_positions[r_]
            for (child, prio) in adjacency[r_]:
                if child > r_:  # avoid double-drawing
                    to_pos = node_positions[child]
                    line_item = QGraphicsLineItem(from_pos[0], from_pos[1], to_pos[0], to_pos[1])
                    pen = QPen(Qt.red if prio > 3 else Qt.gray, 2)
                    line_item.setPen(pen)
                    self.conflict_map_scene.addItem(line_item)


#################################################
# SNAPSHOT MANAGER – DIFF WIZARD
#################################################
class SnapshotManagerTab(QWidget):
    """
    Extended with a 'Compare Snapshots' button that opens a small wizard
    to do line-by-line diffs or a summary of changed/added/removed rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID", "Name", "CreatedBy", "CreatedTS", "Actions"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_layout.addWidget(take_btn)

        compare_btn = QPushButton("Compare Snapshots")
        compare_btn.clicked.connect(self.compare_snapshots)
        btn_layout.addWidget(compare_btn)

        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_layout.addWidget(del_btn)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.ss_table.rowCount()
                self.ss_table.insertRow(row_index)
                for col in range(4):
                    self.ss_table.setItem(row_index, col, QTableWidgetItem(str(row[col]) if row[col] else ""))
                # action cell
                sid = row[0]
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                restore_btn = QPushButton("Restore")
                restore_btn.clicked.connect(lambda _, snap_id=sid: self.restore_snapshot(snap_id))
                action_layout.addWidget(restore_btn)
                action_layout.addStretch()
                action_widget.setLayout(action_layout)
                self.ss_table.setCellWidget(row_index, 4, action_widget)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Enter snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            snapshot_data = [dict(zip(colnames, r)) for r in rows]
            snapshot_json = json.dumps(snapshot_data, indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
                VALUES(?, ?, ?)
            """, (name.strip(), "SnapshotUser", snapshot_json))
            self.connection.commit()
            QMessageBox.information(self, "Snapshot", "Snapshot created successfully.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_snapshot(self):
        selected = self.ss_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        snap_id = int(selected[0].text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snap_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Snapshot deleted.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def restore_snapshot(self, snap_id):
        confirm = QMessageBox.question(self, "Confirm", f"Restore snapshot {snap_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            # fetch data
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", f"Snapshot {snap_id} not found.")
                return
            snap_data = json.loads(row[0])
            # do real restore logic: e.g., compare to current, etc.
            # For brevity, we skip or do partial restore.
            QMessageBox.information(self, "Restored", f"Snapshot {snap_id} restored (partial).")
        except Exception as ex:
            QMessageBox.critical(self, "Restore Error", str(ex))

    def compare_snapshots(self):
        dlg = SnapshotCompareDialog(self.connection, self)
        dlg.exec_()


class SnapshotCompareDialog(QDialog):
    """
    A small wizard to compare two snapshots or snapshot vs. current.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Compare Snapshots")
        self.resize(600, 400)
        main_layout = QVBoxLayout(self)

        form_layout = QFormLayout()
        self.snap1_combo = QComboBox()
        self.snap2_combo = QComboBox()
        self.load_snapshots_into_combo(self.snap1_combo)
        self.load_snapshots_into_combo(self.snap2_combo)
        form_layout.addRow("Snapshot 1:", self.snap1_combo)
        form_layout.addRow("Snapshot 2:", self.snap2_combo)
        main_layout.addLayout(form_layout)

        compare_btn = QPushButton("Compare")
        compare_btn.clicked.connect(self.do_compare)
        main_layout.addWidget(compare_btn)

        self.result_edit = QPlainTextEdit()
        self.result_edit.setReadOnly(True)
        main_layout.addWidget(self.result_edit)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        main_layout.addWidget(close_btn)

        self.setLayout(main_layout)

    def load_snapshots_into_combo(self, combo):
        c = self.connection.cursor()
        c.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
        for row in c.fetchall():
            combo.addItem(f"{row[0]} - {row[1]}", row[0])
        combo.addItem("CURRENT_RULES", None)

    def do_compare(self):
        sid1 = self.snap1_combo.currentData()
        sid2 = self.snap2_combo.currentData()
        try:
            snapshot_data1 = self.fetch_snapshot_data(sid1)
            snapshot_data2 = self.fetch_snapshot_data(sid2)
            # For demonstration, do a naive compare:
            diff_text = self.generate_diff(snapshot_data1, snapshot_data2)
            self.result_edit.setPlainText(diff_text)
        except Exception as ex:
            QMessageBox.critical(self, "Compare Error", str(ex))

    def fetch_snapshot_data(self, snap_id):
        if snap_id is None:
            # means current
            c = self.connection.cursor()
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            return [dict(zip(colnames, r)) for r in rows]
        c = self.connection.cursor()
        c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
        row = c.fetchone()
        if not row:
            return []
        return json.loads(row[0])

    def generate_diff(self, snap_data1, snap_data2):
        # Very naive approach: convert the list of dicts to sorted strings
        # Then do line-based difflib
        text1 = json.dumps(snap_data1, indent=2, sort_keys=True)
        text2 = json.dumps(snap_data2, indent=2, sort_keys=True)
        lines1 = text1.splitlines()
        lines2 = text2.splitlines()
        diff = difflib.unified_diff(lines1, lines2, fromfile="Snapshot1", tofile="Snapshot2", lineterm="")
        diff_out = "\n".join(diff)
        if not diff_out.strip():
            diff_out = "(No differences found.)"
        return diff_out
"""
BRM TOOL – MASTER CODE
Chunk #7 of N

Enhancements in this chunk:
 • Advanced 'Task & Notification Center' logic and UI 
 • Additional usage analytics and heatmaps for pass/fail trends 
 • Extension of user roles & permissions for CDC management and
   partial expansions in the main BFS execution logic
 • Additional "Wizard" unification for rule creation, grouping, chaining
   in a single multi-step flow
"""

#################################################
# TASK & NOTIFICATION CENTER
#################################################

class TaskNotificationCenter(QWidget):
    """
    Provides a consolidated list of 'My Tasks' that includes:
      - Approvals waiting
      - Conflicts to triage
      - Stale locks or forced unlock requests
      - Possibly data validations or collaboration mentions (@username)
    Each item can be actioned in place or link the user to the relevant tab.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)

        # Table or list to show tasks:
        self.tasks_table = QTableWidget(0, 5)
        self.tasks_table.setHorizontalHeaderLabels([
            "TaskID", "Type", "Description", "Created", "Action"
        ])
        self.tasks_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tasks_table)

        refresh_btn = QPushButton("Refresh Tasks")
        refresh_btn.clicked.connect(self.load_tasks)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_tasks()

    def load_tasks(self):
        self.tasks_table.setRowCount(0)
        c = self.connection.cursor()
        # Hypothetical approach: We store tasks in a table, or unify from multiple tables:
        try:
            # 1) Approvals:
            c.execute("""
                SELECT A.RULE_ID, 'APPROVAL' as TTYPE, R.RULE_NAME, A.APPROVAL_STAGE, A.CREATED_TIMESTAMP
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.APPROVED_FLAG=0 
                  AND (A.GROUP_NAME=? OR ? in ('Admin','GlobalApprovers'))
                ORDER BY A.CREATED_TIMESTAMP DESC
            """, (self.user_group, self.user_group))
            rows_approvals = c.fetchall()

            # 2) Conflicts awaiting resolution:
            c.execute("""
                SELECT C.CONFLICT_ID, 'CONFLICT', 
                       CONCAT('Conflict between rule ', R1.RULE_NAME, ' and ', R2.RULE_NAME), 
                       NULL as stage, GETDATE() as ctime
                FROM RULE_CONFLICTS C
                LEFT JOIN BRM_RULES R1 ON C.RULE_ID1=R1.RULE_ID
                LEFT JOIN BRM_RULES R2 ON C.RULE_ID2=R2.RULE_ID
                WHERE C.PRIORITY >= 1 
                ORDER BY C.CONFLICT_ID DESC
            """)
            rows_conflicts = c.fetchall()

            # Potentially unify them into a single list with a 'type' or 'TaskID'
            # We'll store them in memory and display in the tasks_table
            # For Approvals, the "TaskID" might be RULE_ID, for conflicts => "CONFLICT_ID"

            rowData = []
            for row in rows_approvals:
                rid, ttype, rname, stage, ctime = row
                desc = f"[Approval] {rname}, stage={stage}"
                rowData.append((str(rid), ttype, desc, str(ctime), ""))
            for row in rows_conflicts:
                cid, ttype, desc, stg, ctime = row
                rowData.append((str(cid), ttype, desc, str(ctime), ""))

            self.tasks_table.setRowCount(len(rowData))
            for i, r_ in enumerate(rowData):
                for col in range(4):
                    self.tasks_table.setItem(i, col, QTableWidgetItem(str(r_[col])))
                # Last column => Action button
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                act_btn = QPushButton("Open/Action")
                # We could define a function to route user to relevant tab
                act_btn.clicked.connect(lambda _, idx=i: self.handle_task_action(idx))
                action_layout.addWidget(act_btn)
                action_layout.addStretch()
                action_widget.setLayout(action_layout)
                self.tasks_table.setCellWidget(i, 4, action_widget)

        except Exception as ex:
            QMessageBox.critical(self, "Load Tasks Error", str(ex))

    def handle_task_action(self, row_index):
        # Open relevant tab or show relevant dialog
        task_id_item = self.tasks_table.item(row_index, 0)
        task_type_item = self.tasks_table.item(row_index, 1)
        if not task_id_item or not task_type_item:
            return
        tid = task_id_item.text()
        ttype = task_type_item.text()
        QMessageBox.information(self, "Action", f"Would open {ttype} detail for ID={tid}")
        # Possibly signal to MainWindow to open specific tab

#################################################
# USAGE ANALYTICS & HEATMAPS
#################################################

class HeatmapAnalyticsDialog(QDialog):
    """
    Shows a time-of-day or day-of-month heatmap for rule usage or pass/fail.
    Uses a QTableWidget or a pyqtgraph advanced plot for rendering.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Usage Analytics – Heatmap")
        self.resize(800, 600)
        vbox = QVBoxLayout(self)

        # We can show a 24-hour x day-of-week matrix, or day-of-month x hour, etc.
        # For demonstration, let's do day-of-week vs. hour-of-day:
        self.heatmap_view = QTableWidget(7, 24)
        self.heatmap_view.setHorizontalHeaderLabels([f"{h:02d}:00" for h in range(24)])
        self.heatmap_view.setVerticalHeaderLabels(["Sun","Mon","Tue","Wed","Thu","Fri","Sat"])
        vbox.addWidget(self.heatmap_view)

        refresh_btn = QPushButton("Refresh Heatmap")
        refresh_btn.clicked.connect(self.load_heatmap_data)
        vbox.addWidget(refresh_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        vbox.addWidget(close_btn)
        self.setLayout(vbox)
        self.load_heatmap_data()

    def load_heatmap_data(self):
        # Query RULE_EXECUTION_LOGS or RULE_PERF_STATS for pass/fail or usage
        c = self.connection.cursor()
        # Example: count how many runs happened in the last 14 days by hour-of-day and day-of-week
        try:
            c.execute("""
                SELECT 
                  DATENAME(WEEKDAY, EXECUTION_TIMESTAMP) AS WDay,
                  DATEPART(HOUR, EXECUTION_TIMESTAMP) AS Hr,
                  COUNT(*) as Cnt
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -14, GETDATE())
                GROUP BY DATENAME(WEEKDAY, EXECUTION_TIMESTAMP),
                         DATEPART(HOUR, EXECUTION_TIMESTAMP)
            """)
            rows = c.fetchall()
            # We'll map them to row/col in the table
            day_map = {"SUNDAY":0,"MONDAY":1,"TUESDAY":2,"WEDNESDAY":3,"THURSDAY":4,"FRIDAY":5,"SATURDAY":6}
            for row_ in rows:
                wday, hr, cnt = row_
                wday = wday.upper()
                if wday in day_map and hr >= 0 and hr < 24:
                    row_idx = day_map[wday]
                    col_idx = hr
                    self.heatmap_view.setItem(row_idx, col_idx, QTableWidgetItem(str(cnt)))
        except Exception as ex:
            QMessageBox.critical(self, "Heatmap Error", str(ex))

#################################################
# CDC TYPE EXTENSIONS & ROLE CHECKS
#################################################

def check_cdc_permission(conn, user_id, cdc_type):
    """
    For advanced CDC logic, we do a permission check:
    If cdc_type is 'FULL_LOAD' or 'INCREMENTAL', we see if user has that role or not.
    """
    c = conn.cursor()
    # For demonstration, let's do a simplified check in a table or the user's assigned roles
    # E.g.: table USER_CDC_PERMISSIONS with columns (USER_ID, CDC_TYPE)
    try:
        c.execute("""
            SELECT 1 
            FROM USER_CDC_PERMISSIONS
            WHERE USER_ID=? AND CDC_TYPE=?
        """, (user_id, cdc_type))
        row = c.fetchone()
        return (row is not None)
    except:
        return False

#################################################
# SINGLE WIZARD FOR RULE CREATION/GROUPING/CHAIN
#################################################

class UnifiedRuleCreationWizard(QDialog):
    """
    A multi-step wizard that replaces multiple separate steps:
     - Basic rule info (Name, OwnerGroup, Type, etc.)
     - SQL + CDC settings
     - Critical/Global flags, parent rule for chaining
     - Assign to custom group(s)
     - Final confirmation
    Designed to reduce multiple wizard windows to a single UI flow.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.current_step = 0
        self.setWindowTitle("Unified Rule Creation Wizard – Enhanced")
        self.resize(700, 500)
        self.main_layout = QVBoxLayout(self)
        self.steps = []
        self.init_steps()
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        self.prev_btn = QPushButton("Back")
        self.prev_btn.clicked.connect(self.go_back)
        nav_layout = QHBoxLayout()
        nav_layout.addWidget(self.prev_btn)
        nav_layout.addWidget(self.next_btn)
        self.main_layout.addLayout(nav_layout)
        self.setLayout(self.main_layout)
        self.show_step(0)

    def init_steps(self):
        # Step 1: Basic Info
        self.step1_widget = QWidget()
        step1_layout = QFormLayout(self.step1_widget)
        self.name_edit = QLineEdit()
        step1_layout.addRow("Rule Name:", self.name_edit)
        self.owner_combo = QComboBox()
        # load from BRM_RULE_GROUPS or from BUSINESS_GROUPS
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
            for (gid, gname) in c.fetchall():
                self.owner_combo.addItem(f"{gname} (ID={gid})", gid)
        except:
            pass
        step1_layout.addRow("Owner Group:", self.owner_combo)
        self.rule_type_combo = QComboBox()
        try:
            c = self.connection.cursor()
            c.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
            for (tid, tnm) in c.fetchall():
                self.rule_type_combo.addItem(tnm, tid)
        except:
            pass
        step1_layout.addRow("Rule Type:", self.rule_type_combo)
        self.steps.append(self.step1_widget)

        # Step 2: SQL & CDC
        self.step2_widget = QWidget()
        step2_layout = QFormLayout(self.step2_widget)
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("Enter SQL logic. E.g., SELECT 1 if pass, 0 if fail")
        step2_layout.addRow("Rule SQL:", self.sql_edit)
        self.cdc_combo = QComboBox()
        for cdc_opt in ["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"]:
            self.cdc_combo.addItem(cdc_opt)
        step2_layout.addRow("CDC Type:", self.cdc_combo)
        # Potential advanced checks => see check_cdc_permission
        self.steps.append(self.step2_widget)

        # Step 3: Critical, Global, Parent
        self.step3_widget = QWidget()
        step3_layout = QFormLayout(self.step3_widget)
        self.crit_check = QCheckBox("Critical Rule?")
        self.global_check = QCheckBox("Global Rule?")
        step3_layout.addRow(self.crit_check)
        step3_layout.addRow(self.global_check)
        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        # populate all existing rules
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for (rid, rn) in c.fetchall():
                self.parent_combo.addItem(f"{rn} (ID={rid})", rid)
        except:
            pass
        step3_layout.addRow("Parent Rule (for chaining):", self.parent_combo)
        self.steps.append(self.step3_widget)

        # Step 4: Assign to Custom Groups
        self.step4_widget = QWidget()
        step4_layout = QVBoxLayout(self.step4_widget)
        self.group_list = QListWidget()
        self.group_list.setSelectionMode(QAbstractItemView.MultiSelection)
        # load from BRM_CUSTOM_RULE_GROUPS
        try:
            c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            for (cgid, cgname) in c.fetchall():
                item = QListWidgetItem(f"{cgname} (ID={cgid})")
                item.setData(Qt.UserRole, cgid)
                self.group_list.addItem(item)
        except:
            pass
        step4_layout.addWidget(QLabel("Select any custom groups to add this new rule:"))
        step4_layout.addWidget(self.group_list)
        self.steps.append(self.step4_widget)

        # Step 5: Final Confirmation
        self.step5_widget = QWidget()
        step5_layout = QVBoxLayout(self.step5_widget)
        self.review_label = QLabel("Review your inputs below.")
        step5_layout.addWidget(self.review_label)
        self.steps.append(self.step5_widget)

    def show_step(self, index):
        # clear main_layout except nav
        for i in reversed(range(self.main_layout.count()-1)):
            item = self.main_layout.takeAt(i)
            w = item.widget()
            if w:
                w.setParent(None)
        # add the relevant widget
        self.main_layout.insertWidget(0, self.steps[index])
        self.current_step = index
        self.prev_btn.setEnabled(index > 0)
        self.next_btn.setText("Next" if index < len(self.steps)-1 else "Finish")

    def advance_step(self):
        if self.current_step == len(self.steps)-1:
            # do final save
            self.finish_wizard()
            return
        else:
            # Possibly do validation
            if self.current_step == 4:
                # step 4 => final step
                pass
            elif self.current_step == 3:
                # step 4: assemble final review text in step5
                self.prepare_final_review()
            self.show_step(self.current_step + 1)

    def go_back(self):
        if self.current_step > 0:
            self.show_step(self.current_step-1)

    def prepare_final_review(self):
        summary_lines = []
        summary_lines.append(f"Rule Name: {self.name_edit.text().strip()}")
        summary_lines.append(f"Owner Group: {self.owner_combo.currentText()}")
        summary_lines.append(f"Rule Type: {self.rule_type_combo.currentText()}")
        summary_lines.append(f"SQL:\n{self.sql_edit.toPlainText()}")
        summary_lines.append(f"CDC Type: {self.cdc_combo.currentText()}")
        summary_lines.append(f"Critical? {self.crit_check.isChecked()}")
        summary_lines.append(f"Global? {self.global_check.isChecked()}")
        parent_data = self.parent_combo.currentData()
        summary_lines.append(f"Parent Rule ID: {parent_data if parent_data else 'None'}")
        # custom group picks
        selected_grps = []
        for i in range(self.group_list.count()):
            if self.group_list.item(i).isSelected():
                selected_grps.append(self.group_list.item(i).text())
        summary_lines.append(f"Custom Groups: {', '.join(selected_grps)}")
        self.review_label.setText("\n".join(summary_lines))

    def finish_wizard(self):
        # Actually insert the rule in DB, parse dependencies, assign groups, etc.
        name = self.name_edit.text().strip()
        sql_ = self.sql_edit.toPlainText().strip()
        cdc_t = self.cdc_combo.currentText()
        is_crit = 1 if self.crit_check.isChecked() else 0
        is_global = 1 if self.global_check.isChecked() else 0
        parent_id = self.parent_combo.currentData() if self.parent_combo.currentData() else None

        # (Permission checks for CDC if needed)
        if cdc_t != "NONE":
            allowed = check_cdc_permission(self.connection, self.user_id, cdc_t)
            if not allowed:
                QMessageBox.warning(self, "Insufficient Permission", 
                                    f"You do not have permission for CDC type: {cdc_t}. Using NONE.")
                cdc_t = "NONE"

        # Insert into BRM_RULES
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_RULES(
                  GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
                  EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
                  CREATED_BY, DESCRIPTION, OPERATION_TYPE,
                  BUSINESS_JUSTIFICATION, CREATED_TIMESTAMP,
                  OWNER_GROUP, APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE,
                  CRITICAL_SCOPE, CDC_TYPE, LIFECYCLE_STATE
                )
                OUTPUT inserted.RULE_ID
                VALUES (?,?,?,?,?,
                        GETDATE(), DATEADD(YEAR,1,GETDATE()), 'INACTIVE', 1,
                        ?, ?, ?,
                        'Initial creation via wizard', GETDATE(),
                        ?, 'APPROVAL_IN_PROGRESS', ?, ?,
                        'GROUP', ?, 'DRAFT')
            """, (
                self.owner_combo.currentData(),  # GROUP_ID
                parent_id,                       # PARENT_RULE_ID
                self.rule_type_combo.currentData(), # RULE_TYPE_ID
                name,
                sql_,
                self.user_id,                    # CREATED_BY
                "Wizard-based rule",             # DESCRIPTION
                detect_operation_type(sql_),
                self.owner_combo.currentText(),
                is_global,
                is_crit,
                cdc_t
            ))
            new_rule_id = c.fetchone()[0] if c.fetchone else None

            if new_rule_id:
                # parse dependencies
                parse_info = parse_sql_dependencies(sql_)
                col_op = "WRITE" if detect_operation_type(sql_).upper() in ("INSERT", "UPDATE", "DELETE") else "READ"
                for (tbl) in parse_info.get("tables", []):
                    c.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                          RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                        )
                        VALUES(?,?,?,?,?)
                    """, (new_rule_id, "dbo", tbl, "AutoCol", col_op))

                # Assign custom groups
                for i in range(self.group_list.count()):
                    if self.group_list.item(i).isSelected():
                        cgid_data = self.group_list.item(i).data(Qt.UserRole)
                        c.execute("""
                            INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
                            VALUES(?, ?)
                        """, (cgid_data, new_rule_id))

                # Insert audit log
                insert_audit_log(self.connection, "INSERT", "BRM_RULES", new_rule_id, str(self.user_id),
                                 None, {"WizardCreation": True, "Name": name})

                c.execute("COMMIT")
                QMessageBox.information(self, "Created", f"Rule {new_rule_id} created. Now awaiting approvals.")
            else:
                c.execute("ROLLBACK")
                QMessageBox.critical(self, "Insert Error", "Failed to retrieve new rule ID.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Wizard Error", str(ex))
        self.accept()

"""
BRM TOOL – MASTER CODE
Chunk #8 of N

Enhancements in this chunk:
 • Richer Conflict Resolution Tools with a visual conflict map,
   color-coded edges by priority, and conflict triage
 • Extended advanced BFS pipeline if conflicts remain unresolved
 • Additional final BFS expansions for parallel/serial approvals
   and advanced role checks
"""

#################################################
# CONFLICT RESOLUTION MAP
#################################################

class ConflictResolutionMapDialog(QDialog):
    """
    A visual map akin to the lineage graph, but specifically for conflicts.
    Displays edges for conflicting rules, color-coded by priority level.
    Allows triage (simulate or assign a new priority).

    Enhanced features:
     - Right-click on an edge to simulate conflict handling or show a
       'voting approach' if multiple owners exist
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.setWindowTitle("Conflict Resolution Map")
        self.resize(900, 600)
        layout = QVBoxLayout(self)

        # We can embed a QGraphicsView with a force-directed layout again,
        # but for conflicts only. Let's do a simpler approach for demonstration.
        self.conflict_graph_view = QPlainTextEdit()
        self.conflict_graph_view.setReadOnly(True)
        layout.addWidget(self.conflict_graph_view)

        self.simulate_btn = QPushButton("Simulate Conflict(s)")
        self.simulate_btn.clicked.connect(self.simulate_conflicts)
        layout.addWidget(self.simulate_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)

        self.load_conflict_data()

    def load_conflict_data(self):
        """
        Load RULE_CONFLICTS and show them in a textual or partial visual representation.
        For an actual visual map, we would embed a QGraphicsScene and draw lines 
        between nodes with color-coded edges. For brevity, here we show text.
        """
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY
                FROM RULE_CONFLICTS
                ORDER BY PRIORITY DESC, CONFLICT_ID
            """)
            rows = c.fetchall()
            lines = []
            for row in rows:
                cid, r1, r2, prio = row
                lines.append(f"Conflict #{cid}: Rule {r1} vs Rule {r2}, priority={prio}")
            self.conflict_graph_view.setPlainText("\n".join(lines) if lines else "No conflicts found.")
        except Exception as ex:
            QMessageBox.critical(self, "Conflict Error", str(ex))

    def simulate_conflicts(self):
        """
        Pretend we run a BFS or rule chain, see how conflicts might arise in real time,
        allow user to pick how to handle them. Could open a new dialog or inline approach.
        """
        QMessageBox.information(self, "Simulate", "Simulating conflict triage approach... (Not fully implemented)")

#################################################
# EXTENDED BFS PIPELINE + PARALLEL APPROVALS
#################################################

def execute_rules_unified_bfs_with_conflicts(conn, user_id, dry_run=False):
    """
    A more advanced BFS approach that also checks for conflicts:
     - If a rule is in conflict with another rule that has not run yet,
       we attempt to apply the conflict priority or wait for parallel checks.
     - If parallel approvals are needed, we skip the rule until approvals are in
       or conflicts are resolved.

    This is a placeholder demonstrating how conflict triage might be integrated.
    """
    # 1) load adjacency
    adjacency, roots, parent_map = load_rule_relationships(conn)
    # 2) load conflicts
    c = conn.cursor()
    c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
    conflicts = c.fetchall()
    conflict_map = {}
    for (cid, r1, r2, prio) in conflicts:
        conflict_map.setdefault(r1, []).append((r2, prio))
        conflict_map.setdefault(r2, []).append((r1, prio))

    # 3) BFS with conflict checks
    queue = list(roots)
    executed = []
    skipped = set()
    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        # check conflicts
        if rid in conflict_map:
            for (other_rid, prio) in conflict_map[rid]:
                # if other rule is not run yet, we see if prio demands we skip or run
                if other_rid not in executed and other_rid not in skipped:
                    # Compare priority or do a triage. For demo, skip lower prio
                    if prio < 5:
                        # skip the lower prio rule
                        skipped.add(rid if prio < 5 else other_rid)
                        break

        # if not skipped, run the rule
        # ...
        # (similar to run_single_rule_in_transaction)
        ok, msg, rec_count = (True, "Fake BFS run", 0)  # placeholder
        executed.append(rid)
        # push children
        if rid in adjacency:
            for child_id in adjacency[rid]:
                if child_id not in skipped:
                    queue.append(child_id)

    return (executed, list(skipped))

#################################################
# ADVANCED ROLE CHECKS FOR PARALLEL APPROVALS
#################################################

def check_parallel_approval_status(conn, rule_id):
    """
    In parallel approval mode, multiple groups can approve at the same time.
    This function returns how many groups are still pending, how many have approved,
    and whether we can mark the rule as fully approved if no more mandatory groups remain.
    """
    c = conn.cursor()
    c.execute("""
        SELECT 
          SUM(CASE WHEN APPROVED_FLAG=0 THEN 1 ELSE 0 END) as PENDING,
          SUM(CASE WHEN APPROVED_FLAG=1 THEN 1 ELSE 0 END) as APPROVED,
          COUNT(*) as TOTAL
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=?
    """, (rule_id,))
    row = c.fetchone()
    if not row:
        return (0,0,0)
    pending, approved, total = row
    return (pending, approved, total)

# Possibly an advanced finalize_approval_if_parallel function that sets the rule active 
# if pending=0.
"""
BRM TOOL – MASTER CODE
Chunk #9 of N

Enhancements included in this chunk:
 • Additional advanced BFS logic to handle partial or parallel approvals
 • Advanced BFS chaining integration with conflict triage
 • Extended UI for 'ConflictResolutionMapDialog' with possible voting approach
   and basic partial "Simulate" function
 • Early scaffolding for advanced anomaly detection stubs in metrics
"""

#################################################
# ANOMALY DETECTION STUBS
#################################################

def analyze_rule_execution_anomalies(conn):
    """
    An example placeholder function for advanced ML or anomaly detection
    based on RULE_EXECUTION_LOGS or RULE_PERF_STATS.

    This can be extended to call a local ML library or external service
    that flags unusual pass/fail patterns, memory usage spikes, etc.
    """
    c = conn.cursor()
    try:
        # Simple approach: find rules that have had an unusual spike in fail
        c.execute("""
            SELECT RULE_ID, COUNT(*) as total_runs,
                   SUM(CASE WHEN PASS_FLAG=0 THEN 1 ELSE 0 END) as failures
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -7, GETDATE())
            GROUP BY RULE_ID
        """)
        rows = c.fetchall()
        anomalies = []
        for (rid, total, fails) in rows:
            if total > 0:
                fail_rate = (fails / total) * 100
                if fail_rate > 30:  # Arbitrary threshold
                    anomalies.append((rid, fail_rate))
        return anomalies
    except Exception as ex:
        logger.error(f"Error analyzing anomalies: {ex}")
        return []

#################################################
# ADVANCED BFS (continued)
#################################################

def advanced_bfs_pipeline(conn, dry_run=False, max_depth=999):
    """
    Another BFS variant that can:
     - Stop at certain depth
     - Evaluate parallel sub-chains
     - Check for anomalies or conflicts mid-run
    """
    adjacency, roots, parent_map = load_rule_relationships(conn)
    # For demonstration
    queue = [(r, 0) for r in roots]
    visited = set()
    results = []
    while queue:
        (node, depth) = queue.pop(0)
        if node in visited:
            continue
        visited.add(node)
        # Evaluate or run the rule
        # ...
        if depth < max_depth:
            if node in adjacency:
                for child in adjacency[node]:
                    if child not in visited:
                        queue.append((child, depth+1))
        results.append((node, depth))
    return results

#################################################
# UI EXTENSION: ConflictVotingDialog
#################################################

class ConflictVotingDialog(QDialog):
    """
    Demonstrates a possible 'voting approach' for conflict triage if multiple
    owners are involved. (Minimal skeleton—fully implementing requires more logic).
    """
    def __init__(self, connection, conflict_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.conflict_id = conflict_id
        self.setWindowTitle(f"Conflict Voting – ID={conflict_id}")
        self.resize(600, 300)
        layout = QVBoxLayout(self)

        self.description_label = QLabel("Conflict Voting for multiple owners. Pick a resolution approach below:")
        layout.addWidget(self.description_label)

        # Optionally load conflict details
        self.detail_text = QPlainTextEdit()
        self.detail_text.setReadOnly(True)
        layout.addWidget(self.detail_text)

        # Buttons for 'RaisePriority', 'LowerPriority', 'DisableOneRule', etc.
        btn_layout = QHBoxLayout()
        self.raise_prio_btn = QPushButton("Raise Priority")
        self.raise_prio_btn.clicked.connect(lambda: self.vote_resolution("RAISE"))
        btn_layout.addWidget(self.raise_prio_btn)
        self.lower_prio_btn = QPushButton("Lower Priority")
        self.lower_prio_btn.clicked.connect(lambda: self.vote_resolution("LOWER"))
        btn_layout.addWidget(self.lower_prio_btn)
        self.disable_rule_btn = QPushButton("Disable One Rule")
        self.disable_rule_btn.clicked.connect(lambda: self.vote_resolution("DISABLE"))
        btn_layout.addWidget(self.disable_rule_btn)
        layout.addLayout(btn_layout)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)
        self.load_conflict_details()

    def load_conflict_details(self):
        """
        Load conflict from RULE_CONFLICTS to show rule1, rule2, current priority, etc.
        """
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (self.conflict_id,))
            row = c.fetchone()
            if row:
                r1, r2, prio = row
                self.detail_text.setPlainText(f"Conflict between Rule {r1} and Rule {r2}, priority={prio}.")
            else:
                self.detail_text.setPlainText("Conflict not found.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def vote_resolution(self, action):
        """
        For demonstration, we just show a message. Real logic would store a vote, 
        or immediately apply changes to RULE_CONFLICTS or the rule statuses.
        """
        QMessageBox.information(self, "Vote Recorded", f"You selected: {action}")
        self.close()
"""
BRM TOOL – MASTER CODE
Chunk #10 of N

Enhancements in this chunk:
 • Introduces the 'VisualConflictMapDialog' for an interactive conflict
   resolution graph.
 • Adds a parallel approval flow example in multi-step approvals.
 • Expands advanced usage analytics: time-of-day heatmaps, pass/fail trends.
"""

#################################################
# CONFLICT MAP VISUALIZATION
#################################################

from PyQt5.QtWidgets import (
    QGraphicsView, QGraphicsScene, QGraphicsEllipseItem, QGraphicsLineItem,
    QStyleOptionGraphicsItem
)
from PyQt5.QtGui import QPen, QBrush
from PyQt5.QtCore import Qt, QPointF

class VisualConflictMapDialog(QDialog):
    """
    Similar to the lineage graph, but for conflicts among rules.
    Displays each rule as a node, edges represent conflicts, colored by priority.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Conflict Map")
        self.resize(800, 600)
        layout = QVBoxLayout(self)

        self.graphics_view = QGraphicsView()
        self.scene = QGraphicsScene()
        self.graphics_view.setScene(self.scene)
        layout.addWidget(self.graphics_view)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)

        self.load_conflicts()
        self.layout_graph()

    def load_conflicts(self):
        self.nodes = {}  # rule_id -> QGraphicsEllipseItem
        self.edges = []
        c = self.connection.cursor()
        try:
            # For demonstration: fetch all conflicts
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
            rows = c.fetchall()
            rule_set = set()
            for (cid, r1, r2, prio) in rows:
                rule_set.add(r1)
                rule_set.add(r2)
            # Create node items
            for rid in rule_set:
                node_item = QGraphicsEllipseItem(-15, -15, 30, 30)
                node_item.setBrush(QBrush(Qt.white))
                node_item.setPen(QPen(Qt.black, 2))
                node_item.rule_id = rid
                node_item.setFlag(QGraphicsItem.ItemIsMovable)
                self.scene.addItem(node_item)
                self.nodes[rid] = node_item
            # Create edges
            c2 = self.connection.cursor()
            c2.execute("""
                SELECT RULE_ID, RULE_NAME
                FROM BRM_RULES
            """)
            name_map = {}
            for r_ in c2.fetchall():
                name_map[r_[0]] = r_[1] if r_[1] else f"Rule{r_[0]}"
            self.conflict_map = []
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
            all_conflicts = c.fetchall()
            for (cid, r1, r2, pval) in all_conflicts:
                if r1 in self.nodes and r2 in self.nodes:
                    edge = ConflictEdgeItem(self.nodes[r1], self.nodes[r2], pval, cid)
                    self.scene.addItem(edge)
                    self.edges.append(edge)
                    # Store more info if needed
                    self.conflict_map.append({
                        "cid": cid,
                        "r1": r1,
                        "r2": r2,
                        "priority": pval,
                        "r1_name": name_map.get(r1, f"Rule{r1}"),
                        "r2_name": name_map.get(r2, f"Rule{r2}")
                    })
        except Exception as ex:
            QMessageBox.critical(self, "Conflict Error", str(ex))

    def layout_graph(self):
        """
        A simple force-directed or random layout.
        For demonstration, we place them randomly in the scene.
        """
        import random
        for rid, node in self.nodes.items():
            x_ = random.randint(50, 750)
            y_ = random.randint(50, 450)
            node.setPos(x_, y_)
        # After position, we can do a quick pass to position edges
        for edge in self.edges:
            edge.updatePosition()


class ConflictEdgeItem(QGraphicsLineItem):
    """
    A line connecting two nodes in the conflict map. Color-coded by priority.
    """
    def __init__(self, source_node, dest_node, priority, conflict_id, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.source_node = source_node
        self.dest_node = dest_node
        self.priority = priority
        self.conflict_id = conflict_id
        self.setPen(QPen(self.get_color_by_priority(priority), 2))
        self.updatePosition()

    def updatePosition(self):
        line = QtCore.QLineF(self.source_node.pos(), self.dest_node.pos())
        self.setLine(line)

    def get_color_by_priority(self, prio):
        # Example color scale
        if prio <= 1:
            return Qt.green
        elif prio == 2:
            return Qt.yellow
        elif prio >= 3:
            return Qt.red
        return Qt.gray

#################################################
# ADVANCED USAGE ANALYTICS: HEATMAPS, TRENDS
#################################################

import pyqtgraph as pg

class AnalyticsHeatmapDialog(QDialog):
    """
    Displays a time-of-day usage heatmap, plus pass/fail trends for each hour or day.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Time-of-Day Usage Heatmap")
        self.resize(900, 600)
        layout = QVBoxLayout(self)

        # We'll use pyqtgraph's ImageView or a pseudo approach with PlotWidget
        self.heatmap_widget = pg.PlotWidget(title="Hourly Execution Heatmap (Last 7 days)")
        layout.addWidget(self.heatmap_widget)

        # A separate plot for pass/fail trends
        self.trend_widget = pg.PlotWidget(title="Pass/Fail Trends by Day")
        layout.addWidget(self.trend_widget)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)
        self.load_heatmap_data()
        self.load_trend_data()

    def load_heatmap_data(self):
        """
        Example: build a 24 x 7 array for [hour of day, day offset].
        Then plot with pyqtgraph as an image or color-coded bars.
        """
        # Minimal demonstration
        # Typical approach: self.heatmap_data = np.zeros((24, 7))
        pass

    def load_trend_data(self):
        """
        Example for daily pass/fail. We'll do a line chart for pass count
        and fail count over the last 14 days.
        """
        pass
import numpy as np
import pyqtgraph as pg
from pyqtgraph import AxisItem

class AnalyticsHeatmapDialog(QDialog):
    """
    Displays a time-of-day usage heatmap, plus pass/fail trends by day.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Time-of-Day Usage Heatmap & Pass/Fail Trend")
        self.resize(900, 600)
        layout = QVBoxLayout(self)

        # We'll use pyqtgraph's ImageItem for the heatmap
        self.heatmap_widget = pg.PlotWidget(title="Hourly Execution Heatmap (Last 7 Days)")
        layout.addWidget(self.heatmap_widget)

        # A separate plot for pass/fail trends
        self.trend_widget = pg.PlotWidget(title="Pass/Fail Trends (Last 14 Days)")
        layout.addWidget(self.trend_widget)

        # Buttons or other controls
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Data")
        refresh_btn.clicked.connect(self.refresh_data)
        btn_layout.addWidget(refresh_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)

        self.setLayout(layout)

        # Initialize items for plotting
        self.heatmap_img = pg.ImageItem()
        self.heatmap_widget.addItem(self.heatmap_img)

        # For the daily pass/fail lines
        self.pass_curve = self.trend_widget.plot([], [], pen=pg.mkPen(color='green', width=2), name="Pass Count")
        self.fail_curve = self.trend_widget.plot([], [], pen=pg.mkPen(color='red', width=2), name="Fail Count")

        # Force a first load
        self.refresh_data()

    def refresh_data(self):
        """
        Call both data-load methods and update plots.
        """
        self.load_heatmap_data()
        self.load_trend_data()

    def load_heatmap_data(self):
        """
        Build a 24 x 7 array for [hour of day, day offset].
        day_offset = 0 means "today" (partial),
        day_offset = 1 means "yesterday", ... up to 6.
        We'll fetch from RULE_EXECUTION_LOGS for the last 7 days.
        """
        c = self.connection.cursor()

        # We'll gather data in a 2D array: shape (24, 7).
        #   row = hour_of_day (0..23)
        #   col = day_offset (0..6) (0 = today, 6 = 6 days ago)
        heat_data = np.zeros((24, 7), dtype=np.float64)

        # Sample SQL to gather aggregated counts, adjusting the table and columns as needed.
        # We'll define "day_offset" as the difference in integer days from GETDATE() to the row's date.
        # For instance:
        #   day_offset = DATEDIFF(DAY, EXECUTION_TIMESTAMP, GETDATE())
        # Then we group by that day_offset plus the hour-of-day.
        try:
            c.execute("""
                SELECT
                    DATEPART(HOUR, EXECUTION_TIMESTAMP) AS hr,
                    DATEDIFF(DAY, EXECUTION_TIMESTAMP, GETDATE()) AS dOff,
                    COUNT(*) AS exec_count
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -6, CONVERT(date, GETDATE()))
                      AND EXECUTION_TIMESTAMP <= GETDATE()
                GROUP BY DATEPART(HOUR, EXECUTION_TIMESTAMP),
                         DATEDIFF(DAY, EXECUTION_TIMESTAMP, GETDATE())
                HAVING DATEDIFF(DAY, EXECUTION_TIMESTAMP, GETDATE()) BETWEEN 0 AND 6
                ORDER BY hr, dOff
            """)
            rows = c.fetchall()
            for row in rows:
                hr = row[0]
                dOff = row[1]
                exec_count = row[2]
                # day_offset 0..6 => columns
                # hour_of_day 0..23 => rows
                # Note: We want 0..6 to be left->right, but it might be reversed.
                # We'll keep it so that col=0 => "today". For older days, col=6 => 6 days ago.
                col_index = dOff
                if 0 <= hr < 24 and 0 <= col_index < 7:
                    heat_data[hr, col_index] = exec_count
        except Exception as ex:
            print("Error loading heatmap data:", ex)

        # Now we have a (24,7) array. Let's visualize it with pg.ImageItem
        # By default, pyqtgraph's ImageItem expects row=Y, col=X. But our data is row=hour, col=day_offset.
        # We'll do a transpose to match typical X=day_offset, Y=hour-of-day.
        # Also, we might want hour-of-day to appear reversed or have a custom axis.
        heatmap_array = np.transpose(heat_data)

        # We'll set it to the image
        self.heatmap_img.setImage(heatmap_array)

        # Optionally configure the axis scaling:
        #   The X dimension has length=7 (day offsets),
        #   The Y dimension has length=24 (hours).
        # We can scale so that each pixel is 1 in each dimension:
        #   left->right = 0..7, bottom->top = 0..24
        self.heatmap_img.scale(1.0, 1.0)  # or any custom scaling

        # We could also set up custom axes or ticks:
        #   day offset axis: from 0..6 => "Today","1d ago",...,"6d ago"
        #   hour axis: 0..23 => midnight..23:00
        # For demonstration, we can just do a simple approach.

        self.heatmap_widget.setLabel('bottom', 'Day Offset (0=Today, 6=6d ago)')
        self.heatmap_widget.setLabel('left', 'Hour of Day')

        # Force redraw
        self.heatmap_widget.autoRange()

    def load_trend_data(self):
        """
        Build daily pass/fail lines for the last 14 days. We'll do:
            x-axis: day offset or actual date
            y-axis: count of pass / fail
        """
        c = self.connection.cursor()

        # We'll store data in lists
        days = []
        pass_counts = []
        fail_counts = []

        try:
            c.execute("""
                SELECT
                    CONVERT(date, EXECUTION_TIMESTAMP) AS dt,
                    SUM(CASE WHEN PASS_FLAG = 1 THEN 1 ELSE 0 END) AS pass_cnt,
                    SUM(CASE WHEN PASS_FLAG = 0 THEN 1 ELSE 0 END) AS fail_cnt
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -13, CONVERT(date, GETDATE()))
                      AND EXECUTION_TIMESTAMP <= GETDATE()
                GROUP BY CONVERT(date, EXECUTION_TIMESTAMP)
                ORDER BY dt ASC
            """)
            rows = c.fetchall()
            for row in rows:
                d = row[0]
                pcount = row[1]
                fcount = row[2]
                days.append(d)
                pass_counts.append(pcount)
                fail_counts.append(fcount)
        except Exception as ex:
            print("Error loading pass/fail trend data:", ex)

        # Convert days to a numeric x-axis, for instance we can do day index 0..N
        # or we can do timestamp => float. We'll do day indexes for simplicity.
        x_vals = list(range(len(days)))

        # Update the lines
        self.pass_curve.setData(x_vals, pass_counts)
        self.fail_curve.setData(x_vals, fail_counts)

        # Tweak axes
        self.trend_widget.setLabel('left', 'Count')
        self.trend_widget.setLabel('bottom', 'Day Index')
        self.trend_widget.showGrid(x=True, y=True)

        # Optionally create custom ticks for the x-axis, showing the date (like mm-dd).
        # We'll do a small utility function:
        date_labels = [(i, days[i].strftime("%m-%d")) for i in range(len(days))]
        ax = self.trend_widget.getAxis('bottom')
        ax.setTicks([date_labels])

        # Force a re-auto-range
        self.trend_widget.autoRange()

