#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_rule_engine.py
Description:
  The main BRM rule engine logic, now fully integrated with:
    • BFS-based execution for child rules, conflicts, global/critical, composites
    • Single/chain/group simulations
    • Real data validations (via brm_data_validations.py)
    • Lock usage (via brm_core_foundation.LockManager), ensuring concurrency control.

Usage in aggregator:
  - Import BFS or simulation as needed.
  - Display SingleRuleSimulationDialog, ChainSimulationDialog, GroupSimulationDialog for UI-driven runs.
"""

import sys
import logging
import pyodbc
import re
from datetime import datetime, timedelta
from collections import deque

# PyQt5 imports for UI
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPlainTextEdit,
    QPushButton, QComboBox, QCheckBox, QMessageBox
)

# Import from brm_core_foundation
from brm_core_foundation import logger, LockManager, fetch_one_dict, insert_audit_log

# Import real data validations
# We assume brm_data_validations exports run_data_validations_for_table(conn, table_name) => bool
from brm_data_validations import run_data_validations_for_table  # <--- fully integrated reference

###############################################################################
# 1) BFS Relationship Building
###############################################################################
def load_rule_relationships(conn):
    """
    Build adjacency for BFS, factoring child rules (PARENT_RULE_ID), 
    global-critical links (BRM_GLOBAL_CRITICAL_LINKS),
    conflicts (RULE_CONFLICTS), and composite references (COMPOSITE_RULES).
    Returns:
      adjacency => dict: rule_id => set(child_rule_ids)
      roots => list of rule_ids with no parent
      parent_map => dict: rule_id => parent_rule_id
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()

    adjacency = {}
    parent_map = {}
    all_ids = set()

    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid

    # GCR links
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    g_rows = c.fetchall()
    for (gcr, tgt) in g_rows:
        adjacency.setdefault(gcr, set()).add(tgt)

    # conflicts
    c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
    cf_rows = c.fetchall()
    for (r1, r2) in cf_rows:
        adjacency.setdefault(r1, set()).add(r2)
        # Possibly we add adjacency the other direction if needed

    # composites => parse expression for "RuleX" references
    pat = re.compile(r"Rule(\d+)")
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp_rows = c.fetchall()
    for (cid, expr) in comp_rows:
        if expr:
            matches = pat.findall(expr)
            for m_ in matches:
                try:
                    sub_id = int(m_)
                    adjacency.setdefault(sub_id, set()).add(cid)
                except:
                    pass

    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]
    return adjacency, roots, parent_map


def skip_bfs_descendants(start_id, adjacency, skipped):
    """
    Mark all reachable from start_id as skipped => BFS approach.
    """
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch_ in adjacency[cur]:
                if ch_ not in skipped:
                    stack.append(ch_)


def get_rule_map(conn):
    """
    Return dict => rule_id => entire row from BRM_RULES.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    out = {}
    for row in rows:
        rd = dict(zip(colnames, row))
        out[rd["RULE_ID"]] = rd
    return out


###############################################################################
# 2) BFS Execution
###############################################################################
def run_data_validations_for_rule(conn, rule_id):
    """
    For each table in BRM_RULE_TABLE_DEPENDENCIES => call run_data_validations_for_table(...).
    Return True if all pass, else False. 
    """
    c = conn.cursor()
    c.execute("""
        SELECT DATABASE_NAME, TABLE_NAME
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE RULE_ID=?
    """,(rule_id,))
    deps = c.fetchall()

    for (dbn, tname) in deps:
        if not tname:
            continue
        full_table = f"{dbn}.{tname}".lower()
        pass_ok = run_data_validations_for_table(conn, full_table)
        if not pass_ok:
            return False
    return True


def run_single_rule_transaction(conn, rule_info, is_dry_run=True):
    """
    Execute rule_info["RULE_SQL"] within a transaction. 
    If row[0][0]==1 => PASS, else FAIL => or if no rows => PASS by default.
    Return (success_flag, message, record_count).
    """
    sql_ = (rule_info.get("RULE_SQL") or "").strip()
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        rows = c.fetchall()
        rec_count = len(rows)
        if rows and len(rows[0])>0:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        c.execute("ROLLBACK")
        success = False
        msg = str(ex)
    return (success, msg, rec_count)


def insert_simulation_log(conn, rule_id, success_flag, message, record_count):
    """
    Insert a simulation log record (dry-run or BFS run) into a SIMULATION_LOGS table (or RULE_EXECUTION_LOGS).
    """
    c = conn.cursor()
    c.execute("""
        INSERT INTO SIMULATION_LOGS(
            RULE_ID, EXEC_TIMESTAMP, SUCCESS_FLAG, MESSAGE, RECORD_COUNT
        )
        VALUES(?, GETDATE(),?,?,?)
    """,(rule_id, 1 if success_flag else 0, message, record_count))
    conn.commit()


def execute_rules_bfs(
    conn, 
    start_rule_ids, 
    skip_data_validation=False, 
    require_lock=False, 
    lock_user="BFSUser", 
    force_lock=False
):
    """
    BFS from given start_rule_ids. 
    Steps for each rule:
      1) If require_lock => attempt LockManager.lock_rule(...) 
         - if fails => skip BFS from this rule
      2) If not skip_data_validation => run_data_validations_for_rule
         - if fail => skip BFS from this rule
      3) run_single_rule_transaction => if fail & rule is critical => skip children
      4) Insert simulation log
      5) if require_lock => unlock after execution

    Return (executed_list, skipped_set).
    """
    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_map = get_rule_map(conn)
    queue = list(start_rule_ids)
    visited = set()
    executed=[]
    skipped=set()

    while queue:
        rid = queue.pop(0)
        if rid in visited or rid in skipped:
            continue
        visited.add(rid)

        rinfo = rule_map.get(rid)
        if not rinfo:
            skipped.add(rid)
            continue

        # (1) Attempt lock if required
        if require_lock:
            try:
                LockManager.lock_rule(conn, rid, lock_user, force=force_lock)
            except Exception as ex:
                logger.warning(f"Could not lock rule {rid} => skipping BFS from it: {ex}")
                skipped.add(rid)
                if rid in adjacency:
                    skip_bfs_descendants(rid, adjacency, skipped)
                continue

        # (2) Data validations
        if not skip_data_validation:
            pass_ok = run_data_validations_for_rule(conn, rid)
            if not pass_ok:
                logger.info(f"Rule {rid} => data validation failed => skipping BFS for children.")
                skipped.add(rid)
                if rid in adjacency:
                    skip_bfs_descendants(rid, adjacency, skipped)
                if require_lock:
                    # unlock rule
                    try:
                        LockManager.unlock_rule(conn, rid, lock_user, force=force_lock)
                    except:
                        pass
                continue

        # (3) Execute the rule transaction
        (ok, msg, rec_count) = run_single_rule_transaction(conn, rinfo, is_dry_run=False)
        insert_simulation_log(conn, rid, ok, msg, rec_count)
        logger.info(f"Rule {rid} => {msg} (pass={ok}, rec_count={rec_count})")

        # (4) If fail & rule is critical => skip children
        is_crit = (rinfo.get("CRITICAL_RULE",0)==1 or rinfo.get("IS_GLOBAL",0)==1)
        if ok:
            executed.append(rid)
            # BFS => add children
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in visited and ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip
            skipped.add(rid)
            if is_crit and rid in adjacency:
                skip_bfs_descendants(rid, adjacency, skipped)

        # (5) If we locked => unlock
        if require_lock:
            try:
                LockManager.unlock_rule(conn, rid, lock_user, force=force_lock)
            except Exception as e2:
                logger.warning(f"Failed to unlock rule {rid}: {e2}")

    return (executed, skipped)


###############################################################################
# 3) UI Dialogs: single, chain, group simulation
###############################################################################
class SingleRuleSimulationDialog(QDialog):
    """
    A dialog to pick 1 rule => BFS or single-run => integrated with data validations & lock usage
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Single Rule Simulation – BRM Engine")
        self.resize(550,400)

        layout = QVBoxLayout(self)

        # selection
        sel_layout = QHBoxLayout()
        sel_layout.addWidget(QLabel("Select Rule:"))
        self.rule_combo = QComboBox()
        c = self.conn.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        sel_layout.addWidget(self.rule_combo)
        layout.addLayout(sel_layout)

        # checkboxes
        self.skip_val_cb = QCheckBox("Skip Data Validations?")
        self.require_lock_cb = QCheckBox("Require Lock?")
        layout.addWidget(self.skip_val_cb)
        layout.addWidget(self.require_lock_cb)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Run Simulation")
        run_btn.clicked.connect(self.do_simulation)
        bh.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_simulation(self):
        rid = self.rule_combo.currentData()
        skip_val = self.skip_val_cb.isChecked()
        req_lock = self.require_lock_cb.isChecked()

        exed, skp = execute_rules_bfs(
            self.conn, 
            [rid], 
            skip_data_validation=skip_val,
            require_lock=req_lock,
            lock_user="SimUser",
            force_lock=False
        )
        txt = f"Sim => single BFS from rule {rid}.\nExecuted={exed}\nSkipped={list(skp)}"
        self.result_text.setPlainText(txt)


class ChainSimulationDialog(QDialog):
    """
    BFS from a selected "parent" => chain simulation => integrated with validations & lock usage
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Chain Simulation – BRM Engine")
        self.resize(550,400)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Starting Rule:"))
        self.start_combo = QComboBox()
        c = self.conn.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.start_combo.addItem(disp,rid)
        top_h.addWidget(self.start_combo)
        layout.addLayout(top_h)

        self.skip_val_cb = QCheckBox("Skip Data Validations?")
        self.req_lock_cb = QCheckBox("Require Lock?")
        layout.addWidget(self.skip_val_cb)
        layout.addWidget(self.req_lock_cb)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Run BFS Chain")
        run_btn.clicked.connect(self.run_chain)
        bh.addWidget(run_btn)
        cls_btn = QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        bh.addWidget(cls_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)

    def run_chain(self):
        rid = self.start_combo.currentData()
        skip_val = self.skip_val_cb.isChecked()
        req_lock = self.req_lock_cb.isChecked()

        exed, skp = execute_rules_bfs(
            self.conn,
            [rid],
            skip_data_validation=skip_val,
            require_lock=req_lock,
            lock_user="ChainUser",
            force_lock=False
        )
        txt = f"Chain BFS => start={rid}\nExecuted={exed}\nSkipped={list(skp)}"
        self.result_text.setPlainText(txt)


class GroupSimulationDialog(QDialog):
    """
    BFS from all rules in a selected custom group => integrated with validations & lock usage
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Group Simulation – BRM Engine")
        self.resize(550,400)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Custom Group:"))
        self.grp_combo = QComboBox()
        c = self.conn.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for (cgid,cgn) in c.fetchall():
            disp = f"{cgid} - {cgn}"
            self.grp_combo.addItem(disp, cgid)
        top_h.addWidget(self.grp_combo)
        layout.addLayout(top_h)

        self.skip_val_cb = QCheckBox("Skip Data Validations?")
        self.req_lock_cb = QCheckBox("Require Lock?")
        layout.addWidget(self.skip_val_cb)
        layout.addWidget(self.req_lock_cb)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Run BFS for Group")
        run_btn.clicked.connect(self.run_group_bfs)
        bh.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)

    def run_group_bfs(self):
        c = self.conn.cursor()
        cgid = self.grp_combo.currentData()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (cgid,))
        rows = c.fetchall()
        group_rules = [r[0] for r in rows]

        skip_val = self.skip_val_cb.isChecked()
        req_lock = self.req_lock_cb.isChecked()

        exed = []
        skp = set()
        visited = set()

        # BFS from each rule => union results
        for rid in group_rules:
            part_ex, part_sk = execute_rules_bfs(
                self.conn,
                [rid],
                skip_data_validation=skip_val,
                require_lock=req_lock,
                lock_user="GroupUser",
                force_lock=False
            )
            for x in part_ex:
                if x not in exed:
                    exed.append(x)
            for s_ in part_sk:
                skp.add(s_)

        txt = (f"Group BFS => group_id={cgid}\n"
               f"Executed => {exed}\n"
               f"Skipped => {list(skp)}")
        self.result_text.setPlainText(txt)


###############################################################################
# If run standalone test
###############################################################################
if __name__=="__main__":
    from PyQt5.QtWidgets import QApplication
    import pyodbc

    app = QApplication(sys.argv)
    try:
        conn = pyodbc.connect("DSN=YourDSN;Trusted_Connection=yes;")
    except Exception as e:
        print("DB connect error:", e)
        sys.exit(1)

    # Let's just show SingleRuleSimulationDialog as a test
    dlg = SingleRuleSimulationDialog(conn)
    dlg.show()

    sys.exit(app.exec_())