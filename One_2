#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module 2: db_helpers.py
This module provides advanced helper functions for database operations:
  - fetch_all_dict and fetch_one_dict to return query results as dictionaries.
  - insert_audit_log to capture audit entries, including impacted record counts for dry runs.
  - detect_operation_type to identify the SQL operation (including DECISION_TABLE markers).
  - parse_sql_dependencies to extract table names and alias mappings from SQL queries.
"""

import json
import logging
import sqlparse
from sqlparse.sql import Identifier, IdentifierList
from sqlparse.tokens import Keyword, DML

logger = logging.getLogger("BRMToolLogger")

def fetch_all_dict(cursor):
    """
    Retrieve all rows from the cursor as a list of dictionaries.
    """
    try:
        rows = cursor.fetchall()
    except Exception as ex:
        logger.error("Error fetching rows: %s", ex)
        return []
    if cursor.description:
        columns = [col[0] for col in cursor.description]
        return [dict(zip(columns, row)) for row in rows]
    return rows

def fetch_one_dict(cursor):
    """
    Retrieve a single row from the cursor as a dictionary.
    """
    try:
        row = cursor.fetchone()
    except Exception as ex:
        logger.error("Error fetching one row: %s", ex)
        return None
    if row and cursor.description:
        columns = [col[0] for col in cursor.description]
        return dict(zip(columns, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data, impacted_count=None):
    """
    Insert an audit log entry into the audit log table.
    
    Parameters:
      - action: The type of action performed (e.g., 'INSERT', 'UPDATE', etc.).
      - table_name: Name of the table being acted upon.
      - record_id: Identifier of the impacted record.
      - actor: User or process that performed the action.
      - old_data: Dictionary of data before the change.
      - new_data: Dictionary of data after the change.
      - impacted_count: Optional number of records impacted (useful for dry-run simulations).
    """
    try:
        cursor = conn.cursor()
        query = """
        INSERT INTO BRM_AUDIT_LOG (
            ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
            OLD_DATA, NEW_DATA, IMPACTED_COUNT, ACTION_TIMESTAMP
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, GETDATE())
        """
        cursor.execute(query, (
            action,
            table_name,
            str(record_id) if record_id is not None else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None,
            impacted_count if impacted_count is not None else 0
        ))
        conn.commit()
        logger.info("Audit log inserted for action %s on table %s (Record ID: %s)", action, table_name, record_id)
    except Exception as ex:
        logger.exception("Failed to insert audit log: %s", ex)

def detect_operation_type(sql_text: str) -> str:
    """
    Detect the operation type of a SQL query.
    Extended to detect decision table operations using the marker '##DECISION##'.
    
    Returns:
      - A string representing the operation type, e.g., "INSERT", "UPDATE", "DELETE", "SELECT", "DECISION_TABLE", or "OTHER".
    """
    if not sql_text or not sql_text.strip():
        return "OTHER"
    txt = sql_text.strip().upper()
    if "##DECISION##" in txt:
        return "DECISION_TABLE"
    for op in ["INSERT", "UPDATE", "DELETE", "SELECT"]:
        if txt.startswith(op):
            return op
    return "OTHER"

def parse_sql_dependencies(sql_text: str) -> dict:
    """
    Parse the SQL text to extract table dependencies.
    
    Returns:
      A dictionary with:
        - 'tables': a list of table names used in the query.
        - 'alias_map': a mapping from alias to the actual table name.
    
    This function uses sqlparse to identify tokens following 'FROM' and 'JOIN' keywords.
    """
    dependencies = {"tables": [], "alias_map": {}}
    try:
        statements = sqlparse.parse(sql_text)
        for stmt in statements:
            from_seen = False
            for token in stmt.tokens:
                if token.ttype is Keyword and token.value.upper() in ("FROM", "JOIN"):
                    from_seen = True
                    continue
                if from_seen:
                    if isinstance(token, IdentifierList):
                        for identifier in token.get_identifiers():
                            table_name = identifier.get_real_name()
                            alias = identifier.get_alias() or table_name
                            dependencies["tables"].append(table_name)
                            dependencies["alias_map"][alias] = table_name
                    elif isinstance(token, Identifier):
                        table_name = token.get_real_name()
                        alias = token.get_alias() or table_name
                        dependencies["tables"].append(table_name)
                        dependencies["alias_map"][alias] = table_name
                    # Reset flag after processing the token
                    from_seen = False
    except Exception as ex:
        logger.error("Error parsing SQL dependencies: %s", ex)
    return dependencies

# For module testing purposes only
if __name__ == "__main__":
    # Use an in-memory SQLite database for testing purposes
    import sqlite3
    conn = sqlite3.connect(":memory:")
    cur = conn.cursor()
    # Create a dummy audit log table for testing
    cur.execute("""
    CREATE TABLE BRM_AUDIT_LOG (
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT,
        TABLE_NAME TEXT,
        RECORD_ID TEXT,
        ACTION_BY TEXT,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        IMPACTED_COUNT INTEGER,
        ACTION_TIMESTAMP TEXT
    )
    """)
    conn.commit()
    
    # Test inserting an audit log entry
    insert_audit_log(conn, "TEST_INSERT", "DUMMY_TABLE", 1, "Tester", {"field": "old"}, {"field": "new"}, impacted_count=5)
    
    # Test detecting SQL operation type
    sql_test = "INSERT INTO DUMMY_TABLE (id, name) VALUES (1, 'Test')"
    print("Operation type:", detect_operation_type(sql_test))
    
    # Test parsing SQL dependencies
    sql_query = "SELECT * FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID"
    deps = parse_sql_dependencies(sql_query)
    print("Parsed Dependencies:", deps)