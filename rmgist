#!/usr/bin/env python
"""
BRM Tool – Full Integrated Enhanced Version
Supports:
  • SQL Server ODBC (pyodbc) or In‑Memory SQLite
  • Login with seeded users
  • Business Rule Management (CRUD) with advanced SQL parsing for dependencies
  • Multi‐step approvals (with Approve and Reject, BFS‐based)
  • BFS‐based lineage graph with search (for rules, tables and columns)
  • Hierarchy view (Groups -> Rule Groups -> Rules)
  • Enhanced custom rule groups (with backup/restore and rule assignment)
  • Email notifications on rule add/update
  • Group Management & User Management (admin only)
  • Global/Critical Admin (with cycle prevention and re‐approvals)
  • Control Tables viewer
Additional advanced features:
  1. Advanced SQL parsing using sqlparse (for complex SQL)
  2. Rule Simulation (Dry‑run) dialog
  3. Version History and Rollback dialog
  4. Impact Analysis dialog
  5. Rule Scheduling and a Schedule Management tab (with periodic checking)
  6. Metrics Dashboard (using pyqtgraph)
  7. Audit Log viewer with CSV export
  8. Metadata Synchronization stub (menu action)
"""

import sys, logging, json, math, re, smtplib, csv
from datetime import datetime
from collections import deque

# PyQt5 and pyqtgraph imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget, QTableWidgetItem, QMessageBox,
    QComboBox, QInputDialog, QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView,
    QPlainTextEdit, QSplitter, QCheckBox, QTreeView, QListWidget, QListWidgetItem, QMenu, QFileDialog
)
import pyqtgraph as pg

# Try to import pyodbc and sqlparse
try:
    import pyodbc
except ImportError:
    pyodbc = None
import sqlparse
from sqlparse.sql import IdentifierList, Identifier
from sqlparse.tokens import Keyword, DML

###############################################################################
# Logging & Email Configuration
###############################################################################
logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",   # Replace with your SMTP server
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

# Global flag: if True then we are using ODBC (SQL Server); otherwise, in-memory SQLite.
USE_ODBC = False

###############################################################################
# Advanced SQL Parsing using sqlparse
###############################################################################
def is_subselect(parsed):
    if not parsed.is_group:
        return False
    for item in parsed.tokens:
        if item.ttype is DML and item.value.upper() == 'SELECT':
            return True
    return False

def extract_from_part(parsed):
    from_seen = False
    for item in parsed.tokens:
        if from_seen:
            if is_subselect(item):
                yield from extract_from_part(item)
            elif item.ttype is Keyword:
                return
            else:
                if isinstance(item, IdentifierList):
                    for identifier in item.get_identifiers():
                        yield identifier.get_real_name()
                elif isinstance(item, Identifier):
                    yield item.get_real_name()
        if item.ttype is Keyword and item.value.upper() == 'FROM':
            from_seen = True

def extract_tables(sql_text: str):
    """
    Extract table names from SQL using sqlparse.
    Returns a list of table names.
    """
    parsed_statements = sqlparse.parse(sql_text)
    tables = []
    for statement in parsed_statements:
        for table in extract_from_part(statement):
            if table and table not in tables:
                tables.append(table)
    return tables

###############################################################################
# DB Utilities
###############################################################################
def get_cursor_rows(cursor):
    try:
        rows = cursor.fetchall()
    except Exception:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, row)) for row in rows]
    return rows

def get_cursor_one(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return row

def send_email_notification(subject, body, recipients):
    try:
        from email.mime.text import MIMEText
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info("Email sent to: " + ", ".join(recipients))
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG (ODBC or In-Memory SQLite)
###############################################################################
class DatabaseConnectionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Database Connection")
        layout = QVBoxLayout(self)
        self.conn_type_combo = QComboBox()
        self.conn_type_combo.addItem("In-Memory SQLite", "memory")
        if pyodbc:
            try:
                dsn_dict = pyodbc.dataSources()
                for dsn_name, driver in dsn_dict.items():
                    if "SQL SERVER" in driver.upper():
                        self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
            except Exception as e:
                logger.error("Error listing ODBC DSNs: " + str(e))
        layout.addWidget(QLabel("Select Connection Type:"))
        layout.addWidget(self.conn_type_combo)
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Optional: custom ODBC connection string")
        layout.addWidget(self.conn_str_edit)
        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)
    def get_connection(self):
        global USE_ODBC
        choice = self.conn_type_combo.currentData()
        if choice == "memory":
            return setup_in_memory_db()
        else:
            override = self.conn_str_edit.text().strip()
            if override:
                conn_str = override
            else:
                conn_str = f"DSN={choice};Trusted_Connection=yes;"
            try:
                USE_ODBC = True
                return pyodbc.connect(conn_str)
            except Exception as ex:
                QMessageBox.critical(self, "Connection Error", str(ex))
                return None

###############################################################################
# In-Memory SQLite Setup and Schema Creation
###############################################################################
def setup_in_memory_db():
    import sqlite3
    conn = sqlite3.connect("file::memory:?cache=shared", uri=True, timeout=10.0)
    conn.execute("PRAGMA foreign_keys=ON;")
    conn.row_factory = sqlite3.Row
    create_tables_and_seed(conn)
    return conn

def create_tables_and_seed(conn):
    c = conn.cursor()
    c.executescript("""
    -- Users
    CREATE TABLE IF NOT EXISTS USERS(
      USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      USERNAME TEXT UNIQUE NOT NULL,
      PASSWORD TEXT NOT NULL,
      USER_GROUP TEXT NOT NULL
    );
    -- Business Groups
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
      GROUP_NAME TEXT PRIMARY KEY,
      DESCRIPTION TEXT,
      EMAIL TEXT
    );
    -- Rule Types
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
      RULE_TYPE_ID INTEGER PRIMARY KEY,
      RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    -- Rule Groups
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
      GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      GROUP_NAME TEXT UNIQUE NOT NULL,
      DESCRIPTION TEXT
    );
    -- Rules
    CREATE TABLE IF NOT EXISTS BRM_RULES(
      RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      GROUP_ID INTEGER,
      PARENT_RULE_ID INTEGER,
      RULE_TYPE_ID INTEGER NOT NULL,
      RULE_NAME TEXT NOT NULL,
      RULE_SQL TEXT NOT NULL,
      EFFECTIVE_START_DATE TEXT NOT NULL,
      EFFECTIVE_END_DATE TEXT,
      STATUS TEXT NOT NULL,
      VERSION INTEGER NOT NULL DEFAULT 1,
      CREATED_BY TEXT NOT NULL,
      DESCRIPTION TEXT,
      OPERATION_TYPE TEXT,
      BUSINESS_JUSTIFICATION TEXT,
      CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
      UPDATED_BY TEXT,
      OWNER_GROUP TEXT NOT NULL,
      CLUSTER_NAME TEXT,
      APPROVAL_STATUS TEXT DEFAULT 'DRAFT',
      IS_GLOBAL INTEGER DEFAULT 0,
      CRITICAL_RULE INTEGER DEFAULT 0,
      CRITICAL_SCOPE TEXT DEFAULT 'NONE',
      CDC_TYPE TEXT DEFAULT 'NONE',
      UNIQUE(OWNER_GROUP, RULE_NAME)
    );
    -- Rule Table Dependencies
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
      DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      RULE_ID INTEGER NOT NULL,
      DATABASE_NAME TEXT,
      TABLE_NAME TEXT NOT NULL,
      COLUMN_NAME TEXT NOT NULL
    );
    -- Audit Log
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
      AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      ACTION TEXT NOT NULL,
      TABLE_NAME TEXT NOT NULL,
      RECORD_ID TEXT NOT NULL,
      ACTION_BY TEXT NOT NULL,
      OLD_DATA TEXT,
      NEW_DATA TEXT,
      ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    -- Rule Lineage
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
      LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      RULE_ID INTEGER NOT NULL,
      SOURCE_INFO TEXT,
      TARGET_INFO TEXT,
      TRANSFORMATION_DETAILS TEXT,
      CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    -- Column Mapping
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
      MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      RULE_ID INTEGER NOT NULL,
      SOURCE_RULE_ID INTEGER NOT NULL,
      SOURCE_COLUMN_NAME TEXT NOT NULL,
      TARGET_COLUMN_NAME TEXT NOT NULL
    );
    -- Rule Approvals
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
      RULE_ID INTEGER NOT NULL,
      GROUP_NAME TEXT NOT NULL,
      USERNAME TEXT NOT NULL,
      APPROVED_FLAG INTEGER DEFAULT 0,
      APPROVAL_STAGE INTEGER DEFAULT 1,
      APPROVED_TIMESTAMP DATETIME,
      PRIMARY KEY (RULE_ID, GROUP_NAME, USERNAME)
    );
    -- Global/Critical Links
    CREATE TABLE IF NOT EXISTS BRM_GLOBAL_CRITICAL_LINKS(
      LINK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
      GCR_RULE_ID INTEGER NOT NULL,
      TARGET_RULE_ID INTEGER
    );
    -- (For brevity, tables for custom rule groups, backups, schedules, etc. should be added here.)
    """)
    # Seed sample data
    users = [
      ("admin", "admin", "Admin"),
      ("bg1_user", "user", "BG1"),
      ("bg2_user", "user", "BG2"),
      ("bg3_user", "user", "BG3")
    ]
    for u in users:
        c.execute("INSERT OR IGNORE INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?,?,?)", u)
    groups = [
      ("Admin", "Admin group", "admin@example.com"),
      ("BG1", "Business Group 1", "bg1@example.com"),
      ("BG2", "Business Group 2", "bg2@example.com"),
      ("BG3", "Business Group 3", "bg3@example.com")
    ]
    for g in groups:
        c.execute("INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)", g)
    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID, RULE_TYPE_NAME) VALUES(1, 'DQ')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID, RULE_TYPE_NAME) VALUES(2, 'DM')")
    conn.commit()

###############################################################################
# Audit Log Utility
###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
    VALUES(?,?,?,?,?,?,CURRENT_TIMESTAMP)
    """, (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# Rule Utilities (Execution, Approvals, Dependencies)
###############################################################################
def get_op_type_from_sql(sql_text: str) -> str:
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def run_rule_sql(conn, rule_sql):
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = get_cursor_one(c)
        if not row:
            return True, "No rows returned. (Pass)"
        result = list(row.values())[0]
        return (result == 1), f"Returned: {result}"
    except Exception as ex:
        logger.error("Rule execution error: " + str(ex))
        return False, str(ex)

def build_rule_adjacency(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = get_cursor_rows(c)
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r["RULE_ID"]
        pid = r["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [rid for rid in all_ids if rid not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = get_cursor_rows(c)
    link_map = {}
    for r in rows:
        gcr = r["GCR_RULE_ID"]
        tgt = r["TARGET_RULE_ID"]
        if tgt:
            link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = get_cursor_rows(c)
    return {r["RULE_ID"]: r for r in rows}

def skip_descendants(child_id, children_map, skipped):
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def execute_rules_in_order(conn):
    children_map, root_rules = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    executed = []
    skipped = set()
    queue = list(root_rules)
    rule_lookup = get_all_rules_as_dict(conn)
    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning("Rule not found: " + str(rid))
            continue
        rinfo = rule_lookup[rid]
        rule_sql = rinfo["RULE_SQL"]
        logger.info(f"Executing rule {rid}: {rinfo['RULE_NAME']}")
        passed, msg = run_rule_sql(conn, rule_sql)
        if passed:
            logger.info(f"Rule {rid} PASSED")
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            logger.warning(f"Rule {rid} FAILED")
            is_crit = (rinfo["CRITICAL_RULE"] == 1 or rinfo["IS_GLOBAL"] == 1)
            crit_scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and crit_scope != "NONE":
                logger.warning(f"Critical/Global => skipping descendants & links. scope={crit_scope}")
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)
    logger.info(f"ETL done. executed={executed}, skipped={list(skipped)}")
    return executed, skipped

def find_impacted_business_groups(conn, rule_id):
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = get_cursor_one(c)
    if row:
        impacted.add(row["OWNER_GROUP"])
    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?", (curr,))
        children = get_cursor_rows(c)
        for ch in children:
            cid = ch["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (cid,))
            row2 = get_cursor_one(c)
            if row2:
                impacted.add(row2["OWNER_GROUP"])
            queue.append(cid)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    c = conn.cursor()
    stage_counter = 1
    stage_list = []
    MULTISTEP_ORDER = ["BG1", "BG2", "BG3", "FINAL"]
    for step in MULTISTEP_ORDER:
        if step == "FINAL":
            stage_list.append((step, stage_counter))
            stage_counter += 1
        else:
            if step in impacted_bg_list:
                stage_list.append((step, stage_counter))
                stage_counter += 1
    for bg, st in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            c.execute("""
            INSERT OR IGNORE INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
            VALUES(?,?,?,?,?)
            """, (rule_id, bg, user_ap, 0, st))
        else:
            c.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (bg,))
            for rap in get_cursor_rows(c):
                c.execute("""
                INSERT OR IGNORE INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
                VALUES(?,?,?,?,?)
                """, (rule_id, bg, rap["USERNAME"], 0, st))
    conn.commit()

def get_current_approval_stage(conn, rule_id):
    c = conn.cursor()
    c.execute("""
    SELECT MIN(APPROVAL_STAGE) as stage
    FROM BRM_RULE_APPROVALS
    WHERE RULE_ID=? AND APPROVED_FLAG=0
    """, (rule_id,))
    row = get_cursor_one(c)
    if row and row["stage"]:
        return row["stage"]
    return None

###############################################################################
# Rule CRUD: Add, Update, Deactivate, Delete
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    c = conn.cursor()
    owner = rule_data["OWNER_GROUP"]
    rule_name = rule_data["RULE_NAME"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (owner, rule_name))
    if get_cursor_one(c):
        raise ValueError(f"Rule '{rule_name}' already exists in group '{owner}'")
    is_global = rule_data.get("IS_GLOBAL", 0)
    if is_global == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create global rule.")
    c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
      EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION, CREATED_BY,
      DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION, OWNER_GROUP,
      APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE,
      CREATED_TIMESTAMP, UPDATED_BY, CLUSTER_NAME
    )
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,CURRENT_TIMESTAMP,NULL,?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        "INACTIVE",
        1,
        created_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        rule_data["OWNER_GROUP"],
        "APPROVAL_IN_PROGRESS",
        is_global,
        rule_data.get("CRITICAL_RULE", 0),
        rule_data.get("CRITICAL_SCOPE", "NONE"),
        rule_data.get("CDC_TYPE", "NONE"),
        rule_data.get("CLUSTER_NAME", "")
    ))
    new_id = c.lastrowid
    deps = extract_tables(rule_data["RULE_SQL"])
    for table in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (new_id, "", table, "DerivedCol"))
    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()
    if is_global == 1:
        logger.info("Global rule => skip approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)
    try:
        subject = f"New Rule Added: {rule_data['RULE_NAME']}"
        body = f"User {created_by} added rule ID {new_id}\n\nDetails:\n{json.dumps(rule_data, indent=2)}"
        impacted_grps = find_impacted_business_groups(conn, new_id)
        recips = []
        for g in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g,))
            r = get_cursor_one(c)
            if r and r.get("EMAIL"):
                recips.append(r["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on new rule: " + str(ex))
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)
    new_owner = rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_rname = rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()
    if new_owner != old["OWNER_GROUP"] or new_rname != old["RULE_NAME"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (new_owner, new_rname))
        dup = get_cursor_one(c)
        if dup and dup["RULE_ID"] != old["RULE_ID"]:
            raise ValueError(f"Duplicate rule name '{new_rname}' in group '{new_owner}'")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set a rule global.")
    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID = ?,
      PARENT_RULE_ID = ?,
      RULE_TYPE_ID = ?,
      RULE_NAME = ?,
      RULE_SQL = ?,
      EFFECTIVE_START_DATE = ?,
      EFFECTIVE_END_DATE = ?,
      STATUS = 'INACTIVE',
      VERSION = VERSION + 1,
      UPDATED_BY = ?,
      DESCRIPTION = ?,
      OPERATION_TYPE = ?,
      BUSINESS_JUSTIFICATION = ?,
      OWNER_GROUP = ?,
      APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
      IS_GLOBAL = ?,
      CRITICAL_RULE = ?,
      CRITICAL_SCOPE = ?,
      CDC_TYPE = ?,
      CLUSTER_NAME = ?
    WHERE RULE_ID = ?
    """, (
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_rname,
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        new_owner,
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rule_data.get("CLUSTER_NAME", old.get("CLUSTER_NAME", "")),
        rule_data["RULE_ID"]
    ))
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    deps = extract_tables(rule_data["RULE_SQL"])
    for table in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (rule_data["RULE_ID"], "", table, "DerivedCol"))
    new_data = dict(old_data)
    for k, v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "UPDATE", "BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()
    if old["IS_GLOBAL"] == 1 or rule_data.get("IS_GLOBAL", 0) == 1:
        logger.info("Skipping multi-step approvals for global rule update.")
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)
    try:
        subject = f"Rule Updated: {new_rname}"
        body = f"User {updated_by} updated rule ID {rule_data['RULE_ID']}.\n\nOld:\n{json.dumps(old_data, indent=2)}\n\nNew:\n{json.dumps(rule_data, indent=2)}"
        impacted_grps = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        recips = []
        for g in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g,))
            ro = get_cursor_one(c)
            if ro and ro.get("EMAIL"):
                recips.append(ro["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on rule update: " + str(ex))

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Deactivate child rules first.")
    old_data = dict(old)
    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',
        UPDATED_BY=?,
        VERSION=VERSION+1
    WHERE RULE_ID=?
    """, (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist, cannot delete.")
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    leftover = get_cursor_rows(c)
    if leftover:
        raise ValueError("Re-map or remove column references first.")
    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

###############################################################################
# Dialogs: Rule Simulation, Version History, Impact Analysis, Scheduler
###############################################################################
class RuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_sql, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_sql = rule_sql
        self.setWindowTitle("Rule Simulation (Dry-run)")
        self.resize(600, 400)
        layout = QVBoxLayout(self)
        self.sim_result = QPlainTextEdit()
        self.sim_result.setReadOnly(True)
        layout.addWidget(self.sim_result)
        btn_h = QHBoxLayout()
        self.simulate_btn = QPushButton("Simulate Rule")
        self.simulate_btn.clicked.connect(self.simulate)
        btn_h.addWidget(self.simulate_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)
    def simulate(self):
        self.simulate_btn.setEnabled(False)
        result, msg = run_rule_sql(self.connection, self.rule_sql)
        output = f"Result: {'PASS' if result else 'FAIL'}\nDetail: {msg}"
        self.sim_result.setPlainText(output)
        self.simulate_btn.setEnabled(True)

class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History for Rule {rule_id}")
        self.resize(800, 400)
        layout = QVBoxLayout(self)
        self.history_table = QTableWidget(0, 5)
        self.history_table.setHorizontalHeaderLabels(["Audit ID", "Action", "Timestamp", "Old Data", "New Data"])
        self.history_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.history_table)
        btn_h = QHBoxLayout()
        self.rollback_btn = QPushButton("Rollback to Selected Version")
        self.rollback_btn.clicked.connect(self.rollback)
        btn_h.addWidget(self.rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_history()
    def load_history(self):
        c = self.connection.cursor()
        query = """
        SELECT AUDIT_ID, ACTION, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """
        c.execute(query, (self.rule_id,))
        rows = get_cursor_rows(c)
        self.history_table.setRowCount(0)
        for row in rows:
            r = self.history_table.rowCount()
            self.history_table.insertRow(r)
            self.history_table.setItem(r, 0, QTableWidgetItem(str(row["AUDIT_ID"])))
            self.history_table.setItem(r, 1, QTableWidgetItem(row["ACTION"]))
            self.history_table.setItem(r, 2, QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))
            self.history_table.setItem(r, 3, QTableWidgetItem(row["OLD_DATA"] or ""))
            self.history_table.setItem(r, 4, QTableWidgetItem(row["NEW_DATA"] or ""))
        self.history_table.resizeColumnsToContents()
    def rollback(self):
        sel = self.history_table.selectedItems()
        if not sel:
            QMessageBox.warning(self, "No Selection", "Select a version to roll back to.")
            return
        row = sel[0].row()
        old_data_item = self.history_table.item(row, 3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self, "Cannot Rollback", "No rollback data available for this version.")
            return
        confirm = QMessageBox.question(self, "Confirm Rollback", "Are you sure you want to rollback to the selected version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_data_item.text())
            update_rule(self.connection, old_data, "Admin", "Admin")
            QMessageBox.information(self, "Rolled Back", "Rule rolled back successfully.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class ImpactAnalysisDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Impact Analysis for Rule {rule_id}")
        self.resize(600, 400)
        layout = QVBoxLayout(self)
        self.impact_text = QTextEdit()
        self.impact_text.setReadOnly(True)
        layout.addWidget(self.impact_text)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.analyze()
    def analyze(self):
        children_map, _ = build_rule_adjacency(self.connection)
        visited = set()
        impacted = set()
        stack = [self.rule_id]
        while stack:
            curr = stack.pop()
            if curr in visited:
                continue
            visited.add(curr)
            if curr in children_map:
                for child in children_map[curr]:
                    impacted.add(child)
                    stack.append(child)
        self.impact_text.setPlainText(f"Impacted descendant rule IDs: {sorted(impacted)}")

class RuleSchedulerDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Schedule Rule Execution")
        self.resize(400, 200)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for r in get_cursor_rows(c):
            self.rule_combo.addItem(f"{r['RULE_ID']} - {r['RULE_NAME']}", r["RULE_ID"])
        form.addRow("Select Rule:", self.rule_combo)
        self.datetime_edit = QDateTimeEdit(QDateTime.currentDateTime())
        self.datetime_edit.setCalendarPopup(True)
        self.datetime_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        form.addRow("Schedule Time:", self.datetime_edit)
        layout.addLayout(form)
        btn_h = QHBoxLayout()
        schedule_btn = QPushButton("Schedule")
        schedule_btn.clicked.connect(self.schedule_rule)
        btn_h.addWidget(schedule_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)
    def schedule_rule(self):
        rule_id = self.rule_combo.currentData()
        schedule_time = self.datetime_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        c = self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP)
        VALUES(?,?, 'Scheduled', CURRENT_TIMESTAMP)
        """, (rule_id, schedule_time))
        self.connection.commit()
        QMessageBox.information(self, "Scheduled", f"Rule {rule_id} scheduled for {schedule_time}.")

class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 4)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID", "Rule ID", "Schedule Time", "Status"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        btn_h = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Schedules")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_h.addWidget(refresh_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_schedules()
    def load_schedules(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = get_cursor_rows(c)
        self.schedule_table.setRowCount(0)
        for row in rows:
            r = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r)
            self.schedule_table.setItem(r, 0, QTableWidgetItem(str(row["SCHEDULE_ID"])))
            self.schedule_table.setItem(r, 1, QTableWidgetItem(str(row["RULE_ID"])))
            self.schedule_table.setItem(r, 2, QTableWidgetItem(str(row["SCHEDULE_TIME"])))
            self.schedule_table.setItem(r, 3, QTableWidgetItem(row["STATUS"]))
        self.schedule_table.resizeColumnsToContents()

class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.chart = pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_metrics()
    def load_metrics(self):
        c = self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) as count FROM BRM_RULES GROUP BY STATUS")
        rows = get_cursor_rows(c)
        statuses = [r["STATUS"] for r in rows]
        counts = [r["count"] for r in rows]
        self.chart.clear()
        if statuses:
            x = range(len(statuses))
            bar_item = pg.BarGraphItem(x=x, height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(x, statuses))])
            self.chart.setLabel("left", "Count")
            self.chart.setLabel("bottom", "Status")
            self.chart.showGrid(x=True, y=True)

###############################################################################
# Control Tables Viewer Tab
###############################################################################
class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "BRM_RULE_TYPES", "BRM_RULE_GROUPS",
            "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE", "BRM_COLUMN_MAPPING"
        ]
        self.table_combo = QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)
        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)
        self.table_view = QTableWidget(0, 0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)
        self.setLayout(layout)
    def on_load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()
        try:
            if not USE_ODBC:
                c.execute(f"PRAGMA table_info({tbl})")
                info = get_cursor_rows(c)
                col_names = [x["name"] for x in info]
            else:
                c.execute(f"SELECT TOP 1 * FROM {tbl}")
                if c.description:
                    col_names = [d[0] for d in c.description]
                else:
                    col_names = []
        except Exception as ex:
            QMessageBox.critical(self, "Error", "Failed to retrieve table info: " + str(ex))
            return
        try:
            if USE_ODBC:
                query = f"SELECT * FROM {tbl}"
                c.execute(query)
            else:
                c.execute(f"SELECT * FROM {tbl}")
            rows = get_cursor_rows(c)
        except Exception as ex:
            QMessageBox.critical(self, "Error", "Failed to retrieve data: " + str(ex))
            return
        self.table_view.setRowCount(0)
        self.table_view.setColumnCount(len(col_names))
        self.table_view.setHorizontalHeaderLabels(col_names)
        for rd in rows:
            r = self.table_view.rowCount()
            self.table_view.insertRow(r)
            for j, cn in enumerate(col_names):
                val = rd.get(cn, "")
                self.table_view.setItem(r, j, QTableWidgetItem(str(val)))

###############################################################################
# Global/Critical Admin Tab
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return
        filter_layout = QHBoxLayout()
        self.show_only_gcr = QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        filter_layout.addWidget(self.show_only_gcr)
        ref_btn = QPushButton("Refresh Rule List")
        ref_btn.clicked.connect(self.load_rule_list)
        filter_layout.addWidget(ref_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)
        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Rule Name", "Owner Group", "IS_GLOBAL",
            "CRITICAL_RULE", "CRITICAL_SCOPE", "STATUS", "UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)
        gcs_layout = QHBoxLayout()
        self.global_checkbox = QCheckBox("Set Global?")
        gcs_layout.addWidget(self.global_checkbox)
        self.critical_checkbox = QCheckBox("Set Critical?")
        gcs_layout.addWidget(self.critical_checkbox)
        gcs_layout.addWidget(QLabel("Critical Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        gcs_layout.addWidget(self.scope_combo)
        apply_btn = QPushButton("Apply Flags/Scope To Selected")
        apply_btn.clicked.connect(self.apply_gcs_to_selected)
        gcs_layout.addWidget(apply_btn)
        impact_btn = QPushButton("Show Impacted Descendants")
        impact_btn.clicked.connect(self.show_impacted_descendants)
        gcs_layout.addWidget(impact_btn)
        gcs_layout.addStretch()
        layout.addLayout(gcs_layout)
        link_box = QHBoxLayout()
        self.gcr_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Select Parent GCR Rule:"))
        link_box.addWidget(self.gcr_rule_combo)
        self.child_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Child Rule to Link/Unlink:"))
        link_box.addWidget(self.child_rule_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_box.addWidget(link_btn)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_box.addWidget(unlink_btn)
        link_box.addStretch()
        layout.addLayout(link_box)
        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID", "Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)
        ref_all_btn = QPushButton("Refresh Everything")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)
        self.setLayout(layout)
        self.refresh_all()
    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()
    def load_rule_list(self):
        c = self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                   CRITICAL_SCOPE, STATUS, UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                   CRITICAL_SCOPE, STATUS, UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows = c.fetchall()
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r, 0, QTableWidgetItem(str(rd[0])))
            self.rule_table.setItem(r, 1, QTableWidgetItem(rd[1]))
            self.rule_table.setItem(r, 2, QTableWidgetItem(rd[2]))
            self.rule_table.setItem(r, 3, QTableWidgetItem(str(rd[3])))
            self.rule_table.setItem(r, 4, QTableWidgetItem(str(rd[4])))
            self.rule_table.setItem(r, 5, QTableWidgetItem(rd[5]))
            self.rule_table.setItem(r, 6, QTableWidgetItem(rd[6]))
            self.rule_table.setItem(r, 7, QTableWidgetItem(str(rd[7])))
        self.rule_table.resizeColumnsToContents()
    def populate_gcr_rule_combo(self):
        self.gcr_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows = c.fetchall()
        for row in rows:
            rid, rname = row
            disp = f"ID:{rid} - {rname}"
            self.gcr_rule_combo.addItem(disp, rid)
    def populate_child_rule_combo(self):
        self.child_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for r in rows:
            rid, rname = r
            disp = f"ID:{rid} - {rname}"
            self.child_rule_combo.addItem(disp, rid)
    def load_link_view(self):
        self.link_view.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows = c.fetchall()
        for row in rows:
            r = self.link_view.rowCount()
            self.link_view.insertRow(r)
            self.link_view.setItem(r, 0, QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r, 1, QTableWidgetItem(str(row[1])))
        self.link_view.resizeColumnsToContents()
    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                rids.append(int(it.text()))
        return rids
    def apply_gcs_to_selected(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "No Selection", "Select one or more rules first.")
            return
        is_global = 1 if self.global_checkbox.isChecked() else 0
        is_critical = 1 if self.critical_checkbox.isChecked() else 0
        scope_val = self.scope_combo.currentText().upper()
        msg = f"You are about to update {len(rids)} rule(s).\nSet IS_GLOBAL={is_global}, CRITICAL_RULE={is_critical}, CRITICAL_SCOPE='{scope_val}'.\nContinue?"
        confirm = QMessageBox.question(self, "Confirm", msg)
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            old = get_cursor_one(c)
            if not old:
                continue
            new_data = dict(old)
            old_status = old.get("APPROVAL_STATUS", "DRAFT")
            new_data["IS_GLOBAL"] = is_global
            new_data["CRITICAL_RULE"] = is_critical
            new_data["CRITICAL_SCOPE"] = scope_val
            try:
                update_rule(self.connection, new_data, "Admin", "Admin")
            except Exception as ex:
                logger.error(f"Error updating rule {rid}: {ex}")
                continue
            was_approved = (old_status == "APPROVED")
            if was_approved and (is_global == 1 or is_critical == 1):
                c2 = self.connection.cursor()
                c2.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                WHERE RULE_ID=?
                """, (rid,))
                c2.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rid,))
                self.connection.commit()
                if is_global == 0:
                    impacted = find_impacted_business_groups(self.connection, rid)
                    create_multistep_approvals(self.connection, rid, impacted)
                    logger.info(f"Rule {rid} re-initiated approvals after turning critical.")
                else:
                    logger.info(f"Rule {rid} set to global; skipping multi-step approvals.")
        QMessageBox.information(self, "Done", "Global/Critical/Scope updated.")
        self.load_rule_list()
    def show_impacted_descendants(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "Select a rule first.")
            return
        children_map, _ = build_rule_adjacency(self.connection)
        lines = []
        for rid in rids:
            visited = set()
            stack = [rid]
            desc = set()
            while stack:
                curr = stack.pop()
                if curr in visited:
                    continue
                visited.add(curr)
                if curr in children_map:
                    for child_id in children_map[curr]:
                        desc.add(child_id)
                        stack.append(child_id)
            lines.append(f"Rule {rid} => {len(desc)} impacted child(ren). IDs={sorted(desc)}")
        QMessageBox.information(self, "Impacted Descendants", "\n".join(lines))
    def link_child(self):
        pid = self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self, "No GCR Selected", "Pick a parent GCR from the combo.")
            return
        c = self.connection.cursor()
        c.execute("SELECT IS_GLOBAL, CRITICAL_RULE FROM BRM_RULES WHERE RULE_ID=?", (pid,))
        rowp = c.fetchone()
        if not rowp:
            QMessageBox.warning(self, "No Parent Found", f"Rule {pid} not found.")
            return
        if rowp[0] != 1 and rowp[1] != 1:
            QMessageBox.warning(self, "Invalid Parent", "Selected rule is neither global nor critical.")
            return
        cid = self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self, "No Child", "Select a child rule.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Link child {cid} => parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        def would_create_cycle(p_id, c_id):
            full_children_map, _ = build_rule_adjacency(self.connection)
            stack = [c_id]
            visited = set()
            while stack:
                node = stack.pop()
                if node in visited:
                    continue
                visited.add(node)
                if node == p_id:
                    return True
                if node in full_children_map:
                    stack.extend(full_children_map[node])
            return False
        if would_create_cycle(pid, cid):
            QMessageBox.warning(self, "Cycle Detected", f"Linking parent {pid} -> child {cid} creates a cycle.")
            return
        try:
            c.execute("INSERT OR IGNORE INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID) VALUES(?,?)", (pid, cid))
            add_audit_log(self.connection, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{pid}->{cid}", "Admin", None, {"parent_id": pid, "child_id": cid})
            self.connection.commit()
            QMessageBox.information(self, "Linked", f"Child {cid} => parent {pid}")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_link_view()
    def unlink_child(self):
        pid = self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self, "No GCR Selected", "Pick a parent GCR.")
            return
        cid = self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self, "No Child", "Pick a child rule.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Unlink child {cid} from parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?", (pid, cid))
            add_audit_log(self.connection, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{pid}->{cid}", "Admin", {"parent_id": pid, "child_id": cid}, None)
            self.connection.commit()
            QMessageBox.information(self, "Unlinked", f"Child {cid} removed from parent {pid}")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_link_view()

###############################################################################
# Enhanced Lineage Graph Widget
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.node_map = {}      # rule_id -> QGraphicsItem
        self.children_map = {}
        self.parents_map = {}
        self.populate_graph()
    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, RULE_TYPE_ID, CLUSTER_NAME,
               IS_GLOBAL, CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rules = get_cursor_rows(c)
        if not rules:
            txt_item = QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(txt_item)
            return
        for r in rules:
            rid = r["RULE_ID"]
            pid = r["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid, []).append(rid)
                self.parents_map[rid] = pid
            else:
                self.parents_map[rid] = None
        rule_lookup = {r["RULE_ID"]: r for r in rules}
        all_ids = set(r["RULE_ID"] for r in rules)
        child_ids = set([r for r in self.parents_map.keys() if self.parents_map[r] is not None])
        roots = list(all_ids - child_ids)
        queue = deque()
        level_map = {}
        visited = set()
        for rt in roots:
            queue.append((rt, 0))
        while queue:
            (rid, depth) = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            rinfo = rule_lookup[rid]
            count_at_depth = level_map.get(depth, 0)
            level_map[depth] = count_at_depth + 1
            x = depth * 220
            y = count_at_depth * 120
            node_item = self.create_node(rinfo)
            node_item.setPos(x, y)
            self.scene.addItem(node_item)
            self.node_map[rid] = node_item
            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch, depth+1))
        for r in rules:
            pid = r["PARENT_RULE_ID"]
            rid = r["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])
        c.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps = get_cursor_rows(c)
        table_node_map = {}
        table_index = 0
        for dep in deps:
            key = f"{dep['DATABASE_NAME']}.{dep['TABLE_NAME']}".strip(".")
            if key not in table_node_map:
                t_item = QtWidgets.QGraphicsEllipseItem(0, 0, 100, 40)
                t_item.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
                t_item.setPen(QtGui.QPen(QtCore.Qt.black, 2))
                t_item.setPos(800, table_index * 60)
                t_item.setToolTip(f"Table: {key}")
                self.scene.addItem(t_item)
                table_node_map[key] = t_item
                table_index += 1
            rule_id = dep["RULE_ID"]
            if rule_id in self.node_map:
                self.draw_edge(self.node_map[rule_id], table_node_map[key], color=QtGui.QColor("darkmagenta"))
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()
    def create_node(self, rinfo):
        rtype = rinfo["RULE_TYPE_ID"]
        status = rinfo["STATUS"]
        cluster = rinfo.get("CLUSTER_NAME", "") or ""
        is_global = rinfo["IS_GLOBAL"]
        is_crit = rinfo["CRITICAL_RULE"]
        if rtype == 1:
            node = QtWidgets.QGraphicsRectItem(0, 0, 120, 50)
        else:
            node = QtWidgets.QGraphicsEllipseItem(0, 0, 120, 50)
        if status.lower() == "active":
            basecol = QtGui.QColor("lightgreen")
        else:
            basecol = QtGui.QColor("tomato")
        if cluster:
            hv = abs(hash(cluster)) % 360
            basecol = QtGui.QColor.fromHsv(hv, 128, 255)
        node.setBrush(QtGui.QBrush(basecol))
        pen = QtGui.QPen(QtCore.Qt.black, 2)
        if is_crit == 1:
            pen = QtGui.QPen(QtGui.QColor("red"), 3)
        node.setPen(pen)
        display_name = rinfo["RULE_NAME"]
        if is_global == 1:
            display_name = f"(G) {display_name}"
        node.setToolTip(f"Rule {rinfo['RULE_ID']}: {display_name}")
        return node
    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1 = item1.sceneBoundingRect()
        r2 = item2.sceneBoundingRect()
        p1 = r1.center()
        p2 = r2.center()
        line = QtWidgets.QGraphicsLineItem(p1.x(), p1.y(), p2.x(), p2.y())
        line.setPen(QtGui.QPen(color, 2))
        self.scene.addItem(line)
    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item, (QtWidgets.QGraphicsRectItem, QtWidgets.QGraphicsEllipseItem)):
                self.show_rule_details(item.toolTip())
        super().mousePressEvent(event)
    def show_rule_details(self, tooltip):
        QMessageBox.information(self, "Rule Details", tooltip)
    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setPen(QtGui.QPen(QtCore.Qt.black, 2))
    def search_nodes(self, query):
        self.clear_highlights()
        ql = query.lower()
        c = self.connection.cursor()
        found_rules = set()
        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE LOWER(RULE_NAME) LIKE ? OR LOWER(RULE_SQL) LIKE ?
           OR LOWER(DESCRIPTION) LIKE ? OR LOWER(BUSINESS_JUSTIFICATION) LIKE ?
           OR CAST(RULE_ID AS VARCHAR(50)) LIKE ?
        """, (f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%"))
        for r in get_cursor_rows(c):
            found_rules.add(r["RULE_ID"])
        c.execute("""
        SELECT RULE_ID
        FROM BRM_COLUMN_MAPPING
        WHERE LOWER(SOURCE_COLUMN_NAME) LIKE ? OR LOWER(TARGET_COLUMN_NAME) LIKE ?
        """, (f"%{ql}%", f"%{ql}%"))
        for r in get_cursor_rows(c):
            found_rules.add(r["RULE_ID"])
        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE LOWER(DATABASE_NAME) LIKE ? OR LOWER(TABLE_NAME) LIKE ?
        """, (f"%{ql}%", f"%{ql}%"))
        for r in get_cursor_rows(c):
            found_rules.add(r["RULE_ID"])
        if not found_rules:
            QMessageBox.information(self, "No Match", f"No match for '{query}'")
            return
        for rid in found_rules:
            if rid in self.node_map:
                self.node_map[rid].setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
                self.highlight_ancestors(rid)
                self.highlight_descendants(rid)
    def highlight_ancestors(self, start_id):
        cur = start_id
        while cur in self.parents_map and self.parents_map[cur]:
            node = self.node_map.get(cur)
            if node:
                node.setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
            par = self.parents_map[cur]
            if par in self.node_map:
                self.node_map[par].setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
            cur = par
    def highlight_descendants(self, start_id):
        queue = [start_id]
        visited = set()
        while queue:
            cid = queue.pop()
            if cid in visited:
                continue
            visited.add(cid)
            if cid in self.node_map:
                self.node_map[cid].setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
            if cid in self.children_map:
                queue.extend(self.children_map[cid])

###############################################################################
# Multi-Step Approval Tab
###############################################################################
class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.layout().setSpacing(5)
        stages = ["BG1", "BG2", "BG3", "FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20, 20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st, "NotStarted")
            if status == "Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status == "Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status == "Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.appr_table = QTableWidget(0, 7)
        self.appr_table.setHorizontalHeaderLabels(["Rule ID", "Group Name", "Rule Name", "Stage", "Approved?", "Action", "Pipeline"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)
        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_approvals()
    def load_approvals(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
        WHERE A.USERNAME = ? AND A.APPROVED_FLAG = 0
        ORDER BY A.RULE_ID
        """, (self.logged_in_username,))
        rows = get_cursor_rows(c)
        pipeline_data = {}
        all_app = self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        for apr in get_cursor_rows(all_app):
            rid = apr["RULE_ID"]
            grp = apr["GROUP_NAME"]
            stage = apr["APPROVAL_STAGE"]
            flag = apr["APPROVED_FLAG"]
            pipeline_data.setdefault(rid, {"BG1": "NotStarted", "BG2": "NotStarted", "BG3": "NotStarted", "FINAL": "NotStarted"})
            if flag == 1:
                pipeline_data[rid][grp] = "Approved"
            else:
                cur_st = get_current_approval_stage(self.connection, rid)
                if cur_st == stage:
                    pipeline_data[rid][grp] = "Pending"
        minimal_rows = []
        for rd in rows:
            rid = rd["RULE_ID"]
            st = rd["APPROVAL_STAGE"]
            min_st = get_current_approval_stage(self.connection, rid)
            if min_st == st:
                minimal_rows.append(rd)
        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r, 1, QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r, 2, QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r, 3, QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r, 4, QTableWidgetItem(str(rd["APPROVED_FLAG"])))
            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, r_idx=r: self.do_approve(r_idx))
            self.appr_table.setCellWidget(r, 5, approve_btn)
            pipe_map = pipeline_data.get(rd["RULE_ID"], {"BG1": "NotStarted", "BG2": "NotStarted", "BG3": "NotStarted", "FINAL": "NotStarted"})
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r, 6, pipe_widget)
    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index, 0)
        grp_item = self.appr_table.item(row_index, 1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        grp = grp_item.text()
        c = self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG = 1, APPROVED_TIMESTAMP = CURRENT_TIMESTAMP
        WHERE RULE_ID = ? AND GROUP_NAME = ? AND USERNAME = ?
        """, (rule_id, grp, self.logged_in_username))
        nxt = get_current_approval_stage(self.connection, rule_id)
        if nxt is None:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS = 'APPROVED', STATUS = 'ACTIVE' WHERE RULE_ID = ?", (rule_id,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS', STATUS = 'INACTIVE' WHERE RULE_ID = ?", (rule_id,))
        add_audit_log(self.connection, "UPDATE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, {"APPROVED_FLAG": 0}, {"APPROVED_FLAG": 1})
        self.connection.commit()
        QMessageBox.information(self, "Approved", f"You approved rule {rule_id}.")
        self.load_approvals()

###############################################################################
# Control Tables, Search Rule Dialog, Rule Dashboard, Business Rule Management Tab
###############################################################################
class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)
        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID", "Name", "SQL", "Status", "Version", "Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_results()
    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """, (f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows = get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r, 0, QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r, 1, QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r, 2, QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r, 3, QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r, 4, QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r, 5, QTableWidgetItem(row["CREATED_BY"]))

class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1
        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        self.status_filter.addItem("DELETED", "DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)
        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Name", "SQL", "Status", "Version", "Owner Group",
            "Created Timestamp", "Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)
        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)
        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)
        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)
        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics)
        btn_h.addWidget(analytics_btn)
        simulate_btn = QPushButton("Simulate Rule")
        simulate_btn.clicked.connect(self.simulate_rule)
        btn_h.addWidget(simulate_btn)
        impact_btn = QPushButton("Impact Analysis")
        impact_btn.clicked.connect(self.analyze_impact)
        btn_h.addWidget(impact_btn)
        history_btn = QPushButton("Version History")
        history_btn.clicked.connect(self.show_history)
        btn_h.addWidget(history_btn)
        btn_h.addStretch()
        main_layout.addLayout(btn_h)
        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.load_rules()
    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        QMessageBox.information(self, "ETL", f"ETL finished.\nExecuted: {executed}\nSkipped: {list(skipped)}")
        self.load_rules()
    def show_analytics(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()
    def build_filter_query(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            if st.upper() == "DELETED":
                filters.append("(RULE_ID IN (SELECT CAST(RECORD_ID AS INT) FROM BRM_AUDIT_LOG WHERE ACTION='DELETE' AND ISNUMERIC(RECORD_ID)=1))")
            else:
                filters.append("STATUS=?")
                params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params
    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        c.execute(f"SELECT COUNT(*) AS ccount FROM BRM_RULES WHERE {clause}", params)
        rowc = get_cursor_one(c)
        total = rowc["ccount"] if rowc else 0
        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        elif self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page
        c.execute(f"""
        SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
               CREATED_TIMESTAMP, APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """, (*params, offset, self.records_per_page))
        rows = get_cursor_rows(c)
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r, 1, QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r, 2, QTableWidgetItem(rd["RULE_SQL"]))
            st_item = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower() == "active":
                st_item.setBackground(QColor(144, 238, 144))
            else:
                st_item.setBackground(QColor(255, 182, 193))
            self.rule_table.setItem(r, 3, st_item)
            self.rule_table.setItem(r, 4, QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r, 5, QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r, 6, QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r, 7, QTableWidgetItem(rd["APPROVAL_STATUS"]))
    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row, 0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id = None
    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                rids.append(int(it.text()))
        return rids
    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()
    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()
    def simulate_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No Selection", "Please select a rule to simulate.")
            return
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (self.selected_rule_id,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Not Found", "Rule SQL not found.")
            return
        dlg = RuleSimulationDialog(self.connection, row["RULE_SQL"], self)
        dlg.exec_()
    def analyze_impact(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No Selection", "Please select a rule for impact analysis.")
            return
        dlg = ImpactAnalysisDialog(self.connection, self.selected_rule_id, self)
        dlg.exec_()
    def show_history(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No Selection", "Please select a rule to view version history.")
            return
        dlg = VersionHistoryDialog(self.connection, self.selected_rule_id, self)
        dlg.exec_()

###############################################################################
# Business Rule Management Tab
###############################################################################
class BusinessRuleManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)
        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)
        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)
        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)
        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)
        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        layout.addWidget(self.rule_dash)
        layout.addStretch()
        self.setLayout(layout)
    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()
    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self, "No Selection", "Select a rule first.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Not Found", "No rule with that ID.")
            return
        rule_data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()
    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rules selected.")
            return
        success = 0
        fails = []
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rr}: {str(ex)}")
        msg = f"Deactivation done. success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dash.load_rules()
    def on_delete_rule(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule(s) selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        fails = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rid}: {str(ex)}")
        msg = f"Deletion done. success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dash.load_rules()

###############################################################################
# Group Management Tab (Admin Only)
###############################################################################
class GroupManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        if user_group != "Admin":
            layout = QVBoxLayout(self)
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return
        layout = QVBoxLayout(self)
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)
        # Groups & Membership tab
        gm_tab = QWidget()
        gm_layout = QVBoxLayout(gm_tab)
        grp_box = QGroupBox("Group Details")
        grp_layout = QVBoxLayout(grp_box)
        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name", "Description", "Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)
        btn_h = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        btn_h.addWidget(add_grp_btn)
        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        btn_h.addWidget(rename_grp_btn)
        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        btn_h.addWidget(del_grp_btn)
        # (Backup/Restore functions can be added here as needed)
        btn_h.addStretch()
        grp_layout.addLayout(btn_h)
        gm_layout.addWidget(grp_box)
        membership_box = QGroupBox("Membership Management")
        membership_layout = QVBoxLayout(membership_box)
        self.users_table = QTableWidget(0, 3)
        self.users_table.setHorizontalHeaderLabels(["User ID", "Username", "Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)
        memb_btn_h = QHBoxLayout()
        add_usr_btn = QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btn_h.addWidget(add_usr_btn)
        rem_usr_btn = QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btn_h.addWidget(rem_usr_btn)
        memb_btn_h.addStretch()
        membership_layout.addLayout(memb_btn_h)
        gm_layout.addWidget(membership_box)
        self.tabs.addTab(gm_tab, "Groups & Membership")
        # Permissions tab
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        perm_box = QGroupBox("Group Permissions")
        perm_box_layout = QVBoxLayout(perm_box)
        ptop_h = QHBoxLayout()
        ptop_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo = QComboBox()
        ptop_h.addWidget(self.perm_group_combo)
        ptop_h.addStretch()
        perm_box_layout.addLayout(ptop_h)
        self.perm_table = QTableWidget(0, 1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)
        pbtn_h = QHBoxLayout()
        add_perm_btn = QPushButton("Add Permission")
        add_perm_btn.clicked.connect(self.on_add_permission)
        pbtn_h.addWidget(add_perm_btn)
        rem_perm_btn = QPushButton("Remove Permission")
        rem_perm_btn.clicked.connect(self.on_remove_permission)
        pbtn_h.addWidget(rem_perm_btn)
        pbtn_h.addStretch()
        perm_box_layout.addLayout(pbtn_h)
        perm_layout.addWidget(perm_box)
        self.tabs.addTab(perm_tab, "Group Permissions")
        # Approvers tab
        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        ah = QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo = QComboBox()
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)
        self.appr_table = QTableWidget(0, 2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID", "Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)
        appr_btn_h = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btn_h.addWidget(add_appr_btn)
        del_appr_btn = QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btn_h.addWidget(del_appr_btn)
        appr_btn_h.addStretch()
        appr_layout.addLayout(appr_btn_h)
        self.tabs.addTab(appr_tab, "Approvers Management")
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_data()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()
    def load_groups(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = get_cursor_rows(c)
        self.groups_table.setRowCount(0)
        for row in rows:
            r = self.groups_table.rowCount()
            self.groups_table.insertRow(r)
            self.groups_table.setItem(r, 0, QTableWidgetItem(row["GROUP_NAME"]))
            self.groups_table.setItem(r, 1, QTableWidgetItem(row["DESCRIPTION"] or ""))
            self.groups_table.setItem(r, 2, QTableWidgetItem(row["EMAIL"] or ""))
    def load_users(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = get_cursor_rows(c)
        self.users_table.setRowCount(0)
        for row in rows:
            r = self.users_table.rowCount()
            self.users_table.insertRow(r)
            self.users_table.setItem(r, 0, QTableWidgetItem(str(row["USER_ID"])))
            self.users_table.setItem(r, 1, QTableWidgetItem(row["USERNAME"]))
            self.users_table.setItem(r, 2, QTableWidgetItem(row["USER_GROUP"]))
    def load_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = get_cursor_rows(c)
        self.perm_group_combo.clear()
        for r in rows:
            self.perm_group_combo.addItem(r["GROUP_NAME"], r["GROUP_NAME"])
    def load_appr_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = get_cursor_rows(c)
        self.appr_group_combo.clear()
        for r in rows:
            self.appr_group_combo.addItem(r["GROUP_NAME"], r["GROUP_NAME"])
    def load_permissions(self):
        grp = self.perm_group_combo.currentText().strip()
        c = self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (grp,))
        rows = get_cursor_rows(c)
        self.perm_table.setRowCount(0)
        for row in rows:
            r = self.perm_table.rowCount()
            self.perm_table.insertRow(r)
            self.perm_table.setItem(r, 0, QTableWidgetItem(row["TARGET_TABLE"]))
    def load_approvers(self):
        grp = self.appr_group_combo.currentText().strip()
        c = self.connection.cursor()
        c.execute("SELECT APPROVER_ID, USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (grp,))
        rows = get_cursor_rows(c)
        self.appr_table.setRowCount(0)
        for row in rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r, 0, QTableWidgetItem(str(row["APPROVER_ID"])))
            self.appr_table.setItem(r, 1, QTableWidgetItem(row["USERNAME"]))
    def get_selected_group(self):
        idx = self.groups_table.currentRow()
        if idx < 0:
            return None
        it = self.groups_table.item(idx, 0)
        if not it:
            return None
        return it.text().strip()
    def on_add_group(self):
        name, ok = QInputDialog.getText(self, "Add Group", "Group Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Add Group", "Description:")
        if not ok2:
            desc = ""
        email, ok3 = QInputDialog.getText(self, "Add Group", "Email:")
        if not ok3:
            email = ""
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (name.strip(),))
        if get_cursor_one(c):
            QMessageBox.warning(self, "Error", "Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)", (name.strip(), desc.strip(), email.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Success", "Group added.")
        self.load_data()
    def on_rename_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self, "No Selection", "No group selected.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", "New group name:")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
        if get_cursor_one(c):
            QMessageBox.warning(self, "Error", "New group name already exists.")
            return
        try:
            c.execute("BEGIN")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), grp))
            c.execute("UPDATE BRM_RULE_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), grp))
            c.execute("COMMIT")
            add_audit_log(self.connection, "RENAME_GROUP", "BUSINESS_GROUPS", grp, "Admin", {"old_group_name": grp}, {"new_group_name": new_name.strip()})
            QMessageBox.information(self, "Renamed", f"Renamed to {new_name}")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
    def on_delete_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self, "No Selection", "No group selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{grp}'?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (grp,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Group deleted.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def on_add_user_to_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self, "None", "No user.")
            return
        grp, ok = QInputDialog.getText(self, "Add to Group", "Group name:")
        if not ok or not grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (grp.strip(),))
        if not get_cursor_one(c):
            QMessageBox.warning(self, "Error", "Group not found.")
            return
        c.execute("SELECT * FROM USERS WHERE USER_ID=?", (uid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Error", "User not found.")
            return
        if row["USER_GROUP"] == grp.strip():
            QMessageBox.warning(self, "Error", "User already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?", (grp.strip(), uid))
        self.connection.commit()
        QMessageBox.information(self, "Success", "User added to group.")
        self.load_data()
    def on_remove_user_from_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self, "None", "No user.")
            return
        confirm = QMessageBox.question(self, "Confirm", "Remove user from group? (Will move user to BG1)")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?", (uid,))
        self.connection.commit()
        QMessageBox.information(self, "Success", "User moved to BG1.")
        self.load_data()
    def get_selected_user(self):
        row = self.users_table.currentRow()
        if row < 0:
            return None
        it = self.users_table.item(row, 0)
        if not it:
            return None
        return int(it.text())
    def on_add_permission(self):
        grp = self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        tbl, ok = QInputDialog.getText(self, "Add Permission", "Target table:")
        if not ok or not tbl.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME, TARGET_TABLE) VALUES(?,?)", (grp.strip(), tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Success", f"Permission {tbl} => {grp}")
        self.load_permissions()
    def on_remove_permission(self):
        grp = self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self, "None", "No group.")
            return
        row = self.perm_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No permission row.")
            return
        it = self.perm_table.item(row, 0)
        if not it:
            return
        tbl = it.text().strip()
        confirm = QMessageBox.question(self, "Confirm", f"Remove {tbl} from {grp}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?", (grp, tbl))
        self.connection.commit()
        QMessageBox.information(self, "Success", f"Removed {tbl} from {grp}")
        self.load_permissions()
    def on_add_approver(self):
        grp = self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self, "None", "No group.")
            return
        username, ok = QInputDialog.getText(self, "Add Approver", "Username:")
        if not ok or not username.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?", (username.strip(),))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Error", "User not found.")
            return
        c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES(?,?)", (grp.strip(), username.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", f"{username} added as approver for {grp}")
        self.load_approvers()
    def on_remove_approver(self):
        grp = self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self, "None", "No group.")
            return
        row = self.appr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No row selected.")
            return
        it = self.appr_table.item(row, 0)
        if not it:
            return
        appr_id = it.text().strip()
        confirm = QMessageBox.question(self, "Confirm", f"Remove approver {appr_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?", (appr_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Approver removed.")
        self.load_approvers()

###############################################################################
# User Management Tab (Admin Only)
###############################################################################
class UserManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.users_table = QTableWidget(0, 4)
        self.users_table.setHorizontalHeaderLabels(["User ID", "Username", "Password", "User Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        self.users_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.users_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.users_table)
        btn_row = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_row.addWidget(add_btn)
        upd_btn = QPushButton("Update User")
        upd_btn.clicked.connect(self.update_user)
        btn_row.addWidget(upd_btn)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_row.addWidget(del_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_users()
    def load_users(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = get_cursor_rows(c)
        self.users_table.setRowCount(0)
        for row in rows:
            r = self.users_table.rowCount()
            self.users_table.insertRow(r)
            self.users_table.setItem(r, 0, QTableWidgetItem(str(row["USER_ID"])))
            self.users_table.setItem(r, 1, QTableWidgetItem(row["USERNAME"]))
            self.users_table.setItem(r, 2, QTableWidgetItem(row["PASSWORD"]))
            self.users_table.setItem(r, 3, QTableWidgetItem(row["USER_GROUP"]))
    def get_selected_user_id(self):
        sel = self.users_table.selectedItems()
        if not sel:
            return None
        row = sel[0].row()
        uid_item = self.users_table.item(row, 0)
        if uid_item:
            return int(uid_item.text())
        return None
    def add_user(self):
        uname, ok = QInputDialog.getText(self, "Add User", "Username:")
        if not ok or not uname.strip():
            return
        pw, ok2 = QInputDialog.getText(self, "Add User", "Password:")
        if not ok2 or not pw.strip():
            return
        grp, ok3 = QInputDialog.getText(self, "Add User", "User Group:")
        if not ok3 or not grp.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?,?,?)", (uname.strip(), pw.strip(), grp.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Success", "User added.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def update_user(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM USERS WHERE USER_ID=?", (uid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "None", "User not found.")
            return
        old_un = row["USERNAME"]
        old_pw = row["PASSWORD"]
        old_grp = row["USER_GROUP"]
        new_un, ok = QInputDialog.getText(self, "Update User", "New Username:", text=old_un)
        if not ok or not new_un.strip():
            return
        new_pw, ok2 = QInputDialog.getText(self, "Update User", "New Password:", text=old_pw)
        if not ok2 or not new_pw.strip():
            return
        new_grp, ok3 = QInputDialog.getText(self, "Update User", "New Group:", text=old_grp)
        if not ok3 or not new_grp.strip():
            return
        try:
            c.execute("UPDATE USERS SET USERNAME=?, PASSWORD=?, USER_GROUP=? WHERE USER_ID=?", (new_un.strip(), new_pw.strip(), new_grp.strip(), uid))
            self.connection.commit()
            QMessageBox.information(self, "Success", "User updated.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def delete_user(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", "Delete user?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?", (uid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "User removed.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# Metadata Synchronization Stub
###############################################################################
def sync_metadata(connection):
    logger.info("Synchronizing metadata with external catalog...")
    QMessageBox.information(None, "Sync Metadata", "Metadata synchronization completed successfully.")

###############################################################################
# Login Dialog
###############################################################################
class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)
        layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)
        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)
    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        query = "SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?"
        c.execute(query, (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

###############################################################################
# Main Window
###############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Integrated Enhanced Version")
        self.resize(1200, 800)
        self.connection = None
        dlg = DatabaseConnectionDialog()
        if dlg.exec_() == QDialog.Accepted:
            self.connection = dlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = self.login_dialog.user_id
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowu = get_cursor_one(c)
        self.logged_in_username = rowu["USERNAME"] if rowu else "Unknown"
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowg = get_cursor_one(c)
        self.user_group = rowg["USER_GROUP"] if rowg else "Unknown"
        self.init_ui()
    def init_ui(self):
        menubar = self.menuBar()
        fileMenu = menubar.addMenu("File")
        syncAction = QtWidgets.QAction("Sync Metadata", self)
        syncAction.triggered.connect(lambda: sync_metadata(self.connection))
        fileMenu.addAction(syncAction)
        metricsAction = QtWidgets.QAction("View Metrics Dashboard", self)
        metricsAction.triggered.connect(self.show_metrics_dashboard)
        fileMenu.addAction(metricsAction)
        schedAction = QtWidgets.QAction("Schedule a Rule", self)
        schedAction.triggered.connect(lambda: RuleSchedulerDialog(self.connection, self).exec_())
        fileMenu.addAction(schedAction)
        cw = QWidget()
        layout = QVBoxLayout(cw)
        if self.user_group == "Admin":
            top_h = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")
        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lw_container = QWidget()
        lw_layout = QVBoxLayout(lw_container)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        lw_layout.addWidget(self.lineage_tab)
        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/desc/col/db/table...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        self.tabs.addTab(lw_container, "Lineage Visualization")
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")
        self.custom_tab = CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab, "Custom Rule Groups")
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")
        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")
        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Schedule Management")
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics Dashboard")
        cw.setLayout(layout)
        self.setCentralWidget(cw)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)
        self.show()
    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in get_cursor_rows(c):
            disp = f"{row['USERNAME']} ({row['USER_GROUP']})"
            self.switch_combo.addItem(disp, (row["USER_ID"], row["USER_GROUP"]))
    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid == self.user_id and new_grp == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        self.reinit_tabs()
    def reinit_tabs(self):
        self.tabs.clear()
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")
        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lw_container = QWidget()
        lw_layout = QVBoxLayout(lw_container)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        lw_layout.addWidget(self.lineage_tab)
        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/desc/col/db/table...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        self.tabs.addTab(lw_container, "Lineage Visualization")
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")
        self.custom_tab = CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab, "Custom Rule Groups")
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")
        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")
        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Schedule Management")
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics Dashboard")
    def refresh_approvals(self):
        self.approv_tab.load_approvals()
    def check_due_schedules(self):
        c = self.connection.cursor()
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        query = """
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE SCHEDULE_TIME <= ? AND STATUS = 'Scheduled'
        """
        c.execute(query, (now,))
        due = get_cursor_rows(c)
        for schedule in due:
            rule_id = schedule["RULE_ID"]
            c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = get_cursor_one(c)
            if row:
                rule_sql = row["RULE_SQL"]
                result, msg = run_rule_sql(self.connection, rule_sql)
                logger.info(f"Scheduled rule {rule_id} executed: {'PASS' if result else 'FAIL'} - {msg}")
            c.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?", (schedule["SCHEDULE_ID"],))
        self.connection.commit()
        self.schedule_tab.load_schedules()
    def show_metrics_dashboard(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Operational Metrics Dashboard")
        dlg.resize(800, 600)
        layout = QVBoxLayout(dlg)
        metrics_tab = MetricsDashboardTab(self.connection)
        layout.addWidget(metrics_tab)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        layout.addWidget(close_btn)
        dlg.exec_()
    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()
    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()
    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# Main
###############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()