#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: advanced_decision_tables.py
Description:
  This module provides deep integration for decision tables. It features:
    • A fully‐functional UI for managing decision tables (add, update, delete)
    • Execution of decision table logic with dry‐run simulation
      that logs the number of records impacted and returns detailed pass/fail notifications.
    • Real‑time notifications and auto‑refresh of the execution log.
    • Robust error handling and detailed logging.
    
Assumptions:
  • Decision tables are stored in a table named DECISION_TABLES with columns:
      DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY.
  • The DECISION_QUERY contains SQL that returns a value (typically 1 for PASS).
"""

import sys
import json
import logging
import pyodbc
import sqlparse
from datetime import datetime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QDialog, QLineEdit, QLabel, QMessageBox, QInputDialog,
    QPlainTextEdit, QFormLayout, QTextEdit
)
from PyQt5.QtCore import Qt, QTimer

# Configure module-specific logger
logger = logging.getLogger("advanced_decision_tables")

class AdvancedDecisionTablesTab(QWidget):
    """
    A QWidget for comprehensive management and execution of decision tables.
    This tab allows users to view, add, update, delete, and execute decision table logic.
    Execution is performed in a dry-run transaction that logs the number of impacted records
    along with a pass/fail outcome.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Advanced Decision Tables")
        self.layout = QVBoxLayout(self)
        self.init_ui()
        self.load_decision_tables()

    def init_ui(self):
        # Decision Tables Display
        self.dt_table = QTableWidget(0, 4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID", "Table Name", "Description", "Query"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        self.layout.addWidget(self.dt_table)

        # Control Buttons for CRUD and Execution
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_decision_table)
        btn_layout.addWidget(add_btn)

        update_btn = QPushButton("Update Decision Table")
        update_btn.clicked.connect(self.update_decision_table)
        btn_layout.addWidget(update_btn)

        delete_btn = QPushButton("Delete Decision Table")
        delete_btn.clicked.connect(self.delete_decision_table)
        btn_layout.addWidget(delete_btn)

        execute_btn = QPushButton("Execute Decision Table")
        execute_btn.clicked.connect(self.execute_decision_table)
        btn_layout.addWidget(execute_btn)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_decision_tables)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        self.layout.addLayout(btn_layout)

        # Execution Log Area (for simulation logging)
        self.execution_log = QPlainTextEdit()
        self.execution_log.setReadOnly(True)
        self.execution_log.setPlaceholderText("Decision Table Execution Log...")
        self.layout.addWidget(self.execution_log)

    def load_decision_tables(self):
        """
        Load decision table entries from the DECISION_TABLES table.
        Expected columns: DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY.
        """
        self.dt_table.setRowCount(0)
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.dt_table.rowCount()
                self.dt_table.insertRow(row_index)
                for col_index, val in enumerate(row):
                    self.dt_table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            logger.error(f"Error loading decision tables: {ex}")
            QMessageBox.critical(self, "Error", f"Error loading decision tables: {ex}")

    def add_decision_table(self):
        """
        Add a new decision table entry via input dialogs.
        """
        dt_name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not dt_name.strip():
            return
        description, ok = QInputDialog.getMultiLineText(self, "Add Decision Table", "Description:")
        if not ok:
            description = ""
        query, ok = QInputDialog.getMultiLineText(self, "Add Decision Table", "Decision Query (SQL):")
        if not ok or not query.strip():
            QMessageBox.warning(self, "Input Error", "Decision Query is required.")
            return

        try:
            c = self.connection.cursor()
            c.execute("""
                INSERT INTO DECISION_TABLES (TABLE_NAME, DESCRIPTION, DECISION_QUERY)
                VALUES (?, ?, ?)
            """, (dt_name.strip(), description.strip(), query.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Success", "Decision Table added successfully.")
            self.load_decision_tables()
        except Exception as ex:
            logger.error(f"Error adding decision table: {ex}")
            QMessageBox.critical(self, "Error", f"Error adding decision table: {ex}")

    def update_decision_table(self):
        """
        Update an existing decision table entry.
        """
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Selection Error", "No decision table selected.")
            return
        dt_id_item = self.dt_table.item(row, 0)
        if not dt_id_item:
            return
        dt_id = int(dt_id_item.text())
        current_name = self.dt_table.item(row, 1).text() if self.dt_table.item(row, 1) else ""
        current_desc = self.dt_table.item(row, 2).text() if self.dt_table.item(row, 2) else ""
        current_query = self.dt_table.item(row, 3).text() if self.dt_table.item(row, 3) else ""

        dt_name, ok = QInputDialog.getText(self, "Update Decision Table", "Table Name:", text=current_name)
        if not ok or not dt_name.strip():
            return
        description, ok = QInputDialog.getMultiLineText(self, "Update Decision Table", "Description:", text=current_desc)
        if not ok:
            description = current_desc
        query, ok = QInputDialog.getMultiLineText(self, "Update Decision Table", "Decision Query (SQL):", text=current_query)
        if not ok or not query.strip():
            QMessageBox.warning(self, "Input Error", "Decision Query is required.")
            return

        try:
            c = self.connection.cursor()
            c.execute("""
                UPDATE DECISION_TABLES
                SET TABLE_NAME = ?, DESCRIPTION = ?, DECISION_QUERY = ?
                WHERE DECISION_TABLE_ID = ?
            """, (dt_name.strip(), description.strip(), query.strip(), dt_id))
            self.connection.commit()
            QMessageBox.information(self, "Success", "Decision Table updated successfully.")
            self.load_decision_tables()
        except Exception as ex:
            logger.error(f"Error updating decision table: {ex}")
            QMessageBox.critical(self, "Error", f"Error updating decision table: {ex}")

    def delete_decision_table(self):
        """
        Delete the selected decision table.
        """
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Selection Error", "No decision table selected.")
            return
        dt_id_item = self.dt_table.item(row, 0)
        if not dt_id_item:
            return
        dt_id = int(dt_id_item.text())
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete Decision Table ID {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        try:
            c = self.connection.cursor()
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID = ?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision Table deleted successfully.")
            self.load_decision_tables()
        except Exception as ex:
            logger.error(f"Error deleting decision table: {ex}")
            QMessageBox.critical(self, "Error", f"Error deleting decision table: {ex}")

    def execute_decision_table(self):
        """
        Execute the decision table logic for the selected decision table.
        The query is executed in a dry-run transaction. The function logs the number of impacted
        records and provides a pass/fail result via detailed notifications.
        """
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Selection Error", "No decision table selected.")
            return
        dt_id_item = self.dt_table.item(row, 0)
        if not dt_id_item:
            return
        dt_id = int(dt_id_item.text())
        try:
            c = self.connection.cursor()
            c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID = ?", (dt_id,))
            row_query = c.fetchone()
            if not row_query or not row_query[0]:
                QMessageBox.warning(self, "No Query", "Selected decision table has no query defined.")
                return
            decision_query = row_query[0]
            # Begin dry-run execution
            c.execute("BEGIN TRANSACTION")
            c.execute(decision_query)
            result_rows = c.fetchall()
            impacted_count = len(result_rows)
            if result_rows:
                result_value = result_rows[0][0]
                pass_flag = (result_value == 1)
                message = f"Decision Table executed. Returned value: {result_value}. Records impacted: {impacted_count}."
            else:
                pass_flag = True
                message = f"Decision Table executed. No rows returned. Considered PASS by default."
            c.execute("ROLLBACK")  # Ensure no permanent change during simulation
            logger.info(f"Decision Table ID {dt_id} execution: {message}")
            self.execution_log.appendPlainText(message)
            if pass_flag:
                QMessageBox.information(self, "Decision Table Execution", message)
            else:
                QMessageBox.warning(self, "Decision Table Execution", message)
        except Exception as ex:
            c.execute("ROLLBACK")
            error_msg = f"Error executing decision table ID {dt_id}: {ex}"
            logger.error(error_msg)
            self.execution_log.appendPlainText(error_msg)
            QMessageBox.critical(self, "Execution Error", error_msg)


# For standalone testing
if __name__ == "__main__":
    from PyQt5.QtWidgets import QApplication
    app = QApplication(sys.argv)
    try:
        # Establish a test connection (replace with your DSN or connection string)
        connection = pyodbc.connect("DSN=YourDSN;Trusted_Connection=yes;")
    except Exception as ex:
        print(f"Database connection error: {ex}")
        sys.exit(1)
    window = AdvancedDecisionTablesTab(connection)
    window.show()
    sys.exit(app.exec_())