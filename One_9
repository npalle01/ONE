#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: defect_management.py
Description:
  • Provides a defect logging and management system for the Advanced BRM Tool.
  • DefectDialog: a QDialog to add or edit a single defect record.
  • DefectManagementTab: a QWidget that displays the defect logs, allows searching,
    adding/editing/deleting, and auto‑refreshing every 30 seconds.
    
Database Requirements:
  - BRM_DEFECT_LOGS(
       DEFECT_ID int PK, 
       RULE_ID int NULL,
       DESCRIPTION varchar(...), 
       SEVERITY varchar(20),
       REPORTER varchar(50),
       STATUS varchar(20),  -- e.g. 'Open','In Progress','Resolved','Closed'
       RESOLUTION varchar(...),
       TIMESTAMP datetime
    )
"""

import sys
import logging
from datetime import datetime
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QMessageBox, QDialog, QFormLayout, QLineEdit, QTextEdit,
    QComboBox, QPlainTextEdit, QInputDialog, QLabel
)
from core_foundation import logger, insert_audit_log

def add_defect_log(conn, rule_id, description, severity, reporter, status="Open", resolution=None):
    """
    Inserts a row into BRM_DEFECT_LOGS with the given details.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO BRM_DEFECT_LOGS(RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, RESOLUTION, TIMESTAMP)
            VALUES(?,?,?,?,?,?,GETDATE())
        """,(rule_id, description, severity, reporter, status, resolution))
        conn.commit()
        logger.info(f"Defect log added for rule {rule_id} by {reporter}.")
        insert_audit_log(conn, "ADD_DEFECT","BRM_DEFECT_LOGS", None, reporter, None,
                         {"rule_id":rule_id, "desc":description, "severity":severity})
    except Exception as ex:
        logger.error(f"Error adding defect log for rule {rule_id}: {ex}")
        raise

# -----------------------------------------------------------------------------
# 1. DefectDialog – QDialog to add/edit a defect
# -----------------------------------------------------------------------------
class DefectDialog(QDialog):
    """
    A dialog for adding or editing a defect record. 
    If defect_data is provided, we load it for editing.
    """
    def __init__(self, connection, defect_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.defect_data = defect_data
        self.setWindowTitle("Edit Defect" if defect_data else "Add New Defect")
        self.resize(500,400)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.rule_id_edit = QLineEdit()
        self.rule_id_edit.setPlaceholderText("Optional: Rule ID")
        form.addRow("Rule ID:", self.rule_id_edit)

        self.description_edit = QTextEdit()
        form.addRow("Description:", self.description_edit)

        self.severity_combo = QComboBox()
        self.severity_combo.addItems(["Low","Medium","High","Critical"])
        form.addRow("Severity:", self.severity_combo)

        self.reporter_edit = QLineEdit()
        form.addRow("Reporter:", self.reporter_edit)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["Open","In Progress","Resolved","Closed"])
        form.addRow("Status:", self.status_combo)

        self.resolution_edit = QTextEdit()
        form.addRow("Resolution:", self.resolution_edit)

        layout.addLayout(form)

        btn_h = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_defect)
        btn_h.addWidget(save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)

        if self.defect_data:
            self.load_existing_data()

    def load_existing_data(self):
        """
        Populate dialog fields with the existing defect data.
        """
        self.rule_id_edit.setText(str(self.defect_data.get("RULE_ID","")))
        self.description_edit.setPlainText(self.defect_data.get("DESCRIPTION",""))
        sev = self.defect_data.get("SEVERITY","Low")
        idx = self.severity_combo.findText(sev, Qt.MatchFixedString)
        if idx>=0:
            self.severity_combo.setCurrentIndex(idx)
        self.reporter_edit.setText(self.defect_data.get("REPORTER",""))
        st = self.defect_data.get("STATUS","Open")
        idx2 = self.status_combo.findText(st, Qt.MatchFixedString)
        if idx2>=0:
            self.status_combo.setCurrentIndex(idx2)
        self.resolution_edit.setPlainText(self.defect_data.get("RESOLUTION",""))

    def save_defect(self):
        """
        Insert or update the defect in DB, then close if successful.
        """
        try:
            rule_id_text = self.rule_id_edit.text().strip()
            rule_id = int(rule_id_text) if rule_id_text else None
        except ValueError:
            QMessageBox.warning(self, "Input Error", "Rule ID must be an integer or blank.")
            return

        description = self.description_edit.toPlainText().strip()
        if not description:
            QMessageBox.warning(self, "Input Error", "Description is required.")
            return
        severity = self.severity_combo.currentText()
        reporter = self.reporter_edit.text().strip()
        if not reporter:
            QMessageBox.warning(self, "Input Error", "Reporter is required.")
            return
        status = self.status_combo.currentText()
        resolution = self.resolution_edit.toPlainText().strip() or None

        c = self.connection.cursor()
        if self.defect_data:
            # update
            defect_id = self.defect_data["DEFECT_ID"]
            try:
                c.execute("""
                    UPDATE BRM_DEFECT_LOGS
                    SET RULE_ID=?, DESCRIPTION=?, SEVERITY=?, REPORTER=?,
                        STATUS=?, RESOLUTION=?, TIMESTAMP=GETDATE()
                    WHERE DEFECT_ID=?
                """,(rule_id, description, severity, reporter, status, resolution, defect_id))
                c.connection.commit()
                logger.info(f"Defect {defect_id} updated by {reporter}.")
                insert_audit_log(self.connection, "UPDATE_DEFECT","BRM_DEFECT_LOGS", defect_id, reporter,
                                 None, {"desc":description,"status":status})
            except Exception as ex:
                logger.error(f"Error updating defect {defect_id}: {ex}")
                QMessageBox.critical(self, "Error", str(ex))
                return
        else:
            # add new
            try:
                add_defect_log(self.connection, rule_id, description, severity, reporter, status, resolution)
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
                return

        self.accept()

# -----------------------------------------------------------------------------
# 2. DefectManagementTab – main UI for listing/managing defects
# -----------------------------------------------------------------------------
class DefectManagementTab(QWidget):
    """
    A tab that displays a table of BRM_DEFECT_LOGS, supports searching, adding,
    editing, deleting, and auto-refresh every 30 seconds.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.last_defect_count = 0
        layout = QVBoxLayout(self)

        self.notification_label = QLabel("")
        self.notification_label.setStyleSheet("color: green; font-weight:bold;")
        layout.addWidget(self.notification_label)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search defects...")
        self.search_edit.textChanged.connect(self.search_defects)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.defect_table = QTableWidget(0,7)
        self.defect_table.setHorizontalHeaderLabels([
            "Defect ID","Rule ID","Description","Severity","Reporter","Status","Timestamp"
        ])
        self.defect_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.defect_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Defect")
        add_btn.clicked.connect(self.add_defect)
        btn_h.addWidget(add_btn)

        edit_btn = QPushButton("Edit Defect")
        edit_btn.clicked.connect(self.edit_defect)
        btn_h.addWidget(edit_btn)

        del_btn = QPushButton("Delete Defect")
        del_btn.clicked.connect(self.delete_defect)
        btn_h.addWidget(del_btn)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_defects)
        btn_h.addWidget(refresh_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        # auto-refresh
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.auto_refresh)
        self.refresh_timer.start(30000)
        self.load_defects()

    def load_defects(self):
        self.defect_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DEFECT_ID, RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, TIMESTAMP
                FROM BRM_DEFECT_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            rows = c.fetchall()
            curr_count = len(rows)
            for row in rows:
                r_i = self.defect_table.rowCount()
                self.defect_table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.defect_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))
            if self.last_defect_count and curr_count>self.last_defect_count:
                new_count = curr_count - self.last_defect_count
                self.notification_label.setText(f"{new_count} new defect(s) logged.")
                QtCore.QTimer.singleShot(5000, lambda: self.notification_label.setText(""))
            self.last_defect_count = curr_count
        except Exception as ex:
            logger.error(f"Error loading defects: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def search_defects(self, text):
        text_lower = text.lower().strip()
        for row in range(self.defect_table.rowCount()):
            visible = False
            for col in range(self.defect_table.columnCount()):
                item = self.defect_table.item(row, col)
                if item and text_lower in item.text().lower():
                    visible = True
                    break
            self.defect_table.setRowHidden(row, not visible)

    def auto_refresh(self):
        self.load_defects()

    def add_defect(self):
        dlg = DefectDialog(self.connection)
        if dlg.exec_()==QDialog.Accepted:
            self.load_defects()

    def edit_defect(self):
        row = self.defect_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "No Selection", "Select a defect to edit.")
            return
        defect_data = {
            "DEFECT_ID": int(self.defect_table.item(row,0).text()),
            "RULE_ID": self.defect_table.item(row,1).text(),
            "DESCRIPTION": self.defect_table.item(row,2).text(),
            "SEVERITY": self.defect_table.item(row,3).text(),
            "REPORTER": self.defect_table.item(row,4).text(),
            "STATUS": self.defect_table.item(row,5).text(),
            "TIMESTAMP": self.defect_table.item(row,6).text()
        }
        dlg = DefectDialog(self.connection, defect_data=defect_data)
        if dlg.exec_()==QDialog.Accepted:
            self.load_defects()

    def delete_defect(self):
        row = self.defect_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "No Selection", "Select a defect to delete.")
            return
        defect_id = int(self.defect_table.item(row,0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete defect ID {defect_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?", (defect_id,))
            c.connection.commit()
            QMessageBox.information(self, "Deleted", f"Defect {defect_id} deleted.")
            self.load_defects()
        except Exception as ex:
            logger.error(f"Error deleting defect {defect_id}: {ex}")
            QMessageBox.critical(self, "Error", str(ex))