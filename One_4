#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: advanced_simulation.py
CREATE TABLE SIMULATION_LOGS (
  SIMULATION_ID INT IDENTITY PRIMARY KEY,
  RULE_ID INT,
  EXEC_TIMESTAMP DATETIME,
  SUCCESS_FLAG BIT,
  MESSAGE VARCHAR(1000),
  RECORD_COUNT INT
);
Description:
  This module provides an advanced simulation engine with chain (BFS) logic
  that can branch/fork if certain rules fail at critical stages.
  It also includes:
    • AdvancedSimulationEngine with forking support
    • A SimulationManagerWidget UI that logs simulations (including pass/fail, record counts)
      and provides an overview of recent simulations
    • A SingleRuleSimulationDialog for quick tests, plus a MultiRuleForkDialog
      for forking logic demonstration
    • All references to core_foundation for logging and auditing
"""

import sys
import logging
import pyodbc
from datetime import datetime
from collections import deque

from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox, QInputDialog,
    QDialog, QPlainTextEdit
)

from core_foundation import logger, insert_audit_log

# =============================================================================
# 1. AdvancedSimulationEngine – BFS or fork-based logic
# =============================================================================
class AdvancedSimulationEngine:
    """
    Provides BFS execution with potential for forking if a rule fails at a certain stage.
    Also logs results into SIMULATION_LOGS or passes them to the caller.
    """

    @staticmethod
    def run_single_rule_transaction(conn, rule_info, is_dry_run=True):
        """
        Execute a rule's SQL in a transaction. If is_dry_run, always rollback.
        Returns (ok, message, record_count).
        """
        c = conn.cursor()
        rule_id = rule_info.get("RULE_ID")
        sql_text = rule_info.get("RULE_SQL","").strip()

        c.execute("BEGIN TRANSACTION")
        success = False
        msg = ""
        impacted = 0
        try:
            if not sql_text:
                msg = "No SQL found; treat as PASS"
                success = True
            else:
                c.execute(sql_text)
                try:
                    rows = c.fetchall()
                except:
                    rows = []
                impacted = len(rows)
                if rows and len(rows[0])>0:
                    val = rows[0][0]
                    success = (val==1)
                    msg = f"Returned {val}"
                else:
                    success = True
                    msg = "No rows returned -> PASS"
            if is_dry_run or not success:
                c.execute("ROLLBACK")
            else:
                c.execute("COMMIT")
        except Exception as ex:
            c.execute("ROLLBACK")
            success = False
            msg = f"Simulation error: {ex}"
            logger.error(f"Rule {rule_id} simulation failed: {ex}")

        # Log to SIMULATION_LOGS if table exists
        AdvancedSimulationEngine.log_simulation_result(conn, rule_id, success, msg, impacted)
        return success, msg, impacted

    @staticmethod
    def log_simulation_result(conn, rule_id, success_flag, message, record_count):
        """
        Insert a row into SIMULATION_LOGS table, if it exists. 
        Columns: SIMULATION_ID (PK), RULE_ID, EXEC_TIMESTAMP, SUCCESS_FLAG, MESSAGE, RECORD_COUNT
        """
        c = conn.cursor()
        try:
            c.execute("""
                INSERT INTO SIMULATION_LOGS(RULE_ID, EXEC_TIMESTAMP, SUCCESS_FLAG, MESSAGE, RECORD_COUNT)
                VALUES(?, GETDATE(), ?, ?, ?)
            """,(rule_id, 1 if success_flag else 0, message, record_count))
            conn.commit()
            logger.debug(f"Sim log for rule {rule_id}: success={success_flag}, {record_count} recs, msg={message}")
        except Exception as ex:
            logger.error(f"Error logging simulation for rule {rule_id}: {ex}")

    @staticmethod
    def skip_descendants(fork_map, rule_id, skipped):
        stack = [rule_id]
        while stack:
            cur = stack.pop()
            if cur in skipped:
                continue
            skipped.add(cur)
            for child in fork_map.get(cur, []):
                stack.append(child)

    @staticmethod
    def execute_rules_with_fork(conn, start_rule_ids, is_dry_run=True):
        """
        BFS that can 'fork' if a rule fails. This is an advanced approach:
          - If rule is critical and fails, we skip all children (like normal).
          - If rule is 'forkable' and fails, we spawn a "rework" branch or alternative logic (example).
        For demonstration, let's check a hypothetical 'BRANCHING_RULE=1' to trigger a fork scenario.
        Returns (executed, skipped, forked).
        """
        c = conn.cursor()
        c.execute("""
            SELECT RULE_ID, PARENT_RULE_ID, CRITICAL_RULE, 
                   (CASE WHEN ISNULL(BRANCHING_RULE,0)=1 THEN 1 ELSE 0 END) as FORKABLE,
                   RULE_SQL
            FROM BRM_RULES
        """)
        rows = c.fetchall()

        rule_map = {}
        children_map = {}
        for (rid, pid, crit, forkable, rsql) in rows:
            rule_map[rid] = {
                "RULE_ID": rid,
                "PARENT_RULE_ID": pid,
                "CRITICAL_RULE": crit,
                "FORKABLE": forkable,
                "RULE_SQL": rsql
            }
            if pid:
                children_map.setdefault(pid,[]).append(rid)

        executed = []
        skipped = set()
        forked = []
        queue = list(start_rule_ids)

        while queue:
            rid = queue.pop(0)
            if rid in skipped:
                continue
            info = rule_map.get(rid)
            if not info:
                skipped.add(rid)
                continue
            (ok, msg, rec_count) = AdvancedSimulationEngine.run_single_rule_transaction(conn, info, is_dry_run)
            if ok:
                executed.append(rid)
                # Enqueue children
                for ch in children_map.get(rid, []):
                    if ch not in skipped:
                        queue.append(ch)
            else:
                # if critical, skip all descendants
                if info["CRITICAL_RULE"]==1:
                    AdvancedSimulationEngine.skip_descendants(children_map, rid, skipped)
                skipped.add(rid)
                # if forkable, create a "fork" scenario
                if info["FORKABLE"]==1:
                    forked.append(rid)
                    # In real usage, you'd create a new "forked rule" or path. 
                    # We'll simply log it for demonstration.

        return (executed, list(skipped), forked)

# =============================================================================
# 2. UI Dialogs – SingleRuleSimulationDialog, MultiRuleForkDialog
# =============================================================================

class SingleRuleSimulationDialog(QDialog):
    """
    A dialog for simulating a single rule. 
    Uses run_single_rule_transaction from AdvancedSimulationEngine.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Advanced Single Simulation - Rule {rule_id}")
        self.resize(500,400)
        layout = QVBoxLayout(self)

        self.info_label = QLabel("Ready to simulate rule.")
        layout.addWidget(self.info_label)

        self.output_area = QPlainTextEdit()
        self.output_area.setReadOnly(True)
        layout.addWidget(self.output_area)

        btn_run = QPushButton("Run Simulation")
        btn_run.clicked.connect(self.do_run)
        layout.addWidget(btn_run)

        btn_close = QPushButton("Close")
        btn_close.clicked.connect(self.close)
        layout.addWidget(btn_close)

    def do_run(self):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (self.rule_id,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Rule {self.rule_id} not found.")
            return
        rule_info = {"RULE_ID": row[0], "RULE_SQL": row[1]}
        (ok, msg, rec_count) = AdvancedSimulationEngine.run_single_rule_transaction(self.connection, rule_info, is_dry_run=True)
        result_str = (
            f"Rule {self.rule_id}\n"
            f"Pass? {ok}\n"
            f"Message: {msg}\n"
            f"Records impacted: {rec_count}"
        )
        self.output_area.setPlainText(result_str)
        QMessageBox.information(self, "Simulation Result", result_str)

class MultiRuleForkDialog(QDialog):
    """
    A demonstration of the forking BFS scenario. 
    User picks a starting rule, we run execute_rules_with_fork.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Multi-Rule Fork Simulation")
        self.resize(600,400)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.rule_combo = QtWidgets.QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            self.rule_combo.addItem(f"{row[0]} - {row[1]}", row[0])
        top_h.addWidget(QtWidgets.QLabel("Start Rule:"))
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)

        self.output_area = QPlainTextEdit()
        self.output_area.setReadOnly(True)
        layout.addWidget(self.output_area)

        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Run Fork Simulation")
        run_btn.clicked.connect(self.run_fork_sim)
        btn_layout.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)

    def run_fork_sim(self):
        start_rule = self.rule_combo.currentData()
        executed, skipped, forked = AdvancedSimulationEngine.execute_rules_with_fork(self.connection, [start_rule], is_dry_run=True)
        out = (
            f"Starting from rule {start_rule}\n"
            f"Executed: {executed}\n"
            f"Skipped: {skipped}\n"
            f"Forked: {forked}"
        )
        self.output_area.setPlainText(out)
        QMessageBox.information(self, "Fork Simulation Complete", out)

# =============================================================================
# 3. SimulationManagerWidget – UI to display simulation logs and re-run
# =============================================================================

class SimulationManagerWidget(QWidget):
    """
    A widget that displays entries from SIMULATION_LOGS and allows the user to
    run new simulations quickly. Also auto-refreshes logs in real-time.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulation Manager")
        self.last_count = 0

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()

        self.rule_id_edit = QLineEdit()
        self.rule_id_edit.setPlaceholderText("Enter Rule ID to simulate")
        top_h.addWidget(QLabel("Rule ID:"))
        top_h.addWidget(self.rule_id_edit)

        run_btn = QPushButton("Run Sim")
        run_btn.clicked.connect(self.run_sim)
        top_h.addWidget(run_btn)

        layout.addLayout(top_h)

        self.log_table = QTableWidget(0,5)
        self.log_table.setHorizontalHeaderLabels(["RuleID","Timestamp","Success?","RecordCount","Message"])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        btn_h = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_h.addWidget(refresh_btn)

        multi_btn = QPushButton("Open Multi-Rule Fork Dialog")
        multi_btn.clicked.connect(self.open_fork_dialog)
        btn_h.addWidget(multi_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        # auto-refresh logs
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.load_logs)
        self.timer.start(30000)

        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT TOP 200 RULE_ID, CONVERT(varchar, EXEC_TIMESTAMP,120) AS ts,
                       SUCCESS_FLAG, RECORD_COUNT, MESSAGE
                FROM SIMULATION_LOGS
                ORDER BY EXEC_TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_i = self.log_table.rowCount()
                self.log_table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.log_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

        except Exception as ex:
            QMessageBox.critical(self, "Load Error", f"Error loading sim logs: {ex}")

    def run_sim(self):
        txt = self.rule_id_edit.text().strip()
        if not txt.isdigit():
            QMessageBox.warning(self, "Input Error", "Please enter a valid numeric Rule ID.")
            return
        rid = int(txt)
        # We'll do a single rule simulation
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Rule {rid} not found.")
            return
        rule_info = {"RULE_ID": row[0], "RULE_SQL": row[1]}
        (ok, msg, rec_count) = AdvancedSimulationEngine.run_single_rule_transaction(self.connection, rule_info, is_dry_run=True)
        out = (
            f"Rule {rid} => PASS? {ok}, records={rec_count}, msg={msg}"
        )
        QMessageBox.information(self, "Sim Result", out)
        self.load_logs()

    def open_fork_dialog(self):
        dlg = MultiRuleForkDialog(self.connection, self)
        dlg.exec_()
        self.load_logs()