#!/usr/bin/env python
"""
BRM Tool – Production-Ready Single File
Features:
  - In-Memory SQLite or SQL Server (via pyodbc)
  - Tables creation/seed (for SQLite)
  - Full CRUD with multi-step approvals (Approve + Decline)
  - Global/Critical Admin logic
  - Group Management, User Management
  - Custom Rule Groups
  - Control Tables viewer
  - Hierarchy View
  - Advanced end-to-end lineage with BFS + search
  - BFS-driven rule execution
  - Re-approval triggers and final Approve/Decline pipeline
"""

import sys
import sqlite3
import logging
import json
import math
import re
import smtplib
from email.mime.text import MIMEText
from datetime import datetime
from collections import deque

# Attempt pyodbc import (optional for SQL Server)
try:
    import pyodbc
except ImportError:
    pyodbc = None

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog, QDockWidget,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox, QTreeView, QListWidget, QListWidgetItem
)

# pyqtgraph for analytics and advanced graph visualization
import pyqtgraph as pg

###############################################################################
# LOGGING CONFIG
###############################################################################
logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

USE_ODBC = False  # Will be True if user picks ODBC in the DB dialog

###############################################################################
# HELPER UTILS
###############################################################################
def get_cursor_rows(cursor):
    """
    Fetches all rows from a DB cursor as a list of dicts, keyed by column name.
    """
    try:
        rows = cursor.fetchall()
    except:
        return []
    if not rows:
        return []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        out = []
        for r in rows:
            d = {}
            for i,c in enumerate(colnames):
                d[c] = r[i]
            out.append(d)
        return out
    return rows

def get_cursor_one(cursor):
    """
    Fetches a single row from a DB cursor as dict (or None).
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        d = {}
        for i,c in enumerate(colnames):
            d[c] = row[i]
        return d
    return None

def send_email_notification(subject, body, recipients):
    """
    Sends a plain-text email notification using smtplib.
    """
    msg = MIMEText(body, 'plain')
    msg['Subject'] = subject
    msg['From'] = EMAIL_CONFIG['sender_email']
    msg['To'] = ", ".join(recipients)
    try:
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info("Email sent to: " + ", ".join(recipients))
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

def get_last_inserted_id(cursor):
    """
    Returns the last inserted autoincrement ID for both SQLite and SQL Server.
    """
    global USE_ODBC
    if USE_ODBC:
        try:
            cursor.execute("SELECT SCOPE_IDENTITY()")
            row = cursor.fetchone()
            if row and row[0] is not None:
                return int(row[0])
        except:
            pass
        cursor.execute("SELECT @@IDENTITY")
        row2 = cursor.fetchone()
        if row2 and row2[0] is not None:
            return int(row2[0])
        return None
    else:
        return cursor.lastrowid

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QDialog):
    """
    Lets the user pick either an in-memory SQLite DB or an ODBC-based DSN
    for a SQL Server connection.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Database Connection")
        layout = QVBoxLayout(self)

        self.conn_type_combo = QComboBox()
        self.conn_type_combo.addItem("In-Memory SQLite", "memory")
        if pyodbc:
            try:
                dsn_dict = pyodbc.dataSources()
                for dsn_name, driver in dsn_dict.items():
                    if "SQL SERVER" in driver.upper():
                        self.conn_type_combo.addItem(f"ODBC: {dsn_name}", dsn_name)
            except Exception as e:
                logger.error("Error listing DSNs: " + str(e))

        layout.addWidget(QLabel("Connection Type:"))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Optional custom ODBC connection string")
        layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)

    def get_connection(self):
        choice = self.conn_type_combo.currentData()
        if choice == "memory":
            return setup_in_memory_db()
        else:
            override = self.conn_str_edit.text().strip()
            if override:
                conn_str = override
            else:
                conn_str = f"DSN={choice};Trusted_Connection=yes;"
            try:
                global USE_ODBC
                USE_ODBC = True
                return pyodbc.connect(conn_str)
            except Exception as ex:
                QMessageBox.critical(self, "Connection Error", str(ex))
                return None

###############################################################################
# SETUP IN-MEMORY DB + TABLES
###############################################################################
def setup_in_memory_db():
    conn = sqlite3.connect("file::memory:?cache=shared", uri=True, timeout=10.0)
    conn.execute("PRAGMA foreign_keys=ON;")
    conn.row_factory = sqlite3.Row
    create_tables_and_seed(conn)
    return conn

def create_tables_and_seed(conn):
    """
    Creates all the necessary BRM tables (if they don't exist) and seeds
    them with sample data (users, groups, permissions, etc.).
    """
    c = conn.cursor()

    c.execute("""
    CREATE TABLE IF NOT EXISTS USERS(
        USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        USERNAME TEXT UNIQUE NOT NULL,
        PASSWORD TEXT NOT NULL,
        USER_GROUP TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
        GROUP_NAME TEXT PRIMARY KEY,
        DESCRIPTION TEXT,
        EMAIL TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS GROUP_PERMISSIONS(
        GROUP_NAME TEXT NOT NULL,
        TARGET_TABLE TEXT NOT NULL,
        PRIMARY KEY(GROUP_NAME, TARGET_TABLE)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
        RULE_TYPE_ID INTEGER PRIMARY KEY,
        RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
        GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT UNIQUE NOT NULL,
        DESCRIPTION TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULES(
        RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_ID INTEGER,
        PARENT_RULE_ID INTEGER,
        RULE_TYPE_ID INTEGER NOT NULL,
        RULE_NAME TEXT NOT NULL,
        RULE_SQL TEXT NOT NULL,
        EFFECTIVE_START_DATE TEXT NOT NULL,
        EFFECTIVE_END_DATE TEXT,
        STATUS TEXT NOT NULL CHECK (STATUS IN ('ACTIVE','INACTIVE')),
        VERSION INTEGER NOT NULL DEFAULT 1,
        CREATED_BY TEXT NOT NULL,
        DESCRIPTION TEXT,
        OPERATION_TYPE TEXT,
        BUSINESS_JUSTIFICATION TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        UPDATED_BY TEXT,
        OWNER_GROUP TEXT NOT NULL,
        CLUSTER_NAME TEXT,
        APPROVAL_STATUS TEXT NOT NULL DEFAULT 'DRAFT',
        IS_GLOBAL INTEGER NOT NULL DEFAULT 0,
        CRITICAL_RULE INTEGER NOT NULL DEFAULT 0,
        CRITICAL_SCOPE TEXT NOT NULL DEFAULT 'NONE',
        CDC_TYPE TEXT NOT NULL DEFAULT 'NONE'
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
        DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        DATABASE_NAME TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        COLUMN_NAME TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        RECORD_ID TEXT NOT NULL,
        ACTION_BY TEXT NOT NULL,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
        LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_INFO TEXT,
        TARGET_INFO TEXT,
        TRANSFORMATION_DETAILS TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
        MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_RULE_ID INTEGER NOT NULL,
        SOURCE_COLUMN_NAME TEXT NOT NULL,
        TARGET_COLUMN_NAME TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_RULE_GROUPS(
        CUSTOM_GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_NAME TEXT NOT NULL UNIQUE,
        OWNER_BUSINESS_GROUP TEXT NOT NULL,
        CREATED_BY TEXT NOT NULL,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_MEMBERS(
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        RULE_ID INTEGER NOT NULL,
        PRIMARY KEY(CUSTOM_GROUP_ID, RULE_ID)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUP_APPROVERS(
        APPROVER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL
    );
    """)
    # 0=not decided, 1=approved, 2=declined
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
        RULE_ID INTEGER NOT NULL,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        APPROVED_FLAG INTEGER NOT NULL DEFAULT 0,
        APPROVED_TIMESTAMP DATETIME,
        APPROVAL_STAGE INTEGER NOT NULL DEFAULT 1,
        PRIMARY KEY(RULE_ID, GROUP_NAME, USERNAME)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GLOBAL_CRITICAL_LINKS(
        LINK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GCR_RULE_ID INTEGER NOT NULL,
        TARGET_RULE_ID INTEGER,
        TARGET_GROUP_ID INTEGER
    );
    """)

    # seed data
    groups = [
        ("Admin","Admin group","admin@example.com"),
        ("BG1","Group1","bg1@example.com"),
        ("BG2","Group2","bg2@example.com"),
        ("BG3","Group3","bg3@example.com")
    ]
    for g_ in groups:
        c.execute("INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)", g_)

    users = [
        ("admin","admin","Admin"),
        ("bg1_user","user","BG1"),
        ("bg2_user","user","BG2"),
        ("bg3_user","user","BG3")
    ]
    for u_ in users:
        c.execute("INSERT OR IGNORE INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)", u_)

    perms = [
        ("Admin","TABLE_A"),
        ("Admin","TABLE_B"),
        ("Admin","TABLE_C"),
        ("Admin","TABLE_D"),
        ("BG1","TABLE_A"),
        ("BG1","TABLE_B"),
        ("BG2","TABLE_C"),
        ("BG3","TABLE_D")
    ]
    for p_ in perms:
        c.execute("INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)", p_)

    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(1,'DQ')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(2,'DM')")

    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG1','bg1_user')")
    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG2','bg2_user')")
    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG3','bg3_user')")

    c.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION) VALUES('Finance Rules','Finance data rules')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION) VALUES('HR Rules','HR data rules')")

    conn.commit()

###############################################################################
# AUDIT LOG
###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Inserts a record into BRM_AUDIT_LOG capturing the action performed,
    old_data, new_data, user, and timestamp.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA)
    VALUES(?,?,?,?,?,?)
    """,(
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# APPROVALS + BFS + RULE EXECUTION
###############################################################################
def extract_tables(sql_text:str):
    """
    Simplistic parser to find tables after FROM/JOIN keywords.
    Adjust as needed for real SQL parsing.
    """
    found = []
    tokens = re.split(r"\s+", sql_text.strip())
    for i,t in enumerate(tokens):
        if t.upper() in ("FROM","JOIN"):
            if i+1 < len(tokens):
                tbl = re.sub(r"[;(),]","",tokens[i+1])
                found.append(("", tbl))
    return list(set(found))

def run_rule_sql(conn, rule_sql):
    """
    For demonstration, assume rule_sql returns a single row with a single column
    that is 1 for PASS, 0 for FAIL, etc. Returns True if pass, else False.
    """
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = get_cursor_one(c)
        if not row:
            return True
        pass_fail = list(row.values())[0]
        return (pass_fail == 1)
    except Exception as ex:
        logger.error("Rule execution error: " + str(ex))
        return False

def build_rule_adjacency(conn):
    """
    Returns (children_map, root_rules).
    children_map is a dict: parent_rule_id -> list of child rule_ids
    root_rules is a list of rule_ids with no parent.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows = get_cursor_rows(c)
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r_ in rows:
        rid = r_["RULE_ID"]
        pid = r_["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [r for r in all_ids if r not in parent_ids]
    return children_map, roots

def skip_descendants(child_id, children_map, skipped):
    """
    Marks the child and all its descendants as skipped, i.e. BFS won't process them.
    """
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def load_global_critical_links(conn):
    """
    Returns a dict: gcr_rule_id -> set of child rule_ids (or empty if none).
    For global/critical scope linking.
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = get_cursor_rows(c)
    link_map = {}
    for r_ in rows:
        gcr = r_["GCR_RULE_ID"]
        tgt = r_["TARGET_RULE_ID"]
        if tgt:
            link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    """
    Returns a dict of RULE_ID -> rule row (as dict).
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = get_cursor_rows(c)
    return {r_["RULE_ID"]: r_ for r_ in rows}

def execute_rules_in_order(conn):
    """
    Illustrates BFS-based rule execution from root rules downward.
    If a rule fails and is critical/global with scope != 'NONE',
    all its descendants are skipped.
    Returns (executed_list, skipped_set).
    """
    children_map, root_rules = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)

    executed = []
    skipped = set()
    queue = list(root_rules)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            continue

        rinfo = rule_lookup[rid]
        sql_text = rinfo["RULE_SQL"]
        passed = run_rule_sql(conn, sql_text)
        if passed:
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            # If the rule is critical/global and scope != NONE, skip all its descendants
            is_crit = (rinfo["CRITICAL_RULE"] == 1 or rinfo["IS_GLOBAL"] == 1)
            crit_scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and crit_scope != "NONE":
                # skip direct children
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                # skip any global-critical links
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    return executed, skipped

def get_current_approval_stage(conn, rule_id):
    """
    Finds the lowest approval stage number for which APPROVED_FLAG=0 (i.e. pending).
    If no pending approvals, returns None.
    """
    c = conn.cursor()
    c.execute("""
    SELECT MIN(APPROVAL_STAGE) as stage
    FROM BRM_RULE_APPROVALS
    WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row = get_cursor_one(c)
    if row and row["stage"]:
        return row["stage"]
    return None

def insert_if_not_exists(conn, table, columns, values, where_clause, where_params):
    """
    Insert into {table} ({columns}) VALUES (values) if no row matches {where_clause}.
    """
    c = conn.cursor()
    check_sql = f"SELECT 1 FROM {table} WHERE {where_clause}"
    c.execute(check_sql, where_params)
    row = c.fetchone()
    if row:
        return
    col_str = ",".join(columns)
    ph = ",".join(["?"]*len(columns))
    ins_sql = f"INSERT INTO {table}({col_str}) VALUES({ph})"
    c.execute(ins_sql, values)
    conn.commit()

def find_impacted_business_groups(conn, rule_id):
    """
    BFS over the column mappings to see all rules that eventually descend from this one,
    collecting their OWNER_GROUP.  This determines which groups must approve.
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = get_cursor_one(c)
    if row:
        impacted.add(row["OWNER_GROUP"])

    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?",(curr,))
        kids = get_cursor_rows(c)
        for ch_ in kids:
            rid2 = ch_["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rid2,))
            ro2 = get_cursor_one(c)
            if ro2:
                impacted.add(ro2["OWNER_GROUP"])
            queue.append(rid2)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    """
    Creates one or more approval stages for the impacted business groups in order,
    plus a final approval stage.  Each group's designated approvers must approve.
    """
    c = conn.cursor()
    stage_counter = 1
    stage_list = []
    MULTISTEP_ORDER = ["BG1","BG2","BG3","FINAL"]

    # Only include BGn if it is impacted, then always have "FINAL" as last.
    for step in MULTISTEP_ORDER:
        if step == "FINAL":
            stage_list.append((step, stage_counter))
            stage_counter += 1
        else:
            if step in impacted_bg_list:
                stage_list.append((step, stage_counter))
                stage_counter += 1

    # Insert the approvals if not already present
    for bg, st_ in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            cols = ("RULE_ID","GROUP_NAME","USERNAME","APPROVED_FLAG","APPROVAL_STAGE")
            vals = (rule_id,bg,user_ap,0,st_)
            wc = "RULE_ID=? AND GROUP_NAME=? AND USERNAME=?"
            wp = (rule_id,bg,user_ap)
            insert_if_not_exists(conn,"BRM_RULE_APPROVALS",cols,vals,wc,wp)
        else:
            c.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(bg,))
            rowaps = get_cursor_rows(c)
            for rap in rowaps:
                cols = ("RULE_ID","GROUP_NAME","USERNAME","APPROVED_FLAG","APPROVAL_STAGE")
                vals = (rule_id,bg,rap["USERNAME"],0,st_)
                wc = "RULE_ID=? AND GROUP_NAME=? AND USERNAME=?"
                wp = (rule_id,bg,rap["USERNAME"])
                insert_if_not_exists(conn,"BRM_RULE_APPROVALS",cols,vals,wc,wp)

###############################################################################
# CRUD FOR BRM_RULES
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert a new rule into BRM_RULES and set up approvals (unless global).
    Also populates table dependencies from the rule's SQL.
    """
    c = conn.cursor()
    owner = rule_data["OWNER_GROUP"]
    rname = rule_data["RULE_NAME"].strip()

    # Check for duplicates
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",(owner,rname))
    if get_cursor_one(c):
        raise ValueError(f"Rule '{rname}' already exists in group '{owner}'.")

    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_SQL=?",(owner,rule_data["RULE_SQL"]))
    if get_cursor_one(c):
        raise ValueError(f"Another rule in '{owner}' has the same SQL text.")

    is_global = rule_data.get("IS_GLOBAL", 0)
    if is_global == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create a global rule.")

    c.execute("""
    INSERT INTO BRM_RULES(
        GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
        EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,CREATED_BY,
        DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,OWNER_GROUP,
        APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
    )
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rname,
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        "INACTIVE",
        1,
        created_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        owner,
        "APPROVAL_IN_PROGRESS",
        is_global,
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE")
    ))
    new_id = get_last_inserted_id(c)

    # Insert table dependencies
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn, tbn) in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME)
        VALUES(?,?,?,?)
        """,(new_id, dbn, tbn, "DerivedCol"))

    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # If global, skip multi-step approval; else create them
    if is_global == 1:
        logger.info("Global rule => skipping multi-step approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    """
    Update existing rule, reset to 'INACTIVE' + version++ + re-approval (unless global).
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_data["RULE_ID"],))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")

    old_data = dict(old)
    new_owner = rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_rname = rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()
    new_sql   = rule_data["RULE_SQL"]

    # Dup checks
    if new_owner != old["OWNER_GROUP"] or new_rname != old["RULE_NAME"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",(new_owner,new_rname))
        dup = get_cursor_one(c)
        if dup and dup["RULE_ID"] != old["RULE_ID"]:
            raise ValueError(f"Duplicate rule '{new_rname}' in group '{new_owner}'.")

    if (new_owner != old["OWNER_GROUP"]) or (new_sql != old["RULE_SQL"]):
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_SQL=?",(new_owner,new_sql))
        dup2 = get_cursor_one(c)
        if dup2 and dup2["RULE_ID"] != old["RULE_ID"]:
            raise ValueError(f"Another rule in '{new_owner}' has the same SQL text.")

    # Global check
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update a global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set global=1.")

    # Perform the update
    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID=?,
      PARENT_RULE_ID=?,
      RULE_TYPE_ID=?,
      RULE_NAME=?,
      RULE_SQL=?,
      EFFECTIVE_START_DATE=?,
      EFFECTIVE_END_DATE=?,
      STATUS='INACTIVE',
      VERSION=VERSION+1,
      UPDATED_BY=?,
      DESCRIPTION=?,
      OPERATION_TYPE=?,
      BUSINESS_JUSTIFICATION=?,
      OWNER_GROUP=?,
      APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
      IS_GLOBAL=?,
      CRITICAL_RULE=?,
      CRITICAL_SCOPE=?,
      CDC_TYPE=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_rname,
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        new_owner,
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rule_data["RULE_ID"]
    ))

    # Refresh table dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rule_data["RULE_ID"],))
    deps = extract_tables(new_sql)
    for (dbn, tbn) in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME)
        VALUES(?,?,?,?)
        """,(rule_data["RULE_ID"], dbn, tbn, "DerivedCol"))

    # Audit
    new_data = dict(old_data)
    for k,v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "UPDATE", "BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()

    # Re-create approvals unless global
    if old["IS_GLOBAL"] == 1 or rule_data.get("IS_GLOBAL", 0) == 1:
        logger.info("Skipping multi-step approvals for global rule update.")
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Sets rule STATUS='INACTIVE' if fully approved and no active children.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate if rule is not fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate a global rule.")

    # Check for active children
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Deactivate child rules first.")

    old_data = dict(old)
    c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE',UPDATED_BY=?,VERSION=VERSION+1 WHERE RULE_ID=?",(updated_by,rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Permanently removes a rule if it is fully APPROVED but already INACTIVE,
    with no children and no column mappings referencing it.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")

    # Check for children
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist, cannot delete.")

    # Check column mappings
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    leftover = get_cursor_rows(c)
    if leftover:
        raise ValueError("Re-map or remove column references first.")

    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

###############################################################################
# LOGIN DIALOG
###############################################################################
class LoginDialog(QDialog):
    """
    Simple username/password prompt. Checks USERS table for validity.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Failed", "Invalid username/password.")

###############################################################################
# MULTI-STEP APPROVAL TAB (WITH APPROVE + DECLINE)
###############################################################################
class ApprovalPipelineWidget(QWidget):
    """
    Draws four small colored circles (BG1, BG2, BG3, FINAL) showing the
    status of each stage: NotStarted (gray), Pending (yellow), Approved (green),
    or Rejected (red).
    """
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.layout().setSpacing(5)
        for st in ["BG1", "BG2", "BG3", "FINAL"]:
            circle = QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st,"NotStarted")
            if status == "Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status == "Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status == "Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class MultiStepApprovalTab(QWidget):
    """
    Table of rules requiring approval by the logged-in user. If user
    approves, we move to next stage or finalize. If user declines,
    the rule is marked REJECTED + INACTIVE.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.appr_table = QTableWidget(0,8)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID","Group Name","Rule Name","Stage",
            "Approved?","Approve","Decline","Pipeline"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVED_TIMESTAMP,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows = get_cursor_rows(c)

        # gather pipeline data
        all_app = self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        all_rows = get_cursor_rows(all_app)

        from collections import defaultdict
        stage_map = defaultdict(lambda: {
            "BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"
        })

        def cur_stage(rid):
            c2 = self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) as st
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid,))
            ro2 = get_cursor_one(c2)
            return ro2["st"] if ro2 and ro2["st"] else None

        # build a list of all rule IDs to find each rule's current stage
        c2 = self.connection.cursor()
        c2.execute("SELECT RULE_ID FROM BRM_RULES")
        rids = [x["RULE_ID"] for x in get_cursor_rows(c2)]
        rule_cur_stage = {}
        for r_ in rids:
            rule_cur_stage[r_] = cur_stage(r_)

        # fill stage_map
        for apr in all_rows:
            rid = apr["RULE_ID"]
            grp = apr["GROUP_NAME"]
            flg = apr["APPROVED_FLAG"]
            stg = apr["APPROVAL_STAGE"]
            cst = rule_cur_stage.get(rid)
            if flg == 1:
                stage_map[rid][grp] = "Approved"
            elif flg == 2:
                stage_map[rid][grp] = "Rejected"
            else:
                # flg=0 => if stg == cst => 'Pending'; else 'NotStarted'
                if cst == stg:
                    stage_map[rid][grp] = "Pending"
                else:
                    stage_map[rid][grp] = "NotStarted"

        pipeline_data = dict(stage_map)

        # filter only the rows where the user is at the current (pending) stage
        minimal = []
        for rd in rows:
            rid_ = rd["RULE_ID"]
            st_  = rd["APPROVAL_STAGE"]
            cst_ = rule_cur_stage.get(rid_)
            if cst_ == st_:
                minimal.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r, 1, QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r, 2, QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r, 3, QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r, 4, QTableWidgetItem(str(rd["APPROVED_FLAG"])))

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_idx=r: self.do_approve(row_idx))
            self.appr_table.setCellWidget(r, 5, approve_btn)

            decline_btn = QPushButton("Decline")
            decline_btn.clicked.connect(lambda _, row_idx=r: self.do_decline(row_idx))
            self.appr_table.setCellWidget(r, 6, decline_btn)

            pipe_map = pipeline_data.get(rd["RULE_ID"], {
                "BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"
            })
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r, 7, pipe_widget)

    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index, 0)
        grp_item = self.appr_table.item(row_index, 1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        grp = grp_item.text()

        c = self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id, grp, self.logged_in_username))

        nxt = get_current_approval_stage(self.connection, rule_id)
        if nxt is None:
            # no more pending => rule is fully APPROVED => becomes ACTIVE
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED',STATUS='ACTIVE' WHERE RULE_ID=?",(rule_id,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS',STATUS='INACTIVE' WHERE RULE_ID=?",(rule_id,))

        add_audit_log(self.connection,"APPROVE","BRM_RULE_APPROVALS", rule_id, self.logged_in_username,
                      {"APPROVED_FLAG":0}, {"APPROVED_FLAG":1})
        self.connection.commit()
        QMessageBox.information(self, "Approved", f"You approved rule {rule_id}.")
        self.load_approvals()

    def do_decline(self, row_index):
        rid_item = self.appr_table.item(row_index, 0)
        grp_item = self.appr_table.item(row_index, 1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        grp = grp_item.text()

        confirm = QMessageBox.question(self, "Confirm", f"Decline rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return

        c = self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id, grp, self.logged_in_username))

        # entire rule => REJECTED
        c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED',STATUS='INACTIVE' WHERE RULE_ID=?",(rule_id,))
        add_audit_log(self.connection, "DECLINE","BRM_RULE_APPROVALS", rule_id, self.logged_in_username,
                      {"APPROVED_FLAG":0}, {"APPROVED_FLAG":2})
        self.connection.commit()
        QMessageBox.information(self, "Declined", f"You declined rule {rule_id}.")
        self.load_approvals()

###############################################################################
# ADVANCED END-TO-END LINEAGE WIDGET
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    Uses a BFS approach to identify only relevant nodes (rules or tables)
    based on a search query. Rules are shown as rectangles/ellipses;
    tables as ellipses in light blue.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.rule_data = {}
        self.rule_adjacency = {}
        self.table_refs = {}
        self.node_map = {}

        self.load_data()
        self.search_lineage("")  # show everything by default

    def load_data(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,IS_GLOBAL,
               CRITICAL_RULE,RULE_SQL,DESCRIPTION
        FROM BRM_RULES
        """)
        rows = get_cursor_rows(c)
        self.rule_data = {}
        for r_ in rows:
            rid = r_["RULE_ID"]
            self.rule_data[rid] = dict(r_)

        # adjacency: rule->child
        self.rule_adjacency = {}
        for rid in self.rule_data:
            self.rule_adjacency[rid] = set()

        # parent->child via PARENT_RULE_ID
        for rid, info in self.rule_data.items():
            pid = info["PARENT_RULE_ID"]
            if pid and pid in self.rule_data:
                self.rule_adjacency[pid].add(rid)

        # column mappings
        c.execute("SELECT RULE_ID,SOURCE_RULE_ID FROM BRM_COLUMN_MAPPING")
        colmaps = get_cursor_rows(c)
        for cm in colmaps:
            src = cm["SOURCE_RULE_ID"]
            tgt = cm["RULE_ID"]
            if src in self.rule_adjacency:
                self.rule_adjacency[src].add(tgt)

        # table dependencies
        self.table_refs = {}
        for rid in self.rule_data:
            self.table_refs[rid] = set()

        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps = get_cursor_rows(c)
        for d_ in deps:
            rr = d_["RULE_ID"]
            dbn = d_["DATABASE_NAME"] or ""
            tbn = d_["TABLE_NAME"] or ""
            self.table_refs[rr].add((dbn,tbn))

    def search_lineage(self, query:str):
        """
        BFS from all matching rules/tables. Only nodes reachable from these matches
        appear in the final scene.
        """
        q = query.lower()

        # match rules by name, SQL, or description
        matched_rules = set()
        for rid, rd in self.rule_data.items():
            n_l = (rd["RULE_NAME"] or "").lower()
            s_l = (rd["RULE_SQL"] or "").lower()
            d_l = (rd["DESCRIPTION"] or "").lower()
            if q in n_l or q in s_l or q in d_l:
                matched_rules.add(rid)

        # gather all tables
        all_tables = set()
        for rid in self.table_refs:
            all_tables.update(self.table_refs[rid])

        # match tables
        matched_tables = set()
        for tk in all_tables:
            full_t = (tk[0]+"."+tk[1]).lower()
            if q in full_t:
                matched_tables.add(tk)

        # build combined adjacency => (“rule”, rid) or (“table”, (dbn,tbn))
        combined = {}
        for rid in self.rule_data:
            combined[("rule", rid)] = set()
        for tk in all_tables:
            combined[("table", tk)] = set()

        # rule->rule adjacency
        for pr, children in self.rule_adjacency.items():
            for ch_ in children:
                combined[("rule", pr)].add(("rule", ch_))
                combined[("rule", ch_)].add(("rule", pr))

        # rule->table adjacency
        for rid, tset in self.table_refs.items():
            for tk2 in tset:
                combined[("rule", rid)].add(("table", tk2))
                combined[("table", tk2)].add(("rule", rid))

        # BFS from matched rules + matched tables
        from collections import deque
        start_nodes = set()
        for r_ in matched_rules:
            start_nodes.add(("rule", r_))
        for t_ in matched_tables:
            start_nodes.add(("table", t_))

        visited = set()
        queue = deque(start_nodes)
        while queue:
            node = queue.popleft()
            if node in visited:
                continue
            visited.add(node)
            if node in combined:
                for nbr in combined[node]:
                    if nbr not in visited:
                        queue.append(nbr)

        # now build the scene for visited nodes only
        self.scene.clear()
        self.node_map = {}

        # BFS a second time for layout
        queue2 = deque()
        for s_ in start_nodes:
            if s_ in visited:
                queue2.append((s_, 0))

        layer_count = {}
        visited_layout = set()

        while queue2:
            (node, depth) = queue2.popleft()
            if node in visited_layout:
                continue
            visited_layout.add(node)

            layer_count[depth] = layer_count.get(depth, 0)
            x = depth * 280
            y = layer_count[depth] * 100
            layer_count[depth] += 1

            if node[0] == "rule":
                rid = node[1]
                rinfo = self.rule_data[rid]
                item = self.create_rule_node(rinfo)
                item.setPos(x,y)
                self.scene.addItem(item)
                self.node_map[node] = item
            else:
                tk = node[1]
                item = self.create_table_node(tk)
                item.setPos(x,y)
                self.scene.addItem(item)
                self.node_map[node] = item

            # add children to queue
            if node in combined:
                for nbr in combined[node]:
                    if nbr in visited and nbr not in visited_layout:
                        queue2.append((nbr, depth+1))

        # draw edges
        for node in visited:
            if node in self.node_map and node in combined:
                for nbr in combined[node]:
                    if nbr in self.node_map and nbr in visited:
                        self.draw_edge(self.node_map[node], self.node_map[nbr])

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_rule_node(self, rd):
        """
        Creates a QGraphicsRectItem (for DQ) or QGraphicsEllipseItem (for DM),
        with coloring for active vs. inactive, and a red pen if critical.
        """
        rtype = rd["RULE_TYPE_ID"]
        if rtype == 1:
            node = QtWidgets.QGraphicsRectItem(0, 0, 120, 50)
        else:
            node = QtWidgets.QGraphicsEllipseItem(0, 0, 120, 50)

        st = rd["STATUS"]
        if st.lower() == "active":
            col = QtGui.QColor("lightgreen")
        else:
            col = QtGui.QColor("tomato")
        node.setBrush(QtGui.QBrush(col))

        pen = QtGui.QPen(QtCore.Qt.black, 2)
        if rd["CRITICAL_RULE"] == 1:
            pen = QtGui.QPen(QtGui.QColor("red"), 3)
        node.setPen(pen)

        txt = rd["RULE_NAME"]
        if rd["IS_GLOBAL"] == 1:
            txt = "(G) " + txt
        node.setToolTip(f"Rule {rd['RULE_ID']}: {txt}\nSQL: {rd.get('RULE_SQL','')}")
        return node

    def create_table_node(self, tk):
        """
        Creates a QGraphicsEllipseItem for a table node in light blue.
        """
        dbn, tbn = tk
        node = QtWidgets.QGraphicsEllipseItem(0, 0, 100, 40)
        node.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
        node.setPen(QtGui.QPen(QtGui.QColor("blue"), 2))
        node.setToolTip(f"Table: {dbn}.{tbn}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        """
        Draws a straight line edge between the two QGraphicsItems.
        """
        r1 = item1.sceneBoundingRect()
        r2 = item2.sceneBoundingRect()
        p1 = r1.center()
        p2 = r2.center()
        line = QtWidgets.QGraphicsLineItem(p1.x(), p1.y(), p2.x(), p2.y())
        line.setPen(QtGui.QPen(color, 2))
        self.scene.addItem(line)

    def resetView(self):
        """
        Auto-fits the view to the bounding box of all items.
        """
        if self.scene and self.scene.items():
            self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        """
        If user clicks on a node, display a tooltip in a dialog.
        """
        if event.button() == Qt.LeftButton:
            it = self.itemAt(event.pos())
            if isinstance(it, (QtWidgets.QGraphicsRectItem, QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self, "Node Info", it.toolTip())
        super().mousePressEvent(event)

###############################################################################
# A SIMPLE SEARCH DIALOG FOR THE LINEAGE VIEW
###############################################################################
class LineageSearchDialog(QDialog):
    def __init__(self, lineage_widget, parent=None):
        super().__init__(parent)
        self.lineage_widget = lineage_widget
        self.setWindowTitle("Search Lineage")
        layout = QVBoxLayout(self)

        self.edit = QLineEdit()
        self.edit.setPlaceholderText("Search table or rule text ...")
        layout.addWidget(self.edit)

        btn = QPushButton("Search")
        btn.clicked.connect(self.do_search)
        layout.addWidget(btn)

        self.setLayout(layout)

    def do_search(self):
        q = self.edit.text().strip()
        self.lineage_widget.search_lineage(q)
        self.accept()

###############################################################################
# EXAMPLE TABS (STUBS OR ADMIN FEATURES)
###############################################################################
class GroupManagementTab(QWidget):
    """
    Admin-only: Manage business groups, membership, backups, etc.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        if user_group != "Admin":
            lay = QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: Admin Only"))
            self.setLayout(lay)
            return

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Group Management Tab (Admin)"))
        # In a real implementation, you would provide a UI for adding/updating groups, etc.
        self.setLayout(layout)

class UserManagementTab(QWidget):
    """
    Admin-only user mgmt
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("User Management (Admin). Add/Update/Delete users here."))
        self.setLayout(layout)

class CustomRuleGroupEnhancedTab(QWidget):
    """
    Placeholder for a custom rule group feature.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Custom Rule Groups tab"))
        self.setLayout(layout)

class CtrlTablesTab(QWidget):
    """
    Shows reference or control tables (like BRM_RULE_TYPES, etc.).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Control Tables viewer tab"))
        self.setLayout(layout)

class HierarchyViewTab(QWidget):
    """
    Could display a tree of groups/rules, or parent-child relationships.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Hierarchy view of groups/rules"))
        self.setLayout(layout)

class BusinessRuleManagementTab(QWidget):
    """
    A place to show a grid of existing rules, plus Add/Update/Deactivate/Delete controls.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Business Rule Management (CRUD)."))
        # A real implementation might show a QTableWidget with existing rules, etc.
        self.setLayout(layout)

class GlobalCriticalAdminTab(QWidget):
    """
    Admin-only tab for linking/unlinking global/critical rules, re-triggering approvals, etc.
    """
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group

        if user_group != "Admin":
            lay = QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: Admin Only"))
            self.setLayout(lay)
            return

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Global/Critical Admin tab (Admin)"))
        # Real code would manage the global_critical_links, etc.
        self.setLayout(layout)

###############################################################################
# MAIN APP WINDOW
###############################################################################
class BRMTool(QMainWindow):
    """
    Single integrated BRM application window.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Single File Production")
        self.resize(1200, 800)

        # 1) Database connection
        self.connection = None
        dbdlg = DatabaseConnectionDialog()
        if dbdlg.exec_() == QDialog.Accepted:
            self.connection = dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # 2) Login
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = self.login_dialog.user_id

        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowu = get_cursor_one(c)
        self.logged_in_username = rowu["USERNAME"] if rowu else "Unknown"

        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowg = get_cursor_one(c)
        self.user_group = rowg["USER_GROUP"] if rowg else "Unknown"

        self.init_ui()

    def init_ui(self):
        cw = QWidget()
        layout = QVBoxLayout(cw)

        # Admin can impersonate other users
        if self.user_group == "Admin":
            top_h = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # 1) Business Rule Management
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")

        # 2) Approvals
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # 3) Group mgmt + user mgmt if admin
        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")

            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")

        # 4) Hierarchy View
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")

        # 5) Custom Rule Groups
        self.custom_tab = CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab, "Custom Rule Groups")

        # 6) Advanced lineage
        lineage_container = QWidget()
        lin_lay = QVBoxLayout(lineage_container)
        lb = QLabel("End-to-End Lineage")
        lb.setStyleSheet("font-weight:bold;")
        lin_lay.addWidget(lb)

        srch_btn = QPushButton("Search Lineage")
        srch_btn.clicked.connect(self.lineage_search)
        lin_lay.addWidget(srch_btn)

        self.lineage_widget = EnhancedLineageGraphWidget(self.connection)
        lin_lay.addWidget(self.lineage_widget)
        self.tabs.addTab(lineage_container, "Lineage Visualization")

        # 7) Global/Critical Admin (admin only)
        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        # 8) Control tables
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # Auto-refresh the Approvals tab every 5 seconds
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)
        self.show()

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = get_cursor_rows(c)
        for r_ in rows:
            disp = f"{r_['USERNAME']} ({r_['USER_GROUP']})"
            self.switch_combo.addItem(disp, (r_["USER_ID"], r_["USER_GROUP"]))

    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid == self.user_id and new_grp == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        self.reinit_tabs()

    def reinit_tabs(self):
        """
        Completely re-builds the tab layout based on the newly impersonated user’s group.
        """
        self.tabs.clear()

        # 1) BRM
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")

        # 2) Approvals
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # 3) Group & user mgmt if admin
        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")

            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")

        # 4) Hierarchy
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")

        # 5) Custom Rule Groups
        self.custom_tab = CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab, "Custom Rule Groups")

        # 6) Lineage
        lineage_container = QWidget()
        lin_lay = QVBoxLayout(lineage_container)
        lb = QLabel("End-to-End Lineage")
        lb.setStyleSheet("font-weight:bold;")
        lin_lay.addWidget(lb)

        srch_btn = QPushButton("Search Lineage")
        srch_btn.clicked.connect(self.lineage_search)
        lin_lay.addWidget(srch_btn)

        self.lineage_widget = EnhancedLineageGraphWidget(self.connection)
        lin_lay.addWidget(self.lineage_widget)
        self.tabs.addTab(lineage_container, "Lineage Visualization")

        # 7) Global/Critical Admin if admin
        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        # 8) Control tables
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

    def refresh_approvals(self):
        self.approv_tab.load_approvals()

    def lineage_search(self):
        dlg = LineageSearchDialog(self.lineage_widget, self)
        dlg.exec_()

    def closeEvent(self, event):
        """
        On exit, try closing the DB connection.
        """
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# MAIN ENTRY POINT
###############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()