#!/usr/bin/env python
"""
BRM Tool – Single Integrated Version (Enhanced Global/Critical Admin)
Supports:
  • ODBC or In-Memory SQLite
  • Login with seeded users
  • Business Rule Management (with pagination & searching)
  • Multi-step approvals
  • BFS-based lineage graph + search
  • Hierarchy view
  • Custom rule groups (enhanced)
  • Email notifications on rule add/update
  • Group Management & User Management (admin only)
  • Global/Critical Admin (enhanced with cycle prevention and re-approvals)
  • Control Tables viewer
"""

import sys
import sqlite3
import logging
import json
import math
import re
import smtplib
from email.mime.text import MIMEText
from datetime import datetime
from collections import deque

# Attempt pyodbc import for ODBC usage
try:
    import pyodbc
except ImportError:
    pyodbc = None

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog, QDockWidget,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox, QTreeView, QListWidget, QListWidgetItem
)

# For analytics (bar chart, pie chart) – using PyQtGraph
import pyqtgraph as pg

###############################################################################
# Logging & Email Configuration
###############################################################################
logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

# This flag becomes True if user selected an ODBC DSN
USE_ODBC = False

###############################################################################
# Helper: get_last_inserted_id
###############################################################################
def get_last_inserted_id(cursor):
    """
    Returns the last inserted ID in a portable way:
    - For SQLite: use cursor.lastrowid
    - For SQL Server (via pyodbc): try SCOPE_IDENTITY(), then @@IDENTITY.
    """
    if USE_ODBC:
        try:
            # For SQL Server 2005+ if the inserted table has an identity PK:
            cursor.execute("SELECT SCOPE_IDENTITY()")
            row = cursor.fetchone()
            if row and row[0] is not None:
                return int(row[0])
        except Exception as ex:
            logger.warning(f"SCOPE_IDENTITY() failed: {ex}")
        # fallback (less reliable if triggers, etc.):
        cursor.execute("SELECT @@IDENTITY")
        row = cursor.fetchone()
        if row and row[0] is not None:
            return int(row[0])
        return None
    else:
        return cursor.lastrowid

###############################################################################
# DB UTILITIES
###############################################################################
def get_cursor_rows(cursor):
    """
    Fetches all rows from a cursor and returns a list of dicts if possible.
    If using pyodbc, we parse the description to map columns -> row values.
    """
    try:
        rows = cursor.fetchall()
    except Exception:
        return []
    if not rows:
        return []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        result = []
        for r in rows:
            row_dict = {}
            for i, col in enumerate(colnames):
                row_dict[col] = r[i]
            result.append(row_dict)
        return result
    else:
        return rows

def get_cursor_one(cursor):
    """
    Fetches a single row as dict (or None).
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        row_dict = {}
        for i, col in enumerate(colnames):
            row_dict[col] = row[i]
        return row_dict
    return None

def send_email_notification(subject, body, recipients):
    """
    Sends email using SMTP from config.
    """
    msg = MIMEText(body, 'plain')
    msg['Subject'] = subject
    msg['From'] = EMAIL_CONFIG['sender_email']
    msg['To'] = ", ".join(recipients)
    try:
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info("Email sent to: " + ", ".join(recipients))
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QDialog):
    """
    Dialog to select either in-memory SQLite or ODBC DSN for SQL Server.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Database Connection")
        layout = QVBoxLayout(self)

        self.conn_type_combo = QComboBox()
        self.conn_type_combo.addItem("In-Memory SQLite", "memory")

        if pyodbc:
            # Attempt listing DSNs for SQL Server
            try:
                dsn_dict = pyodbc.dataSources()
                for dsn_name, driver in dsn_dict.items():
                    if "SQL SERVER" in driver.upper():
                        self.conn_type_combo.addItem(f"ODBC: {dsn_name}", dsn_name)
            except Exception as e:
                logger.error("Error listing ODBC DSNs: " + str(e))

        layout.addWidget(QLabel("Connection Type:"))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Optional: custom ODBC connection string override")
        layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)

    def get_connection(self):
        """
        Returns either an in-memory SQLite connection or a pyodbc connection.
        """
        choice = self.conn_type_combo.currentData()
        if choice == "memory":
            return setup_in_memory_db()
        else:
            override = self.conn_str_edit.text().strip()
            if override:
                conn_str = override
            else:
                # Example DSN for integrated security
                conn_str = f"DSN={choice};Trusted_Connection=yes;"
            try:
                global USE_ODBC
                USE_ODBC = True
                return pyodbc.connect(conn_str)
            except Exception as ex:
                QMessageBox.critical(self, "Connection Error", str(ex))
                return None

###############################################################################
# SETUP IN-MEMORY SQLITE
###############################################################################
def setup_in_memory_db():
    """
    Creates an in-memory SQLite DB with all required tables + seed data.
    """
    conn = sqlite3.connect("file::memory:?cache=shared", uri=True, timeout=10.0)
    conn.execute("PRAGMA foreign_keys=ON;")
    conn.row_factory = sqlite3.Row
    create_tables_and_seed(conn)
    return conn

def create_tables_and_seed(conn):
    """
    Creates all tables and seeds initial data (users, groups, perms, etc.).
    """
    c = conn.cursor()

    # ---- Create tables
    c.execute("""
    CREATE TABLE IF NOT EXISTS USERS(
        USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        USERNAME TEXT UNIQUE NOT NULL,
        PASSWORD TEXT NOT NULL,
        USER_GROUP TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
        GROUP_NAME TEXT PRIMARY KEY,
        DESCRIPTION TEXT,
        EMAIL TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS GROUP_PERMISSIONS(
        GROUP_NAME TEXT NOT NULL,
        TARGET_TABLE TEXT NOT NULL,
        PRIMARY KEY(GROUP_NAME, TARGET_TABLE),
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
        RULE_TYPE_ID INTEGER PRIMARY KEY,
        RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
        GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT UNIQUE NOT NULL,
        DESCRIPTION TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULES(
        RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_ID INTEGER,
        PARENT_RULE_ID INTEGER,
        RULE_TYPE_ID INTEGER NOT NULL,
        RULE_NAME TEXT NOT NULL,
        RULE_SQL TEXT NOT NULL,
        EFFECTIVE_START_DATE TEXT NOT NULL,
        EFFECTIVE_END_DATE TEXT,
        STATUS TEXT NOT NULL CHECK (STATUS IN ('ACTIVE','INACTIVE')),
        VERSION INTEGER NOT NULL DEFAULT 1,
        CREATED_BY TEXT NOT NULL,
        DESCRIPTION TEXT,
        OPERATION_TYPE TEXT,
        BUSINESS_JUSTIFICATION TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        UPDATED_BY TEXT,
        OWNER_GROUP TEXT NOT NULL,
        CLUSTER_NAME TEXT,
        APPROVAL_STATUS TEXT NOT NULL DEFAULT 'DRAFT',
        IS_GLOBAL INTEGER NOT NULL DEFAULT 0,
        CRITICAL_RULE INTEGER NOT NULL DEFAULT 0,
        CRITICAL_SCOPE TEXT NOT NULL DEFAULT 'NONE',
        CDC_TYPE TEXT NOT NULL DEFAULT 'NONE',
        FOREIGN KEY(RULE_TYPE_ID) REFERENCES BRM_RULE_TYPES(RULE_TYPE_ID),
        FOREIGN KEY(PARENT_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_ID) REFERENCES BRM_RULE_GROUPS(GROUP_ID) ON DELETE SET NULL,
        UNIQUE(OWNER_GROUP,RULE_NAME)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
        DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        DATABASE_NAME TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        RECORD_ID TEXT NOT NULL,
        ACTION_BY TEXT NOT NULL,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
        LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_INFO TEXT,
        TARGET_INFO TEXT,
        TRANSFORMATION_DETAILS TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
        MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_RULE_ID INTEGER NOT NULL,
        SOURCE_COLUMN_NAME TEXT NOT NULL,
        TARGET_COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(SOURCE_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_RULE_GROUPS(
        CUSTOM_GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_NAME TEXT NOT NULL UNIQUE,
        OWNER_BUSINESS_GROUP TEXT NOT NULL,
        CREATED_BY TEXT NOT NULL,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_MEMBERS(
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        RULE_ID INTEGER NOT NULL,
        PRIMARY KEY(CUSTOM_GROUP_ID, RULE_ID),
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUP_APPROVERS(
        APPROVER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
        RULE_ID INTEGER NOT NULL,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        APPROVED_FLAG INTEGER NOT NULL DEFAULT 0,
        APPROVED_TIMESTAMP DATETIME,
        APPROVAL_STAGE INTEGER NOT NULL DEFAULT 1,
        PRIMARY KEY(RULE_ID, GROUP_NAME, USERNAME),
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GLOBAL_CRITICAL_LINKS(
        LINK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GCR_RULE_ID INTEGER NOT NULL,
        TARGET_RULE_ID INTEGER,
        TARGET_GROUP_ID INTEGER,
        FOREIGN KEY(GCR_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(TARGET_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    # ---- Seed data
    groups = [
        ("Admin", "Admin group", "admin@example.com"),
        ("BG1", "Group1", "bg1@example.com"),
        ("BG2", "Group2", "bg2@example.com"),
        ("BG3", "Group3", "bg3@example.com"),
    ]
    for g in groups:
        c.execute("INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)", g)

    users = [
        ("admin", "admin", "Admin"),
        ("bg1_user", "user", "BG1"),
        ("bg2_user", "user", "BG2"),
        ("bg3_user", "user", "BG3"),
    ]
    for u in users:
        c.execute("INSERT OR IGNORE INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)", u)

    perms = [
        ("Admin", "TABLE_A"),
        ("Admin", "TABLE_B"),
        ("Admin", "TABLE_C"),
        ("Admin", "TABLE_D"),
        ("BG1", "TABLE_A"),
        ("BG1", "TABLE_B"),
        ("BG2", "TABLE_C"),
        ("BG3", "TABLE_D")
    ]
    for p in perms:
        c.execute("INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)", p)

    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(1,'DQ')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(2,'DM')")

    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG1','bg1_user')")
    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG2','bg2_user')")
    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG3','bg3_user')")

    c.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION) VALUES('Finance Rules','Finance data rules')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION) VALUES('HR Rules','HR data rules')")

    conn.commit()

###############################################################################
# AUDIT LOG UTILITY
###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Inserts a row in BRM_AUDIT_LOG to track changes (old/new JSON).
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA)
    VALUES(?,?,?,?,?,?)
    """, (action, table_name, str(record_id), action_by,
          json.dumps(old_data) if old_data else None,
          json.dumps(new_data) if new_data else None))
    conn.commit()

###############################################################################
# RULE UTILS (Add, Update, Delete, etc.) + BFS Execution
###############################################################################
def get_op_type_from_sql(sql_text: str) -> str:
    """
    Classifies the SQL statement (INSERT, DELETE, UPDATE, SELECT, OTHER).
    """
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def extract_tables(sql_text: str):
    """
    Naive approach to detect table references from FROM/JOIN in the SQL text.
    Returns a list of (database_name, table_name) tuples.
    """
    found = []
    tokens = re.split(r"\s+", sql_text.strip())
    for i, t in enumerate(tokens):
        if t.upper() in ("FROM", "JOIN"):
            if i+1 < len(tokens):
                tbl = re.sub(r"[;(),]", "", tokens[i+1])
                found.append(("", tbl))  # Not capturing DB name here
    return list(set(found))

def run_rule_sql(conn, rule_sql):
    """
    Example: executes the rule's SQL. 
    We assume it returns a single column/row with 1=pass, 0=fail.
    If no row or any error -> treat as pass==False or True based on preference.
    Here we treat no row as pass==True.
    """
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = get_cursor_one(c)
        if not row:
            return True  # No row => treat as pass
        # If the first column in row is 1 => pass
        pass_fail = list(row.values())[0]
        return (pass_fail == 1)
    except Exception as ex:
        logger.error("Rule execution error: " + str(ex))
        return False

def build_rule_adjacency(conn):
    """
    Returns:
      children_map: dict of {parent_id -> [child_ids]}
      roots: list of rule_ids that have no parent.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = get_cursor_rows(c)
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r["RULE_ID"]
        pid = r["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [rid for rid in all_ids if rid not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    """
    Loads the GCR link table into a dict {gcr_rule_id -> set(child_ids)}.
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = get_cursor_rows(c)
    link_map = {}
    for r in rows:
        gcr = r["GCR_RULE_ID"]
        tgt = r["TARGET_RULE_ID"]
        if tgt:
            link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    """
    Returns {rule_id -> rule_dict} for all rules in BRM_RULES.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = get_cursor_rows(c)
    return {r["RULE_ID"]: r for r in rows}

def skip_descendants(child_id, children_map, skipped):
    """
    Recursively mark all descendants of child_id as skipped in BFS execution.
    """
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def execute_rules_in_order(conn):
    """
    BFS-based rule execution from root rules downward.
    If a rule fails and is global/critical (scope != NONE),
    we skip that rule’s descendants and any GCR-linked children.
    """
    children_map, root_rules = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    executed = []
    skipped = set()
    queue = list(root_rules)
    rule_lookup = get_all_rules_as_dict(conn)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning(f"Rule not found: {rid}")
            continue

        rinfo = rule_lookup[rid]
        rule_sql = rinfo["RULE_SQL"]
        logger.info(f"Executing rule {rid}: {rinfo['RULE_NAME']}")
        passed = run_rule_sql(conn, rule_sql)
        if passed:
            logger.info(f"Rule {rid} PASSED")
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            logger.warning(f"Rule {rid} FAILED")
            is_crit = (rinfo["CRITICAL_RULE"] == 1 or rinfo["IS_GLOBAL"] == 1)
            crit_scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and crit_scope != "NONE":
                logger.warning(f"Critical/Global => skipping descendants & links. scope={crit_scope}")
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    logger.info(f"ETL done. executed={executed}, skipped={list(skipped)}")
    return executed, skipped

def find_impacted_business_groups(conn, rule_id):
    """
    Returns a set of groups impacted by rule_id, including column-mapped children.
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = get_cursor_one(c)
    if row:
        impacted.add(row["OWNER_GROUP"])

    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?", (curr,))
        children = get_cursor_rows(c)
        for ch in children:
            cid = ch["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (cid,))
            row2 = get_cursor_one(c)
            if row2:
                impacted.add(row2["OWNER_GROUP"])
            queue.append(cid)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    """
    Inserts multi-stage approvals (BG1->BG2->BG3->FINAL) for the impacted groups.
    """
    c = conn.cursor()
    stage_counter = 1
    stage_list = []
    MULTISTEP_ORDER = ["BG1", "BG2", "BG3", "FINAL"]
    for step in MULTISTEP_ORDER:
        if step == "FINAL":
            stage_list.append((step, stage_counter))
            stage_counter += 1
        else:
            if step in impacted_bg_list:
                stage_list.append((step, stage_counter))
                stage_counter += 1

    for bg, st in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            c.execute("""
            INSERT OR IGNORE INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVAL_STAGE)
            VALUES(?,?,?,?,?)
            """, (rule_id, bg, user_ap, 0, st))
        else:
            c.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (bg,))
            rowaps = get_cursor_rows(c)
            for rap in rowaps:
                c.execute("""
                INSERT OR IGNORE INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVAL_STAGE)
                VALUES(?,?,?,?,?)
                """, (rule_id, bg, rap["USERNAME"], 0, st))
    conn.commit()

def get_current_approval_stage(conn, rule_id):
    """
    Returns the lowest approval stage not yet approved, or None if all are approved.
    """
    c = conn.cursor()
    c.execute("""
    SELECT MIN(APPROVAL_STAGE) as stage
    FROM BRM_RULE_APPROVALS
    WHERE RULE_ID=? AND APPROVED_FLAG=0
    """, (rule_id,))
    row = get_cursor_one(c)
    if row and row["stage"]:
        return row["stage"]
    return None

def add_rule(conn, rule_data, created_by, user_group):
    """
    Adds a new rule, triggers approvals if not global, and sends emails to impacted groups.
    """
    c = conn.cursor()
    owner = rule_data["OWNER_GROUP"]
    rule_name = rule_data["RULE_NAME"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (owner, rule_name))
    if get_cursor_one(c):
        raise ValueError(f"Rule '{rule_name}' already exists in group '{owner}'")
    is_global = rule_data.get("IS_GLOBAL", 0)
    if is_global == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create global rule.")

    c.execute("""
    INSERT INTO BRM_RULES(
        GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
        EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION, CREATED_BY,
        DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION, OWNER_GROUP,
        APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE
    )
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        "INACTIVE",
        1,
        created_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        rule_data["OWNER_GROUP"],
        "APPROVAL_IN_PROGRESS",
        is_global,
        rule_data.get("CRITICAL_RULE", 0),
        rule_data.get("CRITICAL_SCOPE", "NONE"),
        rule_data.get("CDC_TYPE", "NONE")
    ))
    new_id = get_last_inserted_id(c)

    # Insert dependencies
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn, tbn) in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (new_id, dbn, tbn, "DerivedCol"))

    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # If global, skip normal approvals
    if is_global == 1:
        logger.info("Global rule => skipping multi-step approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)

    # Attempt emailing
    try:
        subject = f"New Rule Added: {rule_data['RULE_NAME']}"
        body = f"User {created_by} added rule ID {new_id}\n\nDetails:\n{json.dumps(rule_data, indent=2)}"
        impacted_grps = find_impacted_business_groups(conn, new_id)
        recips = []
        for g in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g,))
            r = get_cursor_one(c)
            if r and r["EMAIL"]:
                recips.append(r["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on new rule: " + str(ex))

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    """
    Updates an existing rule, re-initiates approvals if not global, and sends email to impacted groups.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)
    new_owner = rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_rname = rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()

    # Check duplicates if changing owner group or name
    if new_owner != old["OWNER_GROUP"] or new_rname != old["RULE_NAME"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (new_owner, new_rname))
        dup = get_cursor_one(c)
        if dup and dup["RULE_ID"] != old["RULE_ID"]:
            raise ValueError(f"Duplicate rule name '{new_rname}' in group '{new_owner}'")

    # Check global update permission
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set a rule global.")

    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID = ?,
      PARENT_RULE_ID = ?,
      RULE_TYPE_ID = ?,
      RULE_NAME = ?,
      RULE_SQL = ?,
      EFFECTIVE_START_DATE = ?,
      EFFECTIVE_END_DATE = ?,
      STATUS = 'INACTIVE',
      VERSION = VERSION + 1,
      UPDATED_BY = ?,
      DESCRIPTION = ?,
      OPERATION_TYPE = ?,
      BUSINESS_JUSTIFICATION = ?,
      OWNER_GROUP = ?,
      APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
      IS_GLOBAL = ?,
      CRITICAL_RULE = ?,
      CRITICAL_SCOPE = ?,
      CDC_TYPE = ?
    WHERE RULE_ID = ?
    """, (
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_rname,
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        new_owner,
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rule_data["RULE_ID"]
    ))
    # Rebuild dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn, tbn) in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (rule_data["RULE_ID"], dbn, tbn, "DerivedCol"))

    new_data = dict(old_data)
    for k, v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "UPDATE", "BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()

    # If global, skip re-approvals
    if old["IS_GLOBAL"] == 1 or rule_data.get("IS_GLOBAL", 0) == 1:
        logger.info("Skipping multi-step approvals for global rule update.")
    else:
        # Re-init approvals
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

    # Attempt emailing
    try:
        subject = f"Rule Updated: {new_rname}"
        body = (
            f"User {updated_by} updated rule ID {rule_data['RULE_ID']}.\n\n"
            f"Old:\n{json.dumps(old_data, indent=2)}\n\nNew:\n{json.dumps(rule_data, indent=2)}"
        )
        impacted_grps = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        recips = []
        for g_ in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g_,))
            ro = get_cursor_one(c)
            if ro and ro["EMAIL"]:
                recips.append(ro["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on rule update: " + str(ex))

def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivate an APPROVED rule. If rule is GLOBAL, only Admin can do so.
    Cannot deactivate if it has ACTIVE children.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Deactivate child rules first.")
    old_data = dict(old)
    c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE', UPDATED_BY=?, VERSION=VERSION+1 WHERE RULE_ID=?", (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Delete an APPROVED, INACTIVE rule with no children or column references.
    If rule is GLOBAL, only Admin can delete.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist, cannot delete.")
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    leftover = get_cursor_rows(c)
    if leftover:
        raise ValueError("Re-map or remove column references first.")
    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

###############################################################################
# LOGIN DIALOG
###############################################################################
class LoginDialog(QDialog):
    """
    Simple login dialog matching seeded data in USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)

        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

###############################################################################
# RULE EDITOR DIALOG
###############################################################################
class RuleEditorDialog(QDialog):
    """
    Dialog to add or edit a rule (basic fields, rule SQL, global/critical checkboxes, etc.).
    """
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_types = rule_types  # dict {name->id}
        self.logged_in_user = logged_in_user
        self.rule_data = rule_data

        title = "Edit Rule" if rule_data else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(900, 500)

        main_layout = QHBoxLayout(self)

        # Left panel (basic info)
        left_box = QGroupBox("Basic Info")
        left_layout = QFormLayout(left_box)

        self.group_combo = QComboBox()
        self.group_combo.addItem("None", None)
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        rows = get_cursor_rows(c)
        for r in rows:
            self.group_combo.addItem(r["GROUP_NAME"], r["GROUP_ID"])
        left_layout.addRow("Rule Group:", self.group_combo)

        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("None", None)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
        pr_rows = get_cursor_rows(c)
        for rr in pr_rows:
            self.parent_rule_combo.addItem(f"{rr['RULE_NAME']} (ID:{rr['RULE_ID']})", rr["RULE_ID"])
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit = QLineEdit()
        left_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo = QComboBox()
        for rt_name in self.rule_types:
            self.type_combo.addItem(rt_name)
        left_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["ACTIVE", "INACTIVE"])
        left_layout.addRow("Status (informational):", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:", self.end_dt)

        self.owner_grp_combo = QComboBox()
        c.execute("SELECT DISTINCT GROUP_NAME FROM GROUP_PERMISSIONS ORDER BY GROUP_NAME")
        og_rows = get_cursor_rows(c)
        for g_ in og_rows:
            self.owner_grp_combo.addItem(g_["GROUP_NAME"], g_["GROUP_NAME"])
        left_layout.addRow("Owner Group:", self.owner_grp_combo)

        self.global_checkbox = None
        if self.logged_in_user == "Admin":
            self.global_checkbox = QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:", self.global_checkbox)

        self.critical_checkbox = QCheckBox()
        left_layout.addRow("Critical Rule?", self.critical_checkbox)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        left_layout.addRow("Critical Scope:", self.scope_combo)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "INSERT_ONLY", "UPSERT"])
        left_layout.addRow("CDC Type:", self.cdc_combo)

        main_layout.addWidget(left_box)

        # Right panel (SQL & descriptions)
        right_box = QGroupBox("Details & Logic")
        right_layout = QFormLayout(right_box)

        self.sql_editor = QPlainTextEdit()
        font = QtGui.QFont("Courier", 10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"), self.sql_editor)

        self.description_edit = QTextEdit()
        right_layout.addRow(QLabel("Description:"), self.description_edit)

        self.justification_edit = QTextEdit()
        right_layout.addRow(QLabel("Justification:"), self.justification_edit)

        btn_box = QHBoxLayout()
        self.save_btn = QPushButton("Save" if rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)
        right_layout.addRow(btn_box)

        main_layout.addWidget(right_box)
        self.setLayout(main_layout)

        if self.rule_data:
            self.load_rule_data(self.rule_data)

    def load_rule_data(self, rd):
        """
        Loads existing rule fields into the editor widgets.
        """
        if rd["GROUP_ID"]:
            idx = self.group_combo.findData(rd["GROUP_ID"])
            if idx >= 0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2 = self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2 >= 0:
                self.parent_rule_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"])

        # match rule_type
        for nm, tid in self.rule_types.items():
            if tid == rd["RULE_TYPE_ID"]:
                i = self.type_combo.findText(nm)
                if i >= 0:
                    self.type_combo.setCurrentIndex(i)
                break

        st = rd["STATUS"]
        i_st = self.status_combo.findText(st)
        if i_st >= 0:
            self.status_combo.setCurrentIndex(i_st)

        # parse start/end date
        try:
            sdt = datetime.strptime(rd["EFFECTIVE_START_DATE"], "%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except:
            pass
        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt = datetime.strptime(rd["EFFECTIVE_END_DATE"], "%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except:
                pass

        og = rd["OWNER_GROUP"]
        iog = self.owner_grp_combo.findText(og)
        if iog >= 0:
            self.owner_grp_combo.setCurrentIndex(iog)

        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        if self.global_checkbox and rd.get("IS_GLOBAL", 0) == 1:
            self.global_checkbox.setChecked(True)
        if rd.get("CRITICAL_RULE", 0) == 1:
            self.critical_checkbox.setChecked(True)
        scope_val = rd.get("CRITICAL_SCOPE", "NONE")
        ix_scope = self.scope_combo.findText(scope_val.upper())
        if ix_scope >= 0:
            self.scope_combo.setCurrentIndex(ix_scope)
        cdc_val = rd.get("CDC_TYPE", "NONE").upper()
        ix_cdc = self.cdc_combo.findText(cdc_val)
        if ix_cdc >= 0:
            self.cdc_combo.setCurrentIndex(ix_cdc)

    def on_save(self):
        """
        Saves (update or add) the rule. Re-initiates approvals if needed.
        """
        if not self.name_edit.text().strip():
            QMessageBox.warning(self, "Error", "Name is empty.")
            return
        sql_text = self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self, "Error", "SQL is empty.")
            return

        op_type = get_op_type_from_sql(sql_text)
        rule_dict = {
            "GROUP_ID": self.group_combo.currentData(),
            "PARENT_RULE_ID": self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID": self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME": self.name_edit.text().strip(),
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
            "CDC_TYPE": self.cdc_combo.currentText().upper()
        }
        created_by = self.logged_in_user

        if self.rule_data:
            # Update existing rule
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm", "Update rule?")
            if confirm != QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self, "Success", "Rule updated. Approval re-initiated.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "DB Error", str(ex))
        else:
            # Add new
            confirm = QMessageBox.question(self, "Confirm", "Add new rule?")
            if confirm != QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self, "Success", f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "DB Error", str(ex))

###############################################################################
# RULE ANALYTICS DIALOG
###############################################################################
class RuleAnalyticsDialog(QDialog):
    """
    Displays a bar chart (rules by creator) and a pie chart-like distribution of statuses.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        chart_hbox = QHBoxLayout()

        self.bar_chart = pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)

        self.pie_chart = pg.PlotWidget(title="Rule Status Distribution")
        self.pie_chart.setBackground('w')
        chart_hbox.addWidget(self.pie_chart)

        layout.addLayout(chart_hbox)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)
        self.load_charts()

    def load_charts(self):
        c = self.connection.cursor()

        # Count by creator
        c.execute("SELECT CREATED_BY, COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY")
        rows = get_cursor_rows(c)
        creators = {r["CREATED_BY"]: r["cnt"] for r in rows}

        # Active/Inactive from BRM_RULES, plus "DELETED" from audit logs
        status_counts = {"ACTIVE": 0, "INACTIVE": 0, "DELETED": 0}
        c.execute("SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        srows = get_cursor_rows(c)
        for s_ in srows:
            s_up = s_["STATUS"].upper()
            if s_up in status_counts:
                status_counts[s_up] = s_["sc"]

        # DELETED from audit
        c.execute("SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'")
        drow = get_cursor_one(c)
        if drow:
            status_counts["DELETED"] = drow["delcnt"]

        # Bar chart: creators
        self.bar_chart.clear()
        if creators:
            sorted_creators = sorted(creators.items(), key=lambda x: x[1], reverse=True)
            names = [x[0] for x in sorted_creators]
            vals = [x[1] for x in sorted_creators]
            bar_item = pg.BarGraphItem(x=range(len(names)), height=vals, width=0.6, brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax = self.bar_chart.getAxis("bottom")
            ax.setTicks([list(zip(range(len(names)), names))])
            self.bar_chart.setLabel("left", "Number of Rules")
            self.bar_chart.setLabel("bottom", "Created By")
            self.bar_chart.showGrid(x=True, y=True)

        # Pie chart: statuses (simple text approach in pyqtgraph)
        self.pie_chart.clear()
        total = sum(status_counts.values())
        if total > 0:
            label_str = "\n".join([f"{k}: {v}" for k, v in status_counts.items()])
            text_item = pg.TextItem(label_str, anchor=(0, 0))
            text_item.setPos(0, 0)
            self.pie_chart.addItem(text_item)

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Displays the last 1000 audit log rows with optional search by Action/Table/Action_By.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800, 600)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action, Table, or Action By...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table = QTableWidget(0, 8)
        self.audit_table.setHorizontalHeaderLabels(["Audit ID", "Action", "Table", "Record ID", "Action By", "Old Data", "New Data", "Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        """
        Loads top 1000 logs. Uses OFFSET or row_number fallback for ODBC.
        """
        c = self.connection.cursor()
        if USE_ODBC:
            # Attempt OFFSET... if fails, fallback
            try:
                query = """
                SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
                FROM BRM_AUDIT_LOG
                ORDER BY ACTION_TIMESTAMP DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(query)
            except:
                # Fallback with row_number
                query = """
                SELECT *
                FROM (
                    SELECT
                        AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP,
                        ROW_NUMBER() OVER (ORDER BY ACTION_TIMESTAMP DESC) as rn
                    FROM BRM_AUDIT_LOG
                ) sub
                WHERE rn <= 1000
                """
                c.execute(query)
        else:
            # SQLite
            c.execute("""
            SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
            LIMIT 1000
            """)

        rows = get_cursor_rows(c)
        self.audit_table.setRowCount(0)
        for row in rows:
            r = self.audit_table.rowCount()
            self.audit_table.insertRow(r)
            self.audit_table.setItem(r, 0, QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r, 1, QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r, 2, QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r, 3, QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r, 4, QTableWidgetItem(row["ACTION_BY"]))

            oldtxt = ""
            if row["OLD_DATA"]:
                try:
                    p = json.loads(row["OLD_DATA"])
                    oldtxt = json.dumps(p, indent=2)
                except:
                    oldtxt = row["OLD_DATA"]
            self.audit_table.setItem(r, 5, QTableWidgetItem(oldtxt))

            newtxt = ""
            if row["NEW_DATA"]:
                try:
                    p2 = json.loads(row["NEW_DATA"])
                    newtxt = json.dumps(p2, indent=2)
                except:
                    newtxt = row["NEW_DATA"]
            self.audit_table.setItem(r, 6, QTableWidgetItem(newtxt))

            self.audit_table.setItem(r, 7, QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))

    def perform_search(self, text):
        """
        Filters rows by partial match in Action, Table, or Action_By columns.
        """
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            match = False
            for col in (1, 2, 4):
                it = self.audit_table.item(row, col)
                if it and txt_l in it.text().lower():
                    match = True
                    break
            self.audit_table.setRowHidden(row, not match)

###############################################################################
# SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialog(QDialog):
    """
    Simple search dialog for BRM_RULES by name or SQL snippet.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID", "Name", "SQL", "Status", "Version", "Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        """
        Searches by name or SQL; returns up to 1000 rules.
        """
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            where_clause = "WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)"
            params = (f"%{txt}%", f"%{txt}%")
        else:
            where_clause = ""
            params = ()

        if USE_ODBC:
            # Try OFFSET first, fallback row_number
            try:
                query = f"""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                FROM BRM_RULES
                {where_clause}
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(query, params)
            except:
                query = f"""
                SELECT * FROM (
                  SELECT
                     RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY,
                     ROW_NUMBER() OVER (ORDER BY RULE_ID DESC) as rn
                  FROM BRM_RULES
                  {where_clause}
                ) sub
                WHERE rn <= 1000
                """
                c.execute(query, params)
        else:
            # SQLite
            query = f"""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            {where_clause}
            ORDER BY RULE_ID DESC
            LIMIT 1000
            """
            c.execute(query, params)

        rows = get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r, 0, QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r, 1, QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r, 2, QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r, 3, QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r, 4, QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r, 5, QTableWidgetItem(row["CREATED_BY"]))

###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    """
    Shows rules in a paginated table, with searching and status filter.
    Also can run ETL and show analytics.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        # Search & Filter row
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        self.status_filter.addItem("DELETED", "DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        # Table
        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels(["Rule ID", "Name", "SQL", "Status", "Version", "Owner Group", "Created Timestamp", "Approval Status"])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        # Pagination controls
        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        # Buttons row
        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)

        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)

        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics)
        btn_h.addWidget(analytics_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)

        # Hooks
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        # Initial load
        self.load_rules()

    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self, "ETL", msg)
        self.load_rules()

    def show_analytics(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()

    def build_filter_query(self):
        """
        Builds the WHERE clause + params to filter by search text or DELETED status.
        """
        f = []
        p = []
        txt = self.search_edit.text().strip()
        if txt:
            f.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            p.extend([f"%{txt}%", f"%{txt}%"])

        st = self.status_filter.currentData()
        if st:
            # handle "DELETED" by subselect from audit
            if st.upper() == "DELETED":
                if USE_ODBC:
                    subselect = "(SELECT CAST(RECORD_ID as INT) FROM BRM_AUDIT_LOG WHERE ACTION='DELETE' AND ISNUMERIC(RECORD_ID)=1)"
                    f.append(f"(RULE_ID IN {subselect})")
                else:
                    f.append("(RULE_ID IN (SELECT RECORD_ID FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'))")
            else:
                f.append("STATUS=?")
                p.append(st)

        clause = " AND ".join(f) if f else "1=1"
        return clause, p

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()

        # Count total
        count_query = f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}"
        c.execute(count_query, params)
        rowc = get_cursor_one(c)
        total = rowc["ccount"] if rowc else 0

        # Page calc
        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        elif self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset = (self.current_page - 1) * self.records_per_page

        # Data retrieval
        if USE_ODBC:
            # Try OFFSET first, fallback
            try:
                data_query = f"""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP, CREATED_TIMESTAMP, APPROVAL_STATUS
                FROM BRM_RULES
                WHERE {clause}
                ORDER BY RULE_ID DESC
                OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
                """
                c.execute(data_query, (*params, offset, self.records_per_page))
            except:
                # row_number fallback
                start_row = offset + 1
                end_row = offset + self.records_per_page
                data_query = f"""
                SELECT * FROM (
                  SELECT
                    RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION,
                    OWNER_GROUP, CREATED_TIMESTAMP, APPROVAL_STATUS,
                    ROW_NUMBER() OVER (ORDER BY RULE_ID DESC) as rn
                  FROM BRM_RULES
                  WHERE {clause}
                ) sub
                WHERE rn BETWEEN ? AND ?
                """
                c.execute(data_query, (*params, start_row, end_row))
        else:
            # SQLite
            data_query = f"""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP, CREATED_TIMESTAMP, APPROVAL_STATUS
            FROM BRM_RULES
            WHERE {clause}
            ORDER BY RULE_ID DESC
            LIMIT ? OFFSET ?
            """
            c.execute(data_query, (*params, self.records_per_page, offset))

        rows = get_cursor_rows(c)
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r, 1, QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r, 2, QTableWidgetItem(rd["RULE_SQL"]))
            st_item = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower() == "active":
                st_item.setBackground(QColor(144, 238, 144))
            else:
                st_item.setBackground(QColor(255, 182, 193))
            self.rule_table.setItem(r, 3, st_item)
            self.rule_table.setItem(r, 4, QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r, 5, QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r, 6, QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r, 7, QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row, 0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id = None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

###############################################################################
# BUSINESS RULE MANAGEMENT TAB
###############################################################################
class BusinessRuleManagementTab(QWidget):
    """
    Hosts the RuleDashboard and action buttons:
      Add Rule, Update Rule, Deactivate, Delete, View Audit, Search
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)

        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)

        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)

        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)

        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)

        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        layout.addWidget(self.rule_dash)

        layout.addStretch()
        self.setLayout(layout)

    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self, "No Selection", "Select a rule first.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Not Found", "No rule with that ID.")
            return
        rule_data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rules selected.")
            return
        success = 0
        fails = []
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rr}: {str(ex)}")
        msg = f"Deactivation done. success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dash.load_rules()

    def on_delete_rule(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule(s) selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        fails = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rid}: {str(ex)}")
        msg = f"Deletion done. success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dash.load_rules()

###############################################################################
# GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTab(QWidget):
    """
    Allows Admin to manage:
      - Business Groups (add, rename, delete, backup/restore)
      - Membership (assign user to group)
      - Group Permissions (add/remove target tables)
      - Approvers (add/remove)
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        if user_group != "Admin":
            lay = QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(lay)
            return

        # You would implement your group/permission UI here.
        # For brevity, let's stub it:
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Group Management (Admin Only) - to be implemented."))
        self.setLayout(layout)

###############################################################################
# BACKUP & RESTORE HELPERS
###############################################################################
class BackupRestoreHelpers:
    """
    Functions to backup/restore entire group or custom rule group.
    """
    @staticmethod
    def backup_group(conn, group_name, action_by="System"):
        c = conn.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE OWNER_GROUP=?", (group_name,))
        rules = get_cursor_rows(c)
        data = {"rules": []}
        for r in rules:
            rd = dict(r)
            rid = r["RULE_ID"]
            c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
            rd["dependencies"] = get_cursor_rows(c)
            c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?", (rid,))
            rd["lineage"] = get_cursor_rows(c)
            c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?", (rid,))
            rd["column_mappings"] = get_cursor_rows(c)
            data["rules"].append(rd)
        js = json.dumps(data, default=str)
        c.execute("SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv FROM BRM_GROUP_BACKUPS WHERE GROUP_NAME=?", (group_name,))
        row = get_cursor_one(c)
        nextv = row["mv"] + 1
        c.execute("INSERT INTO BRM_GROUP_BACKUPS(GROUP_NAME,BACKUP_VERSION,BACKUP_JSON) VALUES(?,?,?)", (group_name, nextv, js))
        conn.commit()
        add_audit_log(conn, "BACKUP", "BRM_GROUP_BACKUPS", group_name, action_by, {"group": group_name}, {"version": nextv})
        return nextv

    @staticmethod
    def restore_group(conn, group_name, backup_version, action_by="System"):
        # Stub for restore logic
        pass

###############################################################################
# USER MANAGEMENT TAB (ADMIN)
###############################################################################
class UserManagementTab(QWidget):
    """
    Allows Admin to add/update/delete Users, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("User Management (Admin Only) - to be implemented."))
        self.setLayout(layout)

###############################################################################
# HIERARCHY VIEW TAB
###############################################################################
class HierarchyViewTab(QWidget):
    """
    Displays a hierarchical tree of groups -> optional rule groups -> rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Hierarchy View - to be implemented."))
        self.setLayout(layout)

###############################################################################
# ENHANCED CUSTOM RULE GROUP TAB
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Allows creation of custom rule groups, renaming, deleting, backup/restore,
    and assigning rules to the custom group.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Custom Rule Groups (Enhanced) - to be implemented."))
        self.setLayout(layout)

###############################################################################
# MULTISTEP APPROVAL TAB
###############################################################################
class MultiStepApprovalTab(QWidget):
    """
    Shows the user their pending approvals in earliest stage. Approve -> next stage or final.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Multi-Step Approvals - to be implemented."))
        self.setLayout(layout)

    def load_approvals(self):
        """
        If you build an approvals UI, refresh it here. Called by timer.
        """
        pass

###############################################################################
# CONTROL TABLES TAB
###############################################################################
class CtrlTablesTab(QWidget):
    """
    Lets you pick a table from a combo and load all rows. Works for either SQLite or SQL Server.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Control Tables Viewer - to be implemented."))
        self.setLayout(layout)

###############################################################################
# GLOBAL/CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    Enhanced tab for Admin to:
      - Filter rules by global/critical or show all
      - Set is_global, critical_rule, and critical_scope
      - Link/unlink children to GCR parent (with cycle prevention)
      - Re-trigger approvals if previously approved but now changed to critical
    """
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        layout = QVBoxLayout(self)
        if user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
        else:
            layout.addWidget(QLabel("Global/Critical Admin - to be implemented."))
        self.setLayout(layout)

###############################################################################
# ENHANCED LINEAGE GRAPH
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    A BFS-based lineage graph with rectangle items for DQ rules or ellipse for DM rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setScene(QtWidgets.QGraphicsScene(self))
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        # For brevity, not fully implemented here.

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    """
    The main application window.
    Launches DatabaseConnectionDialog -> LoginDialog -> builds all tabs.
    Auto-refreshes the Approvals tab every 5 seconds.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Integrated Enhanced Version")
        self.resize(1200, 800)

        # 1) Database connection
        self.connection = None
        dlg = DatabaseConnectionDialog()
        if dlg.exec_() == QDialog.Accepted:
            self.connection = dlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # 2) Login
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = self.login_dialog.user_id

        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowu = get_cursor_one(c)
        self.logged_in_username = rowu["USERNAME"] if rowu else "Unknown"

        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowg = get_cursor_one(c)
        self.user_group = rowg["USER_GROUP"] if rowg else "Unknown"

        self.init_ui()

    def init_ui(self):
        cw = QWidget()
        layout = QVBoxLayout(cw)

        # Add a label for the logged-in user
        layout.addWidget(QLabel(f"Logged in as: {self.logged_in_username} (Group: {self.user_group})"))

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # 1) BRM Tab
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")

        # 2) Group / User Management (admin only)
        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")

            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")

        # 3) Lineage Visualization
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lineage_container = QWidget()
        lineage_lay = QVBoxLayout(lineage_container)
        lineage_lay.addWidget(QLabel("Enhanced Lineage Graph (BFS-based) - partial example."))
        lineage_lay.addWidget(self.lineage_tab)
        self.tabs.addTab(lineage_container, "Lineage Graph")

        # 4) Hierarchy
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")

        # 5) Custom Rule Groups
        self.custom_tab = CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab, "Custom Rule Groups")

        # 6) Approvals
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # 7) Global/Critical Admin (admin only)
        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        # 8) Control Tables
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # auto-refresh approvals
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)

        self.show()

    def refresh_approvals(self):
        """
        Periodically refresh the approvals tab.
        """
        self.approv_tab.load_approvals()

    def get_rule_types(self):
        """
        Used by the rule editor to list possible rule types (e.g. DQ, DM).
        Returns a dict {name -> id}.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_TYPE_NAME, RULE_TYPE_ID FROM BRM_RULE_TYPES")
        rows = get_cursor_rows(c)
        return {r["RULE_TYPE_NAME"]: r["RULE_TYPE_ID"] for r in rows}

    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# MAIN
###############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()