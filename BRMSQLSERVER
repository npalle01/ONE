#!/usr/bin/env python
"""
BRM Tool – SQL Server–only Version

Key Features:
 - Connects via pyodbc to SQL Server
 - Login with seeded USERS table
 - Business Rule Management (Add/Update/Delete with checks)
 - Multi-step Approvals (BG1 -> BG2 -> BG3 -> FINAL)
 - BFS-based lineage graph
 - Hierarchy view
 - Custom rule groups
 - Email notifications
 - Group & User Management (Admin)
 - Global/Critical Admin with cycle prevention
 - Control Tables viewer (TOP 1000 rows)
"""

import sys
import logging
import json
import math
import re
import smtplib
from datetime import datetime
from collections import deque

import pyodbc
from email.mime.text import MIMEText

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime
from PyQt5.QtGui import QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox, QTreeView, QListWidget, QListWidgetItem
)

# Optional analytics library
import pyqtgraph as pg

###############################################################################
# LOGGING & EMAIL CONFIG
###############################################################################
logging.basicConfig(
    filename='brmtool_sqlserver.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

###############################################################################
# HELPER: get_last_inserted_id
###############################################################################
def get_last_inserted_id(cursor):
    """
    For SQL Server: uses SCOPE_IDENTITY() or fallback @@IDENTITY
    """
    try:
        cursor.execute("SELECT SCOPE_IDENTITY()")
        row = cursor.fetchone()
        if row and row[0] is not None:
            return int(row[0])
    except Exception as ex:
        logger.warning(f"SCOPE_IDENTITY() failed: {ex}")

    cursor.execute("SELECT @@IDENTITY")
    row = cursor.fetchone()
    if row and row[0] is not None:
        return int(row[0])
    return None

###############################################################################
# DB UTILITIES
###############################################################################
def get_cursor_rows(cursor):
    """
    Fetches all rows from a pyodbc cursor as a list of dicts.
    """
    rows = cursor.fetchall()
    if not rows:
        return []
    colnames = [desc[0] for desc in cursor.description]
    result = []
    for r in rows:
        row_dict = {}
        for i, col in enumerate(colnames):
            row_dict[col] = r[i]
        result.append(row_dict)
    return result

def get_cursor_one(cursor):
    """
    Fetches a single row as dict (or None).
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        row_dict = {}
        for i, col in enumerate(colnames):
            row_dict[col] = row[i]
        return row_dict
    return None

def send_email_notification(subject, body, recipients):
    """
    Sends an email using SMTP settings in EMAIL_CONFIG
    """
    msg = MIMEText(body, 'plain')
    msg['Subject'] = subject
    msg['From'] = EMAIL_CONFIG['sender_email']
    msg['To'] = ", ".join(recipients)
    try:
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info("Email sent to: " + ", ".join(recipients))
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QDialog):
    """
    Collects a SQL Server ODBC connection string from user.
    Example: DSN=MyDSN;Trusted_Connection=yes;
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("SQL Server Connection")
        layout = QVBoxLayout(self)

        lbl = QLabel("Enter SQL Server ODBC connection string:")
        layout.addWidget(lbl)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("e.g. DSN=MyDSN;Trusted_Connection=yes;")
        layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)

    def get_connection(self):
        conn_str = self.conn_str_edit.text().strip()
        if not conn_str:
            QMessageBox.warning(self, "Empty", "No connection string provided.")
            return None
        try:
            cn = pyodbc.connect(conn_str)
            return cn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

###############################################################################
# AUDIT LOG
###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP)
    VALUES(?,?,?,?,?,?,GETDATE())
    """, (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# RULE UTILS
###############################################################################
def get_op_type_from_sql(sql_text: str) -> str:
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def extract_tables(sql_text: str):
    found = []
    tokens = re.split(r"\s+", sql_text.strip())
    for i, t in enumerate(tokens):
        if t.upper() in ("FROM", "JOIN"):
            if i+1 < len(tokens):
                tbl = re.sub(r"[;(),]", "", tokens[i+1])
                found.append(("", tbl))
    return list(set(found))

def run_rule_sql(conn, rule_sql):
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = get_cursor_one(c)
        if not row:
            return True
        pass_fail = list(row.values())[0]
        return (pass_fail == 1)
    except Exception as ex:
        logger.error("Rule execution error: " + str(ex))
        return False

def build_rule_adjacency(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = get_cursor_rows(c)
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r["RULE_ID"]
        pid = r["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [rid for rid in all_ids if rid not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = get_cursor_rows(c)
    link_map = {}
    for r in rows:
        gcr = r["GCR_RULE_ID"]
        tgt = r["TARGET_RULE_ID"]
        if tgt:
            link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = get_cursor_rows(c)
    return {r["RULE_ID"]: r for r in rows}

def skip_descendants(child_id, children_map, skipped):
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def execute_rules_in_order(conn):
    children_map, root_rules = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    executed = []
    skipped = set()
    queue = list(root_rules)
    rule_lookup = get_all_rules_as_dict(conn)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning(f"Rule not found: {rid}")
            continue

        rinfo = rule_lookup[rid]
        rule_sql = rinfo["RULE_SQL"]
        logger.info(f"Executing rule {rid}: {rinfo['RULE_NAME']}")
        passed = run_rule_sql(conn, rule_sql)
        if passed:
            logger.info(f"Rule {rid} PASSED")
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            logger.warning(f"Rule {rid} FAILED")
            is_crit = (rinfo["CRITICAL_RULE"] == 1 or rinfo["IS_GLOBAL"] == 1)
            crit_scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and crit_scope != "NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    logger.info(f"ETL done. executed={executed}, skipped={list(skipped)}")
    return executed, skipped

def find_impacted_business_groups(conn, rule_id):
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = get_cursor_one(c)
    if row:
        impacted.add(row["OWNER_GROUP"])

    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?", (curr,))
        children = get_cursor_rows(c)
        for ch in children:
            cid = ch["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (cid,))
            row2 = get_cursor_one(c)
            if row2:
                impacted.add(row2["OWNER_GROUP"])
            queue.append(cid)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    c = conn.cursor()
    stage_counter = 1
    stage_list = []
    MULTISTEP_ORDER = ["BG1", "BG2", "BG3", "FINAL"]
    for step in MULTISTEP_ORDER:
        if step == "FINAL":
            stage_list.append((step, stage_counter))
            stage_counter += 1
        else:
            if step in impacted_bg_list:
                stage_list.append((step, stage_counter))
                stage_counter += 1

    for bg, st in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            c.execute("""
            IF NOT EXISTS(
               SELECT 1 FROM BRM_RULE_APPROVALS
               WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
            )
            BEGIN
               INSERT INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVED_TIMESTAMP,APPROVAL_STAGE)
               VALUES(?,?,?,?,NULL,?)
            END
            """, (rule_id, bg, user_ap, 0, st))
        else:
            c2 = conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (bg,))
            rowaps = get_cursor_rows(c2)
            for rap in rowaps:
                c.execute("""
                IF NOT EXISTS(
                   SELECT 1 FROM BRM_RULE_APPROVALS
                   WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
                )
                BEGIN
                   INSERT INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVED_TIMESTAMP,APPROVAL_STAGE)
                   VALUES(?,?,?,?,NULL,?)
                END
                """, (rule_id, bg, rap["USERNAME"], 0, st))
    conn.commit()

def get_current_approval_stage(conn, rule_id):
    c = conn.cursor()
    c.execute("""
    SELECT MIN(APPROVAL_STAGE) as stage
    FROM BRM_RULE_APPROVALS
    WHERE RULE_ID=? AND APPROVED_FLAG=0
    """, (rule_id,))
    row = get_cursor_one(c)
    if row and row["stage"]:
        return row["stage"]
    return None

def add_rule(conn, rule_data, created_by, user_group):
    c = conn.cursor()
    # Check duplicates by name
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if get_cursor_one(c):
        raise ValueError(f"Rule name '{rule_data['RULE_NAME']}' already exists in group '{rule_data['OWNER_GROUP']}'")

    # (Optional) Check duplicates by EXACT RULE_SQL if required
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_SQL=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_SQL"]))
    if get_cursor_one(c):
        raise ValueError("A rule with the same SQL already exists in this group.")

    is_global = rule_data.get("IS_GLOBAL", 0)
    if is_global == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create global rule.")

    ins_sql = """
    INSERT INTO BRM_RULES(
      GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
      EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION, CREATED_BY,
      DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION, OWNER_GROUP,
      APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE,
      CREATED_TIMESTAMP, UPDATED_BY
    )
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,GETDATE(),NULL)
    """
    c.execute(ins_sql, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        "INACTIVE",
        1,
        created_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        rule_data["OWNER_GROUP"],
        "APPROVAL_IN_PROGRESS",
        is_global,
        rule_data.get("CRITICAL_RULE", 0),
        rule_data.get("CRITICAL_SCOPE", "NONE"),
        rule_data.get("CDC_TYPE", "NONE"),
    ))
    new_id = get_last_inserted_id(c)

    # Dependencies
    deps = extract_tables(rule_data["RULE_SQL"])
    for (_, tbn) in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (new_id, '', tbn, 'DerivedCol'))

    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    if is_global == 1:
        logger.info("Global => skip multi-step approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)

    try:
        subject = f"New Rule Added: {rule_data['RULE_NAME']}"
        body = f"User {created_by} added rule ID {new_id}\n\nDetails:\n{json.dumps(rule_data, indent=2)}"
        impacted_grps = find_impacted_business_groups(conn, new_id)
        recips = []
        for g in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g,))
            r = get_cursor_one(c)
            if r and r["EMAIL"]:
                recips.append(r["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on new rule: " + str(ex))

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)

    new_owner = rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_rname = rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()

    # Check duplicates for new name
    if (new_owner != old["OWNER_GROUP"]) or (new_rname != old["RULE_NAME"]):
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",(new_owner, new_rname))
        dup = get_cursor_one(c)
        if dup and dup["RULE_ID"] != old["RULE_ID"]:
            raise ValueError(f"Duplicate rule name '{new_rname}' in group '{new_owner}'")

    # Check duplicates for new SQL
    if (rule_data["RULE_SQL"] != old["RULE_SQL"]) or (new_owner != old["OWNER_GROUP"]):
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_SQL=?",(new_owner, rule_data["RULE_SQL"]))
        dup_sql = get_cursor_one(c)
        if dup_sql and dup_sql["RULE_ID"] != old["RULE_ID"]:
            raise ValueError("A rule with the same SQL already exists in this group.")

    # Check global perms
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set a rule global.")

    up_sql = """
    UPDATE BRM_RULES
    SET
      GROUP_ID=?,
      PARENT_RULE_ID=?,
      RULE_TYPE_ID=?,
      RULE_NAME=?,
      RULE_SQL=?,
      EFFECTIVE_START_DATE=?,
      EFFECTIVE_END_DATE=?,
      STATUS='INACTIVE',
      VERSION=VERSION+1,
      UPDATED_BY=?,
      DESCRIPTION=?,
      OPERATION_TYPE=?,
      BUSINESS_JUSTIFICATION=?,
      OWNER_GROUP=?,
      APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
      IS_GLOBAL=?,
      CRITICAL_RULE=?,
      CRITICAL_SCOPE=?,
      CDC_TYPE=?,
      CREATED_TIMESTAMP=CREATED_TIMESTAMP -- keep original
    WHERE RULE_ID=?
    """
    c.execute(up_sql, (
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_rname,
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        new_owner,
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rule_data["RULE_ID"]
    ))
    # dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    deps = extract_tables(rule_data["RULE_SQL"])
    for (_, tbn) in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (rule_data["RULE_ID"], '', tbn, "DerivedCol"))

    new_data = dict(old_data)
    for k, v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "UPDATE", "BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()

    # Re-init approvals if not global
    if old["IS_GLOBAL"] == 1 or rule_data.get("IS_GLOBAL",0)==1:
        pass
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

    # Email
    try:
        subject = f"Rule Updated: {new_rname}"
        body = (
            f"User {updated_by} updated rule ID {rule_data['RULE_ID']}.\n\n"
            f"Old:\n{json.dumps(old_data, indent=2)}\n\nNew:\n{json.dumps(rule_data, indent=2)}"
        )
        impacted_grps = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        recips = []
        for g_ in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g_,))
            ro = get_cursor_one(c)
            if ro and ro["EMAIL"]:
                recips.append(ro["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on rule update: " + str(ex))

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Deactivate child rules first.")
    old_data = dict(old)

    c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE', UPDATED_BY=?, VERSION=VERSION+1 WHERE RULE_ID=?",
              (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")

    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist, cannot delete.")

    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    leftover = get_cursor_rows(c)
    if leftover:
        raise ValueError("Re-map or remove column references first.")

    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

###############################################################################
# LOGIN DIALOG
###############################################################################
class LoginDialog(QDialog):
    """
    Simple login dialog using USERS table:
    SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)

        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

###############################################################################
# We now define the various Tab classes (BusinessRuleManagementTab, etc.)
###############################################################################
# For brevity, the code is quite large, so below are the key classes with
# no references to old code or placeholders.

# 1) RULE DASHBOARD / BUSINESS RULE MANAGEMENT

class RuleDashboard(QGroupBox):
    """
    Shows rules in a table with searching, filtering, pagination.
    Also has a "Run ETL" and "Analytics" button.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        # Search & Filter
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        self.status_filter.addItem("DELETED", "DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        # Table
        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Name", "SQL", "Status", "Version",
            "Owner Group", "Created Timestamp", "Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        # Pagination
        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        # Buttons row
        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)

        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)

        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics)
        btn_h.addWidget(analytics_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self, "ETL", msg)
        self.load_rules()

    def show_analytics(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()

    def build_filter_query(self):
        f = []
        p = []
        txt = self.search_edit.text().strip()
        if txt:
            f.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            p.extend([f"%{txt}%", f"%{txt}%"])

        st = self.status_filter.currentData()
        if st:
            if st.upper() == "DELETED":
                # We'll interpret "deleted" as rules that appear in the audit log with action=DELETE
                # so we do a subselect
                sub = "(SELECT CAST(RECORD_ID as INT) FROM BRM_AUDIT_LOG WHERE ACTION='DELETE')"
                f.append(f"(RULE_ID IN {sub})")
            else:
                f.append("STATUS=?")
                p.append(st)

        clause = " AND ".join(f) if f else "1=1"
        return clause, p

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        # Count total
        count_query = f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}"
        c.execute(count_query, params)
        rowc = get_cursor_one(c)
        total = rowc["ccount"] if rowc else 0

        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        elif self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset = (self.current_page - 1) * self.records_per_page
        # If your SQL Server is 2012+, you can do OFFSET / FETCH. Otherwise, row_number approach. 
        # We'll do OFFSET approach here:
        try:
            data_query = f"""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
                   CREATED_TIMESTAMP, APPROVAL_STATUS
            FROM BRM_RULES
            WHERE {clause}
            ORDER BY RULE_ID DESC
            OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
            """
            c.execute(data_query, (*params, offset, self.records_per_page))
        except pyodbc.ProgrammingError:
            # fallback: row_number approach
            start_row = offset + 1
            end_row = offset + self.records_per_page
            data_query = f"""
            WITH R AS (
              SELECT
                RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
                CREATED_TIMESTAMP, APPROVAL_STATUS,
                ROW_NUMBER() OVER (ORDER BY RULE_ID DESC) as rn
              FROM BRM_RULES
              WHERE {clause}
            )
            SELECT * FROM R
            WHERE rn BETWEEN ? AND ?
            ORDER BY RULE_ID DESC
            """
            c.execute(data_query, (*params, start_row, end_row))

        rows = get_cursor_rows(c)
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r, 1, QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r, 2, QTableWidgetItem(rd["RULE_SQL"]))
            st_item = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"] and rd["STATUS"].lower() == "active":
                st_item.setBackground(QColor(144, 238, 144))
            else:
                st_item.setBackground(QColor(255, 182, 193))
            self.rule_table.setItem(r, 3, st_item)
            self.rule_table.setItem(r, 4, QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r, 5, QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r, 6, QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r, 7, QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row, 0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id = None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

# 2) RULE ANALYTICS
class RuleAnalyticsDialog(QDialog):
    """
    Displays a bar chart (# of rules by creator) and
    textual display of status distribution
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        chart_hbox = QHBoxLayout()

        self.bar_chart = pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)

        self.text_display = pg.PlotWidget(title="Status Distribution")
        self.text_display.setBackground('w')
        chart_hbox.addWidget(self.text_display)

        layout.addLayout(chart_hbox)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)
        self.load_charts()

    def load_charts(self):
        c = self.connection.cursor()
        # # of rules by CREATED_BY
        c.execute("SELECT CREATED_BY, COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY")
        rows = get_cursor_rows(c)
        creators = {r["CREATED_BY"]: r["cnt"] for r in rows}

        # statuses
        status_counts = {"ACTIVE": 0, "INACTIVE": 0, "DELETED": 0}
        c.execute("SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        srows = get_cursor_rows(c)
        for s_ in srows:
            s_up = s_["STATUS"].upper()
            if s_up in status_counts:
                status_counts[s_up] = s_["sc"]
        # how many deleted from audit?
        c.execute("SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'")
        drow = get_cursor_one(c)
        if drow:
            status_counts["DELETED"] = drow["delcnt"]

        # bar chart
        self.bar_chart.clear()
        if creators:
            sorted_creators = sorted(creators.items(), key=lambda x: x[1], reverse=True)
            names = [x[0] for x in sorted_creators]
            vals = [x[1] for x in sorted_creators]
            bar_item = pg.BarGraphItem(x=range(len(names)), height=vals, width=0.6, brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax = self.bar_chart.getAxis("bottom")
            ax.setTicks([list(zip(range(len(names)), names))])
            self.bar_chart.setLabel("left", "Number of Rules")
            self.bar_chart.setLabel("bottom", "Created By")
            self.bar_chart.showGrid(x=True, y=True)

        self.text_display.clear()
        total = sum(status_counts.values())
        if total > 0:
            label_str = "\n".join([f"{k}: {v}" for k,v in status_counts.items()])
            text_item = pg.TextItem(label_str, anchor=(0,0))
            text_item.setPos(0,0)
            self.text_display.addItem(text_item)

# 3) FULL Business Rule Management Tab
class BusinessRuleManagementTab(QWidget):
    """
    Hosts the RuleDashboard and action buttons for Add/Update/Deactivate/Delete, etc.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)

        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)

        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)

        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)

        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)

        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        layout.addWidget(self.rule_dash)
        layout.addStretch()
        self.setLayout(layout)

    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "None", "Rule not found in DB.")
            return
        rule_data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rules selected.")
            return
        success = 0
        fails = []
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rr}: {str(ex)}")
        msg = f"Deactivation done. success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dash.load_rules()

    def on_delete_rule(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule(s) selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        fails = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rid}: {str(ex)}")
        msg = f"Deletion done. success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dash.load_rules()

# 4) RULE EDITOR DIALOG
class RuleEditorDialog(QDialog):
    """
    Allows Add or Edit of a rule. 
    """
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_types = rule_types
        self.logged_in_user = logged_in_user
        self.rule_data = rule_data

        self.setWindowTitle("Edit Rule" if rule_data else "Add New Rule")
        self.resize(900, 500)
        main_layout = QHBoxLayout(self)

        left_box = QGroupBox("Basic Info")
        left_layout = QFormLayout(left_box)

        self.group_combo = QComboBox()
        self.group_combo.addItem("None", None)
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        rows = get_cursor_rows(c)
        for r in rows:
            self.group_combo.addItem(r["GROUP_NAME"], r["GROUP_ID"])
        left_layout.addRow("Rule Group:", self.group_combo)

        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("None", None)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
        pr_rows = get_cursor_rows(c)
        for rr in pr_rows:
            self.parent_rule_combo.addItem(f"{rr['RULE_NAME']} (ID:{rr['RULE_ID']})", rr["RULE_ID"])
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit = QLineEdit()
        left_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo = QComboBox()
        for rt_name in self.rule_types:
            self.type_combo.addItem(rt_name)
        left_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["ACTIVE","INACTIVE"])
        left_layout.addRow("Status (display):", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:", self.end_dt)

        self.owner_grp_combo = QComboBox()
        c.execute("SELECT DISTINCT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        og_rows = get_cursor_rows(c)
        for g_ in og_rows:
            self.owner_grp_combo.addItem(g_["GROUP_NAME"], g_["GROUP_NAME"])
        left_layout.addRow("Owner Group:", self.owner_grp_combo)

        self.global_checkbox = None
        if self.logged_in_user == "Admin":
            self.global_checkbox = QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:", self.global_checkbox)

        self.critical_checkbox = QCheckBox()
        left_layout.addRow("Critical Rule?", self.critical_checkbox)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        left_layout.addRow("Critical Scope:", self.scope_combo)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","INSERT_ONLY","UPSERT"])
        left_layout.addRow("CDC Type:", self.cdc_combo)

        main_layout.addWidget(left_box)

        right_box = QGroupBox("Details & Logic")
        right_layout = QFormLayout(right_box)

        self.sql_editor = QPlainTextEdit()
        font = QtGui.QFont("Courier",10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"), self.sql_editor)

        self.description_edit = QTextEdit()
        right_layout.addRow(QLabel("Description:"), self.description_edit)

        self.justification_edit = QTextEdit()
        right_layout.addRow(QLabel("Justification:"), self.justification_edit)

        btn_box = QHBoxLayout()
        self.save_btn = QPushButton("Save" if rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)
        right_layout.addRow(btn_box)

        main_layout.addWidget(right_box)
        self.setLayout(main_layout)

        if self.rule_data:
            self.load_rule_data(self.rule_data)

    def load_rule_data(self, rd):
        if rd["GROUP_ID"]:
            idx = self.group_combo.findData(rd["GROUP_ID"])
            if idx >= 0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2 = self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2 >= 0:
                self.parent_rule_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"])

        # match rule_type
        # e.g. self.rule_types = {"DQ":1,"DM":2}, we want the name that matches.
        for nm, tid in self.rule_types.items():
            if tid == rd["RULE_TYPE_ID"]:
                i = self.type_combo.findText(nm)
                if i>=0: self.type_combo.setCurrentIndex(i)
                break

        st = rd["STATUS"]
        i_st = self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        # parse start/end
        try:
            sdt = datetime.strptime(rd["EFFECTIVE_START_DATE"], "%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except:
            pass
        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt = datetime.strptime(rd["EFFECTIVE_END_DATE"], "%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except:
                pass

        og = rd["OWNER_GROUP"]
        iog = self.owner_grp_combo.findText(og)
        if iog>=0:
            self.owner_grp_combo.setCurrentIndex(iog)

        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        if self.global_checkbox and rd.get("IS_GLOBAL",0)==1:
            self.global_checkbox.setChecked(True)
        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_checkbox.setChecked(True)
        scope_val = rd.get("CRITICAL_SCOPE","NONE")
        ix_scope = self.scope_combo.findText(scope_val.upper())
        if ix_scope>=0:
            self.scope_combo.setCurrentIndex(ix_scope)
        cdc_val = rd.get("CDC_TYPE","NONE").upper()
        ix_cdc = self.cdc_combo.findText(cdc_val)
        if ix_cdc>=0:
            self.cdc_combo.setCurrentIndex(ix_cdc)

    def on_save(self):
        if not self.name_edit.text().strip():
            QMessageBox.warning(self,"Error","Name is empty.")
            return
        sql_text = self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self,"Error","SQL is empty.")
            return

        op_type = get_op_type_from_sql(sql_text)
        rule_dict = {
            "GROUP_ID": self.group_combo.currentData(),
            "PARENT_RULE_ID": self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID": self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME": self.name_edit.text().strip(),
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
            "CDC_TYPE": self.cdc_combo.currentText().upper()
        }
        created_by = self.logged_in_user

        if self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success","Rule updated. Approval re-initiated.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"DB Error",str(ex))
        else:
            confirm = QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success",f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"DB Error",str(ex))

# Additional tabs: GroupManagementTab, UserManagementTab, etc.
#  – For brevity, you’d replicate similar logic: read from DB, present tables, do updates with T-SQL.

# For example, a simple ControlTablesTab for browsing top 1000 rows from each control table:
class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS", "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES",
            "BRM_AUDIT_LOG", "BRM_RULE_LINEAGE", "BRM_GROUP_BACKUPS",
            "BRM_COLUMN_MAPPING", "BRM_CUSTOM_RULE_GROUPS", "BRM_CUSTOM_GROUP_MEMBERS",
            "BUSINESS_GROUP_APPROVERS", "BRM_RULE_APPROVALS", "BRM_CUSTOM_GROUP_BACKUPS",
            "BRM_GLOBAL_CRITICAL_LINKS"
        ]
        self.table_combo = QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.table_view = QTableWidget(0,0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)

        self.setLayout(layout)

    def on_load_data(self):
        tbl = self.table_combo.currentText()
        c = self.connection.cursor()
        try:
            query = f"SELECT TOP 1000 * FROM {tbl}"
            c.execute(query)
            rows = get_cursor_rows(c)
            self.table_view.setRowCount(0)
            if not rows:
                self.table_view.setColumnCount(0)
                return
            col_names = list(rows[0].keys())
            self.table_view.setColumnCount(len(col_names))
            self.table_view.setHorizontalHeaderLabels(col_names)
            for rd in rows:
                r = self.table_view.rowCount()
                self.table_view.insertRow(r)
                for j, cn in enumerate(col_names):
                    val = rd[cn] if cn in rd else None
                    self.table_view.setItem(r, j, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Could not load from {tbl}: {ex}")

# Similarly, you'd implement GroupManagementTab, UserManagementTab, etc. as admin-only sections.

# 5) MULTISTEP APPROVAL TAB
class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.layout().setSpacing(5)
        stages = ["BG1","BG2","BG3","FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st,"NotStarted")
            if status=="Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status=="Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class MultiStepApprovalTab(QWidget):
    """
    Shows user their pending approvals (lowest stage).
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.appr_table = QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels(["Rule ID","Group Name","Rule Name","Stage","Approved?","Action","Pipeline"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows = get_cursor_rows(c)

        # gather pipeline info for all rules
        pipeline_data = {}
        all_app = self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        all_rows = get_cursor_rows(all_app)
        for apr in all_rows:
            rid = apr["RULE_ID"]
            grp = apr["GROUP_NAME"]
            stage = apr["APPROVAL_STAGE"]
            flag = apr["APPROVED_FLAG"]
            pipeline_data.setdefault(rid,{"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            if flag==1:
                pipeline_data[rid][grp]="Approved"
            else:
                cur_st = get_current_approval_stage(self.connection, rid)
                if cur_st==stage:
                    pipeline_data[rid][grp]="Pending"

        # only show rows for the user at the current stage
        minimal_rows = []
        for rd in rows:
            rid = rd["RULE_ID"]
            st = rd["APPROVAL_STAGE"]
            min_st = get_current_approval_stage(self.connection, rid)
            if min_st==st:
                minimal_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r,2,QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r,3,QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r,4,QTableWidgetItem("0"))

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _,row_idx=r: self.do_approve(row_idx))
            self.appr_table.setCellWidget(r,5,approve_btn)

            pipe_map = pipeline_data.get(rd["RULE_ID"],{"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r,6,pipe_widget)

    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index,0)
        grp_item = self.appr_table.item(row_index,1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        grp = grp_item.text()
        c = self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id, grp, self.logged_in_username))
        nxt = get_current_approval_stage(self.connection, rule_id)
        if nxt is None:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?", (rule_id,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?", (rule_id,))
        add_audit_log(self.connection, "UPDATE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username,
                      {"APPROVED_FLAG":0}, {"APPROVED_FLAG":1})
        self.connection.commit()
        QMessageBox.information(self, "Approved", f"You approved rule {rule_id}.")
        self.load_approvals()

# 6) A simple “Hierarchy View Tab”
class HierarchyViewTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tree_view = QTreeView()
        layout.addWidget(self.tree_view)

        btn = QPushButton("Refresh Hierarchy")
        btn.clicked.connect(self.refresh_tree)
        layout.addWidget(btn)

        self.setLayout(layout)
        self.refresh_tree()

    def refresh_tree(self):
        model = QStandardItemModel()
        model.setHorizontalHeaderLabels(["Hierarchy"])
        root_item = QStandardItem("APPLICATION")
        root_item.setEditable(False)
        model.appendRow(root_item)

        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        groups = get_cursor_rows(c)

        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS")
        rg_rows = get_cursor_rows(c)
        rg_map = {x["GROUP_ID"]: x["GROUP_NAME"] for x in rg_rows}

        for g in groups:
            g_item = QStandardItem(f"{g['GROUP_NAME']} ({g['EMAIL']})")
            g_item.setEditable(False)
            root_item.appendRow(g_item)

            c.execute("SELECT * FROM BRM_RULES WHERE OWNER_GROUP=?", (g["GROUP_NAME"],))
            arr = get_cursor_rows(c)
            # Just list them for demonstration, or do your BFS adjacency if desired
            for r_ in arr:
                item_txt = f"Rule {r_['RULE_ID']}: {r_['RULE_NAME']}"
                if r_["IS_GLOBAL"]==1:
                    item_txt += " (GLOBAL)"
                if r_["CRITICAL_RULE"]==1:
                    item_txt += " (CRITICAL)"
                it = QStandardItem(item_txt)
                it.setEditable(False)
                g_item.appendRow(it)

        self.tree_view.setModel(model)
        self.tree_view.expandAll()

# 7) An EnhancedLineageGraphWidget for BFS-based lineage
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.node_map = {}
        self.children_map = {}
        self.parents_map = {}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
        FROM BRM_RULES
        """)
        rules = get_cursor_rows(c)
        if not rules:
            txt_item = QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(txt_item)
            return

        # adjacency
        for r in rules:
            rid = r["RULE_ID"]
            pid = r["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                self.parents_map[rid] = pid

        rule_lookup = {r["RULE_ID"]:r for r in rules}
        all_ids = set(r["RULE_ID"] for r in rules)
        child_ids = set(self.parents_map.keys())
        roots = list(all_ids - child_ids)

        from collections import deque
        queue = deque()
        level_map = {}
        visited = set()
        for rt in roots:
            queue.append((rt,0))

        while queue:
            (rid,depth) = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            rinfo = rule_lookup[rid]
            c_so_far = level_map.get(depth,0)
            level_map[depth] = c_so_far+1
            x = depth * 220
            y = c_so_far * 120
            node_item = self.create_node(rinfo)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid] = node_item
            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch,depth+1))

        # Draw edges
        for r in rules:
            pid = r["PARENT_RULE_ID"]
            rid = r["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # Table dependencies
        c.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps = get_cursor_rows(c)
        table_nodes = {}
        for dep in deps:
            key = f"{dep['DATABASE_NAME']}.{dep['TABLE_NAME']}"
            if key not in table_nodes:
                t_item = QtWidgets.QGraphicsEllipseItem(0,0,100,40)
                t_item.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
                t_item.setToolTip(key)
                t_item.setPos(800, len(table_nodes)*60)
                self.scene.addItem(t_item)
                table_nodes[key] = t_item
            rid_ = dep["RULE_ID"]
            if rid_ in self.node_map:
                self.draw_edge(self.node_map[rid_], table_nodes[key], color=QtGui.QColor("darkmagenta"))

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, rinfo):
        rtype = rinfo["RULE_TYPE_ID"]
        status = rinfo["STATUS"]
        cluster = rinfo.get("CLUSTER_NAME","") or ""
        is_global = rinfo["IS_GLOBAL"]
        is_crit = rinfo["CRITICAL_RULE"]

        if rtype==1:
            node = QtWidgets.QGraphicsRectItem(0,0,120,50)
        else:
            node = QtWidgets.QGraphicsEllipseItem(0,0,120,50)

        if status and status.lower()=="active":
            basecol = QtGui.QColor("lightgreen")
        else:
            basecol = QtGui.QColor("tomato")

        if cluster:
            hv = abs(hash(cluster)) % 360
            basecol = QtGui.QColor.fromHsv(hv,128,255)
        node.setBrush(QtGui.QBrush(basecol))
        pen = QtGui.QPen(QtCore.Qt.black,2)
        if is_crit==1:
            pen = QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)

        name_display = rinfo["RULE_NAME"]
        if is_global==1:
            name_display = f"(G) {name_display}"
        node.setToolTip(f"Rule {rinfo['RULE_ID']}: {name_display}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1 = item1.sceneBoundingRect()
        r2 = item2.sceneBoundingRect()
        p1 = r1.center()
        p2 = r2.center()
        line = QtWidgets.QGraphicsLineItem(p1.x(),p1.y(),p2.x(),p2.y())
        line.setPen(QtGui.QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(),Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button()==Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item,(QtWidgets.QGraphicsRectItem, QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self,"Rule Details", item.toolTip())
        super().mousePressEvent(event)

###############################################################################
# RULE EDITOR AGAIN (already above)...

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    """
    Master window that orchestrates:
      - Connection to SQL Server
      - Login
      - QTabWidget with various tabs
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – SQL Server Version")
        self.resize(1200,800)

        # 1) Connect to DB
        self.connection = None
        dbdlg = DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection = dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # 2) Login
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id = self.login_dialog.user_id
        c = self.connection.cursor()
        c.execute("SELECT USERNAME, USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowu = get_cursor_one(c)
        if rowu:
            self.logged_in_username = rowu["USERNAME"]
            self.user_group = rowu["USER_GROUP"]
        else:
            self.logged_in_username = "Unknown"
            self.user_group = "Unknown"

        self.init_ui()

    def init_ui(self):
        cw = QWidget()
        layout = QVBoxLayout(cw)

        # If admin, allow user-switch
        if self.user_group=="Admin":
            top_h = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # BRM Tab
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")

        # If admin, add group mgmt, user mgmt, etc. 
        if self.user_group=="Admin":
            # Could define GroupManagementTab, UserManagementTab, etc.
            pass

        # Lineage
        lw_container = QWidget()
        lw_layout = QVBoxLayout(lw_container)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lw_layout.addWidget(self.lineage_tab)
        lw_container.setLayout(lw_layout)
        self.tabs.addTab(lw_container, "Lineage Visualization")

        # Hierarchy
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")

        # Approvals
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # Control Tables
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # auto-refresh approvals
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)

        self.show()

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = get_cursor_rows(c)
        for row in rows:
            disp = f"{row['USERNAME']} ({row['USER_GROUP']})"
            self.switch_combo.addItem(disp, (row["USER_ID"], row["USER_GROUP"]))

    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        self.reinit_tabs()

    def reinit_tabs(self):
        self.tabs.clear()
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")
        # etc. Rebuild other tabs as needed.

        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")
        # etc.

    def refresh_approvals(self):
        self.approv_tab.load_approvals()

    def get_rule_types(self):
        """
        Queries BRM_RULE_TYPES, returns dict {type_name: type_id}
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_TYPE_NAME, RULE_TYPE_ID FROM BRM_RULE_TYPES")
        rows = get_cursor_rows(c)
        return {r["RULE_TYPE_NAME"]: r["RULE_TYPE_ID"] for r in rows}

    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Shows last 1000 logs with optional search by action/table/action_by
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800,600)

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search action/table/action_by")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table = QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels([
            "Audit ID","Action","Table","Record ID","Action By","Old Data","New Data","Timestamp"
        ])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        c = self.connection.cursor()
        try:
            q = """
            SELECT TOP 1000 
              AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
            """
            c.execute(q)
            rows = get_cursor_rows(c)
            self.audit_table.setRowCount(0)
            for row in rows:
                r = self.audit_table.rowCount()
                self.audit_table.insertRow(r)
                self.audit_table.setItem(r, 0, QTableWidgetItem(str(row["AUDIT_ID"])))
                self.audit_table.setItem(r, 1, QTableWidgetItem(row["ACTION"]))
                self.audit_table.setItem(r, 2, QTableWidgetItem(row["TABLE_NAME"]))
                self.audit_table.setItem(r, 3, QTableWidgetItem(row["RECORD_ID"]))
                self.audit_table.setItem(r, 4, QTableWidgetItem(row["ACTION_BY"]))

                oldtxt = row["OLD_DATA"] if row["OLD_DATA"] else ""
                newtxt = row["NEW_DATA"] if row["NEW_DATA"] else ""
                self.audit_table.setItem(r, 5, QTableWidgetItem(oldtxt))
                self.audit_table.setItem(r, 6, QTableWidgetItem(newtxt))
                self.audit_table.setItem(r, 7, QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Failed loading logs: {ex}")

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            match = False
            for col in (1,2,4):
                it = self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    match=True
                    break
            self.audit_table.setRowHidden(row, not match)

###############################################################################
# SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialog(QDialog):
    """
    Simple search for BRM_RULES by name or SQL (top 1000).
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800,600)

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet ...")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt = self.search_edit.text().strip()
        c = self.connection.cursor()
        if txt:
            try:
                q = """
                SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(q, (f"%{txt}%",f"%{txt}%"))
            except pyodbc.ProgrammingError:
                # fallback row_number
                q = """
                WITH R AS(
                  SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY,
                         ROW_NUMBER() OVER (ORDER BY RULE_ID DESC) AS rn
                  FROM BRM_RULES
                  WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                )
                SELECT * FROM R WHERE rn<=1000
                """
                c.execute(q, (f"%{txt}%",f"%{txt}%"))
        else:
            try:
                q = """
                SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(q)
            except pyodbc.ProgrammingError:
                q = """
                WITH R AS(
                  SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY,
                         ROW_NUMBER() OVER (ORDER BY RULE_ID DESC) AS rn
                  FROM BRM_RULES
                )
                SELECT * FROM R WHERE rn<=1000
                """
                c.execute(q)

        rows = get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r,0,QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r,1,QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r,2,QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r,3,QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r,4,QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r,5,QTableWidgetItem(row["CREATED_BY"]))

###############################################################################
# MAIN
###############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()