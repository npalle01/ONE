#!/usr/bin/env python3
"""
ADVANCED BRM TOOL - PART 1 of 4
--------------------------------
This Part includes:
  - Logging & Email config
  - DatabaseConnectionDialog
  - Basic DB helpers + Audit
  - User LoginDialog
  - Operation detection & advanced SQL parser
  - BFS adjacency + advanced CRUD with multi-step approvals references
  - No references to old or placeholder code
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
from datetime import datetime
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QComboBox, QMessageBox, QLineEdit
)

# ------------------------------------------------------------------------------
# 1) LOGGING & EMAIL
# ------------------------------------------------------------------------------
logging.basicConfig(
    filename='brm_tool.log', 
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Send email (plain text) to 'recipients' using EMAIL_CONFIG.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

# ------------------------------------------------------------------------------
# 2) DATABASE CONNECTION DIALOG
# ------------------------------------------------------------------------------
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Lets user pick an ODBC DSN or provide custom connection string for pyodbc.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection - Part 1")
        self.resize(420, 200)

        layout = QVBoxLayout(self)
        lbl = QLabel("Select SQL Server ODBC DSN or custom conn string:")
        layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC conn string (optional)")
        layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cb_btn = QPushButton("Cancel")
        cb_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cb_btn)
        layout.addLayout(btn_h)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self,"Error","No DSN or conn string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self,"Connection Error", str(ex))
            return None

# ------------------------------------------------------------------------------
# 3) DB HELPERS + AUDIT
# ------------------------------------------------------------------------------
def get_cursor_rows(cursor):
    """
    Safely fetches rows => list of dict, if columns present.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return [dict(zip(cols, r)) for r in rows]
    return rows

def get_cursor_one(cursor):
    """
    Fetch one => dict if columns present, else None.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return dict(zip(cols, row))
    return None

def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert an audit record. old_data/new_data can be dict => stored as JSON text.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
      OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """,(
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

# ------------------------------------------------------------------------------
# 4) LOGIN DIALOG
# ------------------------------------------------------------------------------
class LoginDialog(QtWidgets.QDialog):
    """
    Basic username/password prompt checking a USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login - Part 1")
        self.resize(300,150)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self,"Error","Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")

# ------------------------------------------------------------------------------
# 5) OPERATION DETECTION + ADVANCED SQL PARSER
# ------------------------------------------------------------------------------
def detect_operation_type(sql_text: str)->str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, or OTHER 
    by checking the first word of sql_text (case-insensitive).
    """
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def enhanced_advanced_extract_tables(sql_text:str):
    """
    Parse the SQL text to find:
     - tables (list of (schema, table, alias, is_subselect))
     - cte_tables (list of (cte_name, references))
     - alias_map (dict alias -> (schema, table))
     - columns (list of (col_name, is_dml_target, in_select))
    """
    import sqlparse
    from sqlparse.sql import Identifier, IdentifierList, Parenthesis
    from sqlparse.tokens import Keyword, DML

    statements = sqlparse.parse(sql_text)
    final_tables = []
    cte_info = []
    alias_map = {}
    column_list = []

    for stmt in statements:
        cte_dict = _extract_with_clauses(stmt)
        for cName, refs in cte_dict.items():
            cte_info.append((cName, refs))

        main_refs, main_alias = _extract_main_from(stmt.tokens, set(cte_dict.keys()))
        final_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs = _extract_columns(stmt)
        column_list.extend(col_refs)

    final_tables = list({x for x in final_tables})  # unique
    return {
        "tables": final_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": column_list
    }

def _extract_with_clauses(statement):
    from sqlparse.tokens import Keyword
    cte_map={}
    tokens = list(statement.tokens)
    i=0
    while i<len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper()=="WITH":
            i+=1
            i=_parse_cte_block(tokens, i, cte_map)
            continue
        i+=1
    return cte_map

def _parse_cte_block(tokens,i,cte_map):
    from sqlparse.sql import Identifier, Parenthesis
    from sqlparse.tokens import Keyword
    while i<len(tokens):
        tk=tokens[i]
        if isinstance(tk, Identifier):
            cte_name=tk.get_real_name()
            i+=1
            i=_parse_cte_as_clause(tokens,i,cte_name,cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i+=1
    return i

def _parse_cte_as_clause(tokens,i,cte_name,cte_map):
    from sqlparse.sql import Parenthesis
    from sqlparse.tokens import Keyword
    while i<len(tokens):
        tk=tokens[i]
        val=tk.value.upper() if tk.ttype else ""
        if val=="AS":
            i+=1
            if i<len(tokens):
                sub=tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs=_extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name]=sub_refs
                    i+=1
                    return i
        else:
            i+=1
    return i

def _extract_subselect_tokens(tokens):
    from sqlparse.sql import Identifier, IdentifierList
    from sqlparse.tokens import Keyword, DML
    results=[]
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident,set())
                    st=(st[0], st[1], st[2],True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st=_parse_identifier(tk,set())
                st=(st[0], st[1], st[2],True)
                results.append(st)
        i+=1
    return results

def _is_subselect(token):
    from sqlparse.tokens import DML
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper()=="SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    from sqlparse.sql import Identifier, IdentifierList
    from sqlparse.tokens import Keyword
    results=[]
    alias_map={}
    tokens=list(tokenlist)
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, known_cte_names)
                    results.append(st)
                    al=st[2]
                    if al:
                        alias_map[al]=(st[0],st[1])
            elif isinstance(tk, Identifier):
                st=_parse_identifier(tk, known_cte_names)
                results.append(st)
                al=st[2]
                if al:
                    alias_map[al]=(st[0],st[1])
        i+=1
    return (results, alias_map)

def _parse_identifier(ident, known_cte_names):
    alias=ident.get_alias()
    real_name=ident.get_real_name()
    schema_name=ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None,f"(CTE) {real_name}",alias,False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    from sqlparse.tokens import DML
    results=[]
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is DML:
            dml_word=tk.value.upper()
            if dml_word=="SELECT":
                col_refs=_parse_select_list(tokens,i+1)
                for c_ in col_refs:
                    results.append((c_,False,True))
            elif dml_word in ("INSERT","UPDATE"):
                col_refs2=_parse_dml_columns(tokens,i,dml_word)
                for c_ in col_refs2:
                    results.append((c_,True,False))
        i+=1
    return results

def _parse_select_list(tokens,start_idx):
    from sqlparse.sql import IdentifierList,Identifier
    from sqlparse.tokens import Keyword
    columns=[]
    i=start_idx
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                colnm=ident.get_name()
                if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(colnm)
        elif isinstance(tk, Identifier):
            colnm=tk.get_name()
            if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(colnm)
        i+=1
    return columns

def _parse_dml_columns(tokens,start_idx,dml_word):
    from sqlparse.sql import Parenthesis,IdentifierList,Identifier
    columns=[]
    if dml_word=="INSERT":
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                # parse columns in parentheses
                for subiden in tk.tokens:
                    if isinstance(subiden, IdentifierList):
                        for ident in subiden.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(subiden, Identifier):
                        columns.append(subiden.get_name())
                return columns
            i+=1
    elif dml_word=="UPDATE":
        found_set=False
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.ttype and tk.ttype==sqlparse.tokens.Keyword and tk.value.upper()=="SET":
                found_set=True
                i+=1
                columns.extend(_parse_update_set_list(tokens,i))
                break
            i+=1
    return columns

def _parse_update_set_list(tokens, start_i):
    from sqlparse.sql import Identifier
    from sqlparse.tokens import Keyword
    columns=[]
    i=start_i
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, Identifier):
            columns.append(tk.get_name())
        i+=1
    return columns

# ------------------------------------------------------------------------------
# 6) BFS ADJACENCY + ADVANCED CRUD + APPROVALS (No placeholders)
# ------------------------------------------------------------------------------
def build_rule_adjacency(conn):
    """
    Return children_map: { parent_rule_id: [child_rule_ids] }, plus a list of root rule_ids.
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows=c.fetchall()
    children_map={}
    all_ids=set()
    parent_ids=set()
    for row in rows:
        rid=row[0]
        pid=row[1]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid,[]).append(rid)
    roots=[x for x in all_ids if x not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    """
    Return { gcr_rule_id: set(child_rule_ids) } from BRM_GLOBAL_CRITICAL_LINKS
    """
    c=conn.cursor()
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows=c.fetchall()
    link_map={}
    for row in rows:
        gcr=row[0]
        tgt=row[1]
        link_map.setdefault(gcr,set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    """
    Return { rule_id: entire row }
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows=c.fetchall()
    cols=[desc[0] for desc in c.description]
    out={}
    for r_ in rows:
        d=dict(zip(cols,r_))
        out[d["RULE_ID"]]=d
    return out

def skip_descendants(child_id, children_map, skipped):
    """
    BFS skip for critical failure => skip all children
    """
    stack=[child_id]
    while stack:
        cur=stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in children_map:
            stack.extend(children_map[cur])

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert record in RULE_EXECUTION_LOGS.
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
    )
    VALUES(?,GETDATE(),?,?,?)
    """,(rule_id,1 if pass_flag else 0,message,record_count))
    conn.commit()

def execute_rules_in_order(conn):
    """
    BFS from roots => if critical fails => skip children. 
    Return (executed_list, skipped_set).
    """
    children_map, roots=build_rule_adjacency(conn)
    gcr_links=load_global_critical_links(conn)
    rule_lookup=get_all_rules_as_dict(conn)

    executed=[]
    skipped=set()
    c=conn.cursor()
    queue=list(roots)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            continue
        rinfo=rule_lookup[rid]
        sql_=rinfo["RULE_SQL"]
        is_crit=(rinfo["CRITICAL_RULE"]==1 or rinfo["IS_GLOBAL"]==1)
        crit_scope=(rinfo["CRITICAL_SCOPE"] or "NONE").upper()

        c.execute("BEGIN TRANSACTION")
        success=False
        msg=""
        record_count=0
        try:
            c.execute(sql_)
            rows=c.fetchall()
            if rows:
                record_count=len(rows)
                val=rows[0][0]
                success=(val==1)
                msg=f"Returned: {val}"
            else:
                success=True
                msg="No rows => PASS"
            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success=False
            msg=str(ex)

        insert_rule_execution_log(conn, rid, success, msg, record_count)

        if success:
            executed.append(rid)
            if rid in children_map:
                for ch_ in children_map[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            if is_crit and crit_scope!="NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    return (executed, skipped)

def get_child_rules_bfs(conn, start_rule_id):
    """
    BFS gather all descendants (including any global-critical links).
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    all_=c.fetchall()
    children_map={}
    for row in all_:
        rid=row[0]
        pid=row[1]
        if pid:
            children_map.setdefault(pid,[]).append(rid)
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    glinks=c.fetchall()
    gl_map={}
    for row in glinks:
        g_parent=row[0]
        g_child=row[1]
        gl_map.setdefault(g_parent,[]).append(g_child)

    visited=set()
    queue=[start_rule_id]
    results=set()
    while queue:
        cur=queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in children_map:
            for ch_ in children_map[cur]:
                results.add(ch_)
                queue.append(ch_)
        if cur in gl_map:
            for ch_ in gl_map[cur]:
                results.add(ch_)
                queue.append(ch_)
    return results

def find_impacted_business_groups(conn, rule_id):
    """
    BFS from rule => gather owner groups. Return set of group names.
    """
    impacted=set()
    c=conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if row:
        impacted.add(row[0])
    children=get_child_rules_bfs(conn, rule_id)
    for cid in children:
        c2=conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(cid,))
        rr=c2.fetchone()
        if rr:
            impacted.add(rr[0])
    return impacted

def create_multistep_approvals(conn, rule_id):
    """
    Setup multi-step approvals BG1->BG2->BG3->FINAL, only for groups actually impacted.
    """
    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    base_order=["BG1","BG2","BG3","FINAL"]
    impacted=find_impacted_business_groups(conn, rule_id)
    pipeline=[]
    stage_ctr=1

    for stg in base_order:
        if stg=="FINAL":
            pipeline.append(stg)
        else:
            if stg in impacted:
                pipeline.append(stg)

    for st_ in pipeline:
        if st_=="FINAL":
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,
                                           APPROVED_FLAG,APPROVED_TIMESTAMP,APPROVAL_STAGE)
            VALUES(?,?,?,?,NULL,?)
            """,(rule_id,"FINAL","final_approver",0,stage_ctr))
            stage_ctr+=1
        else:
            c2=conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(st_,))
            rows=c2.fetchall()
            for r_ in rows:
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,
                                               APPROVED_FLAG,APPROVED_TIMESTAMP,APPROVAL_STAGE)
                VALUES(?,?,?,?,NULL,?)
                """,(rule_id, st_, r_[0], 0, stage_ctr))
            stage_ctr+=1
    conn.commit()

def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert new rule => BFS approvals if not global => parse table dependencies => audit log.
    """
    c=conn.cursor()
    # check dup name
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    new_sql=rule_data["RULE_SQL"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
    if c.fetchone():
        raise ValueError("Another rule with same SQL not allowed.")

    if rule_data.get("IS_GLOBAL",0)==1 and user_group!="Admin":
        raise ValueError("Only Admin can create global rule.")

    op_type=detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"]=op_type

    row=c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
      EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
      CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
      CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,
      APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
    )
    OUTPUT inserted.RULE_ID
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS","INACTIVE"),
        1,
        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),
        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE")
    )).fetchone()
    if not row:
        raise ValueError("Insert failed, no RULE_ID returned.")
    new_id=row[0]

    # parse dependencies
    parse_info=enhanced_advanced_extract_tables(new_sql)
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    else:
        col_op="READ"
    for (sch,tb,alias,_) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            dbn=sch if sch else "dbo"
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(new_id, dbn, tb, "DerivedCol", col_op))

    add_audit_log(conn,"INSERT","BRM_RULES",new_id, created_by, None, rule_data)
    conn.commit()

    # BFS approvals if not global
    if rule_data.get("IS_GLOBAL",0)==0:
        create_multistep_approvals(conn, new_id)

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c=conn.cursor()
    rid=rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data=dict(old)

    new_sql=rule_data["RULE_SQL"].strip()
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"])==1 and user_group!="Admin":
        raise ValueError("Only Admin can set is_global=1.")

    op_type=detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"]=op_type

    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID=?,
      PARENT_RULE_ID=?,
      RULE_TYPE_ID=?,
      RULE_NAME=?,
      RULE_SQL=?,
      EFFECTIVE_START_DATE=?,
      EFFECTIVE_END_DATE=?,
      STATUS='INACTIVE',
      VERSION=VERSION+1,
      UPDATED_BY=?,
      DESCRIPTION=?,
      OPERATION_TYPE=?,
      BUSINESS_JUSTIFICATION=?,
      OWNER_GROUP=?,
      CLUSTER_NAME=?,
      APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
      IS_GLOBAL=?,
      CRITICAL_RULE=?,
      CRITICAL_SCOPE=?,
      CDC_TYPE=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"],
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old["BUSINESS_JUSTIFICATION"]),
        rule_data.get("OWNER_GROUP", old["OWNER_GROUP"]),
        rule_data.get("CLUSTER_NAME", old.get("CLUSTER_NAME","")),
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rid
    ))

    # re-populate dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    parse_info=enhanced_advanced_extract_tables(new_sql)
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    else:
        col_op="READ"
    for (sch,tb,alias,_) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            dbn=sch if sch else "dbo"
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(rid, dbn, tb, "DerivedCol", col_op))

    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"]=old_data["VERSION"]+1

    add_audit_log(conn,"UPDATE","BRM_RULES",rid, updated_by, old_data, new_data)
    conn.commit()

    # if not global => recreate BFS approvals
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"])==0:
        create_multistep_approvals(conn, rid)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate unless fully APPROVED.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")

    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids=c.fetchall()
    if kids:
        raise ValueError("Deactivate child rules first.")

    old_data=dict(old)
    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',UPDATED_BY=?,VERSION=VERSION+1
    WHERE RULE_ID=?
    """,(updated_by, rule_id))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    add_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete if not fully APPROVED.")
    if old["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")

    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids=c.fetchall()
    if kids:
        raise ValueError("Child rules exist, cannot delete.")

    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    leftover=c.fetchall()
    if leftover:
        raise ValueError("Re-map or remove references first.")

    old_data=dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by, old_data, None)
    conn.commit()

#
# End of PART 1 code
# Next: Wait for your "OK", then receive PART 2
#
"""
ADVANCED BRM TOOL - PART 2 of 4
--------------------------------
In this part:
  1) Simulation dialogs (SingleRuleSimulationDialog, ChainSimulationDialog, GroupSimulationDialog)
  2) Scheduling (EnhancedScheduleDialog, ScheduleManagementTab)
  3) Sync metadata (sync_metadata_improved)
  4) DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab
  5) SnapshotManagerTab, TagsManagerTab, DataValidationTab
  (The advanced UI classes – no references to old code or placeholders.)
"""

import sys
import json
import math
import logging
import pyodbc
import sqlparse
from datetime import datetime
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDate
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QMessageBox, QInputDialog, QWidget
)

logger = logging.getLogger(__name__)

# We assume we have from PART 1:
#   - BFS references (execute_rules_in_order, etc.)
#   - advanced CRUD references (add_rule, update_rule,...)
#   - detect_operation_type, enhanced_advanced_extract_tables
#   - get_cursor_one, get_cursor_rows, add_audit_log
#   - plus the DB connection & logging in place.

###############################################################################
# 1) Single Rule Simulation
###############################################################################
class SingleRuleSimulationDialog(QDialog):
    """
    Lets the user do a “dry-run” of a single rule’s SQL => 
    we assume the rule’s SQL returns 1 => PASS, else 0 => FAIL 
    (or an exception => FAIL).
    """
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.sql_text = sql_text

        self.setWindowTitle(f"Simulate Rule {rule_id}")
        self.resize(500,300)
        layout = QVBoxLayout(self)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

    def do_sim(self):
        c = self.connection.cursor()
        c.execute("BEGIN TRANSACTION")
        success=False
        msg=""
        try:
            c.execute(self.sql_text)
            rows = c.fetchall()
            if rows:
                val = rows[0][0]
                success = (val==1)
                msg = f"Returned: {val}"
            else:
                success = True
                msg = "No rows => PASS"
        except Exception as ex:
            success = False
            msg = str(ex)
        c.execute("ROLLBACK")

        result = "PASS" if success else "FAIL"
        self.result_text.setPlainText(f"{result} => {msg}")

###############################################################################
# 2) Chain Simulation
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    BFS-based chain sim: pick a parent => do a dry-run for each child.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Rule Chain - Part 2")
        self.resize(500,300)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.parent_rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for row in rows:
            rid=row[0]
            rname=row[1]
            disp=f"{rid} - {rname}"
            self.parent_rule_combo.addItem(disp, rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)

    def sim_chain(self):
        pid=self.parent_rule_combo.currentData()
        ex,sk=self.do_chain_sim(pid)
        txt=f"Chain from rule {pid}\nExecuted => {ex}\nSkipped => {sk}"
        self.result_text.setPlainText(txt)

    def do_chain_sim(self, start_rule):
        """
        BFS from start_rule => run dry-run => if fail => skip
        """
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,PARENT_RULE_ID,RULE_SQL FROM BRM_RULES")
        rows=c.fetchall()
        rule_dict={}
        children_map={}
        for row in rows:
            rid=row[0]
            pid=row[1]
            sql_=row[2]
            rule_dict[rid]={
                "RULE_ID":rid,
                "PARENT_RULE_ID":pid,
                "RULE_SQL":sql_
            }
            if pid:
                children_map.setdefault(pid,[]).append(rid)

        executed=[]
        skipped=set()
        queue=[start_rule]

        while queue:
            rid=queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_dict:
                skipped.add(rid)
                continue
            sql_ = rule_dict[rid]["RULE_SQL"]
            c.execute("BEGIN TRANSACTION")
            ok=False
            msg=""
            try:
                c.execute(sql_)
                rows_ = c.fetchall()
                if rows_:
                    val = rows_[0][0]
                    ok=(val==1)
                    msg=f"Returned: {val}"
                else:
                    ok=True
                    msg="No rows => PASS"
            except Exception as ex:
                ok=False
                msg=str(ex)
            c.execute("ROLLBACK")

            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch_ in children_map[rid]:
                        if ch_ not in skipped:
                            queue.append(ch_)
            else:
                skipped.add(rid)

        return executed, skipped

###############################################################################
# 3) Group Simulation
###############################################################################
class GroupSimulationDialog(QDialog):
    """
    Dry-run all rules in a custom group => show pass/fails
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Simulate Custom Group - Part 2")
        self.resize(500,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.group_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows = c.fetchall()
        for row in rows:
            cg_id=row[0]
            cg_name=row[1]
            disp=f"{cg_id} - {cg_name}"
            self.group_combo.addItem(disp,cg_id)
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_group(self):
        cg_id=self.group_combo.currentData()
        ex,fails=self.do_sim(cg_id)
        msg=f"Group {cg_id}\nExecuted => {ex}\nFails => {fails}"
        self.result_text.setPlainText(msg)

    def do_sim(self, custom_group_id):
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        rows=c.fetchall()
        group_rules=[r[0] for r in rows]

        c.execute("SELECT RULE_ID,RULE_SQL FROM BRM_RULES")
        all_ = c.fetchall()
        rule_map={}
        for row in all_:
            rule_map[row[0]] = row[1]

        executed=[]
        fails=[]
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            sql_ = rule_map[rid]
            c.execute("BEGIN TRANSACTION")
            ok=False
            msg=""
            try:
                c.execute(sql_)
                rr=c.fetchall()
                if rr:
                    val=rr[0][0]
                    ok=(val==1)
                else:
                    ok=True
                if not ok:
                    fails.append(rid)
                else:
                    executed.append(rid)
            except:
                fails.append(rid)
            c.execute("ROLLBACK")

        return executed, fails

###############################################################################
# 4) SYNC METADATA
###############################################################################
def sync_metadata_improved(conn):
    """
    Compare sys.tables => BRM_RULE_TABLE_DEPENDENCIES => mark missing references.
    """
    c=conn.cursor()
    c.execute("""
    SELECT s.name AS schema_name, t.name AS table_name
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id=s.schema_id
    ORDER BY s.name, t.name
    """)
    actual_tables=set()
    for row in c.fetchall():
        fulln=f"{row[0]}.{row[1]}".lower()
        actual_tables.add(fulln)

    c.execute("""
    SELECT DEPENDENCY_ID, RULE_ID, DATABASE_NAME, TABLE_NAME 
    FROM BRM_RULE_TABLE_DEPENDENCIES
    """)
    deps=c.fetchall()
    missing=[]
    updated=0
    for d_ in deps:
        dep_id=d_[0]
        tbl=(d_[3] or "").strip()
        if "." not in tbl:
            candidate=f"dbo.{tbl}".lower()
        else:
            candidate=tbl.lower()
        if candidate not in actual_tables:
            missing.append(dep_id)
    for dep_id in missing:
        c.execute("""
        UPDATE BRM_RULE_TABLE_DEPENDENCIES
        SET TABLE_NAME='MISSING_'+TABLE_NAME
        WHERE DEPENDENCY_ID=?
        """,(dep_id,))
        updated+=1
    conn.commit()
    msg=(f"Metadata sync done.\n"
         f"Found {len(actual_tables)} real tables.\n"
         f"Scanned {len(deps)} dependencies.\n"
         f"Marked {updated} as 'MISSING_'.\n")
    QMessageBox.information(None,"Sync Metadata",msg)

###############################################################################
# 5) SCHEDULING
###############################################################################
class EnhancedScheduleDialog(QDialog):
    """
    UI to schedule a rule at a chosen date/time => RULE_SCHEDULES
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Enhanced Scheduling UI - Part 2")
        self.resize(400,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for row in rows:
            rid=row[0]
            rname=row[1]
            disp=f"{rid} - {rname}"
            self.rule_combo.addItem(disp,rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QtCore.QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        date_=self.calendar.selectedDate()
        time_=self.time_edit.time()
        dt_str=f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(rid,dt_str,"Scheduled"))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} scheduled at {dt_str}")
        self.close()

class ScheduleManagementTab(QWidget):
    """
    Tab to show existing schedules => update or delete => minimal approach.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.schedule_table=QTableWidget(0,5)
        self.schedule_table.setHorizontalHeaderLabels([
            "ScheduleID","RuleID","ScheduleTime","Status","Actions"
        ])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn=QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_ = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_)
            self.schedule_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(r_,1,QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(r_,2,QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(r_,3,QTableWidgetItem(row[3]))

            act_widget=QWidget()
            h=QHBoxLayout(act_widget)
            h.setContentsMargins(0,0,0,0)
            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _, idx=r_: self.update_schedule(idx))
            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _, idx=r_: self.delete_schedule(idx))
            h.addWidget(upd_btn)
            h.addWidget(del_btn)
            h.addStretch()
            self.schedule_table.setCellWidget(r_,4,act_widget)

        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, rowidx):
        sch_id_item=self.schedule_table.item(rowidx,0)
        if not sch_id_item:
            return
        sch_id=int(sch_id_item.text())
        new_dt,ok=QInputDialog.getText(self,"Update Schedule","Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, rowidx):
        sch_id_item=self.schedule_table.item(rowidx,0)
        if not sch_id_item:
            return
        sch_id=int(sch_id_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()

###############################################################################
# 6) DECISION TABLES, CONFLICT PRIORITY, COMPOSITE RULES, SNAPSHOTS, TAGS, DATAVAL
###############################################################################
class DecisionTablesTab(QWidget):
    """
    Manage DECISION_TABLES: ID, TABLE_NAME, DESCRIPTION
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dt_table=QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels(["DecisionTableID","TableName","Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows=c.fetchall()
        for r_ in rows:
            rr=self.dt_table.rowCount()
            self.dt_table.insertRow(rr)
            for j,v in enumerate(r_):
                self.dt_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def add_dt(self):
        name,ok=QInputDialog.getText(self,"Add Decision Table","Table Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional desc:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(name.strip(),desc.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Done","Decision table added.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No row selected.")
            return
        it=self.dt_table.item(row,0)
        if not it:
            return
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Decision table removed.")
        self.load_dt()


class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        setp_btn=QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.cf_table.rowCount()
            self.cf_table.insertRow(rr)
            for j,v in enumerate(row):
                self.cf_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule ID1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule ID2:")
        if not ok2:
            return
        pr,ok3=QInputDialog.getInt(self,"Priority","(int):")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pr))
        self.connection.commit()
        QMessageBox.information(self,"Done","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        it=self.cf_table.item(row,0)
        if not it:
            return
        cf_id=int(it.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cf_id))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        it=self.cf_table.item(row,0)
        if not it:
            return
        cf_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()


class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES: (COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CompositeRuleID","Name","LogicExpr","ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_crule)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_crule)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_crules)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_crules()

    def load_crules(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.cr_table.rowCount()
            self.cr_table.insertRow(rr)
            for j,v in enumerate(row):
                self.cr_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def add_crule(self):
        name,ok=QInputDialog.getText(self,"New Composite Rule","Name:")
        if not ok or not name.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expr","(e.g. 'Rule1==PASS AND Rule2==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","(Optional) Action:")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
        VALUES(?,?,?)
        """,(name.strip(),expr.strip(),act.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","Composite rule created.")
        self.load_crules()

    def del_crule(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        if not it:
            return
        cid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_crules()

class SnapshotManagerTab(QWidget):
    """
    RULE_SNAPSHOTS table for storing snapshots of BRM_RULES in JSON.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels([
            "SnapshotID","SnapshotName","CreatedBy","CreatedTimestamp","SnapshotJSON"
        ])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snapshot)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            rr=self.ss_table.rowCount()
            self.ss_table.insertRow(rr)
            for j,v in enumerate(row):
                self.ss_table.setItem(rr,j,QTableWidgetItem(str(v) if v else ""))

    def take_snapshot(self):
        name,ok=QInputDialog.getText(self,"Snapshot","Snapshot name:")
        if not ok or not name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        data=[]
        for r_ in rows:
            data.append(dict(zip(colnames,r_)))
        jtxt=json.dumps(data)

        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(name.strip(),"SnapshotUser",jtxt))
        self.connection.commit()
        QMessageBox.information(self,"Done","Snapshot created.")
        self.load_snapshots()

    def del_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        it=self.ss_table.item(row,0)
        if not it:
            return
        sid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Snapshot removed.")
        self.load_snapshots()

class TagsManagerTab(QWidget):
    """
    RULE_TAGS: (TAG_ID,RULE_ID,TAG_NAME)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows=c.fetchall()
        for row in rows:
            rr=self.tags_table.rowCount()
            self.tags_table.insertRow(rr)
            for j,v in enumerate(row):
                self.tags_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        if not it:
            return
        tid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()

class DataValidationTab(QWidget):
    """
    DATA_VALIDATIONS => (VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)

        rem_btn=QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_val)
        bh.addWidget(rem_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            for j,v in enumerate(row):
                self.dv_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name:")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'RANGE','NOT NULL'):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional) param string:")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS)
        VALUES(?,?,?,?)
        """,(tbl.strip(),col.strip(),vtype.strip(),pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Validation rule added.")
        self.load_vals()

    def remove_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove data validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()


#
# End of PART 2 code
# Next: Wait for your "OK", then receive PART 3.
#
"""
ADVANCED BRM TOOL - PART 3 of 4
--------------------------------
In this part:
  1) Alerts & dashboards
  2) AuditLogViewer for BRM_AUDIT_LOG with searching & CSV export
  3) SearchRuleDialog
  4) VersionHistoryDialog with rollback logic
  5) Performance monitoring & gather_rule_performance_metrics
  6) Additional BFS references for skipping/conflicts
  7) Example Locking functions
"""

import sys
import json
import math
import logging
from datetime import datetime
import pyodbc

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPlainTextEdit, QPushButton, QLabel,
    QTableWidget, QTableWidgetItem, QMessageBox, QInputDialog, QDialog, QFileDialog
)
import pyqtgraph as pg

logger = logging.getLogger(__name__)

# We assume from PART 1+2 we have:
#   get_cursor_rows, get_cursor_one, add_audit_log
#   BFS logic, advanced CRUD, plus the various UI code from part 2.

###############################################################################
# 1) Alerts & Dashboards
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    """
    Simple example to show:
      - Approvals older than X days
      - upcoming schedules
    in a text area.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # old approvals > 3 days
        c.execute("""
        SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
               DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(SELECT MIN(APPROVAL_STAGE) 
                                FROM BRM_RULE_APPROVALS
                                WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0)
          AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        old_ap=c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for row in old_ap:
                lines.append(f" - Rule {row[0]} stage={row[1]} => {row[2]}, age={row[3]}")
        else:
            lines.append("No old approvals found.")

        lines.append("")
        # upcoming schedules in next 24h
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upcoming=c.fetchall()
        if upcoming:
            lines.append("Upcoming schedules in next 24h:")
            for up_ in upcoming:
                lines.append(f" - ID={up_[0]}, rule={up_[1]}, time={up_[2]}")
        else:
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))

###############################################################################
# 2) AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Lists last 1000 audit logs => user can search or export to CSV.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        self.setWindowTitle("Audit Logs – Part 3")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table=QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels(["AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)
        exp_btn=QPushButton("Export to CSV")
        exp_btn.clicked.connect(self.export_csv)
        bh.addWidget(exp_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.audit_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_=self.audit_table.rowCount()
            self.audit_table.insertRow(r_)
            for col_i in range(8):
                txt=str(row[col_i]) if row[col_i] is not None else ""
                if col_i in (5,6):
                    # old/new data => possibly JSON
                    if row[col_i]:
                        try:
                            j_=json.loads(row[col_i])
                            txt=json.dumps(j_,indent=2)
                        except:
                            txt=str(row[col_i])
                self.audit_table.setItem(r_,col_i,QTableWidgetItem(txt))

    def perform_search(self, text):
        txt_l=text.lower()
        for row_i in range(self.audit_table.rowCount()):
            show=False
            for col_i in (1,2,4): # action,table,action_by
                it=self.audit_table.item(row_i,col_i)
                if it and txt_l in it.text().lower():
                    show=True
                    break
            self.audit_table.setRowHidden(row_i,not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Save CSV","","CSV Files (*.csv)")
        if not path:
            return
        import csv
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row_i in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row_i):
                    continue
                rowdata=[]
                for col_i in range(self.audit_table.columnCount()):
                    it=self.audit_table.item(row_i,col_i)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported","CSV export complete.")

###############################################################################
# 3) SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialog(QDialog):
    """
    Search by name or SQL snippet => list up to 1000 matches => show minimal info.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        self.setWindowTitle("Search Rules – Part 3")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QtWidgets.QLineEdit()
        self.search_edit.setPlaceholderText("Name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","CreatedBy"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        rb=QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        layout.addWidget(rb)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        c=self.connection.cursor()
        txt=self.search_edit.text().strip()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=c.fetchall()

        self.res_table.setRowCount(0)
        for row_ in rows:
            r_i=self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for j,v in enumerate(row_):
                self.res_table.setItem(r_i,j,QTableWidgetItem(str(v)))

###############################################################################
# 4) VERSION HISTORY DIALOG (with rollback)
###############################################################################
class VersionHistoryDialog(QDialog):
    """
    Display rule's “INSERT, UPDATE” changes from BRM_AUDIT_LOG => 
    old/new data => optionally rollback to older version.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id

        self.setWindowTitle(f"Version History – Rule {rule_id} - Part 3")
        self.resize(800,400)
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb_btn=QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.do_rollback)
        bh.addWidget(rb_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,ACTION_TIMESTAMP,OLD_DATA,NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? 
          AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()

        self.table.setRowCount(0)
        for row_ in rows:
            rr=self.table.rowCount()
            self.table.insertRow(rr)
            # fill row
            self.table.setItem(rr,0,QTableWidgetItem(str(row_[0])))
            self.table.setItem(rr,1,QTableWidgetItem(row_[1]))
            self.table.setItem(rr,2,QTableWidgetItem(str(row_[2]) if row_[2] else ""))
            oldtxt=str(row_[3]) if row_[3] else ""
            newtxt=str(row_[4]) if row_[4] else ""
            self.table.setItem(rr,3,QTableWidgetItem(oldtxt))
            self.table.setItem(rr,4,QTableWidgetItem(newtxt))

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected for rollback.")
            return
        row=sel[0].row()
        old_data_item=self.table.item(row,3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self,"No Old Data","This row has no old_data.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to selected version?")
        if confirm!=QMessageBox.Yes:
            return
        import json
        try:
            old_data=json.loads(old_data_item.text())
            self.apply_rollback(old_data)
            QMessageBox.information(self,"Rolled Back","Rule rollback done.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def apply_rollback(self, old_data):
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")
        c.execute("BEGIN TRANSACTION")
        new_sql=old_data["RULE_SQL"]
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(old_data["RULE_NAME"],new_sql,old_data["OWNER_GROUP"],rid))

        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        from_part1_optype = self.detect_optype(new_sql)
        parse_info = self.extract_sql_deps(new_sql)
        col_op="READ"
        if from_part1_optype in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"
        for (sch,tb,alias,_) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                dbn=sch if sch else "dbo"
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid,dbn,tb,"RolledBackCol",col_op))
        c.execute("COMMIT")

    def detect_optype(self,sql_):
        # local method replicating part1's detect_operation_type
        txt=sql_.strip().upper()
        if txt.startswith("INSERT"):
            return "INSERT"
        elif txt.startswith("UPDATE"):
            return "UPDATE"
        elif txt.startswith("DELETE"):
            return "DELETE"
        elif txt.startswith("SELECT"):
            return "SELECT"
        return "OTHER"

    def extract_sql_deps(self,sql_):
        # local method replicating part1's advanced parser
        from sqlparse.sql import Identifier,IdentifierList,Parenthesis
        from sqlparse.tokens import Keyword,DML
        import sqlparse

        statements=sqlparse.parse(sql_)
        final_tables=[]
        for stmt in statements:
            cte_dict=self._extract_with_clauses(stmt)
            main_refs,_=self._extract_main_from(stmt.tokens,set(cte_dict.keys()))
            final_tables.extend(main_refs)
            # we won't do columns right now for brevity
        final_tables=list({x for x in final_tables})
        return {"tables":final_tables}

    def _extract_with_clauses(self,stmt):
        from sqlparse.tokens import Keyword
        tokens=list(stmt.tokens)
        cte_map={}
        i=0
        while i<len(tokens):
            tk=tokens[i]
            if tk.ttype is Keyword and tk.value.upper()=="WITH":
                i+=1
                i=self._parse_cte_block(tokens,i,cte_map)
                continue
            i+=1
        return cte_map

    def _parse_cte_block(self,tokens,i,cte_map):
        from sqlparse.sql import Identifier, Parenthesis
        from sqlparse.tokens import Keyword
        while i<len(tokens):
            tk=tokens[i]
            if isinstance(tk,Identifier):
                cte_name=tk.get_real_name()
                i+=1
                i=self._parse_cte_as_clause(tokens,i,cte_name,cte_map)
            elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
                return i
            else:
                i+=1
        return i

    def _parse_cte_as_clause(self,tokens,i,cte_name,cte_map):
        from sqlparse.sql import Parenthesis
        from sqlparse.tokens import Keyword
        while i<len(tokens):
            tk=tokens[i]
            val=tk.value.upper() if tk.ttype else ""
            if val=="AS":
                i+=1
                if i<len(tokens):
                    sub=tokens[i]
                    if isinstance(sub,Parenthesis):
                        sub_refs=self._extract_subselect_tokens(sub.tokens)
                        cte_map[cte_name]=sub_refs
                        i+=1
                        return i
            else:
                i+=1
        return i

    def _extract_subselect_tokens(self,tokens):
        from sqlparse.sql import Identifier,IdentifierList
        from sqlparse.tokens import Keyword,DML
        results=[]
        from_seen=False
        i=0
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and self._is_subselect(tk):
                results.extend(self._extract_subselect_tokens(tk.tokens))
            if tk.ttype is Keyword:
                upv=tk.value.upper()
                if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                    from_seen=True
                else:
                    from_seen=False
            if from_seen:
                if isinstance(tk,IdentifierList):
                    for ident in tk.get_identifiers():
                        st=self._parse_identifier(ident,set())
                        st=(st[0],st[1],st[2],True)
                        results.append(st)
                elif isinstance(tk,Identifier):
                    st=self._parse_identifier(tk,set())
                    st=(st[0],st[1],st[2],True)
                    results.append(st)
            i+=1
        return results

    def _is_subselect(self,token):
        from sqlparse.tokens import DML
        if not token.is_group:
            return False
        for sub in token.tokens:
            if sub.ttype is DML and sub.value.upper()=="SELECT":
                return True
        return False

    def _extract_main_from(self,tokenlist,known_cte_names):
        from sqlparse.sql import Identifier, IdentifierList
        from sqlparse.tokens import Keyword
        results=[]
        alias_map={}
        tokens=list(tokenlist)
        from_seen=False
        i=0
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and self._is_subselect(tk):
                results.extend(self._extract_subselect_tokens(tk.tokens))
            if tk.ttype is Keyword:
                upv=tk.value.upper()
                if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                    from_seen=True
                else:
                    from_seen=False
            if from_seen:
                if isinstance(tk,IdentifierList):
                    for ident in tk.get_identifiers():
                        st=self._parse_identifier(ident,known_cte_names)
                        results.append(st)
                elif isinstance(tk,Identifier):
                    st=self._parse_identifier(tk,known_cte_names)
                    results.append(st)
            i+=1
        return (results,alias_map)

    def _parse_identifier(self,ident,known_cte_names):
        alias=ident.get_alias()
        real_name=ident.get_real_name()
        schema_name=ident.get_parent_name()
        if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
            return (None,f"(CTE){real_name}",alias,False)
        return (schema_name,real_name,alias,False)

###############################################################################
# 5) PERFORMANCE MONITORING
###############################################################################
def gather_rule_performance_metrics(conn):
    """
    Example: recalc average durations from RULE_EXECUTION_LOGS => store in RULE_PERF_STATS
    """
    c=conn.cursor()
    c.execute("""
    SELECT RULE_ID,AVG(DATEDIFF(MILLISECOND,START_TIME,END_TIME)) as avg_ms
    FROM RULE_EXECUTION_LOGS
    WHERE START_TIME IS NOT NULL AND END_TIME IS NOT NULL
    GROUP BY RULE_ID
    """)
    rows=c.fetchall()
    for row in rows:
        rid=row[0]
        avg_ms=row[1] if row[1] else 0
        c2=conn.cursor()
        c2.execute("""
        MERGE RULE_PERF_STATS as T
        USING (SELECT ? as rid, ? as ams) as src(rid,ams)
        ON T.RULE_ID=src.rid
        WHEN MATCHED THEN
            UPDATE SET T.AVG_EXEC_MS=src.ams, T.UPDATED_TS=GETDATE()
        WHEN NOT MATCHED THEN
            INSERT(RULE_ID,AVG_EXEC_MS,UPDATED_TS)
            VALUES(src.rid,src.ams,GETDATE());
        """,(rid,avg_ms))
    conn.commit()

class PerfMonitoringWidget(QWidget):
    """
    UI to gather & show RULE_PERF_STATS => 
    columns: RULE_ID, AVG_EXEC_MS, UPDATED_TS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        gather_btn=QPushButton("Gather Performance Stats")
        gather_btn.clicked.connect(self.gather_stats)
        layout.addWidget(gather_btn)

        self.table=QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["RuleID","AvgExecMS","UpdatedTS"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_perf)
        layout.addWidget(ref_btn)

        self.setLayout(layout)

    def gather_stats(self):
        gather_rule_performance_metrics(self.connection)
        QMessageBox.information(self,"Done","Performance stats updated.")
        self.load_perf()

    def load_perf(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,AVG_EXEC_MS,UPDATED_TS FROM RULE_PERF_STATS ORDER BY RULE_ID")
        rows=c.fetchall()
        for row_ in rows:
            r_ = self.table.rowCount()
            self.table.insertRow(r_)
            for j,v in enumerate(row_):
                self.table.setItem(r_, j, QTableWidgetItem(str(v)))

###############################################################################
# 6) EXAMPLE LOCKING (RULE_LOCKS)
###############################################################################
def acquire_rule_lock(conn, rule_id, locked_by, comment="Editing"):
    """
    Attempt to lock a rule => if locked by another => fail
    """
    c=conn.cursor()
    c.execute("SELECT LOCK_ID,LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if row:
        if row[1].lower()!=locked_by.lower():
            raise ValueError(f"Rule {rule_id} locked by user {row[1]}")
        # else same user => do nothing
        return
    c.execute("""
    INSERT INTO RULE_LOCKS(RULE_ID,LOCKED_BY,LOCK_TIMESTAMP,COMMENTS,EXCLUSIVE_FLAG)
    VALUES(?,?,GETDATE(),?,1)
    """,(rule_id, locked_by, comment))
    conn.commit()

def release_rule_lock(conn, rule_id, locked_by, force=False):
    """
    Release rule lock if locked_by matches or if force= True
    """
    c=conn.cursor()
    c.execute("SELECT LOCK_ID,LOCKED_BY FROM RULE_LOCKS WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        return
    if not force and row[1].lower()!=locked_by.lower():
        raise ValueError(f"Cannot release => locked by {row[1]}")
    c.execute("DELETE FROM RULE_LOCKS WHERE LOCK_ID=?",(row[0],))
    conn.commit()

def check_rule_lock(conn, rule_id):
    """
    Return lock info or None
    """
    c=conn.cursor()
    c.execute("SELECT LOCKED_BY,LOCK_TIMESTAMP,COMMENTS FROM RULE_LOCKS WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        return None
    return {
        "locked_by": row[0],
        "lock_timestamp": row[1],
        "comments": row[2] if row[2] else ""
    }

#
# End of PART 3 code
# Next: Wait for your "OK", then receive PART 4 (final).
#
"""
ADVANCED BRM TOOL - PART 4 of 4
--------------------------------
In this final part:
  1) Main window assembly (BRMToolMain or BRMTool)
  2) The “Rule Dashboard” with basic pagination & filtering
  3) The “Lineage” and “Hierarchy” tabs
  4) Group & User management
  5) Custom Groups (backup/restore)
  6) Launch code: main() with DB connect + login
  7) Putting it all together: final BFS checks, timers for approvals & schedules
"""

import sys
import json
import math
import logging
from datetime import datetime
import pyodbc

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTabWidget, QLineEdit, QMessageBox, QComboBox, QAbstractItemView,
    QTableWidget, QTableWidgetItem, QPlainTextEdit, QInputDialog, QDialog
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QColor
import pyqtgraph as pg

logger = logging.getLogger(__name__)


###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QtWidgets.QGroupBox):
    """
    A simple dashboard listing BRM_RULES with paging, search, status filter.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        self.selected_rule_id=None
        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        # top row => search text + status filter
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL snippet...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        # table => columns: RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP, CREATED_TIMESTAMP, APPROVAL_STATUS
        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","OwnerGroup","CreatedTS","ApprovalStatus"])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        # nav row => prev, page label, next
        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)

        # events
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_query(self):
        filters=[]
        params=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params

    def load_rules(self):
        c=self.connection.cursor()
        clause,params=self.build_filter_query()

        # first get count
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, params)
        rowc=c.fetchone()
        total=rowc[0] if rowc else 0
        self.total_pages=max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset=(self.current_page-1)*self.records_per_page

        data_q=f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,
               CREATED_TIMESTAMP,APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*params, offset, self.records_per_page))
        rows=c.fetchall()

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_ = self.rule_table.rowCount()
            self.rule_table.insertRow(r_)
            for col_i in range(8):
                txt=str(rd[col_i])
                item=QTableWidgetItem(txt)
                if col_i==3:
                    # status => color
                    if txt.lower()=="active":
                        item.setBackground(QColor(144,238,144))
                    else:
                        item.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_, col_i, item)

    def update_selected_rule_id(self):
        sel=self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.rule_table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()


###############################################################################
# LINEAGE GRAPH (DRAGGABLE / SCROLL)
###############################################################################
class DraggableLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    Variation of the lineage graph that supports panning with the mouse.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.children_map={}
        self.parents_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,
               CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rules=c.fetchall()
        if not rules:
            txt_item=QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(txt_item)
            return

        # build adjacency
        all_ids=set()
        for row in rules:
            rid=row[0]
            pid=row[2]
            all_ids.add(rid)
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                self.parents_map[rid]=pid

        from collections import deque
        child_ids=set(self.parents_map.keys())
        roots=list(all_ids - child_ids)

        # store details
        rule_lookup={}
        for row in rules:
            d={
                "RULE_ID": row[0],
                "RULE_NAME": row[1],
                "PARENT_RULE_ID": row[2],
                "STATUS": row[3],
                "RULE_TYPE_ID": row[4],
                "CLUSTER_NAME": row[5],
                "IS_GLOBAL": row[6],
                "CRITICAL_RULE": row[7]
            }
            rule_lookup[row[0]]=d

        queue=deque()
        level_map={}
        visited=set()
        for rt in roots:
            queue.append((rt,0))

        while queue:
            rid, depth=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info=rule_lookup[rid]
            level_map[depth]=level_map.get(depth,0)+1
            count_at_level=level_map[depth]-1
            x=depth*220
            y=count_at_level*120
            node_item=self.create_node(info)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid]=node_item

            if rid in self.children_map:
                for ch_ in self.children_map[rid]:
                    queue.append((ch_, depth+1))

        # draw edges parent->child
        for row in rules:
            rid=row[0]
            pid=row[2]
            if pid and (pid in self.node_map) and (rid in self.node_map):
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # table dependencies
        c.execute("""
        SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
        FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps=c.fetchall()
        tbl_map={}
        idx=0
        for d_ in deps:
            drid=d_[0]
            dbn=d_[1]
            tbn=d_[2]
            cop=d_[4]
            key=f"{dbn}.{tbn}".lower().strip(".")
            if key not in tbl_map:
                t_item=QtWidgets.QGraphicsEllipseItem(0,0,100,40)
                t_item.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
                t_item.setToolTip(f"Table: {key}")
                t_item.setPos(800, idx*60)
                self.scene.addItem(t_item)
                tbl_map[key]=t_item
                idx+=1
            if drid in self.node_map:
                color=QtGui.QColor("darkred") if cop=="WRITE" else QtGui.QColor("darkblue")
                self.draw_edge(self.node_map[drid], tbl_map[key], color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self,info):
        rtype=info["RULE_TYPE_ID"]
        status=info["STATUS"]
        cluster=info["CLUSTER_NAME"] or ""
        is_g=info["IS_GLOBAL"]
        is_c=info["CRITICAL_RULE"]

        if rtype==1:
            node=QtWidgets.QGraphicsRectItem(0,0,120,50)
        else:
            node=QtWidgets.QGraphicsEllipseItem(0,0,120,50)

        if status.lower()=="active":
            basecol=QtGui.QColor("lightgreen")
        else:
            basecol=QtGui.QColor("tomato")
        if cluster:
            hv=abs(hash(cluster))%360
            basecol=QtGui.QColor.fromHsv(hv,128,255)
        node.setBrush(QtGui.QBrush(basecol))

        pen=QtGui.QPen(QtCore.Qt.black,2)
        if is_c==1:
            pen=QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)

        disp=info["RULE_NAME"]
        if is_g==1:
            disp=f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self,item1,item2,color=QtGui.QColor("darkblue")):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=QtWidgets.QGraphicsLineItem(p1.x(),p1.y(),p2.x(),p2.y())
        line.setPen(QtGui.QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button()==QtCore.Qt.LeftButton:
            item=self.itemAt(event.pos())
            if isinstance(item,(QtWidgets.QGraphicsRectItem,QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self,"Rule Details", item.toolTip())
        super().mousePressEvent(event)

    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setPen(QtGui.QPen(QtCore.Qt.black,2))

    def search_nodes(self, query):
        """
        optional search => highlight
        """
        self.clear_highlights()
        ql=query.lower()
        c=self.connection.cursor()
        found=set()

        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE LOWER(RULE_NAME) LIKE ?
           OR LOWER(RULE_SQL) LIKE ?
           OR LOWER(DESCRIPTION) LIKE ?
           OR LOWER(BUSINESS_JUSTIFICATION) LIKE ?
           OR CAST(RULE_ID AS VARCHAR(50)) LIKE ?
        """,(f"%{ql}%",f"%{ql}%",f"%{ql}%",f"%{ql}%",f"%{ql}%"))
        for row in c.fetchall():
            found.add(row[0])

        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE LOWER(DATABASE_NAME) LIKE ? OR LOWER(TABLE_NAME) LIKE ?
        """,(f"%{ql}%",f"%{ql}%"))
        for row in c.fetchall():
            found.add(row[0])

        if not found:
            QMessageBox.information(self,"No match",f"No match for '{query}'")
            return

        def highlight_ancestors(rid):
            cur=rid
            while cur in self.parents_map:
                if cur in self.node_map:
                    self.node_map[cur].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                par=self.parents_map[cur]
                if par in self.node_map:
                    self.node_map[par].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                cur=par
        def highlight_descendants(rid):
            stack=[rid]
            visited=set()
            while stack:
                c_=stack.pop()
                if c_ in visited:
                    continue
                visited.add(c_)
                if c_ in self.node_map:
                    self.node_map[c_].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                if c_ in self.children_map:
                    stack.extend(self.children_map[c_])

        for rid in found:
            if rid in self.node_map:
                self.node_map[rid].setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
                highlight_ancestors(rid)
                highlight_descendants(rid)

###############################################################################
# GROUP MANAGEMENT, USER MANAGEMENT, CUSTOM GROUPS
###############################################################################
class GroupManagementTab(QWidget):
    """
    Manage business groups, membership, group perms, group approvers (admin only).
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # groups & membership
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QtWidgets.QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        grp_btns.addWidget(del_grp_btn)
        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        membership_box=QtWidgets.QGroupBox("Membership Management")
        membership_layout=QVBoxLayout(membership_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btns.addWidget(add_usr_btn)
        rem_usr_btn=QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btns.addWidget(rem_usr_btn)
        memb_btns.addStretch()
        membership_layout.addLayout(memb_btns)
        gm_layout.addWidget(membership_box)

        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # permissions subtab
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)

        perm_box=QtWidgets.QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)
        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.on_add_permission)
        ph.addWidget(addp_btn)
        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.on_remove_permission)
        ph.addWidget(remp_btn)
        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # approvers subtab
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)
        ah=QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btns.addWidget(add_appr_btn)
        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btns.addWidget(del_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            rr=self.groups_table.rowCount()
            self.groups_table.insertRow(rr)
            for j,v in enumerate(row):
                self.groups_table.setItem(rr,j,QTableWidgetItem(str(v) if v else ""))

    def get_selected_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            return None
        it=self.groups_table.item(row,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",(name.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def on_rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def on_delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group removed.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.users_table.rowCount()
            self.users_table.insertRow(rr)
            for j,v in enumerate(row):
                self.users_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def get_selected_user(self):
        row=self.users_table.currentRow()
        if row<0:
            return None
        it=self.users_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user from group => user moves to BG1.")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def load_group_combo(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            self.perm_group_combo.addItem(row[0],row[0])

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=c.fetchall()
        for row_ in rows:
            rr=self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(row_[0]))

    def on_add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        table,ok=QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.Orders'):")
        if not ok or not table.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),table.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def on_remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","No group selected.")
            return
        row=self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        table_name=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{table_name}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(),table_name))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    def load_appr_group_combo(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            self.appr_group_combo.addItem(row[0], row[0])

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        self.appr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=c.fetchall()
        for row_ in rows:
            rr=self.appr_table.rowCount()
            self.appr_table.insertRow(rr)
            for j,v in enumerate(row_):
                self.appr_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def on_add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        usern,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(),usern.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver '{usern}' added to {grp}.")
        self.load_approvers()

    def on_remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        app_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver ID={app_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(app_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

class UserManagementTab(QWidget):
    """
    Admin UI => manage USERS table (add, delete, pass change).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password","UserGroup"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.on_add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.on_delete_user)
        bh.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.on_change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.user_table.rowCount()
            self.user_table.insertRow(rr)
            for j,v in enumerate(row):
                self.user_table.setItem(rr,j,QTableWidgetItem(str(v)))

    def get_selected_user_id(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user(self):
        name,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not name.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(name.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","User added.")
        self.load_users()

    def on_delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user {uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","User removed.")
        self.load_users()

    def on_change_password(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"Password","New password:")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Password changed.")
        self.load_users()

class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manage BRM_CUSTOM_RULE_GROUPS => backup/restore => assign rules => rename, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()

        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        self.tree=QtWidgets.QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)

        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QtWidgets.QListWidget()
        self.rule_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)
        right_widget.setLayout(rw_layout)

        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for g_ in groups:
            cg_id=g_[0]
            cg_name=g_[1]
            owner=g_[2]
            disp=f"{cg_name} ({owner})"
            g_item=QtWidgets.QTreeWidgetItem([disp])
            g_item.setData(0, Qt.UserRole, cg_id)
            g_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for rr in assigned:
                rid=rr[0]
                rname=rr[1]
                isg=rr[2]
                iscrit=rr[3]
                txt=f"Rule {rid}: {rname}"
                rr_item=QtWidgets.QTreeWidgetItem([txt])
                rr_item.setData(0, Qt.UserRole, rid)
                if isg==1:
                    rr_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightblue")))
                if iscrit==1:
                    rr_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)

        rows=c.fetchall()
        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set(x[0] for x in c2.fetchall())
        for r_ in rows:
            rid=r_[0]
            rname=r_[1]
            og=r_[2]
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rname} (Owner {og})"
            it=QtWidgets.QListWidgetItem(disp)
            it.setData(Qt.UserRole, rid)
            self.rule_list.addItem(it)

    def on_tree_context(self,pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # child => rule
            menu=QtWidgets.QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id,rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed.")
                self.refresh_all()

    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return None,None
        item=sel[0]
        par=item.parent()
        if par:
            item=par
        gid=item.data(0,Qt.UserRole)
        disp=item.text(0)
        return gid,disp

    def rename_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[x[0] for x in c.fetchall()]
        backup_data={"group_name":grpname,"members":assigned}

        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 AS new_ver
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rv=c.fetchone()
        new_ver=rv[0] if rv else 1

        import json
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {r[0]} (ts {r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return
        import re
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        ver=int(m.group(1))

        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return

        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found??")
            return

        import json
        backup_data=json.loads(backup_json)
        new_name=backup_data["group_name"]
        members=backup_data["members"]
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_name,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected in tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)

        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in list.")
            return
        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()


###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    """
    The main advanced window that assembles all tabs & features from parts 1-4.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Part 4 - Full Implementation")
        self.resize(1300,850)
        self.connection=None
        self.user_id=None
        self.logged_in_username=None
        self.user_group=None

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        syncAct=QtWidgets.QAction("Sync Metadata",self)
        syncAct.triggered.connect(self.sync_metadata_ui)
        fileMenu.addAction(syncAct)

        metricsAct=QtWidgets.QAction("Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        chainAct=QtWidgets.QAction("Simulate Rule Chain",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        grpAct=QtWidgets.QAction("Simulate Custom Group",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        helpMenu=menubar.addMenu("Help")
        usageAct=QtWidgets.QAction("Show Tips",self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        # central
        cw=QWidget()
        layout=QVBoxLayout(cw)

        # if Admin => impersonate
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # 1) Business Rules => with a RuleDashboard & some action buttons
        br_tab=QWidget()
        br_layout=QVBoxLayout(br_tab)
        cr_h=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        cr_h.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        cr_h.addWidget(upd_btn)

        lock_btn=QPushButton("Lock")
        lock_btn.clicked.connect(self.lock_selected_rule)
        cr_h.addWidget(lock_btn)

        unlock_btn=QPushButton("Unlock")
        unlock_btn.clicked.connect(self.unlock_selected_rule)
        cr_h.addWidget(unlock_btn)

        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.on_deactivate_rule)
        cr_h.addWidget(deact_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.on_delete_rule)
        cr_h.addWidget(del_btn)

        etl_btn=QPushButton("Run ETL BFS")
        etl_btn.clicked.connect(self.run_etl_bfs)
        cr_h.addWidget(etl_btn)

        sim_btn=QPushButton("Simulate Rule")
        sim_btn.clicked.connect(self.sim_single_rule)
        cr_h.addWidget(sim_btn)
        cr_h.addStretch()
        br_layout.addLayout(cr_h)

        from __main__ import RuleDashboard
        self.brm_dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_layout.addWidget(self.brm_dashboard)
        br_tab.setLayout(br_layout)
        self.tabs.addTab(br_tab,"Business Rules")

        # 2) Approvals
        from __main__ import MultiStepApprovalTab
        self.approv_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # 3) GCR Admin if admin
        if self.user_group=="Admin":
            from __main__ import GlobalCriticalAdminTab
            self.gcr_tab=GlobalCriticalAdminTab(self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # 4) Hierarchy
        from __main__ import HierarchyViewTab
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # 5) Lineage
        from __main__ import DraggableLineageGraphWidget
        lin_w=QWidget()
        lin_layout=QVBoxLayout(lin_w)
        lb=QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lin_layout.addWidget(lb)
        self.lineage_tab=DraggableLineageGraphWidget(self.connection)
        lin_layout.addWidget(self.lineage_tab)

        line_h=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table..")
        sb=QPushButton("Search")
        sb.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rb=QPushButton("Reset View")
        rb.clicked.connect(self.lineage_tab.resetView)
        refb=QPushButton("Refresh Graph")
        refb.clicked.connect(self.lineage_tab.populate_graph)
        line_h.addWidget(self.lineage_search)
        line_h.addWidget(sb)
        line_h.addWidget(rb)
        line_h.addWidget(refb)
        line_h.addStretch()
        lin_layout.addLayout(line_h)
        lin_w.setLayout(lin_layout)
        self.tabs.addTab(lin_w,"Lineage")

        # 6) Custom Groups
        from __main__ import CustomRuleGroupEnhancedTab
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # 7) Scheduling
        from __main__ import ScheduleManagementTab
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # 8) Control Tables
        from __main__ import CtrlTablesTab
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # 9) Metrics
        from __main__ import MetricsDashboardTab
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # 10) Alerts
        from __main__ import AlertsAndDashboardsTab
        self.alert_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Dashboards")

        # 11) Group Management
        from __main__ import GroupManagementTab
        self.grp_mgmt=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt,"Group Management")

        # 12) User Management
        if self.user_group=="Admin":
            from __main__ import UserManagementTab
            self.user_mgmt=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt,"User Management")

        # Tools => Audit logs, search, version hist
        toolsMenu=self.menuBar().addMenu("Tools")
        alAct=QtWidgets.QAction("View Audit Logs",self)
        alAct.triggered.connect(self.launch_audit_log)
        toolsMenu.addAction(alAct)

        srAct=QtWidgets.QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_search)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (Ask ID)",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        # advanced sub-menu => Decision,Conflict,Composite,Snapshot,Tags,DataVal,Perf
        advMenu=self.menuBar().addMenu("Advanced")

        from __main__ import DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab
        from __main__ import SnapshotManagerTab, TagsManagerTab, DataValidationTab
        from __main__ import PerfMonitoringWidget

        self.decision_tab=DecisionTablesTab(self.connection)
        self.conflict_tab=ConflictPriorityManagerTab(self.connection)
        self.composite_tab=CompositeRulesTab(self.connection)
        self.snap_tab=SnapshotManagerTab(self.connection)
        self.tags_tab=TagsManagerTab(self.connection)
        self.dv_tab=DataValidationTab(self.connection)
        self.perf_tab=PerfMonitoringWidget(self.connection)

        advMenu.addAction("Open Decision Tables",lambda: self.tabs.addTab(self.decision_tab,"Decision Tables"))
        advMenu.addAction("Open Conflict Priority",lambda: self.tabs.addTab(self.conflict_tab,"Conflict Priority"))
        advMenu.addAction("Open Composite Rules",lambda: self.tabs.addTab(self.composite_tab,"Composite Rules"))
        advMenu.addAction("Open Snapshot Manager",lambda: self.tabs.addTab(self.snap_tab,"Snapshots"))
        advMenu.addAction("Open Tags Manager",lambda: self.tabs.addTab(self.tags_tab,"Tags Manager"))
        advMenu.addAction("Open Data Validation",lambda: self.tabs.addTab(self.dv_tab,"Data Validation"))
        advMenu.addAction("Open Performance Stats",lambda: self.tabs.addTab(self.perf_tab,"Performance Stats"))

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # timers => auto refresh approvals & schedule check
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

    # -------------- menubar actions --------------
    def sync_metadata_ui(self):
        from __main__ import sync_metadata_improved
        sync_metadata_improved(self.connection)

    def show_metrics_dialog(self):
        from __main__ import MetricsDashboardTab
        dlg=QtWidgets.QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800,600)
        ly=QtWidgets.QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection)
        ly.addWidget(chart)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        ly.addWidget(cb)
        dlg.exec_()

    def launch_chain_sim(self):
        from __main__ import ChainSimulationDialog
        dlg=ChainSimulationDialog(self.connection,self)
        dlg.exec_()

    def launch_group_sim(self):
        from __main__ import GroupSimulationDialog
        dlg=GroupSimulationDialog(self.connection,self)
        dlg.exec_()

    def show_help(self):
        msg=("BRM Tool - Full advanced version.\n"
             "Use the tabs for rules, approvals, scheduling, etc.\n"
             "Locks => pick a rule => lock => no one else can update unless Admin or the locker.")
        QMessageBox.information(self,"Help/Tips",msg)

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        new_uid,new_grp=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        QMessageBox.information(self,"Switched",f"Impersonating user {new_uid} => group {new_grp}")

    def populate_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            uid=row[0]
            uname=row[1]
            ugr=row[2]
            disp=f"{uname} ({ugr})"
            self.switch_combo.addItem(disp,(uid,ugr))

    # -------------- rule actions --------------
    def on_add_rule(self):
        from __main__ import RuleEditorDialog
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QtWidgets.QDialog.Accepted:
            QMessageBox.information(self,"Success","New rule added.")
            self.brm_dashboard.load_rules()

    def on_update_rule(self):
        from __main__ import RuleEditorDialog
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid=rids[0]
        if not self.check_lock(rid):
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No rule {rid}")
            return
        cols=[desc[0] for desc in c.description]
        rule_data=dict(zip(cols,row))
        dlg=RuleEditorDialog(self.connection,self.user_group,rule_data,self)
        if dlg.exec_()==QtWidgets.QDialog.Accepted:
            QMessageBox.information(self,"Updated",f"Rule {rid} updated.")
            self.brm_dashboard.load_rules()

    def check_lock(self, rule_id):
        from __main__ import check_rule_lock
        lock_info=check_rule_lock(self.connection, rule_id)
        if lock_info:
            if lock_info["locked_by"].lower()!=self.logged_in_username.lower() and self.user_group!="Admin":
                QMessageBox.warning(self,"Locked",f"Rule {rule_id} locked by {lock_info['locked_by']}.")
                return False
        return True

    def lock_selected_rule(self):
        from __main__ import acquire_rule_lock
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Lock","Select exactly 1 rule.")
            return
        rid=rids[0]
        try:
            acquire_rule_lock(self.connection,rid,self.logged_in_username,"Editing")
            QMessageBox.information(self,"Locked",f"Rule {rid} locked by you.")
        except ValueError as vex:
            QMessageBox.warning(self,"Locked",str(vex))

    def unlock_selected_rule(self):
        from __main__ import release_rule_lock
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Unlock","Select exactly 1 rule.")
            return
        rid=rids[0]
        try:
            release_rule_lock(self.connection,rid,self.logged_in_username,force=(self.user_group=="Admin"))
            QMessageBox.information(self,"Unlocked",f"Rule {rid} unlocked.")
        except ValueError as vex:
            QMessageBox.warning(self,"Error",str(vex))

    def on_deactivate_rule(self):
        from __main__ import deactivate_rule
        s=self.brm_dashboard.get_selected_rule_ids()
        if not s:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rr in s:
            if not self.check_lock(rr):
                fails.append(f"Rule {rr} locked => skip.")
                continue
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivate => success={success}"
        if fails:
            msg+="\nFails:\n"+"\n".join(fails)
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def on_delete_rule(self):
        from __main__ import delete_rule
        s=self.brm_dashboard.get_selected_rule_ids()
        if not s:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(s)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rr in s:
            if not self.check_lock(rr):
                fails.append(f"Rule {rr} locked => skip.")
                continue
            try:
                delete_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Delete => success={success}"
        if fails:
            msg+="\nFails:\n"+"\n".join(fails)
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_etl_bfs(self):
        from __main__ import execute_rules_in_order
        ex,sk=execute_rules_in_order(self.connection)
        msg=f"ETL BFS => executed={ex}, skipped={list(sk)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def sim_single_rule(self):
        from __main__ import SingleRuleSimulationDialog
        s=self.brm_dashboard.get_selected_rule_ids()
        if len(s)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=s[0]
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"None",f"No rule {rid}")
            return
        sql_=row[0]
        dlg=SingleRuleSimulationDialog(self.connection,rid,sql_,self)
        dlg.exec_()

    # -------------- tools actions --------------
    def launch_audit_log(self):
        from __main__ import AuditLogViewer
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_search(self):
        from __main__ import SearchRuleDialog
        dlg=SearchRuleDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
        if not ok:
            return
        from __main__ import VersionHistoryDialog
        dlg=VersionHistoryDialog(self.connection, rid, self)
        dlg.exec_()

    def check_due_schedules(self):
        """
        Check RULE_SCHEDULES => if due => run them => minimal approach
        """
        now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled' AND SCHEDULE_TIME<=?
        """,(now,))
        due=c.fetchall()
        for item in due:
            sch_id=item[0]
            rid=item[1]
            c2=self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                rowx=c2.fetchone()
                if rowx:
                    try:
                        c2.execute(rowx[0])
                    except Exception as ex:
                        logger.error(f"Scheduled rule {rid} => fail: {ex}")
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                        self.connection.commit()
                        continue
                c2.execute("COMMIT")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
            except Exception as ex:
                logger.error(f"Scheduled exec error: {ex}")
            self.connection.commit()
        self.sch_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()


###############################################################################
# Example Rule Editor (used in on_add_rule, on_update_rule)
###############################################################################
class RuleEditorDialog(QDialog):
    """
    Minimal example of a rule editor for name, sql, etc.
    The BFS, advanced parsing, etc. happen in the final code or after user hits OK.
    """
    def __init__(self, connection, user_group, existing_rule, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.existing_rule=existing_rule
        self.setWindowTitle("Rule Editor")
        self.resize(500,300)

        layout=QVBoxLayout(self)
        form=QVBoxLayout()

        self.name_edit=QLineEdit()
        self.sql_edit=QPlainTextEdit()
        self.owner_group_edit=QLineEdit()
        self.rt_edit=QLineEdit() # RULE_TYPE_ID
        self.cluster_edit=QLineEdit()

        # if existing => fill
        if existing_rule:
            self.name_edit.setText(str(existing_rule["RULE_NAME"]))
            self.sql_edit.setPlainText(str(existing_rule["RULE_SQL"]))
            self.owner_group_edit.setText(str(existing_rule["OWNER_GROUP"]))
            self.rt_edit.setText(str(existing_rule["RULE_TYPE_ID"]))
            self.cluster_edit.setText(str(existing_rule.get("CLUSTER_NAME","")))

        form.addWidget(QLabel("Rule Name:"))
        form.addWidget(self.name_edit)
        form.addWidget(QLabel("SQL:"))
        form.addWidget(self.sql_edit)
        form.addWidget(QLabel("Owner Group:"))
        form.addWidget(self.owner_group_edit)
        form.addWidget(QLabel("Rule Type ID:"))
        form.addWidget(self.rt_edit)
        form.addWidget(QLabel("Cluster Name:"))
        form.addWidget(self.cluster_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        ok_btn=QPushButton("OK")
        ok_btn.clicked.connect(self.accept)
        bh.addWidget(ok_btn)
        cb_btn=QPushButton("Cancel")
        cb_btn.clicked.connect(self.reject)
        bh.addWidget(cb_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def accept(self):
        # gather fields => call add_rule or update_rule from part1
        from __main__ import add_rule, update_rule
        name=self.name_edit.text().strip()
        sql_=self.sql_edit.toPlainText().strip()
        owner=self.owner_group_edit.text().strip()
        rt_id=self.rt_edit.text().strip()
        clus=self.cluster_edit.text().strip()
        if not name or not sql_ or not rt_id or not owner:
            QMessageBox.warning(self,"Error","Fill all required fields.")
            return
        try:
            if not self.existing_rule:
                # new
                rule_data={
                    "RULE_NAME": name,
                    "RULE_SQL": sql_,
                    "OWNER_GROUP": owner,
                    "RULE_TYPE_ID": rt_id,
                    "EFFECTIVE_START_DATE":datetime.now().strftime("%Y-%m-%d"),
                    "STATUS":"INACTIVE",
                    "CLUSTER_NAME": clus
                }
                new_id=add_rule(self.connection, rule_data, "EditorUser", self.user_group)
            else:
                # update
                rule_data={
                    "RULE_ID": self.existing_rule["RULE_ID"],
                    "RULE_NAME": name,
                    "RULE_SQL": sql_,
                    "OWNER_GROUP": owner,
                    "RULE_TYPE_ID": rt_id,
                    "EFFECTIVE_START_DATE": self.existing_rule.get("EFFECTIVE_START_DATE",datetime.now()),
                    "CLUSTER_NAME": clus
                }
                update_rule(self.connection, rule_data, "EditorUser", self.user_group)
            super().accept()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# MAIN LAUNCH
###############################################################################
def main():
    import sys
    from PyQt5.QtWidgets import QApplication

    app=QApplication(sys.argv)

    # DB connect
    from __main__ import DatabaseConnectionDialog
    dbdlg=DatabaseConnectionDialog()
    if dbdlg.exec_()==dbdlg.Accepted:
        conn=dbdlg.get_connection()
        if not conn:
            sys.exit(1)
    else:
        sys.exit(0)

    # login
    from __main__ import LoginDialog
    logdlg=LoginDialog(conn)
    if logdlg.exec_()!=QtWidgets.QDialog.Accepted:
        sys.exit(0)
    user_id=logdlg.user_id
    user_group=logdlg.user_group

    # fetch user info
    c=conn.cursor()
    c.execute("SELECT USERNAME,USER_GROUP FROM USERS WHERE USER_ID=?",(user_id,))
    row=c.fetchone()
    if not row:
        sys.exit(0)
    logged_in_username=row[0]
    user_group=row[1]

    # create main window
    window=BRMTool()
    window.connection=conn
    window.user_id=user_id
    window.logged_in_username=logged_in_username
    window.user_group=user_group

    window.init_ui()
    window.show()
    sys.exit(app.exec_())
    