#!/usr/bin/env python
"""
BRM TOOL - PART 1 of 8
Core Logging, Email, DB Connection, Basic DB Helpers, 
Audit Log, Login Dialog, Detect Operation Type, 
Advanced SQL Parser.

Excludes BFS, multi-step approvals, advanced CRUD, 
scheduling, main UI, etc. 
Fully implemented for Part 1â€™s scope (no pass placeholders).
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse

from datetime import datetime
from collections import deque
from email.mime.text import MIMEText

# PyQt5 (for DB Connection + Login dialogs)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QComboBox, QMessageBox, QLineEdit,
    QPlainTextEdit, QFormLayout, QCalendarWidget
)
from sqlparse.sql import Identifier, IdentifierList, Parenthesis, Token
from sqlparse.tokens import Keyword, DML

###############################################################################
# LOGGING CONFIG
###############################################################################
logging.basicConfig(
    filename='brm_tool.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# EMAIL CONFIG
###############################################################################
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_username",
    "smtp_password": "your_smtp_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Sends email via SMTP to 'recipients' using EMAIL_CONFIG. 
    No Slack/Teams usage.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()

        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Lets user pick an ODBC DSN or type a custom ODBC connection string.
    No SSO logic included. 
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection (Part 1)")
        self.resize(400, 200)

        layout = QVBoxLayout(self)
        lbl = QLabel("Select a SQL Server ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                # Filter DSNs for SQL SERVER
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: "+str(e))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        layout.addWidget(self.conn_str_edit)

        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cb = QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cb)

        layout.addLayout(bh)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self,"Error","No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self,"Connection Error",str(ex))
            return None

###############################################################################
# DB HELPERS
###############################################################################
def get_cursor_rows(cursor):
    """
    Fetches ALL rows => returns list of dicts if description exists.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows=[]
    if cursor.description:
        colnames=[desc[0] for desc in cursor.description]
        return [dict(zip(colnames,r)) for r in rows]
    return rows

def get_cursor_one(cursor):
    """
    Fetches ONE row => returns dict if description exists.
    """
    row=cursor.fetchone()
    if row and cursor.description:
        colnames=[desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return None

###############################################################################
# AUDIT LOG
###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert an audit record into BRM_AUDIT_LOG with JSON for old/new.
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
      OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """,(
        action,
        table_name,
        str(record_id) if record_id is not None else None,
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# LOGIN DIALOG (non-SSO)
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Basic username/password prompt. Checks 'USERS' table for match.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=None
        self.user_group=None
        self.setWindowTitle("Login (Part 1)")
        self.resize(300, 150)

        layout=QVBoxLayout(self)
        self.user_edit=QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit=QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn=QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern=self.user_edit.text().strip()
        passw=self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self,"Error","Enter username & password.")
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(usern, passw))
        row=get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")

###############################################################################
# DETECT OPERATION TYPE
###############################################################################
def detect_operation_type(sql_text:str)->str:
    """
    Quick parse => returns: INSERT, UPDATE, DELETE, SELECT, or OTHER
    depending on the first statement word in 'sql_text'.
    """
    txt=sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

###############################################################################
# ADVANCED SQL PARSER (TABLES + COLUMNS)
###############################################################################
def enhanced_advanced_extract_tables(sql_text:str):
    """
    Returns a dict:
    {
      "tables": [(schema, table, alias, is_subselect)],
      "cte_tables": [(cte_name, references)],
      "alias_map": { alias: (schema, table) },
      "columns": [(col_name, is_dml_target(bool), in_select(bool))]
    }
    Uses sqlparse to parse WITH/CTEs, SELECT, etc. 
    No placeholders.
    """
    statements=sqlparse.parse(sql_text)
    final_tables=[]
    cte_info=[]
    alias_map={}
    column_list=[]

    for stmt in statements:
        # parse CTE
        cte_dict=_extract_with_clauses(stmt)
        for cName, refs in cte_dict.items():
            cte_info.append((cName, refs))

        # parse main FROM
        main_refs, main_alias = _extract_main_from(stmt.tokens, set(cte_dict.keys()))
        final_tables.extend(main_refs)
        alias_map.update(main_alias)

        # parse columns
        col_refs=_extract_columns(stmt)
        column_list.extend(col_refs)

    final_tables=list({x for x in final_tables})
    return {
        "tables": final_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": column_list
    }

def _extract_with_clauses(statement):
    cte_map={}
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper()=="WITH":
            i+=1
            i=_parse_cte_block(tokens, i, cte_map)
            continue
        i+=1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    while i<len(tokens):
        tk=tokens[i]
        if isinstance(tk, Identifier):
            cte_name=tk.get_real_name()
            i+=1
            i=_parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i+=1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i<len(tokens):
        tk=tokens[i]
        val=tk.value.upper() if tk.ttype else ""
        if val=="AS":
            i+=1
            if i<len(tokens):
                sub=tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs=_extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name]=sub_refs
                    i+=1
                    return i
        else:
            i+=1
    return i

def _extract_subselect_tokens(tokens):
    results=[]
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident,set())
                    st=(st[0],st[1],st[2],True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st=_parse_identifier(tk,set())
                st=(st[0],st[1],st[2],True)
                results.append(st)
        i+=1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper()=="SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    results=[]
    alias_map={}
    tokens=list(tokenlist)
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, known_cte_names)
                    results.append(st)
                    al=st[2]
                    if al:
                        alias_map[al]=(st[0],st[1])
            elif isinstance(tk, Identifier):
                st=_parse_identifier(tk, known_cte_names)
                results.append(st)
                al=st[2]
                if al:
                    alias_map[al]=(st[0],st[1])
        i+=1
    return results, alias_map

def _parse_identifier(ident, known_cte_names):
    alias=ident.get_alias()
    real_name=ident.get_real_name()
    schema_name=ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    results=[]
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is DML:
            dml_word=tk.value.upper()
            if dml_word=="SELECT":
                col_refs=_parse_select_list(tokens, i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif dml_word in ("INSERT","UPDATE"):
                col_refs2=_parse_dml_columns(tokens, i, dml_word)
                for c_ in col_refs2:
                    results.append((c_, True, False))
        i+=1
    return results

def _parse_select_list(tokens, start_idx):
    columns=[]
    i=start_idx
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                colnm=ident.get_name()
                if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(colnm)
        elif isinstance(tk, Identifier):
            colnm=tk.get_name()
            if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(colnm)
        i+=1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    columns=[]
    if dml_word=="INSERT":
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and isinstance(tk,Parenthesis):
                for subiden in tk.tokens:
                    if isinstance(subiden,IdentifierList):
                        for ident in subiden.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(subiden,Identifier):
                        columns.append(subiden.get_name())
                return columns
            i+=1
    elif dml_word=="UPDATE":
        found_set=False
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.ttype is Keyword and tk.value.upper()=="SET":
                found_set=True
                i+=1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i+=1
    return columns

def _parse_update_set_list(tokens, start_i):
    columns=[]
    i=start_i
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, Identifier):
            columns.append(tk.get_name())
        i+=1
    return columns

# END PART 1 of 8
"""
BRM TOOL - PART 2 of 8
BFS rule execution, multi-step approvals, advanced CRUD for rules.
No repeated code from Part 1. Relies on Part 1â€™s DB helper, parser, etc.
Production-ready (no placeholders).
"""

import json
from datetime import datetime
from collections import deque

# We do NOT repeat logging config or DB helpers from Part 1. 
# We simply rely on them being defined in Part 1 code.

###############################################################################
# BFS RULE EXEC + STATS
###############################################################################
def build_rule_adjacency(conn):
    """
    Reads BRM_RULES (RULE_ID, PARENT_RULE_ID) and returns:
      (children_map, roots_list)

    children_map => { parent_rule_id : [child_rule_ids, ...] }
    roots_list => rules that have no parent (BFS start points)
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    children_map = {}
    all_ids = set()
    parent_ids = set()

    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)

    roots = [x for x in all_ids if x not in parent_ids]
    return (children_map, roots)

def load_global_critical_links(conn):
    """
    Loads GCR parent->child relationships from BRM_GLOBAL_CRITICAL_LINKS.
    Returns a dict: { gcr_rule_id : set_of_child_rule_ids }
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = c.fetchall()
    link_map = {}
    for (gcr, tgt) in rows:
        link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    """
    Returns dict of { rule_id: row_as_dict } for quick BFS lookups
    from BRM_RULES.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rr = c.fetchall()
    cols = [desc[0] for desc in c.description]
    res={}
    for row in rr:
        d = dict(zip(cols,row))
        res[d["RULE_ID"]]=d
    return res

def skip_descendants(child_id, children_map, skipped):
    """
    BFS skip function: adds 'child_id' + all its descendants to skipped set.
    """
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Inserts an entry into RULE_EXECUTION_LOGS to track BFS rule outcomes.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
    )
    VALUES(?, GETDATE(), ?, ?, ?)
    """,(rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()

def execute_rules_in_order(conn):
    """
    BFS-based rule execution from all root rules downward.
    If a rule is critical/global and fails => skip children.
    Logs results into RULE_EXECUTION_LOGS. 
    Returns (executed_ids, skipped_ids).
    """
    children_map, roots = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)

    executed = []
    skipped = set()
    c = conn.cursor()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            # no info => skip
            skipped.add(rid)
            continue

        rinfo = rule_lookup[rid]
        sql_ = rinfo["RULE_SQL"]
        is_crit = (rinfo["CRITICAL_RULE"]==1 or rinfo["IS_GLOBAL"]==1)
        crit_scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()

        c.execute("BEGIN TRANSACTION")
        success=False
        msg=""
        record_count=0
        try:
            c.execute(sql_)
            rows = c.fetchall()
            if rows:
                record_count = len(rows)
                val = rows[0][0]
                success = (val==1)
                msg = f"Returned: {val}"
            else:
                success = True
                msg = "No rows => PASS"
            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success=False
            msg=str(ex)

        insert_rule_execution_log(conn, rid, success, msg, record_count)

        if success:
            executed.append(rid)
            if rid in children_map:
                for child_rule in children_map[rid]:
                    if child_rule not in skipped:
                        queue.append(child_rule)
        else:
            if is_crit and crit_scope!="NONE":
                # skip children + GCR links
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    return (executed, skipped)

###############################################################################
# BFS FOR CHILD RULES
###############################################################################
def get_child_rules_bfs(conn, start_rule_id):
    """
    BFS all child rules (descendants) of 'start_rule_id',
    also includes GCR links. Returns set of child rule_ids.
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    allrows=c.fetchall()
    children_map={}
    for (rid, pid) in allrows:
        if pid:
            children_map.setdefault(pid,[]).append(rid)

    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    glinks=c.fetchall()
    gl_map={}
    for (gparent, gchild) in glinks:
        gl_map.setdefault(gparent,[]).append(gchild)

    visited=set()
    queue=[start_rule_id]
    results=set()

    while queue:
        cur=queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in children_map:
            for ch_ in children_map[cur]:
                results.add(ch_)
                queue.append(ch_)
        if cur in gl_map:
            for ch_ in gl_map[cur]:
                results.add(ch_)
                queue.append(ch_)

    return results

###############################################################################
# MULTI-STEP APPROVALS
###############################################################################
def find_impacted_business_groups(conn, rule_id):
    """
    BFS from rule_id => gather all child rules => union their owner groups
    + the parent rule's own group => final impacted set.
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row[0])

    child_ids = get_child_rules_bfs(conn, rule_id)
    for cid in child_ids:
        c2=conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(cid,))
        r2=c2.fetchone()
        if r2:
            impacted.add(r2[0])

    return impacted

def create_multistep_approvals(conn, rule_id):
    """
    Recreates approval pipeline for a rule, 
    including BFS child owners => re-approval triggers for them too.
    The pipeline is BG1->BG2->BG3->FINAL, but only if that BG is impacted.
    """
    impacted = find_impacted_business_groups(conn, rule_id)
    base_order = ["BG1","BG2","BG3","FINAL"]

    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    stage_ctr=1

    pipeline=[]
    for stg in base_order:
        if stg=="FINAL":
            pipeline.append(stg)
        else:
            if stg in impacted:
                pipeline.append(stg)

    for stage_name in pipeline:
        if stage_name=="FINAL":
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
              APPROVED_TIMESTAMP, APPROVAL_STAGE
            )
            VALUES(?,?,?,?,NULL,?)
            """,(rule_id, "FINAL", "final_approver", 0, stage_ctr))
            stage_ctr+=1
        else:
            c2=conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(stage_name,))
            ap_rows=c2.fetchall()
            for (approver_username,) in ap_rows:
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                  APPROVED_TIMESTAMP, APPROVAL_STAGE
                )
                VALUES(?,?,?,?,NULL,?)
                """,(rule_id, stage_name, approver_username, 0, stage_ctr))
            stage_ctr+=1

    conn.commit()

###############################################################################
# ADVANCED RULE CRUD (Add, Update, Deactivate, Delete)
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert a new rule into BRM_RULES. 
    - check duplicates, 
    - check group perms, 
    - parse SQL => table deps,
    - create multi-step approvals if not global
    - store in RULES, RULE_TABLE_DEPENDENCIES
    - log to audit
    """
    c=conn.cursor()

    # check duplicates by (owner_group + rule_name)
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    # check duplicates by SQL
    new_sql=rule_data["RULE_SQL"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
    if c.fetchone():
        raise ValueError("Another rule with the same SQL exists. Not allowed.")

    # only Admin can create global
    if rule_data.get("IS_GLOBAL", 0)==1 and user_group!="Admin":
        raise ValueError("Only Admin can create global rule.")

    # detect op type
    op_type = detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"] = op_type

    # check group perms
    owner_grp=rule_data["OWNER_GROUP"]
    c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(owner_grp,))
    perm_rows=c.fetchall()
    allowed_tables=set(x[0].lower() for x in perm_rows)

    parse_info = enhanced_advanced_extract_tables(new_sql)
    for (schema,tbl,alias,is_sub) in parse_info["tables"]:
        if tbl:
            schema_part = schema if schema else "dbo"
            full_name = (f"{schema_part}.{tbl}").lower()
            if full_name not in allowed_tables:
                raise ValueError(f"Group '{owner_grp}' does not have permission for table '{full_name}'")

    # insert
    row = c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
      EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
      CREATED_BY, DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
      CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP, CLUSTER_NAME,
      APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE
    )
    OUTPUT inserted.RULE_ID
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS","INACTIVE"),
        1,
        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),
        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE")
    )).fetchone()

    if not row:
        raise ValueError("Insert failed, no RULE_ID returned.")
    new_id = row[0]

    # table dependencies
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    else:
        col_op="READ"

    for (sch, tb, alias, is_sub) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(new_id, sch if sch else "N/A", tb, "DerivedCol", col_op))

    # add audit
    add_audit_log(conn,"INSERT","BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # if not global => create multi-step approvals
    if rule_data.get("IS_GLOBAL",0)==0:
        create_multistep_approvals(conn, new_id)

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    """
    Updates existing rule (by RULE_ID).
    - re-check duplicates, 
    - re-check group perms, 
    - re-set approvals if not global
    - update table deps
    - log audit
    """
    c=conn.cursor()
    rid=rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs,old))

    new_owner=rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"])
    new_name=rule_data.get("RULE_NAME", old_data["RULE_NAME"]).strip()

    # check dup name
    if (new_owner!=old_data["OWNER_GROUP"] or new_name!=old_data["RULE_NAME"]):
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",(new_owner,new_name))
        du=c.fetchone()
        if du and du[0]!=rid:
            raise ValueError(f"Duplicate rule '{new_name}' in group '{new_owner}'")

    new_sql=rule_data["RULE_SQL"].strip()
    if new_sql!=old_data["RULE_SQL"].strip():
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        rowx=c.fetchone()
        if rowx and rowx[0]!=rid:
            raise ValueError("Another rule with that SQL exists. Not allowed.")

    # if global => only admin can update
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"])==1 and user_group!="Admin":
        raise ValueError("Only Admin can set is_global=1.")

    op_type=detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"]=op_type

    # check group perms
    c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(new_owner,))
    perm_rows=c.fetchall()
    allowed_tables=set(x[0].lower() for x in perm_rows)

    parse_info = enhanced_advanced_extract_tables(new_sql)
    for (schema, tbl, alias, is_sub) in parse_info["tables"]:
        if tbl:
            schema_part = schema if schema else "dbo"
            full_name=(f"{schema_part}.{tbl}").lower()
            if full_name not in allowed_tables:
                raise ValueError(f"Group '{new_owner}' not permitted for table '{full_name}'")

    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID=?,
      PARENT_RULE_ID=?,
      RULE_TYPE_ID=?,
      RULE_NAME=?,
      RULE_SQL=?,
      EFFECTIVE_START_DATE=?,
      EFFECTIVE_END_DATE=?,
      STATUS='INACTIVE',
      VERSION=VERSION+1,
      UPDATED_BY=?,
      DESCRIPTION=?,
      OPERATION_TYPE=?,
      BUSINESS_JUSTIFICATION=?,
      OWNER_GROUP=?,
      CLUSTER_NAME=?,
      APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
      IS_GLOBAL=?,
      CRITICAL_RULE=?,
      CRITICAL_SCOPE=?,
      CDC_TYPE=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_name,
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        new_owner,
        rule_data.get("CLUSTER_NAME", old_data.get("CLUSTER_NAME","")),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rid
    ))

    # re-insert table deps
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    else:
        col_op="READ"

    for (sch,tb,alias, is_sub) in parse_info["tables"]:
        if tb and not tb.startswith("(CTE)"):
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """,(rid, sch if sch else "N/A", tb, "DerivedCol", col_op))

    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"] = old_data["VERSION"]+1

    add_audit_log(conn, "UPDATE","BRM_RULES", rid, updated_by, old_data, new_data)
    conn.commit()

    # re-init approvals if not global
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"])==0:
        create_multistep_approvals(conn, rid)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivate rule => must be fully approved, 
    not global if user not Admin, no active children.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if not row:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs,row))

    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids=c.fetchall()
    if kids:
        raise ValueError("Deactivate child rules first.")

    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE', UPDATED_BY=?, VERSION=VERSION+1
    WHERE RULE_ID=?
    """,(updated_by, rule_id))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1

    add_audit_log(conn, "DEACTIVATE","BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Delete a rule => must be fully approved, inactive, no children, 
    not global unless admin, and no references in BRM_COLUMN_MAPPING.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs,row))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")

    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids=c.fetchall()
    if kids:
        raise ValueError("Child rules exist, cannot delete.")

    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id, rule_id))
    leftover=c.fetchall()
    if leftover:
        raise ValueError("Re-map or remove column references first.")

    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log(conn, "DELETE","BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

# END PART 2 of 8
"""
BRM TOOL - PART 3 of 8
Single/Chain/Group Simulations, 
Improved sync_metadata, 
Scheduling (dialog + tab),
Advanced Feature Tabs (decision, conflict, composite, snapshots, tags, data validations).
No placeholders or references to old code.
Relies on Part 1 & 2 for logging, BFS, CRUD, etc.
"""

import json
import math
import logging
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget
)
from PyQt5.QtCore import Qt, QDateTime, QDate
import pyqtgraph as pg

###############################################################################
# SINGLE RULE SIM
###############################################################################
def run_rule_sql_dry_run(conn, rule_sql):
    """
    Dry-run a ruleâ€™s SQL => returns (success_bool, message_str).
    success_bool = True if SQL returns at least 1 row with [0][0]==1 or if no rows => PASS
    """
    c=conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    try:
        c.execute(rule_sql)
        rows=c.fetchall()
        if rows:
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
    except Exception as ex:
        success=False
        msg=str(ex)
    c.execute("ROLLBACK")
    return (success,msg)

class SingleRuleSimulationDialog(QDialog):
    """
    Allows user to test-run one ruleâ€™s SQL => see pass/fail quickly.
    """
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.sql_text=sql_text

        self.setWindowTitle(f"Simulate Rule {rule_id} (Part 3)")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_box=QHBoxLayout()
        run_btn=QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        btn_box.addWidget(run_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_box.addWidget(close_btn)
        layout.addLayout(btn_box)

        self.setLayout(layout)

    def do_sim(self):
        success,msg = run_rule_sql_dry_run(self.connection, self.sql_text)
        result_str = f"{'PASS' if success else 'FAIL'} => {msg}"
        self.result_text.setPlainText(result_str)

###############################################################################
# CHAIN SIM
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    BFS chain simulation from a chosen parent rule. 
    If the rule fails => skip BFS descendants.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        self.setWindowTitle("Simulate Rule Chain (Part 3)")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.parent_rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid, rname) in rows:
            disp=f"{rid} - {rname}"
            self.parent_rule_combo.addItem(disp, rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)

        cls_btn=QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        bh.addWidget(cls_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_chain(self):
        pid=self.parent_rule_combo.currentData()
        ex,sk=self.do_chain_dry_run(pid)
        txt=(f"Chain from rule {pid}\n"
             f"Executed => {ex}\n"
             f"Skipped => {sk}")
        self.result_text.setPlainText(txt)

    def do_chain_dry_run(self, start_rule):
        """
        BFS chain => if rule fails => skip children.
        Uses run_rule_sql_dry_run from above code.
        """
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,PARENT_RULE_ID,RULE_SQL FROM BRM_RULES")
        rows=c.fetchall()
        rule_map={}
        children_map={}
        for (rid, pid, sql_) in rows:
            rule_map[rid]=sql_
            if pid:
                children_map.setdefault(pid,[]).append(rid)

        executed=[]
        skipped=set()
        queue=[start_rule]

        while queue:
            rid=queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_map:
                skipped.add(rid)
                continue
            sql_=rule_map[rid]
            ok,msg=run_rule_sql_dry_run(self.connection,sql_)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch_ in children_map[rid]:
                        if ch_ not in skipped:
                            queue.append(ch_)
            else:
                skipped.add(rid)

        return (executed, skipped)

###############################################################################
# GROUP SIM
###############################################################################
class GroupSimulationDialog(QDialog):
    """
    Simulate a custom group => run each rule in it => pass/fail individually.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        self.setWindowTitle("Simulate Custom Group (Part 3)")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.group_combo=QComboBox()

        c=connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows=c.fetchall()
        for (cg_id, cg_name) in rows:
            disp=f"{cg_id} - {cg_name}"
            self.group_combo.addItem(disp, cg_id)
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)

        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)

        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_group(self):
        cg_id=self.group_combo.currentData()
        ex, fails=self.run_group_sim(cg_id)
        msg=f"Group {cg_id}\nExecuted => {ex}\nFails => {fails}"
        self.result_text.setPlainText(msg)

    def run_group_sim(self, custom_group_id):
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        rows=c.fetchall()
        group_rules=[r[0] for r in rows]

        c.execute("SELECT RULE_ID,RULE_SQL FROM BRM_RULES")
        allrows=c.fetchall()
        rule_map={}
        for (rid, sql_) in allrows:
            rule_map[rid]=sql_

        executed=[]
        fails=[]
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            sql_=rule_map[rid]
            ok,msg=run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return (executed, fails)

###############################################################################
# SYNC METADATA IMPROVED
###############################################################################
def sync_metadata_improved(conn):
    """
    Checks actual sys.tables => if rule dependency references a non-existent table => prefix 'MISSING_'
    """
    c=conn.cursor()
    c.execute("""
    SELECT s.name AS schema_name, t.name AS table_name
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id=s.schema_id
    ORDER BY s.name, t.name
    """)
    actual_tables=set()
    for row in c.fetchall():
        fulln=f"{row[0]}.{row[1]}".lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps=c.fetchall()
    missing=[]
    updated=0
    for d_ in deps:
        dep_id=d_[0]
        tbl=(d_[3] or "").strip()
        if "." not in tbl:
            candidate=f"dbo.{tbl}".lower()
        else:
            candidate=tbl.lower()
        if candidate not in actual_tables:
            missing.append(dep_id)

    for dep_id in missing:
        c.execute("""
        UPDATE BRM_RULE_TABLE_DEPENDENCIES
        SET TABLE_NAME='MISSING_' + TABLE_NAME
        WHERE DEPENDENCY_ID=?
        """,(dep_id,))
        updated+=1

    conn.commit()
    msg=(f"Metadata Sync completed.\n"
         f"Found {len(actual_tables)} real tables.\n"
         f"Scanned {len(deps)} dependencies.\n"
         f"Marked {updated} references as MISSING.\n")
    QMessageBox.information(None,"Sync Metadata",msg)

###############################################################################
# SCHEDULING (DIALOG + TAB)
###############################################################################
class EnhancedScheduleDialog(QDialog):
    """
    Let user pick a rule + date/time => create a schedule record.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Enhanced Scheduling UI (Part 3)")
        self.resize(400,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        date_=self.calendar.selectedDate()
        time_=self.time_edit.time()
        dt_str=f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP)
        VALUES(?,?, 'Scheduled', GETDATE())
        """,(rid, dt_str))
        self.connection.commit()

        QMessageBox.information(self,"Scheduled",f"Rule {rid} scheduled at {dt_str}.")
        self.close()

class ScheduleManagementTab(QWidget):
    """
    Tab that shows SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS => user can update or delete
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.schedule_table=QTableWidget(0,5)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID","Rule ID","Schedule Time","Status","Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn=QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            self.schedule_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(r_i,2,QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(r_i,3,QTableWidgetItem(str(row[3])))

            act_widget=QWidget()
            h=QHBoxLayout(act_widget)
            h.setContentsMargins(0,0,0,0)

            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rowidx=r_i: self.update_schedule(rowidx))
            h.addWidget(upd_btn)

            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rowidx=r_i: self.delete_schedule(rowidx))
            h.addWidget(del_btn)

            h.addStretch()
            self.schedule_table.setCellWidget(r_i,4,act_widget)

        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, rowidx):
        sch_id_item=self.schedule_table.item(rowidx,0)
        if not sch_id_item:
            return
        sch_id=int(sch_id_item.text())

        new_dt,ok=QInputDialog.getText(self,"Update Schedule","Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, rowidx):
        sch_id_item=self.schedule_table.item(rowidx,0)
        if not sch_id_item:
            return
        sch_id=int(sch_id_item.text())

        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()

        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()

###############################################################################
# ADVANCED FEATURES TABS
###############################################################################
class DecisionTablesTab(QWidget):
    """
    Manage decision tables => table_name + optional description
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.dt_table=QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels(["Decision Table ID","Table Name","Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)
        bh.addStretch()

        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows=c.fetchall()
        for r_ in rows:
            row_i=self.dt_table.rowCount()
            self.dt_table.insertRow(row_i)
            self.dt_table.setItem(row_i,0,QTableWidgetItem(str(r_[0])))
            self.dt_table.setItem(row_i,1,QTableWidgetItem(r_[1]))
            self.dt_table.setItem(row_i,2,QTableWidgetItem(r_[2] if r_[2] else ""))

    def add_dt(self):
        name,ok=QInputDialog.getText(self,"Add Decision Table","Table Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(name.strip(),desc.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Added","Decision table created.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No decision table selected.")
            return
        it=self.dt_table.item(row,0)
        if not it:
            return
        dt_id=int(it.text())

        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()

        QMessageBox.information(self,"Deleted","Decision table removed.")
        self.load_dt()

class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS => (RULE_ID1, RULE_ID2, PRIORITY).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["Conflict ID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        setp_btn=QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            self.cf_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.cf_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.cf_table.setItem(r_i,2,QTableWidgetItem(str(row[2])))
            self.cf_table.setItem(r_i,3,QTableWidgetItem(str(row[3])))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule ID1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule ID2:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Enter priority (int):")
        if not ok3:
            return

        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pri))
        self.connection.commit()

        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        if not cfid_item:
            return
        cf_id=int(cfid_item.text())

        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return

        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp, cf_id))
        self.connection.commit()

        QMessageBox.information(self,"Updated","Conflict priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        if not cfid_item:
            return
        cf_id=int(cfid_item.text())

        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()

        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()

class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES => CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["Composite Rule ID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_crule)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_crule)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_crules)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_crules()

    def load_crules(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.cr_table.rowCount()
            self.cr_table.insertRow(rr)
            self.cr_table.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.cr_table.setItem(rr,1,QTableWidgetItem(row[1]))
            self.cr_table.setItem(rr,2,QTableWidgetItem(row[2] if row[2] else ""))
            self.cr_table.setItem(rr,3,QTableWidgetItem(row[3] if row[3] else ""))

    def add_crule(self):
        name,ok=QInputDialog.getText(self,"New Composite Rule","Name:")
        if not ok or not name.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expr","(e.g. 'Rule1==PASS AND Rule2==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","(Optional):")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
        VALUES(?,?,?)
        """,(name.strip(), expr.strip(), act.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Created","Composite rule created.")
        self.load_crules()

    def del_crule(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        if not it:
            return
        cid=int(it.text())

        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
        self.connection.commit()

        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_crules()

class SnapshotManagerTab(QWidget):
    """
    Manage rule snapshots => full backup of BRM_RULES in JSON.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["Snapshot ID","SNAPSHOT_NAME","CREATED_BY","CREATED_TIMESTAMP","SNAPSHOT_JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snapshot)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            rr=self.ss_table.rowCount()
            self.ss_table.insertRow(rr)
            self.ss_table.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.ss_table.setItem(rr,1,QTableWidgetItem(row[1]))
            self.ss_table.setItem(rr,2,QTableWidgetItem(row[2]))
            self.ss_table.setItem(rr,3,QTableWidgetItem(str(row[3])))
            self.ss_table.setItem(rr,4,QTableWidgetItem(row[4] if row[4] else ""))

    def take_snapshot(self):
        name,ok=QInputDialog.getText(self,"Snapshot","Snapshot name:")
        if not ok or not name.strip():
            return

        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        rules_list=[]
        for row in rows:
            rules_list.append(dict(zip(colnames,row)))

        import json
        snapshot_json=json.dumps(rules_list)
        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(name.strip(),"SnapshotUser",snapshot_json))
        self.connection.commit()

        QMessageBox.information(self,"Snapshot","Snapshot created.")
        self.load_snapshots()

    def del_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        it=self.ss_table.item(row,0)
        if not it:
            return
        ssid=int(it.text())

        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {ssid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(ssid,))
        self.connection.commit()

        QMessageBox.information(self,"Deleted","Snapshot removed.")
        self.load_snapshots()

class TagsManagerTab(QWidget):
    """
    Manage rule tags => RULE_TAGS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows=c.fetchall()
        for r_ in rows:
            rr=self.tags_table.rowCount()
            self.tags_table.insertRow(rr)
            self.tags_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.tags_table.setItem(rr,1,QTableWidgetItem(str(r_[1])))
            self.tags_table.setItem(rr,2,QTableWidgetItem(r_[2]))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return

        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        if not it:
            return
        tag_id=int(it.text())

        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tag_id,))
        self.connection.commit()

        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()

class DataValidationTab(QWidget):
    """
    Manage DATA_VALIDATIONS => table_name, column_name, validation_type, params
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_val)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
        ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for r_ in rows:
            rr=self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            self.dv_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.dv_table.setItem(rr,1,QTableWidgetItem(r_[1]))
            self.dv_table.setItem(rr,2,QTableWidgetItem(r_[2]))
            self.dv_table.setItem(rr,3,QTableWidgetItem(r_[3]))
            self.dv_table.setItem(rr,4,QTableWidgetItem(r_[4] if r_[4] else ""))

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name (e.g. dbo.SomeTable):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column Name","(e.g. Amount):")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'RANGE','NOT NULL'):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional) JSON or text:")
        if not ok4:
            pars=""

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS)
        VALUES(?,?,?,?)
        """,(tbl.strip(), col.strip(), vtype.strip(), pars.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Added","Data validation added.")
        self.load_vals()

    def remove_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        vid=int(it.text())

        confirm=QMessageBox.question(self,"Confirm",f"Remove validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()

        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

# END PART 3 of 8
"""
BRM TOOL - PART 4 of 8
Approvals Tab (Approve/Reject), Hierarchy Tree, 
Lineage Graph Widget (skeleton), 
Control Tables Tab, Metrics Dashboard Tab.
No code repeated from previous parts.
"""

import sys
import json
import math
import logging
from datetime import datetime
from collections import deque

# PyQt5
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QMessageBox, QAbstractItemView, QComboBox,
    QPlainTextEdit, QDialog, QTreeWidget, QTreeWidgetItem,
    QFileDialog, QTextEdit, QListWidget, QListWidgetItem
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
import pyqtgraph as pg

###############################################################################
# MULTI-STEP APPROVAL TAB
###############################################################################
class MultiStepApprovalTab(QWidget):
    """
    Shows userâ€™s pending approvals. The user can Approve or Reject.
    Only the earliest stage gets to approve. If the rule is already in a higher stage => not shown.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.appr_table=QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels(
            ["Rule ID","Group","Rule Name","Stage","Approved?","Approve","Reject"]
        )
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        """
        Load only the pending approvals for the logged_in_username, 
        ensure only the earliest stage is shown for each rule.
        """
        c=self.connection.cursor()
        query = """
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, A.APPROVAL_STAGE,
               R.RULE_NAME, R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """
        c.execute(query,(self.logged_in_username,))
        rows=c.fetchall()

        def get_current_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) as stage
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            if ro and ro[0]:
                return ro[0]
            return None

        minimal_rows=[]
        for rd in rows:
            rid=rd[0]
            stage=rd[4]
            cur_st=get_current_stage(rid)
            if cur_st == stage:
                minimal_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(rd[0])))  # rule_id
            self.appr_table.setItem(r_i,1,QTableWidgetItem(rd[1]))       # group_name
            self.appr_table.setItem(r_i,2,QTableWidgetItem(rd[5]))       # rule_name
            self.appr_table.setItem(r_i,3,QTableWidgetItem(str(rd[4])))  # stage
            self.appr_table.setItem(r_i,4,QTableWidgetItem(str(rd[3])))  # approved_flag?

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rowidx=r_i: self.do_approve(rowidx))
            self.appr_table.setCellWidget(r_i,5,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rowidx=r_i: self.do_reject(rowidx))
            self.appr_table.setCellWidget(r_i,6, reject_btn)

    def do_approve(self, row_i):
        rid_item=self.appr_table.item(row_i,0)
        grp_item=self.appr_table.item(row_i,1)
        if not rid_item or not grp_item:
            return

        rid=int(rid_item.text())
        grp=grp_item.text()

        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))

        def get_current_stage2(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            return ro[0] if ro and ro[0] else None

        nxt = get_current_stage2(rid)
        if nxt is None:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?",(rid,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?",(rid,))

        # add audit
        old_data={"APPROVED_FLAG":0}
        new_data={"APPROVED_FLAG":1}
        from_part1_str="We rely on add_audit_log from Part 1"
        add_audit_log(self.connection,"UPDATE","BRM_RULE_APPROVALS",rid,self.logged_in_username,old_data,new_data)

        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} was approved.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.appr_table.item(row_i,0)
        grp_item=self.appr_table.item(row_i,1)
        if not rid_item or not grp_item:
            return

        rid=int(rid_item.text())
        grp=grp_item.text()

        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))

        c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?",(rid,))

        add_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"REJECTED":True})
        self.connection.commit()

        QMessageBox.information(self,"Rejected",f"Rule {rid} rejected.")
        self.load_approvals()

###############################################################################
# HIERARCHY VIEW
###############################################################################
class HierarchyViewTab(QWidget):
    """
    Displays a tree => top-level groups => child rules. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Group / Rule"])
        layout.addWidget(self.tree)

        ref_btn=QPushButton("Refresh Hierarchy")
        ref_btn.clicked.connect(self.load_hierarchy)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows=c.fetchall()
        grp_map={}
        for (gid, gname) in grp_rows:
            top_item=QTreeWidgetItem([f"{gname} (ID={gid})"])
            self.tree.addTopLevelItem(top_item)
            grp_map[gid]=top_item

        c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID FROM BRM_RULES ORDER BY RULE_ID")
        rule_rows=c.fetchall()
        for (rid, rnm, g_id) in rule_rows:
            if g_id in grp_map:
                parent_it=grp_map[g_id]
                child=QTreeWidgetItem([f"Rule {rid}: {rnm}"])
                parent_it.addChild(child)

        self.tree.expandAll()

###############################################################################
# ENHANCED LINEAGE GRAPH (SKELETON)
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    Displays a graph of rule => table dependencies, parent->child rules, etc.
    For brevity, a skeleton. A real version might do BFS to position nodes.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)

        self.node_map={}
        self.children_map={}
        self.parents_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        # minimal logic => just place a text item:
        txt_item=QtWidgets.QGraphicsTextItem("Lineage Graph - Not fully implemented.")
        txt_item.setPos(0,0)
        self.scene.addItem(txt_item)

    def resetView(self):
        self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

###############################################################################
# CONTROL TABLES TAB
###############################################################################
class CtrlTablesTab(QWidget):
    """
    Allows user to pick from known tables => load data in a QTableWidget.
    We'll define a hard-coded list or allow them to type a table name. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES","DECISION_TABLES","RULE_CONFLICTS",
            "COMPOSITE_RULES","RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS",
            "BRM_RULE_APPROVALS","BRM_CUSTOM_RULE_GROUPS","BRM_CUSTOM_GROUP_MEMBERS",
            # add more if needed
        ]

        self.table_combo=QComboBox()
        for t_ in self.table_list:
            self.table_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn=QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def on_load_data(self):
        tbl=self.table_combo.currentText()
        if not tbl:
            return

        c=self.connection.cursor()
        try:
            # get columns
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error getting columns: {ex}")
            return

        try:
            c.execute(f"SELECT * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving data: {ex}")
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)

        for row in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for j,val in enumerate(row):
                self.data_table.setItem(r_i, j, QTableWidgetItem(str(val)))

        self.data_table.resizeColumnsToContents()

###############################################################################
# METRICS DASHBOARD
###############################################################################
class MetricsDashboardTab(QWidget):
    """
    Basic bar chart of rule counts by status, using pyqtgraph.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.chart=pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        ref_btn=QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()

        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]

        self.chart.clear()
        if statuses:
            x=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(x), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([ list(zip(x, statuses)) ])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True, y=True)

# END PART 4 of 8
"""
BRM TOOL - PART 5 of 8
Alerts/Dashboards, Group Management, User Management, 
Custom Rule Group Enhanced Tab.
No duplication from Parts 1-4, references them if needed.
"""

import json
import math
import logging
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QMessageBox, QAbstractItemView, QComboBox,
    QPlainTextEdit, QLineEdit, QInputDialog, QDialog, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QFormLayout, QGroupBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

###############################################################################
# ALERTS & DASHBOARDS TAB
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    """
    Shows pending old approvals, upcoming schedules, etc.
    Looks at data from BRM_RULE_APPROVALS, RULE_SCHEDULES, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # 1) find approvals older than 3 days
        c.execute("""
        SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
               DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP), GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(SELECT MIN(APPROVAL_STAGE)
                                FROM BRM_RULE_APPROVALS
                                WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0)
          AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP), GETDATE())>3
        """)
        old_ap=c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for row in old_ap:
                lines.append(f" - Rule {row[0]} stage={row[1]} age={row[3]} => {row[2]}")
        else:
            lines.append("No old approvals found.")

        lines.append("")

        # 2) upcoming schedules in next 24h
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upcoming=c.fetchall()
        if upcoming:
            lines.append("Upcoming schedules in next 24h:")
            for up_ in upcoming:
                lines.append(f" - ID={up_[0]}, rule={up_[1]}, time={up_[2]}")
        else:
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))

###############################################################################
# GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTab(QWidget):
    """
    Manage business groups, membership, group permissions, and group approvers.
    Only Admin can do this.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # 1) Groups & Membership
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)

        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        grp_btns.addWidget(del_grp_btn)

        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        membership_box=QGroupBox("Membership Management")
        membership_layout=QVBoxLayout(membership_box)

        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btns.addWidget(add_usr_btn)

        rem_usr_btn=QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btns.addWidget(rem_usr_btn)

        memb_btns.addStretch()
        membership_layout.addLayout(memb_btns)
        gm_layout.addWidget(membership_box)

        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab, "Groups & Membership")

        # 2) Permissions
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)

        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)

        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.on_add_permission)
        ph.addWidget(addp_btn)

        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.on_remove_permission)
        ph.addWidget(remp_btn)

        ph.addStretch()
        perm_box_layout.addLayout(ph)
        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # 3) Approvers
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btns.addWidget(add_appr_btn)

        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btns.addWidget(del_appr_btn)

        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        # refresh button
        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    # GROUPS
    def load_groups(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.groups_table.setRowCount(0)
        for row in rows:
            rr=self.groups_table.rowCount()
            self.groups_table.insertRow(rr)
            self.groups_table.setItem(rr,0,QTableWidgetItem(row[0]))
            self.groups_table.setItem(rr,1,QTableWidgetItem(row[1] if row[1] else ""))
            self.groups_table.setItem(rr,2,QTableWidgetItem(row[2] if row[2] else ""))

    def get_selected_group(self):
        i=self.groups_table.currentRow()
        if i<0:
            return None
        it=self.groups_table.item(i,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)",
                  (name.strip(), desc.strip(), em.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def on_rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def on_delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group removed.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    # MEMBERSHIP
    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            self.users_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.users_table.setItem(r_i,1,QTableWidgetItem(row[1]))
            self.users_table.setItem(r_i,2,QTableWidgetItem(row[2]))

    def get_selected_user(self):
        i=self.users_table.currentRow()
        if i<0:
            return None
        it=self.users_table.item(i,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldg=c.fetchone()
        if not oldg:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if oldg[0]==grp.strip():
            QMessageBox.warning(self,"Error","User is already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(), uid))
        self.connection.commit()

        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user from group => user moves to BG1.")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()

        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    # PERMISSIONS
    def load_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.perm_group_combo.clear()
        for row in rows:
            self.perm_group_combo.addItem(row[0], row[0])

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for r_ in rows:
            rr=self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(r_[0]))

    def on_add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        table,ok=QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.Portfolio'):")
        if not ok or not table.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(), table.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def on_remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","No group selected.")
            return
        row=self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        tbl=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{tbl}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(), tbl))
        self.connection.commit()

        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    # APPROVERS
    def load_appr_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.appr_group_combo.clear()
        for row in rows:
            self.appr_group_combo.addItem(row[0], row[0])

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        self.appr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID, USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=c.fetchall()
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(row[1]))

    def on_add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        usern,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES(?,?)",
                  (grp.strip(), usern.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Added",f"Approver '{usern}' added to {grp}.")
        self.load_approvers()

    def on_remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        app_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver ID={app_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(app_id,))
        self.connection.commit()

        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

###############################################################################
# USER MANAGEMENT TAB
###############################################################################
class UserManagementTab(QWidget):
    """
    Manage users: add, delete, change password, set group. Only Admin can see/do this.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["User ID","Username","Password","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.on_add_user)
        btn_h.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.on_delete_user)
        btn_h.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.on_change_password)
        btn_h.addWidget(pass_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.user_table.rowCount()
            self.user_table.insertRow(rr)
            for cc in range(4):
                self.user_table.setItem(rr, cc, QTableWidgetItem(str(row[cc])))

    def get_selected_user_id(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user(self):
        uname,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",
                  (uname.strip(), pwd.strip(), grp.strip()))
        self.connection.commit()

        QMessageBox.information(self,"Created","User added.")
        self.load_users()

    def on_delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()

        QMessageBox.information(self,"Deleted","User removed.")
        self.load_users()

    def on_change_password(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(), uid))
        self.connection.commit()

        QMessageBox.information(self,"Updated","Password changed.")
        self.load_users()

###############################################################################
# CUSTOM RULE GROUP ENHANCED TAB
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manage custom groups => BFS backups, restore versions, assign rules, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Custom Group / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)

        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        splitter.addWidget(right_widget)
        layout.addWidget(splitter)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for (cg_id, cg_name, owner) in groups:
            disp=f"{cg_name} ({owner})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0, Qt.UserRole, cg_id)
            g_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for (rid, rname, isg, iscrit) in assigned:
                txt=f"Rule {rid}: {rname}"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0, Qt.UserRole, rid)
                if isg==1:
                    rr_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightblue")))
                if iscrit==1:
                    rr_item.setBackground(0, QtGui.QBrush(QtGui.QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()

        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)

        rows=c.fetchall()

        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set(x[0] for x in c2.fetchall())

        for (rid, rname, og) in rows:
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rname} (Owner {og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole, rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # child => rule
            menu=QtWidgets.QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id, rule_id))
                self.connection.commit()

                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed.")
                self.refresh_all()

    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(
          CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP
        )
        VALUES(?,?,?,GETDATE())
        """,(name, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()

        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return None,None
        item=sel[0]
        par=item.parent()
        if par:
            item=par
        gid=item.data(0, Qt.UserRole)
        disp=item.text(0)
        return gid, disp

    def rename_group(self):
        gid, disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(), gid))
            self.connection.commit()

            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gid, disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        gid, disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname=row[0]

        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[x[0] for x in c.fetchall()]
        backup_data={"group_name":grpname,"members":assigned}

        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 AS new_ver
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1

        import json
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid, new_ver, json.dumps(backup_data)))
        self.connection.commit()

        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        gid, disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return

        items=[f"Version {r[0]} (ts {r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return

        import re
        m=re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver=int(m.group(1))

        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return

        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found.")
            return

        import json
        backup_data=json.loads(backup_json)
        new_name=backup_data["group_name"]
        members=backup_data["members"]

        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name,gid))

            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(
                  CUSTOM_GROUP_ID,RULE_ID
                )VALUES(?,?)
                """,(gid, mid))

            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected in the tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)

        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return

        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(
                  CUSTOM_GROUP_ID,RULE_ID
                )
                VALUES(?,?)
                """,(gid, rid))
                count+=1
            except:
                pass

        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()

# END PART 5 of 8
"""
BRM TOOL - PART 6 of 8
Audit Log Viewer, Rule Search Dialog, Version History Dialog.
No duplication from Parts 1-5.
"""

import sys
import json
import csv
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Show BRM_AUDIT_LOG records, with search & CSV export.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs (Part 6)")
        self.resize(800,600)

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table=QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels([
            "Audit ID","Action","Table","Record ID","Action By","Old Data","New Data","Timestamp"
        ])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.audit_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.audit_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        exp_btn=QPushButton("Export to CSV")
        exp_btn.clicked.connect(self.export_csv)
        bh.addWidget(exp_btn)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.audit_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
               OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_ = self.audit_table.rowCount()
            self.audit_table.insertRow(r_)
            self.audit_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.audit_table.setItem(r_,1,QTableWidgetItem(row[1]))
            self.audit_table.setItem(r_,2,QTableWidgetItem(row[2]))
            self.audit_table.setItem(r_,3,QTableWidgetItem(row[3]))
            self.audit_table.setItem(r_,4,QTableWidgetItem(row[4]))

            oldtxt=""
            if row[5]:
                try:
                    d_=json.loads(row[5])
                    oldtxt=json.dumps(d_, indent=2)
                except:
                    oldtxt=row[5]
            self.audit_table.setItem(r_,5,QTableWidgetItem(oldtxt))

            newtxt=""
            if row[6]:
                try:
                    d2=json.loads(row[6])
                    newtxt=json.dumps(d2, indent=2)
                except:
                    newtxt=row[6]
            self.audit_table.setItem(r_,6,QTableWidgetItem(newtxt))

            self.audit_table.setItem(r_,7,QTableWidgetItem(str(row[7])))

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            show=False
            for col_i in (1,2,4):
                item=self.audit_table.item(row, col_i)
                if item and txt_l in item.text().lower():
                    show=True
                    break
            self.audit_table.setRowHidden(row, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Save CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row):
                    continue
                rowdata=[]
                for col in range(self.audit_table.columnCount()):
                    it=self.audit_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)

        QMessageBox.information(self,"Exported","Audit logs exported to CSV.")

###############################################################################
# SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialog(QDialog):
    """
    Search rules by name or SQL snippet, show results in a table.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules (Part 6)")
        self.resize(800,600)

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.res_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.res_table)

        rb=QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        layout.addWidget(rb)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)

        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_i=self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for i_ in range(6):
                self.res_table.setItem(r_i, i_, QTableWidgetItem(str(row[i_])))

###############################################################################
# VERSION HISTORY DIALOG
###############################################################################
class VersionHistoryDialog(QDialog):
    """
    Show version changes from BRM_AUDIT_LOG for a single rule ID, optionally do rollback.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History for Rule {rule_id} (Part 6)")
        self.resize(800,400)

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["Audit ID","Action","Timestamp","Old Data","New Data"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb=QPushButton("Rollback Selected")
        rb.clicked.connect(self.do_rollback)
        bh.addWidget(rb)

        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)

        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES'
          AND RECORD_ID=?
          AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()

        self.table.setRowCount(0)
        for row in rows:
            rr=self.table.rowCount()
            self.table.insertRow(rr)
            self.table.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(rr,1,QTableWidgetItem(row[1]))
            self.table.setItem(rr,2,QTableWidgetItem(str(row[2])))

            oldtxt=""
            if row[3]:
                try:
                    d_=json.loads(row[3])
                    oldtxt=json.dumps(d_, indent=2)
                except:
                    oldtxt=row[3]
            self.table.setItem(rr,3,QTableWidgetItem(oldtxt))

            newtxt=""
            if row[4]:
                try:
                    d2=json.loads(row[4])
                    newtxt=json.dumps(d2, indent=2)
                except:
                    newtxt=row[4]
            self.table.setItem(rr,4,QTableWidgetItem(newtxt))

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected for rollback.")
            return
        rowidx=sel[0].row()
        old_data_item=self.table.item(rowidx,3)
        if not old_data_item:
            QMessageBox.warning(self,"No Data","No old_data found in that row.")
            return
        old_data_json=old_data_item.text().strip()
        if not old_data_json:
            QMessageBox.warning(self,"No Data","Empty old_data field => cannot rollback.")
            return

        confirm=QMessageBox.question(self,"Confirm","Rollback to selected version?")
        if confirm!=QMessageBox.Yes:
            return

        # parse old_data
        import json
        try:
            old_data=json.loads(old_data_json)
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Could not parse old_data JSON: {ex}")
            return

        self.apply_rollback(old_data)
        QMessageBox.information(self,"Rolled Back","Rule rollback done.")
        self.load_history()

    def apply_rollback(self, old_data):
        """
        A naive rollback => sets rule to old_dataâ€™s fields:
         RULE_NAME, RULE_SQL, OWNER_GROUP, set STATUS=INACTIVE, 
         + re-insert table deps from parse.
        """
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")
        old_rule_sql=old_data["RULE_SQL"]
        # forcibly set status=INACTIVE, re-approval

        c.execute("BEGIN TRANSACTION")
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(
            old_data["RULE_NAME"],
            old_rule_sql,
            old_data["OWNER_GROUP"],
            rid
        ))

        # re-parse table deps
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))

        # we rely on the advanced parser from Part 1
        op_type = detect_operation_type(old_rule_sql)
        parse_info = enhanced_advanced_extract_tables(old_rule_sql)
        col_op="READ"
        if op_type in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"

        for (sch, tb, alias, is_sub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid, sch if sch else "N/A", tb, "RolledBackCol", col_op))

        c.execute("COMMIT")

# END PART 6 of 8
"""
BRM TOOL - PART 7 of 8
RuleDashboard (with pagination, filter) and RuleEditorDialog (add/update).
No duplication from Parts 1-6; references them if needed.
"""

import sys
import json
import math
from datetime import datetime
from PyQt5.QtWidgets import (
    QGroupBox, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QComboBox, QPushButton, QTableWidget, QTableWidgetItem,
    QMessageBox, QAbstractItemView, QPlainTextEdit, QDateTimeEdit, QCheckBox,
    QTextEdit, QDialog, QFormLayout
)
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtGui import QColor

###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    """
    A paginated table of rules with search by name/SQL snippet,
    plus status filter (Active/Inactive/All).
    Provides a method get_selected_rule_ids() to see what's selected.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.selected_rule_id=None

        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        # top bar with search + status filter
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL snippet...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        # table
        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Name","SQL","Status","Version","Owner Group","Created TS","Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        # paging controls
        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")

        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)

        # signals
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_query(self):
        filters=[]
        params=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)

        if filters:
            clause=" AND ".join(filters)
        else:
            clause="1=1"

        return (clause, params)

    def load_rules(self):
        c=self.connection.cursor()

        clause,params=self.build_filter_query()
        # count
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, params)
        rowc=c.fetchone()
        total=rowc[0] if rowc else 0

        self.total_pages=max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page

        data_q=f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,
               CREATED_TIMESTAMP,APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*params, offset, self.records_per_page))
        rows=c.fetchall()

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i in range(8):
                it=QTableWidgetItem(str(rd[col_i]))
                if col_i==3:  # status
                    if str(rd[col_i]).upper()=="ACTIVE":
                        it.setBackground(QColor(144,238,144))  # lightgreen
                    else:
                        it.setBackground(QColor(255,182,193))  # lightpink
                self.rule_table.setItem(r_i, col_i, it)

    def update_selected_rule_id(self):
        sel=self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.rule_table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i in idxs:
            row=i.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

###############################################################################
# RULE EDITOR DIALOG
###############################################################################
class RuleEditorDialog(QDialog):
    """
    Allows user to Add or Update a rule. 
    On save => calls add_rule or update_rule from Part 2.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)

        title="Update Rule" if self.is_update else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(800,550)

        self.main_layout=QVBoxLayout(self)
        form_layout=QFormLayout()

        # 1) Group combo
        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows=c.fetchall()
        for (gid,gname) in grp_rows:
            disp=f"{gname} (ID={gid})"
            self.group_combo.addItem(disp, gid)
        form_layout.addRow("Rule Group:", self.group_combo)

        # 2) Parent rule
        self.parent_rule_combo=QComboBox()
        self.parent_rule_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        pr_rows=c.fetchall()
        for (rid,rname) in pr_rows:
            disp2=f"{rname} (ID={rid})"
            self.parent_rule_combo.addItem(disp2, rid)
        form_layout.addRow("Parent Rule:", self.parent_rule_combo)

        # 3) name
        self.name_edit=QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        # 4) rule type combo
        self.rule_type_combo=QComboBox()
        c.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        rt_rows=c.fetchall()
        for (rtid, rtn) in rt_rows:
            self.rule_type_combo.addItem(rtn, rtid)
        form_layout.addRow("Rule Type:", self.rule_type_combo)

        # 5) status => typically "INACTIVE" or "ACTIVE"
        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        # 6) start/end datetime
        self.start_dt=QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_layout.addRow("Effective Start:", self.start_dt)

        self.end_dt=QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_layout.addRow("Effective End:", self.end_dt)

        # 7) CDC
        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_layout.addRow("CDC Type:",self.cdc_combo)

        # 8) SQL
        self.sql_edit=QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, 0 => FAIL. Example: SELECT 1 WHERE ...")
        form_layout.addRow("Rule SQL:", self.sql_edit)

        # 9) description, justification
        self.desc_edit=QTextEdit()
        form_layout.addRow("Description:", self.desc_edit)

        self.just_edit=QTextEdit()
        form_layout.addRow("Justification:", self.just_edit)

        # 10) global + critical
        self.global_cb=None
        if self.user_group=="Admin":
            self.global_cb=QCheckBox("Global (Admin only)")
            form_layout.addRow("Global Rule:", self.global_cb)

        self.critical_cb=QCheckBox()
        form_layout.addRow("Critical Rule:", self.critical_cb)

        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_layout.addRow("Critical Scope:",self.scope_combo)

        self.main_layout.addLayout(form_layout)

        bh=QHBoxLayout()
        self.save_btn=QPushButton("Save" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.on_save)
        bh.addWidget(self.save_btn)

        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(cancel_btn)

        self.main_layout.addLayout(bh)
        self.setLayout(self.main_layout)

        if self.is_update and self.rule_data:
            self.load_existing_rule_data(self.rule_data)

    def load_existing_rule_data(self, rd):
        """
        Fill form fields from existing rule_data.
        """
        gid=rd.get("GROUP_ID")
        if gid:
            ix=self.group_combo.findData(gid)
            if ix>=0:
                self.group_combo.setCurrentIndex(ix)

        pid=rd.get("PARENT_RULE_ID")
        if pid:
            ix2=self.parent_rule_combo.findData(pid)
            if ix2>=0:
                self.parent_rule_combo.setCurrentIndex(ix2)
        else:
            self.parent_rule_combo.setCurrentIndex(0)

        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3=self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)

        st=rd.get("STATUS","INACTIVE")
        i_st=self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        fmt="%Y-%m-%d %H:%M:%S"
        sd=rd.get("EFFECTIVE_START_DATE","")
        if sd:
            try:
                dt_=datetime.strptime(sd,fmt)
                self.start_dt.setDateTime(dt_)
            except:
                pass
        ed=rd.get("EFFECTIVE_END_DATE","")
        if ed:
            try:
                dt2_=datetime.strptime(ed,fmt)
                self.end_dt.setDateTime(dt2_)
            except:
                pass

        cdcv=rd.get("CDC_TYPE","NONE").upper()
        c_ix=self.cdc_combo.findText(cdcv)
        if c_ix>=0:
            self.cdc_combo.setCurrentIndex(c_ix)

        self.sql_edit.setPlainText(rd.get("RULE_SQL",""))
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.user_group=="Admin" and "IS_GLOBAL" in rd:
            if rd["IS_GLOBAL"]==1 and self.global_cb:
                self.global_cb.setChecked(True)
        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_cb.setChecked(True)

        scp=rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp=self.scope_combo.findText(scp)
        if i_scp>=0:
            self.scope_combo.setCurrentIndex(i_scp)

    def on_save(self):
        nm=self.name_edit.text().strip()
        sql_=self.sql_edit.toPlainText().strip()
        if not nm:
            QMessageBox.warning(self,"Error","Rule name is required.")
            return
        if not sql_:
            QMessageBox.warning(self,"Error","SQL cannot be empty.")
            return

        group_id=self.group_combo.currentData()
        parent_id=self.parent_rule_combo.currentData()
        rt_id=self.rule_type_combo.currentData()
        cdcval=self.cdc_combo.currentText().upper()

        st=self.status_combo.currentText()
        start_dt_str=self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_dt_str=self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")

        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()

        isg=0
        if self.user_group=="Admin" and self.global_cb:
            if self.global_cb.isChecked():
                isg=1
        isc=1 if self.critical_cb.isChecked() else 0
        scp_=self.scope_combo.currentText().upper()

        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?",(group_id,))
        rowg=c.fetchone()
        if rowg:
            gname=rowg[0]
        else:
            gname="BG1"

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id if parent_id else None,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": start_dt_str,
            "EFFECTIVE_END_DATE": end_dt_str,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdcval,
            "OWNER_GROUP": gname
        }

        # references advanced CRUD from Part 2
        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            confirm=QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Success",f"Rule '{nm}' updated. Re-approval started.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id=add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Success",f"Rule '{nm}' created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))

# END PART 7 of 8
"""
BRM TOOL - PART 8 of 8
Global/Critical Admin Tab, Main BRMTool window, main() entry point.
Depends on prior Parts 1-7.
"""

import sys
import json
import math
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTabWidget, QLineEdit, QMessageBox, QComboBox, QDialog
)
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QColor

###############################################################################
# GLOBAL/CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    If user_group=="Admin", can manage is_global, critical_rule, critical_scope,
    plus GCR links (parent->child).
    """
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app=main_app
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return

        filter_h=QHBoxLayout()
        self.show_only_gcr=QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        filter_h.addWidget(self.show_only_gcr)
        filter_h.addWidget(ref_btn)
        filter_h.addStretch()
        layout.addLayout(filter_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Rule Name","Owner Group","IS_GLOBAL",
            "CRITICAL_RULE","CRITICAL_SCOPE","STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        gcs_h=QHBoxLayout()
        self.global_cb=QCheckBox("Set Global?")
        gcs_h.addWidget(self.global_cb)
        self.critical_cb=QCheckBox("Set Critical?")
        gcs_h.addWidget(self.critical_cb)
        gcs_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        gcs_h.addWidget(self.scope_combo)

        apply_btn=QPushButton("Apply Flags/Scope to Selected")
        apply_btn.clicked.connect(self.apply_gcs_to_selected)
        gcs_h.addWidget(apply_btn)
        gcs_h.addStretch()
        layout.addLayout(gcs_h)

        link_box=QHBoxLayout()
        self.gcr_rule_combo=QComboBox()
        link_box.addWidget(QLabel("Parent GCR Rule:"))
        link_box.addWidget(self.gcr_rule_combo)

        self.child_rule_combo=QComboBox()
        link_box.addWidget(QLabel("Child Rule:"))
        link_box.addWidget(self.child_rule_combo)

        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_box.addWidget(link_btn)

        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_box.addWidget(unlink_btn)

        link_box.addStretch()
        layout.addLayout(link_box)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all_btn=QPushButton("Refresh Everything")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                   CRITICAL_SCOPE, STATUS, UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                   CRITICAL_SCOPE, STATUS, UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.rule_table.setItem(r_i,col_i,QTableWidgetItem(str(val)))
        self.rule_table.resizeColumnsToContents()

    def populate_gcr_rule_combo(self):
        self.gcr_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for (rid,rname) in rows:
            disp=f"ID:{rid} - {rname}"
            self.gcr_rule_combo.addItem(disp, rid)

    def populate_child_rule_combo(self):
        self.child_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rname) in rows:
            disp=f"ID:{rid} - {rname}"
            self.child_rule_combo.addItem(disp, rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))
        self.link_view.resizeColumnsToContents()

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i in idxs:
            row=i.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def apply_gcs_to_selected(self):
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No Selection","Select rule(s) first.")
            return
        is_global=1 if self.global_cb.isChecked() else 0
        is_crit=1 if self.critical_cb.isChecked() else 0
        scope_val=self.scope_combo.currentText().upper()

        confirm=QMessageBox.question(
            self,"Confirm",
            f"Set IS_GLOBAL={is_global}, CRITICAL_RULE={is_crit}, SCOPE={scope_val} for {len(rids)} rule(s)?"
        )
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        for rid in rids:
            c.execute("""
            UPDATE BRM_RULES
            SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
            WHERE RULE_ID=?
            """,(is_global, is_crit, scope_val, rid))
        self.connection.commit()

        QMessageBox.information(self,"Done",f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No Parent GCR","Select a parent GCR rule.")
            return
        cid=self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self,"No Child","Select a child rule.")
            return

        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID)
        VALUES(?,?)
        """,(pid, cid))
        add_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"parent":pid,"child":cid})
        self.connection.commit()

        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_rule_combo.currentData()
        cid=self.child_rule_combo.currentData()
        if not pid or not cid:
            return

        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("""
        DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
        WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
        """,(pid, cid))
        add_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",{"parent":pid,"child":cid},None)
        self.connection.commit()

        QMessageBox.information(self,"Unlinked",f"Child {cid} from {pid}")
        self.load_link_view()

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    """
    Main BRM Tool Window with:
     - Business Rules tab
     - Approvals tab
     - GCR Admin tab (if Admin)
     - Hierarchy tab
     - Lineage tab
     - Custom Groups
     - Scheduling
     - Control Tables
     - Metrics
     - Alerts & Dashboards
     - Group Mgmt (if Admin)
     - User Mgmt (if Admin)
    Tools menu => Audit logs, search, version history
    Timers => approvals refresh, schedule checks
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool - Final (Part 8)")
        self.resize(1300,850)
        self.connection=None
        self.user_id=None
        self.user_group=None

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        syncAct=QtWidgets.QAction("Sync Metadata", self)
        syncAct.triggered.connect(self.sync_metadata_real)
        fileMenu.addAction(syncAct)

        metricsAct=QtWidgets.QAction("View Metrics Dashboard", self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        schedAct=QtWidgets.QAction("New Schedule (Dialog)", self)
        schedAct.triggered.connect(self.launch_enh_sched)
        fileMenu.addAction(schedAct)

        chainAct=QtWidgets.QAction("Simulate Rule Chain", self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        grpAct=QtWidgets.QAction("Simulate Custom Group", self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        helpMenu=menubar.addMenu("Help")
        usageAct=QtWidgets.QAction("Show Tips", self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        cw=QWidget()
        layout=QVBoxLayout(cw)

        # if admin => user can impersonate
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # 1) Business rules tab
        brw=QWidget()
        br_lay=QVBoxLayout(brw)

        cr_h=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        cr_h.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        cr_h.addWidget(upd_btn)

        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.on_deactivate_rule)
        cr_h.addWidget(deact_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.on_delete_rule)
        cr_h.addWidget(del_btn)

        etl_btn=QPushButton("Run ETL (BFS)")
        etl_btn.clicked.connect(self.run_etl_bfs)
        cr_h.addWidget(etl_btn)

        sim_btn=QPushButton("Simulate Rule")
        sim_btn.clicked.connect(self.simulate_single_rule)
        cr_h.addWidget(sim_btn)

        cr_h.addStretch()
        br_lay.addLayout(cr_h)

        self.brm_dashboard=RuleDashboard(self.connection, self.user_id, self.user_group)
        br_lay.addWidget(self.brm_dashboard)
        brw.setLayout(br_lay)
        self.tabs.addTab(brw, "Business Rules")

        # 2) Approvals
        self.approv_tab=MultiStepApprovalTab(self.connection, "", "", self)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # 3) GCR Admin
        self.gcr_tab=GlobalCriticalAdminTab(self, self.connection, "", self)
        self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # 4) Hierarchy
        self.hierarchy=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy,"Hierarchy")

        # 5) Lineage
        lin_w=QWidget()
        lin_l=QVBoxLayout(lin_w)
        lb=QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lin_l.addWidget(lb)

        self.lineage_tab=EnhancedLineageGraphWidget(self.connection)
        lin_l.addWidget(self.lineage_tab)

        line_h=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table..")
        sbtn=QPushButton("Search")
        sbtn.clicked.connect(lambda: self.lineage_tab.populate_graph())
        # or a skeleton to highlight
        line_h.addWidget(self.lineage_search)
        line_h.addWidget(sbtn)
        rb=QPushButton("Reset View")
        rb.clicked.connect(self.lineage_tab.resetView)
        line_h.addWidget(rb)
        refb=QPushButton("Refresh Graph")
        refb.clicked.connect(self.lineage_tab.populate_graph)
        line_h.addWidget(refb)
        line_h.addStretch()
        lin_l.addLayout(line_h)
        lin_w.setLayout(lin_l)
        self.tabs.addTab(lin_w,"Lineage")

        # 6) Custom Groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection, 0, "")
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # 7) Scheduling
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # 8) Control Tables
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # 9) Metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # 10) Alerts
        self.alert_tab=AlertsAndDashboardsTab(self.connection, 0, "", self)
        self.tabs.addTab(self.alert_tab,"Alerts & Dashboards")

        # 11) Group Mgmt
        self.grp_mgmt=GroupManagementTab(self.connection,0,"")
        self.tabs.addTab(self.grp_mgmt,"Group Management")

        # 12) User Mgmt
        self.user_mgmt=UserManagementTab(self.connection)
        self.tabs.addTab(self.user_mgmt,"User Management")

        # Tools menu
        toolsMenu=self.menuBar().addMenu("Tools")
        alAct=QtWidgets.QAction("View Audit Logs", self)
        alAct.triggered.connect(self.launch_audit_log)
        toolsMenu.addAction(alAct)

        srAct=QtWidgets.QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_search)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (Enter Rule ID)", self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # timers
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

    def sync_metadata_real(self):
        sync_metadata_improved(self.connection)

    def show_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard Popup")
        dlg.resize(800,600)
        dlay=QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection)
        dlay.addWidget(chart)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        dlay.addWidget(cb)
        dlg.exec_()

    def launch_enh_sched(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()

    def launch_chain_sim(self):
        dlg=ChainSimulationDialog(self.connection,self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=GroupSimulationDialog(self.connection,self)
        dlg.exec_()

    def show_help(self):
        msg="BRM Tool advanced usage. Use tabs to manage rules, approvals, scheduling, etc."
        QMessageBox.information(self,"Help/Tips",msg)

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        QMessageBox.information(self,"Switched",f"Impersonating user {new_uid} => group {new_grp}.")

    def populate_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for (uid,uname,ugrp) in rows:
            disp=f"{uname} ({ugrp})"
            self.switch_combo.addItem(disp, (uid,ugrp))

    def on_add_rule(self):
        dlg=RuleEditorDialog(self.connection, self.user_group, None, self)
        if dlg.exec_()==QDialog.Accepted:
            QMessageBox.information(self,"Success","New rule added.")
            self.brm_dashboard.load_rules()

    def on_update_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No rule with ID={rid}")
            return
        colnames=[desc[0] for desc in c.description]
        rule_data=dict(zip(colnames,row))

        dlg=RuleEditorDialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_()==QDialog.Accepted:
            QMessageBox.information(self,"Updated",f"Rule {rid} updated.")
            self.brm_dashboard.load_rules()

    def on_deactivate_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivation done. success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def on_delete_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return

        success=0
        fails=[]
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deletion done. success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_etl_bfs(self):
        executed,skipped=execute_rules_in_order(self.connection)
        msg=f"Run ETL BFS => executed={executed}, skipped={list(skipped)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def simulate_single_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","No rule for that ID.")
            return
        sql_=row[0]
        dlg=SingleRuleSimulationDialog(self.connection, rid, sql_, self)
        dlg.exec_()

    def launch_audit_log(self):
        dlg=AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search(self):
        dlg=SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection, rid, self)
        dlg.exec_()

    def check_due_schedules(self):
        """
        Periodically checks if any scheduled rule is due => attempt to run its SQL.
        """
        c=self.connection.cursor()
        now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
        """,(now,))
        due=c.fetchall()
        for item in due:
            sch_id=item[0]
            rid=item[1]

            c2=self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                row=c2.fetchone()
                if row:
                    try:
                        c2.execute(row[0])
                    except Exception as ex:
                        logger.error(f"Scheduled rule {rid} => FAIL: {ex}")
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                        self.connection.commit()
                        continue
                c2.execute("COMMIT")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
            except Exception as ex:
                logger.error(f"Scheduled exec error: {ex}")
            self.connection.commit()

        self.sch_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# MAIN ENTRY POINT
###############################################################################
def main():
    from PyQt5.QtWidgets import QApplication
    app = QApplication(sys.argv)

    # 1) Database connection
    dbdlg=DatabaseConnectionDialog()
    if dbdlg.exec_()==QDialog.Accepted:
        connection=dbdlg.get_connection()
        if not connection:
            sys.exit(1)
    else:
        sys.exit(0)

    # 2) Login
    logdlg=LoginDialog(connection)
    if logdlg.exec_()!=QDialog.Accepted:
        sys.exit(0)
    user_id=logdlg.user_id
    user_group=logdlg.user_group

    # 3) Launch main window
    window=BRMTool()
    window.connection=connection
    window.user_id=user_id
    window.user_group=user_group

    # Replace references in sub tabs
    window.approv_tab.connection=connection
    window.approv_tab.logged_in_username=window.logged_in_username if hasattr(window,"logged_in_username") else user_id
    window.approv_tab.user_group=user_group
    window.approv_tab.load_approvals()

    window.gcr_tab.connection=connection
    window.gcr_tab.user_group=user_group
    window.gcr_tab.refresh_all()

    window.brm_dashboard.connection=connection
    window.brm_dashboard.user_id=user_id
    window.brm_dashboard.user_group=user_group
    window.brm_dashboard.load_rules()

    window.custom_tab.connection=connection
    window.custom_tab.user_id=user_id
    window.custom_tab.user_group=user_group
    window.custom_tab.refresh_all()

    window.sch_tab.connection=connection
    window.sch_tab.load_schedules()

    window.ctrl_tab.connection=connection

    window.metrics_tab.connection=connection
    window.metrics_tab.load_metrics()

    window.alert_tab.connection=connection
    window.alert_tab.user_id=user_id
    window.alert_tab.user_group=user_group
    window.alert_tab.check_alerts()

    window.grp_mgmt.connection=connection
    window.grp_mgmt.user_id=user_id
    window.grp_mgmt.user_group=user_group
    window.grp_mgmt.load_data()

    window.user_mgmt.connection=connection
    window.user_mgmt.load_users()

    # fetch username from DB
    c=connection.cursor()
    c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(user_id,))
    row=c.fetchone()
    if row:
        window.logged_in_username=row[0]

    window.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()

# END PART 8 of 8