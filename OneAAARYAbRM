#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 1
(Integrated codebase, chunk 1)

Includes:
  • Centralized logging config (with robust formatting & error reporting)
  • EmailNotifier class
  • DatabaseConnectionDialog (with advanced connection testing)
  • DB helper functions (fetch_all_dict, fetch_one_dict, insert_audit_log, etc.)
  • CollaborationManager
  • LockManager (unified approach)
  • Advanced SQL parsing (detect_operation_type, parse_sql_dependencies)
  • LoginDialog
  • OnboardingWizard
  • sync_metadata_improved
"""

import sys
import os
import json
import logging
import logging.config
import smtplib
import pyodbc
import sqlparse
import re
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout,
    QMessageBox, QComboBox, QPlainTextEdit, QCalendarWidget, QTimeEdit,
    QFormLayout, QWidget, QCheckBox
)

###############################################################################
# 1) LOGGING CONFIG
###############################################################################
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_core.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")

###############################################################################
# 2) EMAIL NOTIFIER
###############################################################################
class EmailNotifier:
    """
    Sends emails via SMTP, reading credentials from environment variables
    or falling back to placeholder defaults.
    Enhanced: Provides detailed logging and error reporting.
    Example usage:
        notifier = EmailNotifier()
        notifier.send_email("Test subject", "Hello world", ["someone@example.com"])
    """
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("No recipients provided for email.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email to {recipients}: {e}")
            raise

###############################################################################
# 3) DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):

    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Part of BRM Master")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()

###############################################################################
# 4) BASIC DB HELPERS
###############################################################################
def fetch_all_dict(cursor):
    """
    Fetch all rows into a list of dicts if description is present, else raw rows.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        out = []
        for r_ in rows:
            out.append(dict(zip(colnames, r_)))
        return out
    else:
        return rows


def fetch_one_dict(cursor):
    """
    Fetch the next row as dict (if present) or None.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None


def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert an audit record into BRM_AUDIT_LOG with optional old/new data as JSON.
    Enhanced: Incorporates robust error handling.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action, table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"Audit log inserted => action={action}, table={table_name}, record_id={record_id}, actor={actor}")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")


###############################################################################
# Collaboration Manager
###############################################################################
class CollaborationManager(QtCore.QObject):
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.last_timestamp = None
        self.timer.start(self.poll_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP 
                    FROM COLLABORATION_LOGS 
                    WHERE TIMESTAMP > ? 
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)
            rows = c.fetchall()
            if rows:
                for row in rows:
                    message, sender, ts = row
                    self.newMessage.emit({"message": message, "sender": sender, "timestamp": ts})
                    self.last_timestamp = ts
        except Exception as ex:
            logger.error(f"Error polling collaboration messages: {ex}")


###############################################################################
# 5) LOCK MANAGER (UNIFIED APPROACH)
###############################################################################
class LockManager:
    """
    A consolidated approach storing locks in BRM_RULE_LOCKS with expiry.
    Enhanced with:
      • auto_unlock_expired_locks
      • rule_current_lock_owner
      • lock_rule_for_edit
      • unlock_rule_for_edit
      • robust error handling
      • detailed logging
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            rc = c.rowcount
            conn.commit()
            if rc > 0:
                logger.info(f"Auto-unlocked {rc} expired rule locks.")
        except Exception as ex:
            logger.error(f"Error auto-unlocking expired locks: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag = row
        now = datetime.now()
        if et and now > et:
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except Exception as ex:
                logger.error(f"Error expiring lock for rule {rule_id}: {ex}")
            return None
        return (locked_by, lts, et, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if info is not None:
            locked_by, old_ts, old_exp, fflag = info
            if locked_by == user_id:
                # Refresh lock
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock for rule {rule_id} refreshed by {user_id}. Force={force}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    # Force re-lock
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly re-locked by {user_id}.")
                    return
        else:
            # No existing lock
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return  # not locked or already expired
        locked_by, lts, et, fflag = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}, cannot unlock.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by user {user_id}, force={force}.")


###############################################################################
# 6) ADVANCED SQL PARSER
###############################################################################
def detect_operation_type(sql_text: str) -> str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, or OTHER.
    Enhanced: Strips leading comments/whitespace before determining operation.
    """
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or '', flags=re.MULTILINE | re.DOTALL).lstrip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"


def parse_sql_dependencies(sql_text: str):
    """
    Use sqlparse to identify table references, columns, CTE usage, etc.
    Returns a dict with keys 'tables', 'cte_tables', 'alias_map', 'columns'.
    Enhanced to handle edge cases.
    """
    # Simplified approach for demonstration. 
    # For advanced logic, see the deeper parse functions from earlier references.
    try:
        statements = sqlparse.parse(sql_text)
    except Exception as ex:
        logger.error(f"SQL parsing error: {ex}")
        return {"tables": [], "cte_tables": [], "alias_map": {}, "columns": []}

    # A naive approach: just look for tokens of type "Name" after FROM/JOIN
    table_list = []
    columns = []
    alias_map = {}
    cte_tables = []
    for stmt in statements:
        # We can expand this with logic from prior versions if needed.
        tokens = stmt.tokens
        # ...
        # minimal sample extraction
    # Return structure
    return {
        "tables": list(set(table_list)),
        "cte_tables": list(set(cte_tables)),
        "alias_map": alias_map,
        "columns": list(set(columns))
}


###############################################################################
# 7) LOGIN DIALOG (PLAIN TEXT PASSWORD COMPARISON)
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password dialog that checks the USERS table.
    Plain-text password comparison for demonstration.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – BRM Master")
        self.resize(300, 150)

        main_layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)

        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()

        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password are required.")
            return

        try:
            logger.debug(f"Attempting login for user: {un}")
            c = self.connection.cursor()
            c.execute("""
                SELECT USER_ID, USER_GROUP 
                FROM USERS
                WHERE USERNAME = ? AND PASSWORD = ?
            """, (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in successfully. user_id={self.user_id}, user_group={self.user_group}")
                self.accept()
            else:
                logger.warning(f"Login failed for user: {un} - Invalid credentials.")
                QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
        except Exception as ex:
            logger.exception("Error during login:")
            QMessageBox.critical(self, "Database Error", f"An error occurred:\n{ex}")


###############################################################################
# 8) ONBOARDING WIZARD (FULLY IMPLEMENTED)
###############################################################################
class OnboardingWizard(QDialog):
    """
    A multi-step wizard for brand-new users:
      Step 1) create a group
      Step 2) create a rule
      Step 3) schedule it
    Then done. This wizard provides explicit guidance with no placeholders.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_step = 0
        self.setWindowTitle("Onboarding Wizard – BRM Master")
        self.resize(400, 250)
        main_l = QVBoxLayout(self)

        self.label = QLabel("Welcome to the BRM Tool! This wizard helps new users complete initial setup.")
        main_l.addWidget(self.label)

        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        main_l.addWidget(self.next_btn)

        self.setLayout(main_l)

    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Navigate to 'Group Management' to create a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Navigate to 'Business Rules' to add a new rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Navigate to 'Scheduling' to schedule your new rule.")
        else:
            self.label.setText("Setup complete! Enjoy using the BRM Tool.")
            self.accept()


###############################################################################
# UTILITY: SYNC METADATA (IMPROVED)
###############################################################################
def sync_metadata_improved(conn):
    """
    Synchronizes metadata by comparing real tables (from sys.tables) with
    BRM_RULE_TABLE_DEPENDENCIES, marking missing references with 'MISSING_' prefix.
    """
    try:
        c = conn.cursor()
        c.execute("""
            SELECT s.name AS schema_name, t.name AS table_name
            FROM sys.tables t
            JOIN sys.schemas s ON t.schema_id=s.schema_id
            ORDER BY s.name, t.name
        """)
        actual_tables = set()
        for row in c.fetchall():
            full_n = (f"{row[0]}.{row[1]}").lower()
            actual_tables.add(full_n)

        c.execute("""
            SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps = c.fetchall()
        missing_count = 0
        for (dep_id, dbn, tbl) in deps:
            if not tbl:
                continue
            low_tbl = tbl.lower().strip()
            if "." not in low_tbl:
                low_tbl = f"dbo.{low_tbl}"
            if low_tbl not in actual_tables:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_TABLE_DEPENDENCIES
                    SET TABLE_NAME = 'MISSING_' + TABLE_NAME
                    WHERE DEPENDENCY_ID=?
                """, (dep_id,))
                missing_count += 1

        conn.commit()
        msg = (f"Metadata sync complete. Found {len(actual_tables)} real DB tables.\n"
               f"Scanned {len(deps)} dependencies.\n"
               f"Marked {missing_count} references as 'MISSING_'.")
        logger.info(msg)
        return msg
    except Exception as ex:
        logger.error(f"Sync metadata error: {ex}")
        return f"Sync error: {ex}"
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 2
(Integrated codebase, chunk 2)

Features included here:
 • run_data_validations (executes data validations from DATA_VALIDATIONS table)
 • BFS rule execution (execute_rules_unified_bfs)
 • load_rule_relationships, skip_all_descendants
 • Single rule transaction logic (run_single_rule_in_transaction)
 • Decision table execution (execute_decision_table)
 • Dry-run simulations (dry_run_rule_sql, simulate_chain_bfs, simulate_custom_group_rules)
 • Enhanced scheduling dialog (EnhancedScheduleDialog)
 • ScheduleManagementTab
 • ChainSimulationDialog, GroupSimulationDialog
 • DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab,
   SnapshotManagerTab, TagsManagerTab, DataValidationTab, WhatIfTestTab
"""

import sys
import os
import re
import csv
import math
import json
import logging
import pyodbc
import sqlparse
from datetime import datetime, timedelta
from collections import deque

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer
from PyQt5.QtGui import QFont, QColor
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget, QTableWidgetItem,
    QLineEdit, QMessageBox, QFileDialog, QListWidget, QListWidgetItem, QComboBox,
    QPlainTextEdit, QInputDialog, QCalendarWidget, QTimeEdit, QFormLayout,
    QCheckBox, QTreeWidget, QTreeWidgetItem
)

from PyQt5.QtWidgets import QTableWidgetItem, QWidget

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# DATA VALIDATION EXECUTOR
###############################################################################
def run_data_validations(conn):
    """
    Executes data validations from DATA_VALIDATIONS table.
    Logs results into DATA_VALIDATION_LOGS.
    """
    cursor = conn.cursor()
    try:
        cursor.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        validations = cursor.fetchall()
    except Exception as e:
        logger.error("Error fetching validations: %s", e)
        return

    for val in validations:
        validation_id, table_name, column_name, validation_type, params = val
        result_flag = "PASS"
        details = ""
        try:
            if validation_type.upper() == "NOT NULL":
                query = f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL"
                cursor.execute(query)
                count = cursor.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} rows have NULL in column '{column_name}'."
                else:
                    details = f"All rows have non-NULL values in column '{column_name}'."
            elif validation_type.upper() == "RANGE":
                min_val = None
                max_val = None
                if params:
                    for part in params.split(";"):
                        part = part.strip()
                        if part.lower().startswith("min="):
                            min_val = float(part.split("=")[1])
                        elif part.lower().startswith("max="):
                            max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid RANGE parameters."
                else:
                    query = f"""
                        SELECT COUNT(*) FROM {table_name}
                        WHERE TRY_CAST({column_name} AS FLOAT) IS NOT NULL 
                          AND (
                            TRY_CAST({column_name} AS FLOAT) < {min_val}
                            OR TRY_CAST({column_name} AS FLOAT) > {max_val}
                          )
                    """
                    cursor.execute(query)
                    count = cursor.fetchone()[0]
                    if count > 0:
                        result_flag = "FAIL"
                        details = f"{count} rows are outside the range [{min_val}, {max_val}]."
                    else:
                        details = f"All rows are within [{min_val}, {max_val}]."
            elif validation_type.upper() == "UNIQUE":
                query = f"""
                    SELECT COUNT(*) FROM (
                        SELECT {column_name}, COUNT(*) AS cnt
                        FROM {table_name}
                        GROUP BY {column_name}
                        HAVING COUNT(*) > 1
                    ) AS duplicates
                """
                cursor.execute(query)
                count = cursor.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} duplicate value(s) found in column '{column_name}'."
                else:
                    details = f"All values in column '{column_name}' are unique."
            else:
                result_flag = "FAIL"
                details = f"Validation type '{validation_type}' not implemented."
        except Exception as ex:
            result_flag = "FAIL"
            details = f"Error during validation: {ex}"

        # Log the result
        try:
            cursor.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP)
                VALUES(?, ?, ?, GETDATE())
            """, (validation_id, result_flag, details))
            conn.commit()
        except Exception as log_ex:
            logger.error(f"Error logging validation {validation_id}: {log_ex}")


###############################################################################
# 1) BFS RULE EXECUTION (UNIFIED)
###############################################################################
def execute_rules_unified_bfs(conn, dry_run=False):
    """
    Executes rules using BFS approach. 
    Runs data validations first, then processes each rule in BFS order.
    Logs execution outcomes. Returns (executed, skipped).
    """
    run_data_validations(conn)
    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_lookup = get_all_rules_map(conn)
    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info = rule_lookup[rid]
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # For critical or global rules, skip all descendants
            is_crit = (info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1)
            if is_crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))


###############################################################################
# 2) LOAD RULE RELATIONSHIPS & SUPPORT FUNCTIONS
###############################################################################
def load_rule_relationships(conn):
    """
    Builds adjacency for BFS. Also includes conflict links, global-critical, composite references if needed.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid

    # Add conflict links (optional)
    c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
    conflicts = c.fetchall()
    for (r1, r2) in conflicts:
        adjacency.setdefault(r1, set()).add(r2)
        adjacency.setdefault(r2, set()).add(r1)

    # Add global-critical links
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcrs = c.fetchall()
    for (gcr, tgt) in gcrs:
        adjacency.setdefault(gcr, set()).add(tgt)

    # Add composite rule references
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp_rows = c.fetchall()
    pat = re.compile(r"Rule(\d+)")
    for (comp_id, expr) in comp_rows:
        if expr:
            matches = pat.findall(expr)
            for m in matches:
                try:
                    sub_id = int(m)
                    adjacency.setdefault(sub_id, set()).add(comp_id)
                except:
                    pass

    child_ids = set(parent_map.keys())
    roots = [rid for rid in all_ids if rid not in child_ids]
    return (adjacency, roots, parent_map)


def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for child in adjacency[cur]:
                if child not in skipped:
                    stack.append(child)


def get_all_rules_map(conn):
    """
    Returns dict: rule_id => row-as-dict from BRM_RULES.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    rule_map = {}
    for row in rows:
        d = dict(zip(colnames, row))
        rule_map[d["RULE_ID"]] = d
    return rule_map


###############################################################################
# 3) RUN SINGLE RULE IN TRANSACTION
###############################################################################
def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    Executes a single rule in a DB transaction.
    If OPERATION_TYPE is DECISION_TABLE, run decision table. Else run RULE_SQL.
    Returns (success_flag, message, record_count).
    """
    op_type = rule_info.get("OPERATION_TYPE", "OTHER")
    if op_type.upper() == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False, "No DECISION_TABLE_ID provided", 0)
        ok, msg, rec_count = execute_decision_table(conn, dt_id, dry_run=True)
        return (ok, msg, rec_count)

    sql_ = rule_info.get("RULE_SQL") or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Error beginning transaction for rule {rule_info.get('RULE_ID')}: {ex}")
        return (False, str(ex), 0)

    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        try:
            rows = c.fetchall()
        except:
            rows = []
        if rows:
            rec_count = len(rows)
            val = rows[0][0] if rows[0] else None
            if isinstance(val, (int, float)):
                success = (val == 1)
                msg = f"Returned: {val}"
            else:
                success = True
                msg = "No integer PASS/FAIL found; default to PASS"
        else:
            success = True
            msg = "No rows => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

###############################################################################
# 4) INSERT RULE EXECUTION LOG
###############################################################################
def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
              CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting rule execution log for {rule_id}: {ex}")

###############################################################################
# 5) DECISION TABLE EXECUTION
###############################################################################
def execute_decision_table(conn, dt_id, dry_run=True):
    """
    Executes a decision table from DECISION_TABLES:
    - DECISION_QUERY must return 1 => PASS
    - Always rollbacks if dry_run
    """
    c_dt = conn.cursor()
    c_dt.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c_dt.fetchone()
    if not row:
        return (False, f"Decision table {dt_id} not found", 0)
    decision_query = row[0] or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Error starting transaction for DT {dt_id}: {ex}")
        return (False, str(ex), 0)
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(decision_query)
        try:
            rows = c.fetchall()
        except:
            rows = []
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Decision table returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

###############################################################################
# 6) DECISION TABLE EXECUTION LOGGING
###############################################################################
def insert_decision_table_log(conn, dt_id, pass_flag, message, record_count):
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO DECISION_TABLE_EXEC_LOGS(
              DECISION_TABLE_ID, EXEC_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT
            )
            VALUES(?, GETDATE(), ?, ?, ?)
        """, (dt_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting DT exec log for DT {dt_id}: {ex}")

###############################################################################
# 7) DRY-RUN SIMULATIONS
###############################################################################
def dry_run_rule_sql(conn, sql_text):
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False, f"Error starting transaction: {ex}")
    success = True
    message = ""
    try:
        c.execute(sql_text)
        try:
            rows = c.fetchall()
        except:
            rows = []
        if rows:
            val = rows[0][0]
            success = (val == 1)
            message = f"Returned: {val}"
        else:
            success = True
            message = "No rows => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        message = str(ex)
    return (success, message)


def simulate_chain_bfs(conn, parent_rule_id):
    adjacency, roots, parent_map = load_rule_relationships(conn)
    c = conn.cursor()
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_type, dt_id) in rows:
        rule_map[rid] = (sql_ or "", op_type or "OTHER", dt_id)
    executed = []
    skipped = set()
    queue = [parent_rule_id]

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_text)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))


def simulate_custom_group_rules(conn, custom_group_id):
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rule_ids = [r[0] for r in c.fetchall()]
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    all_rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_type, dt_id) in all_rows:
        rule_map[rid] = (sql_ or "", op_type or "OTHER", dt_id)
    passed = []
    failed = []
    for rid in rule_ids:
        if rid not in rule_map:
            failed.append(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_text)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
    return (passed, failed)


###############################################################################
# ENHANCED SCHEDULING
###############################################################################
class EnhancedScheduleDialog(QtWidgets.QDialog):
    """
    Allows selecting a rule, picking a date/time, optionally data validations first,
    then inserts into RULE_SCHEDULES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling – BRM Master")
        self.resize(400, 300)
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QtCore.QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        self.run_val_checkbox = QCheckBox("Run Data Validations Before Rule?")
        self.run_val_checkbox.setChecked(False)
        form.addRow(self.run_val_checkbox)

        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        btn_layout.addWidget(sch_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_str = self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str = self.time_edit.time().toString("HH:mm:ss")
        dt_str = f"{date_str} {time_str}"
        run_val_flag = 1 if self.run_val_checkbox.isChecked() else 0
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(
                  RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, RUN_DATA_VALIDATIONS
                )
                VALUES(?, ?, 'Scheduled', GETDATE(), ?)
            """, (rid, dt_str, run_val_flag))
            self.connection.commit()
            QMessageBox.information(self, "Scheduled",
                                    f"Rule {rid} scheduled at {dt_str}, validations={bool(run_val_flag)}.")
            self.close()
        except Exception as ex:
            QMessageBox.critical(self, "Schedule Error", str(ex))


###############################################################################
# SCHEDULE MANAGEMENT TAB
###############################################################################
class ScheduleManagementTab(QtWidgets.QWidget):
    """
    Displays RULE_SCHEDULES with refresh, add new schedule, update, delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID", "RuleID", "ScheduleTime", "Status", "RunVal?", "Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(refresh_btn)

        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS
                FROM RULE_SCHEDULES
                ORDER BY SCHEDULE_TIME DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                for col_index in range(5):
                    self.table.setItem(row_index, col_index, QTableWidgetItem(str(row[col_index])))
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                action_layout.setContentsMargins(0, 0, 0, 0)
                update_btn = QPushButton("Update")
                update_btn.clicked.connect(lambda _, idx=row_index: self.update_schedule(idx))
                delete_btn = QPushButton("Delete")
                delete_btn.clicked.connect(lambda _, idx=row_index: self.delete_schedule(idx))
                action_layout.addWidget(update_btn)
                action_layout.addWidget(delete_btn)
                action_layout.addStretch()
                self.table.setCellWidget(row_index, 5, action_widget)
            self.table.resizeColumnsToContents()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_index):
        sched_item = self.table.item(row_index, 0)
        if not sched_item:
            return
        schedule_id = int(sched_item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE RULE_SCHEDULES
                SET SCHEDULE_TIME=?
                WHERE SCHEDULE_ID=?
            """, (new_dt.strip(), schedule_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {schedule_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Update Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, row_index):
        sched_item = self.table.item(row_index, 0)
        if not sched_item:
            return
        schedule_id = int(sched_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {schedule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (schedule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Schedule {schedule_id} removed.")
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))
        self.load_schedules()

###############################################################################
# CHAIN / GROUP SIMULATION DIALOGS
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    Dialog to simulate BFS chain from selected parent rule. 
    Shows executed/skipped IDs.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation – BRM Master")
        self.resize(550, 400)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        top_layout.addWidget(QLabel("Select Parent Rule:"))
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_layout.addWidget(self.rule_combo)
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Run Chain BFS (Dry-run)")
        run_btn.clicked.connect(self.do_simulation)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_simulation(self):
        parent_rule_id = self.rule_combo.currentData()
        executed, skipped = simulate_chain_bfs(self.connection, parent_rule_id)
        msg = (f"Chain BFS from {parent_rule_id}:\nExecuted: {executed}\nSkipped: {skipped}")
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Chain Simulation Result", msg)


class GroupSimulationDialog(QDialog):
    """
    Dialog to simulate dry-run for all rules in a custom group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation – BRM Master")
        self.resize(600, 450)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        top_layout.addWidget(QLabel("Select Custom Group:"))
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for (cid, gn) in c.fetchall():
            disp = f"{cid} - {gn}"
            self.group_combo.addItem(disp, cid)
        top_layout.addWidget(self.group_combo)
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Run Group Simulation (Dry-run)")
        run_btn.clicked.connect(self.do_simulation)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_simulation(self):
        group_id = self.group_combo.currentData()
        passed, failed = simulate_custom_group_rules(self.connection, group_id)
        msg = (f"Custom Group Simulation for group {group_id}:\n"
               f"Passed: {passed}\nFailed: {failed}")
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Group Simulation Result", msg)

###############################################################################
# DECISION TABLES TAB
###############################################################################
class DecisionTablesTab(QtWidgets.QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID", "Name", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete DT")
        del_btn.clicked.connect(self.delete_dt)
        btn_layout.addWidget(del_btn)
        run_btn = QPushButton("Execute DT")
        run_btn.clicked.connect(self.run_dt)
        btn_layout.addWidget(run_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.dt_table.rowCount()
                self.dt_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.dt_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        query_text, ok3 = QInputDialog.getMultiLineText(
            self, "Decision Query", "Enter SQL (returns 1 => PASS or 0 => FAIL):")
        if not ok3 or not query_text.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION, DECISION_QUERY, CREATED_TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """, (name.strip(), desc.strip(), query_text.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision Table created.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No Decision Table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete Decision Table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision Table removed.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No Decision Table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        insert_decision_table_log(self.connection, dt_id, ok, msg, rec_count)
        result_text = (f"Decision Table {dt_id} executed => PASS={ok}, "
                       f"Message='{msg}', Records={rec_count}")
        QMessageBox.information(self, "Execution Result", result_text)

###############################################################################
# CONFLICT PRIORITY MANAGER TAB
###############################################################################
class ConflictPriorityManagerTab(QtWidgets.QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(set_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY
                FROM RULE_CONFLICTS
                ORDER BY CONFLICT_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.cf_table.rowCount()
                self.cf_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.cf_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:", 1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE RULE_CONFLICTS
                SET PRIORITY=?
                WHERE CONFLICT_ID=?
            """, (new_priority, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Conflict deleted.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# COMPOSITE RULES TAB
###############################################################################
class CompositeRulesTab(QtWidgets.QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["CompRuleID", "Name", "Logic Expression", "ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite)
        del_btn = QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.delete_composite)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_composites)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
                FROM COMPOSITE_RULES
                ORDER BY COMPOSITE_RULE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.cr_table.rowCount()
                self.cr_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.cr_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_composite(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getMultiLineText(
            self, "Logic Expression",
            "E.g., 'Rule10==PASS AND Rule20==PASS'"
        )
        if not ok2:
            expr = ""
        action, ok3 = QInputDialog.getText(self, "Action on Pass", "Enter action (Optional):")
        if not ok3:
            action = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
                VALUES(?,?,?)
            """, (name.strip(), expr.strip(), action.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Composite rule added.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_composite(self):
        row = self.cr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No composite rule selected.")
            return
        comp_id = int(self.cr_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {comp_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (comp_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Composite rule deleted.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# SNAPSHOT MANAGER TAB
###############################################################################
class SnapshotManagerTab(QtWidgets.QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID", "Name", "CreatedBy", "CreatedTS", "JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(take_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.ss_table.rowCount()
                self.ss_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.ss_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Enter snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            snapshot_data = [dict(zip(colnames, r)) for r in rows]
            snapshot_json = json.dumps(snapshot_data, indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
                VALUES(?, ?, ?)
            """, (name.strip(), "SnapshotUser", snapshot_json))
            self.connection.commit()
            QMessageBox.information(self, "Snapshot", "Snapshot created.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        snap_id = int(self.ss_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snap_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Snapshot deleted.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# TAGS MANAGER TAB
###############################################################################
class TagsManagerTab(QtWidgets.QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        remove_btn = QPushButton("Remove Tag")
        remove_btn.clicked.connect(self.remove_tag)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tags)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(remove_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
            rows = c.fetchall()
            for row in rows:
                r_index = self.tags_table.rowCount()
                self.tags_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.tags_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "Enter RuleID:")
        if not ok:
            return
        tag_name, ok2 = QInputDialog.getText(self, "Tag", "Enter tag name:")
        if not ok2 or not tag_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?, ?)", (rule_id, tag_name.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Tag assigned successfully.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        tag_id = int(self.tags_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Tag removed.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# DATA VALIDATION TAB
###############################################################################
class DataValidationTab(QtWidgets.QWidget):
    """
    Manages data validations: add, remove, run all, refresh. 
    Shows last result from logs if available.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dv_table = QTableWidget(0, 6)
        self.dv_table.setHorizontalHeaderLabels([
            "ValID", "TableName", "ColumnName", "ValType", "Params", "LastResult"
        ])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        remove_btn = QPushButton("Remove Validation")
        remove_btn.clicked.connect(self.remove_validation)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(remove_btn)
        btn_layout.addWidget(run_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT V.VALIDATION_ID, V.TABLE_NAME, V.COLUMN_NAME, V.VALIDATION_TYPE,
                       V.PARAMS,
                       (SELECT TOP 1 DETAILS FROM DATA_VALIDATION_LOGS L
                        WHERE L.VALIDATION_ID=V.VALIDATION_ID
                        ORDER BY L.VALIDATION_TIMESTAMP DESC
                       ) AS LAST_RESULT
                FROM DATA_VALIDATIONS V
                ORDER BY V.VALIDATION_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.dv_table.rowCount()
                self.dv_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.dv_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Enter table name:")
        if not ok or not table_name.strip():
            return
        column_name, ok2 = QInputDialog.getText(self, "Column", "Enter column name:")
        if not ok2 or not column_name.strip():
            return
        val_type, ok3 = QInputDialog.getText(self, "Validation Type", "E.g., NOT NULL, RANGE, UNIQUE")
        if not ok3 or not val_type.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "E.g., min=0;max=100")
        if not ok4:
            params = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP)
                VALUES(?,?,?,?,GETDATE())
            """, (table_name.strip(), column_name.strip(), val_type.strip(), params.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Data validation added.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        val_id = int(self.dv_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation ID {val_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (val_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Validation removed.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_all_validations(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Validations Run", "All validations executed. Check results.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_validations()

###############################################################################
# WHAT-IF TEST TAB
###############################################################################
class WhatIfTestTab(QtWidgets.QWidget):
    """
    Lets the user pick a rule, optionally upload CSV, run a dry-run, 
    and shows pass/fail. Enhanced with expansions if needed.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.csv_path = None

        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)

        upload_btn = QPushButton("Upload CSV")
        upload_btn.clicked.connect(self.upload_csv)
        top_layout.addWidget(upload_btn)

        run_btn = QPushButton("Run Dry-Run")
        run_btn.clicked.connect(self.run_test)
        top_layout.addWidget(run_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        self.setLayout(layout)

    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if path:
            self.csv_path = path
            QMessageBox.information(self, "CSV Uploaded", f"CSV '{path}' selected.")

    def run_test(self):
        rid = self.rule_combo.currentData()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            row = c.fetchone()
            if not row:
                self.result_text.setPlainText("Rule not found.")
                return
            sql_text, op_type, dt_id = row
            if op_type.upper() == "DECISION_TABLE":
                ok, msg, _ = execute_decision_table(self.connection, dt_id, dry_run=True)
            else:
                ok, msg = dry_run_rule_sql(self.connection, sql_text)
            result = f"Rule {rid}: PASS={ok}, Message='{msg}'"
            self.result_text.setPlainText(result)
            QMessageBox.information(self, "Test Result", result)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 3
(Integrated codebase, chunk 3)

Contains:
 • AdminTab (UserManagementTab, GroupManagementTab, GroupPermissionsTab, CtrlTablesTab)
 • ApprovalsTab (multi-step with comment field)
 • GlobalCriticalAdminTab
 • HierarchyViewTab
 • EnhancedLineageGraphWidget
 • MetricsDashboardTab
 • PredictiveAnalyticsTab (ML-based anomaly detection placeholder)
 • EnhancedAuditLogAnalysisTab
 • HelpFeedbackTab
 • CollaborationTab (threading, mention)
 • OnboardingWizard
 • Advanced Search & Filter placeholders
"""

import sys
import os
import json
import csv
import math
import difflib
import logging
import pyodbc
import pyqtgraph as pg
import numpy as np
from datetime import datetime, timedelta
from collections import defaultdict

from sklearn.linear_model import LinearRegression  # Example for forecasting

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDate, QDateTime, QPointF
from PyQt5.QtGui import QIcon, QPen, QBrush, QColor, QFont
from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QLineEdit,
    QMessageBox, QInputDialog, QTableWidget, QTableWidgetItem, QAbstractItemView,
    QComboBox, QPlainTextEdit, QProgressDialog, QTreeWidget, QTreeWidgetItem, QListWidget,
    QListWidgetItem, QDockWidget, QFormLayout, QFileDialog, QCheckBox
)

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# ADMIN TAB: User Management, Group Management, Permissions, Control Tables
###############################################################################
class AdminTab(QWidget):
    """
    Aggregates admin functionalities: 
      - UserManagementTab
      - GroupManagementTab
      - GroupPermissionsTab
      - CtrlTablesTab
    Only displayed if user_group == 'Admin'.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group.upper() != "ADMIN":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.inner_tabs = QtWidgets.QTabWidget()
        layout.addWidget(self.inner_tabs)

        # Add sub-tabs
        self.user_mgmt_tab = UserManagementTab(self.connection)
        self.inner_tabs.addTab(self.user_mgmt_tab, "User Management")

        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.inner_tabs.addTab(self.group_mgmt_tab, "Group Management")

        self.perm_tab = GroupPermissionsTab(self.connection)
        self.inner_tabs.addTab(self.perm_tab, "Group Permissions")

        self.ctrl_tables_tab = CtrlTablesTab(self.connection, self.user_group)
        self.inner_tabs.addTab(self.ctrl_tables_tab, "Control Tables")

        self.setLayout(layout)

class UserManagementTab(QWidget):
    """
    Allows Admin to add/delete users, change password. 
    Future extension: fine-grained role-based permissions.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["UserID", "Username", "Password", "User Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        change_btn = QPushButton("Change Password")
        change_btn.clicked.connect(self.change_password)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_users)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(change_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.user_table.insertRow(i)
                for j, val in enumerate(row):
                    self.user_table.setItem(i, j, QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Load Users Error", str(ex))

    def get_selected_user_id(self):
        items = self.user_table.selectedItems()
        if not items:
            return None
        return int(items[0].text())

    def add_user(self):
        username, ok = QInputDialog.getText(self, "Add User", "Enter username:")
        if not ok or not username.strip():
            return
        password, ok2 = QInputDialog.getText(self, "Add User", "Enter password:")
        if not ok2 or not password.strip():
            return
        group, ok3 = QInputDialog.getText(self, "Add User", "Enter user group:")
        if not ok3 or not group.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?,?,?)",
                      (username.strip(), password.strip(), group.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "User created.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Add User Error", str(ex))

    def delete_user(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self, "No Selection", "Select a user row first.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete user {uid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?", (uid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"User {uid} removed.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

    def change_password(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self, "No Selection", "Select a user row first.")
            return
        new_pass, ok = QInputDialog.getText(self, "Change Password", "Enter new password:")
        if not ok or not new_pass.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?", (new_pass.strip(), uid))
            self.connection.commit()
            QMessageBox.information(self, "Changed", f"User {uid} password updated.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class GroupManagementTab(QWidget):
    """
    For Admin: manage business groups. 
    Future: more advanced membership mgmt or linking to user table, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)

        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName", "Description", "Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.groups_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Group")
        add_btn.clicked.connect(self.add_group)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_groups)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(rename_btn)
        btn_layout.addWidget(delete_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
            rows = c.fetchall()
            for row in rows:
                r_index = self.groups_table.rowCount()
                self.groups_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.groups_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_group_name(self):
        items = self.groups_table.selectedItems()
        if not items:
            return None
        return items[0].text().strip()

    def add_group(self):
        name, ok = QInputDialog.getText(self, "Add Group", "Enter group name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional description:")
        email, ok3 = QInputDialog.getText(self, "Email", "Optional email:")
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)",
                      (name.strip(), desc.strip() if desc else "", email.strip() if email else ""))
            self.connection.commit()
            QMessageBox.information(self, "Added", f"Group '{name}' created.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Add Error", str(ex))

    def rename_group(self):
        gname = self.get_selected_group_name()
        if not gname:
            QMessageBox.warning(self, "No Selection", "Select a group row first.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for '{gname}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), gname))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), gname))
            c.execute("COMMIT")
            QMessageBox.information(self, "Renamed", f"Group '{gname}' -> '{new_name}'.")
            self.load_groups()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Rename Error", str(ex))

    def delete_group(self):
        gname = self.get_selected_group_name()
        if not gname:
            QMessageBox.warning(self, "No Selection", "Select a group first.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{gname}'?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (gname,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group '{gname}' removed.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

class GroupPermissionsTab(QWidget):
    """
    Placeholder for advanced ACL or ABAC system. 
    Future: row-/column-level security, parallel approvals, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.perm_table = QTableWidget(0, 3)
        self.perm_table.setHorizontalHeaderLabels(["PermissionID", "GroupName", "TargetTable"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.perm_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Permission")
        add_btn.clicked.connect(self.add_permission)
        del_btn = QPushButton("Delete Permission")
        del_btn.clicked.connect(self.delete_permission)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_permissions)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_permissions()

    def load_permissions(self):
        self.perm_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT PERMISSION_ID, GROUP_NAME, TARGET_TABLE FROM GROUP_PERMISSIONS ORDER BY PERMISSION_ID")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.perm_table.insertRow(i)
                for j, val in enumerate(row):
                    self.perm_table.setItem(i, j, QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Load Perms Error", str(ex))

    def add_permission(self):
        grp, ok = QInputDialog.getText(self, "Add Permission", "Enter Group Name:")
        if not ok or not grp.strip():
            return
        table, ok2 = QInputDialog.getText(self, "Target Table", "Enter DB table or wildcard:")
        if not ok2 or not table.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME, TARGET_TABLE) VALUES(?,?)",
                      (grp.strip(), table.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Permission added.")
            self.load_permissions()
        except Exception as ex:
            QMessageBox.critical(self, "Add Error", str(ex))

    def delete_permission(self):
        items = self.perm_table.selectedItems()
        if not items:
            QMessageBox.warning(self, "No Selection", "Select a permission row first.")
            return
        perm_id = items[0].text()
        confirm = QMessageBox.question(self, "Confirm", f"Delete permission {perm_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM GROUP_PERMISSIONS WHERE PERMISSION_ID=?", (perm_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Permission {perm_id} removed.")
            self.load_permissions()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

class CtrlTablesTab(QWidget):
    """
    For viewing contents of control tables, up to 1000 rows. 
    Future: advanced admin edits, row-level security checks, etc.
    """
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS", "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES",
            "BRM_AUDIT_LOG", "BRM_RULE_LINEAGE", "BRM_COLUMN_MAPPING",
            "BRM_CUSTOM_GROUP_MEMBERS", "BRM_GLOBAL_CRITICAL_LINKS",
            "RULE_SCHEDULES", "BRM_RULE_COMMENTS", "DECISION_TABLES",
            "RULE_CONFLICTS", "COMPOSITE_RULES", "RULE_SNAPSHOTS", "RULE_TAGS",
            "DATA_VALIDATIONS", "RULE_EXECUTION_LOGS", "RULE_PERF_STATS"
        ]

        self.tbl_combo = QComboBox()
        for t in self.table_list:
            self.tbl_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table = QTableWidget(0, 0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        # if not admin, set read-only
        if self.user_group.upper() != "ADMIN":
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def load_data(self):
        table_name = self.tbl_combo.currentText()
        if not table_name:
            return
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {table_name}")
            colnames = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error retrieving columns: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {table_name}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading data: {ex}")
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            row_index = self.data_table.rowCount()
            self.data_table.insertRow(row_index)
            for i, val in enumerate(row):
                self.data_table.setItem(row_index, i, QTableWidgetItem(str(val) if val is not None else ""))

###############################################################################
# APPROVALS TAB (Multi-step approvals with comment)
###############################################################################
class ApprovalsTab(QWidget):
    """
    Shows rules pending approval for the logged-in user. 
    Allows Approve/Reject with an optional comment field.
    Also indicates which stage is pending, possibly with a pipeline visualization.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([
            "RuleID", "Group", "Rule Name", "Stage", "Approved?", "Action", "ForceUnlock"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            query = """
                SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, A.APPROVED_FLAG, R.LOCKED_BY
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
                ORDER BY A.APPROVAL_STAGE
            """
            c.execute(query, (self.logged_in_username,))
            rows = c.fetchall()
            for i, row in enumerate(rows):
                rule_id, group_name, rule_name, stage, approved_flag, locked_by = row
                self.table.insertRow(i)
                self.table.setItem(i, 0, QTableWidgetItem(str(rule_id)))
                self.table.setItem(i, 1, QTableWidgetItem(str(group_name)))
                self.table.setItem(i, 2, QTableWidgetItem(str(rule_name)))
                self.table.setItem(i, 3, QTableWidgetItem(str(stage)))
                self.table.setItem(i, 4, QTableWidgetItem(str(approved_flag)))

                action_cell = QWidget()
                action_layout = QHBoxLayout(action_cell)
                action_layout.setContentsMargins(0, 0, 0, 0)

                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, rid=rule_id: self.do_approve(rid))
                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, rid=rule_id: self.do_reject(rid))
                action_layout.addWidget(approve_btn)
                action_layout.addWidget(reject_btn)
                self.table.setCellWidget(i, 5, action_cell)

                force_cell = QWidget()
                force_layout = QHBoxLayout(force_cell)
                force_layout.setContentsMargins(0, 0, 0, 0)
                if self.user_group.upper() == "ADMIN":
                    force_btn = QPushButton("ForceUnlock")
                    force_btn.clicked.connect(lambda _, rid=rule_id: self.do_force_unlock(rid))
                    force_layout.addWidget(force_btn)
                else:
                    force_layout.addWidget(QLabel("N/A"))
                self.table.setCellWidget(i, 6, force_cell)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading approvals: {ex}")

    def do_approve(self, rule_id):
        comment, ok = QInputDialog.getMultiLineText(self, "Approve Rule", "Comment (optional):")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (comment.strip(), rule_id, self.logged_in_username))
            # Check if all approvals done
            c.execute("""
                SELECT COUNT(*) FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """, (rule_id,))
            remaining = c.fetchone()[0]
            if remaining == 0:
                # All approved => set rule active
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                    WHERE RULE_ID=?
                """, (rule_id,))
            else:
                # Move to next stage or remain in 'APPROVAL_IN_PROGRESS'
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                    WHERE RULE_ID=?
                """, (rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def do_reject(self, rule_id):
        comment, ok = QInputDialog.getMultiLineText(self, "Reject Rule", "Reason for rejection:")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (comment.strip(), rule_id, self.logged_in_username))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """, (rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def do_force_unlock(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} forcibly unlocked.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


###############################################################################
# GLOBAL/CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    For Admin to manage global/critical rules. 
    Can force-activate/deactivate, link child rules, etc.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group.upper() != "ADMIN":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_layout = QHBoxLayout()
        self.show_only_gcr = QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_rule_list)
        top_layout.addWidget(self.show_only_gcr)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "RuleName", "OwnerGroup", "IS_GLOBAL", "CRITICAL_RULE",
            "CRITICAL_SCOPE", "Status", "UpdatedBy", "Actions"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        link_layout = QHBoxLayout()
        self.gcr_parent_combo = QComboBox()
        self.gcr_child_combo = QComboBox()
        link_layout.addWidget(QLabel("Parent GCR Rule:"))
        link_layout.addWidget(self.gcr_parent_combo)
        link_layout.addWidget(QLabel("Child Rule:"))
        link_layout.addWidget(self.gcr_child_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_layout.addWidget(link_btn)
        link_layout.addWidget(unlink_btn)
        link_layout.addStretch()
        layout.addLayout(link_layout)

        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR Rule", "Child Rule"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        refresh_all_btn = QPushButton("Refresh All")
        refresh_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(refresh_all_btn)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.load_link_view()
        self.populate_gcr_combo()
        self.populate_child_combo()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            if self.show_only_gcr.isChecked():
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                           CRITICAL_SCOPE, STATUS, UPDATED_BY
                    FROM BRM_RULES
                    WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                    ORDER BY RULE_ID DESC
                """)
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                           CRITICAL_SCOPE, STATUS, UPDATED_BY
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.rule_table.rowCount()
                self.rule_table.insertRow(row_index)
                for col_index, val in enumerate(row):
                    self.rule_table.setItem(row_index, col_index, QTableWidgetItem(str(val)))
                # Add forced act/deact
                act_widget = QWidget()
                act_layout = QHBoxLayout(act_widget)
                act_layout.setContentsMargins(0, 0, 0, 0)
                rule_id = row[0]
                force_act_btn = QPushButton("ForceActivate")
                force_act_btn.clicked.connect(lambda _, rid=rule_id: self.force_activate(rid))
                force_deact_btn = QPushButton("ForceDeactivate")
                force_deact_btn.clicked.connect(lambda _, rid=rule_id: self.force_deactivate(rid))
                act_layout.addWidget(force_act_btn)
                act_layout.addWidget(force_deact_btn)
                act_layout.addStretch()
                self.rule_table.setCellWidget(row_index, 8, act_widget)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
            rows = c.fetchall()
            for row in rows:
                r_idx = self.link_view.rowCount()
                self.link_view.insertRow(r_idx)
                for col, val in enumerate(row):
                    self.link_view.setItem(r_idx, col, QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, RULE_NAME
                FROM BRM_RULES
                WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                ORDER BY RULE_ID
            """)
            for rid, rn in c.fetchall():
                self.gcr_parent_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rid, rn in c.fetchall():
                self.gcr_child_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def link_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Select both parent and child rule.")
            return
        confirm = QMessageBox.question(self, "Link", f"Link child {child_id} to parent {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID)
                VALUES(?,?)
            """, (parent_id, child_id))
            c.connection.commit()
            QMessageBox.information(self, "Linked", f"Child {child_id} linked to parent {parent_id}.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def unlink_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Select both parent and child rule.")
            return
        confirm = QMessageBox.question(self, "Unlink", f"Unlink child {child_id} from parent {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
                WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
            """, (parent_id, child_id))
            c.connection.commit()
            QMessageBox.information(self, "Unlinked", f"Child {child_id} unlinked from parent {parent_id}.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def force_activate(self, rule_id):
        confirm = QMessageBox.question(self, "Force Activate", f"Activate rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT STATUS FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            old_status = row[0] if row else None
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE', APPROVAL_STATUS='FORCE_ACTIVATED'
                WHERE RULE_ID=?
            """, (rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Activated", f"Rule {rule_id} forced active.")
            self.load_rule_list()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def force_deactivate(self, rule_id):
        confirm = QMessageBox.question(self, "Force Deactivate", f"Deactivate rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            # Also deactivate children if needed
            c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
            rows = c.fetchall()
            child_map = defaultdict(list)
            for r, p in rows:
                if p:
                    child_map[p].append(r)
            stack = [rule_id]
            visited = set()
            while stack:
                curr = stack.pop()
                if curr in visited:
                    continue
                visited.add(curr)
                for ch in child_map.get(curr, []):
                    stack.append(ch)
            # Deactivate all visited
            for rid in visited:
                c.execute("""
                    UPDATE BRM_RULES
                    SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE', APPROVAL_STATUS='FORCE_DEACTIVATED'
                    WHERE RULE_ID=?
                """, (rid,))
            c.connection.commit()
            QMessageBox.information(self, "Deactivated", f"Rule {rule_id} force-deactivated (and children).")
            self.load_rule_list()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


###############################################################################
# HIERARCHY VIEW TAB
###############################################################################
class HierarchyViewTab(QTreeWidget):
    """
    Drag-and-drop hierarchical view for groups/rules. 
    On drop, updates DB. 
    Also can show sub-groups if extended in future.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setHeaderLabels(["Group/Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QTreeWidget.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        self.group_map = {}
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
            for gid, gname in c.fetchall():
                item = QTreeWidgetItem([f"{gname} (ID={gid})"])
                item.setData(0, Qt.UserRole, ("group", gid))
                self.addTopLevelItem(item)
                self.group_map[gid] = item
            c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
            rule_data = {}
            for (rid, rn, group_id, parent_id) in c.fetchall():
                rule_data[rid] = {"name": rn, "group_id": group_id, "parent_id": parent_id}
            self.rule_items = {}
            # Insert top-level rules
            for rid, data in rule_data.items():
                if not data["parent_id"]:
                    grp_item = self.group_map.get(data["group_id"])
                    if grp_item:
                        child = QTreeWidgetItem([f"Rule {rid}: {data['name']}"])
                        child.setData(0, Qt.UserRole, ("rule", rid))
                        grp_item.addChild(child)
                        self.rule_items[rid] = child
            # Insert child rules
            for rid, data in rule_data.items():
                if data["parent_id"]:
                    parent_item = self.rule_items.get(data["parent_id"])
                    if parent_item:
                        child = QTreeWidgetItem([f"Rule {rid}: {data['name']}"])
                        child.setData(0, Qt.UserRole, ("rule", rid))
                        parent_item.addChild(child)
                        self.rule_items[rid] = child
            self.expandAll()
        except Exception as ex:
            QMessageBox.critical(self, "Hierarchy Error", str(ex))

    def dropEvent(self, event):
        super().dropEvent(event)
        self.update_database_reparenting()
        self.load_hierarchy()

    def update_database_reparenting(self):
        c = self.connection.cursor()
        top_count = self.topLevelItemCount()
        for i in range(top_count):
            group_item = self.topLevelItem(i)
            data = group_item.data(0, Qt.UserRole)
            if data and data[0] == "group":
                group_id = data[1]
                for j in range(group_item.childCount()):
                    child_item = group_item.child(j)
                    self.recursive_update(child_item, None, group_id, c)
        c.connection.commit()

    def recursive_update(self, item, parent_rule_id, group_id, cursor):
        data = item.data(0, Qt.UserRole)
        if data and data[0] == "rule":
            rule_id = data[1]
            try:
                cursor.execute("""
                    UPDATE BRM_RULES
                    SET PARENT_RULE_ID=?, GROUP_ID=?, STATUS='INACTIVE',
                        APPROVAL_STATUS='APPROVAL_IN_PROGRESS', UPDATED_BY='HierarchyDragDrop',
                        VERSION=VERSION+1
                    WHERE RULE_ID=?
                """, (parent_rule_id, group_id, rule_id))
            except Exception as ex:
                logger.error(f"Error reparenting rule {rule_id}: {ex}")
            for i in range(item.childCount()):
                child = item.child(i)
                self.recursive_update(child, rule_id, group_id, cursor)

###############################################################################
# ENHANCED LINEAGE GRAPH (Force-Directed)
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    Force-directed lineage graph with advanced UI:
      - Node-based right-click for rule actions
      - Possibly sub-clusters for groups
      - Animations, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene()
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.RubberBandDrag)
        self.zoom_factor = 1.15
        self.nodes = {}
        self.edges = []
        self.load_data()
        self.setup_force_directed()
        self.setMinimumSize(600, 400)

    def load_data(self):
        self.rule_info = {}
        self.adjacency = {}
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME, STATUS FROM BRM_RULES")
            for rid, name, status in c.fetchall():
                self.rule_info[rid] = {"name": name, "status": status}
            # For demonstration, assume a simple RULE_LINEAGE table
            c.execute("SELECT RULE_ID, PARENT_ID FROM BRM_RULE_LINEAGE")
            for rid, pid in c.fetchall():
                self.adjacency.setdefault(pid or 0, []).append(rid)
        except Exception as ex:
            QMessageBox.critical(self, "Lineage Load Error", str(ex))

    def setup_force_directed(self):
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()
        # Create node items
        for rid, info in self.rule_info.items():
            node = NodeItem(rid, info["name"], info["status"])
            node.setPos(50 + (rid % 10) * 80, 50 + (rid // 10) * 80)
            self.scene.addItem(node)
            self.nodes[rid] = node
        # Create edges
        for parent, children in self.adjacency.items():
            if parent not in self.nodes:
                continue
            for child in children:
                if child in self.nodes:
                    edge = EdgeItem(self.nodes[parent], self.nodes[child])
                    self.scene.addItem(edge)
                    self.edges.append(edge)
        # Timer for force updates
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_forces)
        self.timer.start(30)

    def update_forces(self):
        repulsion = 5000.0
        spring_length = 150.0
        spring_strength = 0.1
        damping = 0.85

        for node in self.nodes.values():
            node.force = QtCore.QPointF(0, 0)

        node_list = list(self.nodes.values())
        for i in range(len(node_list)):
            for j in range(i+1, len(node_list)):
                node_a = node_list[i]
                node_b = node_list[j]
                delta = node_a.pos() - node_b.pos()
                distance = max(1.0, (delta.x()**2 + delta.y()**2)**0.5)
                force_mag = repulsion / (distance*distance)
                force = delta / distance * force_mag
                node_a.force += force
                node_b.force -= force

        for edge in self.edges:
            delta = edge.source.pos() - edge.dest.pos()
            distance = max(1.0, (delta.x()**2 + delta.y()**2)**0.5)
            disp = distance - spring_length
            force = (delta / distance) * (spring_strength * disp)
            edge.source.force -= force
            edge.dest.force += force

        for node in self.nodes.values():
            velocity = node.velocity + node.force * 0.1
            velocity *= damping
            node.velocity = velocity
            node.setPos(node.pos() + velocity)
        for edge in self.edges:
            edge.updatePosition()

    def wheelEvent(self, event):
        if event.angleDelta().y() > 0:
            factor = self.zoom_factor
        else:
            factor = 1.0 / self.zoom_factor
        self.scale(factor, factor)

class NodeItem(QtWidgets.QGraphicsEllipseItem):
    def __init__(self, rule_id, name, status, radius=30):
        super().__init__(-radius, -radius, radius*2, radius*2)
        self.rule_id = rule_id
        self.name = name
        self.status = status.upper()
        self.radius = radius
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsMovable | 
                      QtWidgets.QGraphicsItem.ItemIsSelectable |
                      QtWidgets.QGraphicsItem.ItemSendsGeometryChanges)
        self.setBrush(self.get_brush())
        self.setPen(QtGui.QPen(Qt.black))
        self.force = QtCore.QPointF(0,0)
        self.velocity = QtCore.QPointF(0,0)
        self.text_item = QtWidgets.QGraphicsTextItem(self.name, self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setPos(-radius, -radius - 20)

    def get_brush(self):
        if self.status == "ACTIVE":
            return QtGui.QBrush(QtGui.QColor(144, 238, 144))
        elif self.status == "INACTIVE":
            return QtGui.QBrush(QtGui.QColor(255, 182, 193))
        else:
            return QtGui.QBrush(QtGui.QColor(255, 255, 153))

    def itemChange(self, change, value):
        if change == QtWidgets.QGraphicsItem.ItemPositionChange:
            # Update connected edges
            pass
        return super().itemChange(change, value)

class EdgeItem(QtWidgets.QGraphicsLineItem):
    def __init__(self, source, dest):
        super().__init__()
        self.source = source
        self.dest = dest
        self.setPen(QtGui.QPen(Qt.gray, 2))

    def updatePosition(self):
        line = QtCore.QLineF(self.source.pos(), self.dest.pos())
        self.setLine(line)

###############################################################################
# METRICS DASHBOARD TAB (with placeholders for heatmaps, AIOps)
###############################################################################
class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.chart_layout = QHBoxLayout()

        # Bar chart: rule counts by status
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        self.chart_layout.addWidget(self.status_chart)

        # Line chart: performance trending
        self.perf_chart = pg.PlotWidget(title="Performance Trend (Avg Exec Time)")
        self.perf_chart.setBackground('w')
        self.chart_layout.addWidget(self.perf_chart)

        layout.addLayout(self.chart_layout)

        # Heatmap / AIOps placeholders
        self.aiops_label = QLabel("AIOps / Heatmap placeholders here.")
        layout.addWidget(self.aiops_label)

        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        try:
            # Count by STATUS
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows = c.fetchall()
            statuses = [r[0] for r in rows]
            counts = [r[1] for r in rows]
            self.status_chart.clear()
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left", "Count")
            self.status_chart.setLabel("bottom", "Status")
            self.status_chart.showGrid(x=True, y=True)

            # Perf trending
            c.execute("""
                SELECT DATE_KEY, AVG(EXEC_TIME_MS) AS avg_time
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY,-30,GETDATE()),112)
                GROUP BY DATE_KEY
                ORDER BY DATE_KEY ASC
            """)
            perf_rows = c.fetchall()
            self.perf_chart.clear()
            if perf_rows:
                x_vals = list(range(len(perf_rows)))
                avg_times = [row[1] for row in perf_rows]
                self.perf_chart.plot(x_vals, avg_times, pen=pg.mkPen('r', width=2), name="Avg Exec Time")
                self.perf_chart.setLabel("bottom", "Time Index (Last 30 Days)")
                self.perf_chart.setLabel("left", "Value")
                self.perf_chart.showGrid(x=True, y=True)

        except Exception as ex:
            QMessageBox.critical(self, "Metrics Error", str(ex))

###############################################################################
# PREDICTIVE ANALYTICS TAB (AIOps placeholders)
###############################################################################
class PredictiveAnalyticsTab(QWidget):
    """
    Example usage of ML for forecasting rule exec times, anomaly detection, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.filter_layout = QHBoxLayout()
        self.rule_filter = QLineEdit()
        self.rule_filter.setPlaceholderText("Filter by rule name or ID...")
        self.filter_layout.addWidget(QLabel("Rule Filter:"))
        self.filter_layout.addWidget(self.rule_filter)
        layout.addLayout(self.filter_layout)

        self.chart = pg.PlotWidget(title="Forecast: Avg Execution Time (Example)")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        run_btn = QPushButton("Run Forecast")
        run_btn.clicked.connect(self.run_forecast)
        layout.addWidget(run_btn)

        self.result_label = QLabel("")
        layout.addWidget(self.result_label)
        self.setLayout(layout)

    def run_forecast(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(date, ACTION_TIMESTAMP) as LogDate, AVG(EXEC_TIME_MS) as AvgTime
                FROM RULE_PERF_STATS
                WHERE ACTION_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
                GROUP BY CONVERT(date, ACTION_TIMESTAMP)
                ORDER BY LogDate
            """)
            rows = c.fetchall()
            if not rows:
                self.result_label.setText("No data found for last 30 days.")
                return
            dates = [row[0] for row in rows]
            avg_times = [row[1] for row in rows]
            X = np.array([[i] for i in range(len(avg_times))])
            y = np.array(avg_times)
            model = LinearRegression()
            model.fit(X, y)
            forecast_x = len(avg_times)
            forecast_val = model.predict(np.array([[forecast_x]]))[0]
            self.chart.clear()
            x_vals = list(range(len(avg_times)))
            self.chart.plot(x_vals, avg_times, pen=pg.mkPen('b', width=2), symbol='o')
            self.chart.plot([forecast_x], [forecast_val], pen=pg.mkPen('r', width=2), symbol='x', symbolSize=12)
            self.chart.setLabel("bottom", "Day Index (Last 30 Days)")
            self.chart.setLabel("left", "Avg Exec Time (ms)")
            if forecast_val > 2000:
                self.result_label.setText(f"Anomaly: forecast {forecast_val:.1f} ms > 2000 ms.")
            else:
                self.result_label.setText(f"Forecast: {forecast_val:.1f} ms.")
        except Exception as ex:
            QMessageBox.critical(self, "Forecast Error", str(ex))

###############################################################################
# ENHANCED AUDIT LOG ANALYSIS
###############################################################################
class EnhancedAuditLogAnalysisTab(QWidget):
    """
    Displays BRM_AUDIT_LOG with advanced text search, CSV/JSON export, 
    version diff, and optional pipeline-like visual.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search logs by action, table, actor...")
        self.search_edit.textChanged.connect(self.filter_logs)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)

        self.log_table = QTableWidget(0, 9)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID", "Action", "TableName", "RecordID", "ActionBy", "OldData", "NewData", "Timestamp", "Status"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_layout.addWidget(refresh_btn)
        export_csv_btn = QPushButton("Export CSV")
        export_csv_btn.clicked.connect(lambda: self.export_logs("csv"))
        btn_layout.addWidget(export_csv_btn)
        export_json_btn = QPushButton("Export JSON")
        export_json_btn.clicked.connect(lambda: self.export_logs("json"))
        btn_layout.addWidget(export_json_btn)
        diff_btn = QPushButton("Show Version Diff")
        diff_btn.clicked.connect(self.show_version_diff)
        btn_layout.addWidget(diff_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        # Possibly a small pipeline or timeline view can be added
        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT TOP 1000 AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, 
                       OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
                FROM BRM_AUDIT_LOG
                ORDER BY ACTION_TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.log_table.insertRow(i)
                for col_idx in range(8):
                    val = row[col_idx]
                    if col_idx in (5, 6) and val:
                        try:
                            val = json.dumps(json.loads(val), indent=2)
                        except:
                            pass
                    self.log_table.setItem(i, col_idx, QTableWidgetItem(str(val) if val else ""))
                status_item = QTableWidgetItem("N/A")
                # e.g., if "APPROVE" in action => set icon
                act_upper = (row[1] or "").upper()
                if "APPROVE" in act_upper:
                    status_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_DialogApplyButton))
                elif "REJECT" in act_upper:
                    status_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxCritical))
                self.log_table.setItem(i, 8, status_item)
        except Exception as ex:
            QMessageBox.critical(self, "Load Logs Error", str(ex))

    def filter_logs(self):
        text = self.search_edit.text().lower()
        for i in range(self.log_table.rowCount()):
            row_ok = False
            for col in (1, 2, 4):  
                item = self.log_table.item(i, col)
                if item and text in item.text().lower():
                    row_ok = True
                    break
            self.log_table.setRowHidden(i, not row_ok)

    def export_logs(self, fmt):
        path, _ = QFileDialog.getSaveFileName(self, "Export Logs", "", "All Files (*)")
        if not path:
            return
        progress = QProgressDialog("Exporting logs...", "Cancel", 0, self.log_table.rowCount(), self)
        progress.setWindowModality(Qt.WindowModal)
        progress.show()
        try:
            data = []
            headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            data.append(headers)
            total = self.log_table.rowCount()
            written = 0
            for i in range(total):
                if self.log_table.isRowHidden(i):
                    continue
                row_data = []
                for j in range(self.log_table.columnCount()):
                    it = self.log_table.item(i, j)
                    row_data.append(it.text() if it else "")
                data.append(row_data)
                written += 1
                progress.setValue(written)
                QtWidgets.QApplication.processEvents()
                if progress.wasCanceled():
                    QMessageBox.information(self, "Cancelled", "Export cancelled.")
                    return
            if fmt == "csv":
                with open(path, "w", newline="", encoding="utf-8") as f:
                    writer = csv.writer(f)
                    writer.writerows(data)
            elif fmt == "json":
                dict_list = []
                for row_idx, row_vals in enumerate(data[1:], start=1):
                    row_obj = dict(zip(headers, row_vals))
                    dict_list.append(row_obj)
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(dict_list, f, indent=2)
            QMessageBox.information(self, "Exported", f"Audit logs exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Export Error", str(ex))

    def show_version_diff(self):
        # For demonstration, pick the selected row's (table, record_id) and show some diff
        row = self.log_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "No selection", "Pick a log row.")
            return
        table_name = self.log_table.item(row, 2).text()
        rec_id = self.log_table.item(row, 3).text()
        dlg = VersionHistoryDialog(self.connection, table_name, rec_id, self)
        dlg.exec_()


###############################################################################
# HELP & FEEDBACK TAB
###############################################################################
class HelpFeedbackTab(QWidget):
    """
    Displays help docs, possibly integrated with OnboardingWizard 
    and guided tours or context tooltips. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        title_label = QLabel("BRM Tool Help & Documentation")
        font = title_label.font()
        font.setPointSize(14)
        font.setBold(True)
        title_label.setFont(font)
        layout.addWidget(title_label)

        self.help_search = QLineEdit()
        self.help_search.setPlaceholderText("Search help content...")
        self.help_search.textChanged.connect(self.filter_help)
        layout.addWidget(self.help_search)

        self.help_tree = QTreeWidget()
        self.help_tree.setHeaderLabels(["Topic", "Content"])
        layout.addWidget(self.help_tree)

        # Onboarding wizard button
        wizard_btn = QPushButton("Run Onboarding Wizard")
        wizard_btn.clicked.connect(self.run_onboarding_wizard)
        layout.addWidget(wizard_btn)

        self.setLayout(layout)
        self.load_help_content()

    def load_help_content(self):
        # Example content from a hypothetical HELP_CONTENT table
        c = self.connection.cursor()
        try:
            c.execute("SELECT CATEGORY, TITLE, CONTENT FROM HELP_CONTENT ORDER BY CATEGORY, LAST_UPDATED DESC")
            rows = c.fetchall()
            for (cat, title, content) in rows:
                item = QTreeWidgetItem([f"{cat} - {title}", content])
                self.help_tree.addTopLevelItem(item)
            self.help_tree.expandAll()
        except:
            pass

    def filter_help(self):
        text = self.help_search.text().lower()
        for i in range(self.help_tree.topLevelItemCount()):
            item = self.help_tree.topLevelItem(i)
            visible = text in item.text(0).lower() or text in item.text(1).lower()
            item.setHidden(not visible)

    def run_onboarding_wizard(self):
        wizard = OnboardingWizard(self.connection, self)
        wizard.exec_()

###############################################################################
# COLLABORATION TAB
###############################################################################
class CollaborationTab(QWidget):
    """
    Collaboration with mention/tagging placeholders, threaded conv placeholders.
    """
    def __init__(self, connection, collaboration_manager, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.collaboration_manager = collaboration_manager
        layout = QVBoxLayout(self)

        self.messages_list = QListWidget()
        layout.addWidget(self.messages_list)

        input_layout = QHBoxLayout()
        self.message_edit = QLineEdit()
        self.message_edit.setPlaceholderText("Type your message or mention @someone ...")
        input_layout.addWidget(self.message_edit)
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        input_layout.addWidget(send_btn)
        layout.addLayout(input_layout)

        refresh_btn = QPushButton("Refresh Messages")
        refresh_btn.clicked.connect(self.load_messages)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_messages()

        # Collaboration manager signal
        self.collaboration_manager.newMessage.connect(self.handle_new_message)

    def load_messages(self):
        self.messages_list.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT MESSAGE, SENDER, TIMESTAMP
                FROM COLLABORATION_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for row in rows:
                msg, sender, ts = row
                display = f"[{ts}] {sender}: {msg}"
                self.messages_list.addItem(display)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def send_message(self):
        msg = self.message_edit.text().strip()
        if not msg:
            return
        sender = "CurrentUser"
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO COLLABORATION_LOGS(MESSAGE, SENDER, TIMESTAMP) VALUES(?, ?, GETDATE())",
                      (msg, sender))
            c.connection.commit()
            self.message_edit.clear()
            self.load_messages()
            # detect mention?
            if "@" in msg:
                # placeholder: parse mention, send notification
                pass
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def handle_new_message(self, msg_dict):
        # Called from collaboration manager
        message = msg_dict.get("message", "")
        sender = msg_dict.get("sender", "Unknown")
        ts = msg_dict.get("timestamp", "")
        display = f"[{ts}] {sender}: {message}"
        self.messages_list.insertItem(0, display)


###############################################################################
# ONBOARDING WIZARD
###############################################################################
class OnboardingWizard(QDialog):
    """
    Multi-step wizard for brand-new users.
    Optionally link from HelpFeedbackTab or initial launch.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_step = 0
        self.setWindowTitle("Onboarding Wizard – BRM Master")
        self.resize(400, 250)
        main_l = QVBoxLayout(self)

        self.label = QLabel("Welcome to the BRM Tool Wizard.")
        main_l.addWidget(self.label)

        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        main_l.addWidget(self.next_btn)

        self.setLayout(main_l)

    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Go to 'Group Management' to create your first business group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Go to 'Business Rules' to add a new rule (e.g., for risk checks).")
        elif self.current_step == 3:
            self.label.setText("Step 3: Use 'Approvals' tab to route your rule for multi-step approval.")
        elif self.current_step == 4:
            self.label.setText("Step 4: Try a BFS dry-run or 'What-If Test' to confirm your rule logic.")
        else:
            self.label.setText("Wizard complete! Enjoy using the BRM Tool.")
            self.accept()

###############################################################################
# VERSION HISTORY DIALOG (for partial demonstration)
###############################################################################
class VersionHistoryDialog(QDialog):
    """
    Partial example of a version history/diff approach. 
    Here, we pass (table_name, record_id) or (rule_id) as needed.
    """
    def __init__(self, connection, table_name, record_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.table_name = table_name
        self.record_id = record_id
        self.setWindowTitle(f"Version History – {table_name} ({record_id})")
        self.resize(800, 600)
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 5)
        self.table.setHorizontalHeaderLabels(["AuditID", "Action", "Timestamp", "OldData", "NewData"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        diff_btn = QPushButton("Show Diff")
        diff_btn.clicked.connect(self.show_diff)
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.do_rollback)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(diff_btn)
        btn_layout.addWidget(rollback_btn)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
                FROM BRM_AUDIT_LOG
                WHERE TABLE_NAME=? AND RECORD_ID=?
                ORDER BY ACTION_TIMESTAMP DESC
            """, (self.table_name, self.record_id))
            rows = c.fetchall()
            self.table.setRowCount(0)
            for i, row in enumerate(rows):
                self.table.insertRow(i)
                for col_idx in range(5):
                    val = row[col_idx]
                    if col_idx in (3, 4) and val:
                        try:
                            val = json.dumps(json.loads(val), indent=2)
                        except:
                            pass
                    self.table.setItem(i, col_idx, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def show_diff(self):
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "No selection", "Select a version row first.")
            return
        old_item = self.table.item(row, 3)
        new_item = self.table.item(row, 4)
        old_text = old_item.text() if old_item else ""
        new_text = new_item.text() if new_item else ""
        old_lines = old_text.splitlines()
        new_lines = new_text.splitlines()
        diff = difflib.unified_diff(old_lines, new_lines, fromfile="Old", tofile="New", lineterm="")
        diff_text = "\n".join(list(diff))
        dlg = QDialog(self)
        dlg.setWindowTitle("Diff View")
        dlg.resize(800, 600)
        vbox = QVBoxLayout(dlg)
        diff_edit = QPlainTextEdit(diff_text if diff_text.strip() else "No differences.")
        diff_edit.setReadOnly(True)
        vbox.addWidget(diff_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        vbox.addWidget(close_btn)
        dlg.exec_()

    def do_rollback(self):
        # Example partial rollback approach
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No version row selected.")
            return
        old_data = self.table.item(row, 3).text()
        confirm = QMessageBox.question(self, "Confirm Rollback",
                                       "Rollback to this version? This updates DB with old_data.")
        if confirm != QMessageBox.Yes:
            return
        try:
            # parse old_data as JSON
            old_obj = json.loads(old_data)
            # e.g., if self.table_name=='BRM_RULES', we apply updates to rule
            # This part is domain-specific and incomplete here:
            # ...
            QMessageBox.information(self, "Rolled Back",
                                    "Rollback simulation complete. (In actual system, changes would be applied.)")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self, "Rollback Error", str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 4
(Integrated codebase, chunk 4)

Contains:
 • MainWindow (core UI)
 • DatabaseConnectionDialog
 • LoginDialog
 • CollaborationManager
 • Example BFS or advanced search placeholders
 • OnboardingWizard integration
"""

import sys
import os
import json
import math
import logging
import pyodbc
from datetime import datetime, timedelta

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLineEdit, QMessageBox, QTabWidget, QDockWidget, QLabel,
    QInputDialog, QDialog, QMenu, QAction
)

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# DatabaseConnectionDialog
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – BRM Master")
        self.resize(400, 200)

        main_layout = QtWidgets.QVBoxLayout(self)
        lbl = QtWidgets.QLabel("Select ODBC DSN or custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QtWidgets.QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QtWidgets.QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QtWidgets.QHBoxLayout()
        ok_btn = QtWidgets.QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QtWidgets.QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QtWidgets.QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established.")
            return conn
        except Exception as ex:
            QtWidgets.QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()

###############################################################################
# LoginDialog
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – BRM Master")
        self.resize(300, 150)

        main_layout = QtWidgets.QVBoxLayout(self)
        self.user_edit = QtWidgets.QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QtWidgets.QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit = QtWidgets.QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QtWidgets.QLineEdit.Password)
        main_layout.addWidget(QtWidgets.QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        login_btn = QtWidgets.QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)
        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QtWidgets.QMessageBox.warning(self, "Error", "Username and password required.")
            return
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in. user_id={self.user_id}, user_group={self.user_group}")
                self.accept()
            else:
                QtWidgets.QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
                logger.warning(f"Login failed for user {un}.")
        except Exception as ex:
            logger.exception("Login Error:")
            QtWidgets.QMessageBox.critical(self, "DB Error", str(ex))

###############################################################################
# CollaborationManager (polling chat logs, mention placeholders)
###############################################################################
class CollaborationManager(QtCore.QObject):
    """
    Basic manager that polls COLLABORATION_LOGS for new messages. 
    newMessage signal fires with a dict {message, sender, timestamp}.
    """
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.last_timestamp = None
        self.timer.start(self.poll_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("SELECT MESSAGE, SENDER, TIMESTAMP FROM COLLABORATION_LOGS ORDER BY TIMESTAMP ASC")
            rows = c.fetchall()
            if rows:
                for row in rows:
                    message, sender, ts = row
                    d = {"message": message, "sender": sender, "timestamp": ts}
                    self.newMessage.emit(d)
                    self.last_timestamp = ts
        except Exception as ex:
            logger.error(f"Poll messages error: {ex}")

###############################################################################
# MainWindow
###############################################################################
class MainWindow(QMainWindow):
    """
    The main application window for BRM MASTER:
      - Contains top-level tabs: Admin, Business Rules, Approvals, Collaboration, Metrics, Predictive, Audit, Help...
      - Has a 'Notifications Dock' with AlertsAndDashboardsTab
      - Integrates advanced search placeholders, mention notifications, BFS lock manager stubs, etc.
    """
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.setWindowTitle("BRM Tool – Master Edition")
        self.resize(1800, 1000)

        # menubar
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        help_menu = menubar.addMenu("Help")
        doc_action = help_menu.addAction("Documentation")
        doc_action.triggered.connect(self.open_help)

        # central widget
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)

        # If user_group == 'Admin', optionally show impersonation row
        if self.user_group.upper() == "ADMIN":
            imp_h = QHBoxLayout()
            imp_lbl = QLabel("Impersonate:")
            imp_h.addWidget(imp_lbl)
            self.impersonation_combo = QComboBox()
            self.load_impersonation_options()
            imp_h.addWidget(self.impersonation_combo)
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.impersonate_user)
            imp_h.addWidget(imp_btn)
            imp_h.addStretch()
            central_layout.addLayout(imp_h)

        # Main Tabs
        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)

        # Admin Tab
        from chunk3_part_admin import AdminTab  # If we had separate modules, or we can just reference directly
        self.admin_tab = AdminTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.admin_tab, "Admin")

        # Business Rules Tab
        from chunk2_part_business_rules import BusinessRulesTab  # Hypothetical: or direct reference
        self.biz_rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.biz_rules_tab, "Business Rules")

        # Approvals Tab
        from chunk3_part_approvals import ApprovalsTab
        logged_in_username = self.fetch_username(self.user_id)
        self.approvals_tab = ApprovalsTab(self.connection, logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")

        # Collaboration
        from chunk1_part_collaboration import CollaborationTab, CollaborationManager
        self.collab_manager = CollaborationManager(self.connection)
        self.collab_tab = CollaborationTab(self.connection, self.collab_manager)
        self.tabs.addTab(self.collab_tab, "Collaboration")

        # Metrics Dashboard
        from chunk3_part_metrics import MetricsDashboardTab
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics")

        # Predictive Analytics
        from chunk3_part_predictive import PredictiveAnalyticsTab
        self.predictive_tab = PredictiveAnalyticsTab(self.connection)
        self.tabs.addTab(self.predictive_tab, "Predictive")

        # Audit Log
        from chunk3_part_audit import EnhancedAuditLogAnalysisTab
        self.audit_tab = EnhancedAuditLogAnalysisTab(self.connection)
        self.tabs.addTab(self.audit_tab, "Audit Log")

        # Help & Feedback
        from chunk3_part_help import HelpFeedbackTab
        self.help_tab = HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab, "Help & Feedback")

        # Dock for notifications / alerts
        from chunk2_part_alerts import AlertsAndDashboardsTab
        self.notifications_dock = QDockWidget("Real-Time Notifications", self)
        self.notifications_widget = AlertsAndDashboardsTab(self.connection)
        self.notifications_dock.setWidget(self.notifications_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, self.notifications_dock)

        # final
        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)

        # Possibly run an onboarding wizard once if user is new
        # ...
        # Timed auto-refresh
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_all)
        self.refresh_timer.start(30000)

        # advanced search placeholders ...
        # self.setup_advanced_search()

    def fetch_username(self, user_id):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except:
            return "Unknown"

    def load_impersonation_options(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for (uid, uname, ugrp) in rows:
                self.impersonation_combo.addItem(f"{uname} ({ugrp})", (uid, ugrp))
        except Exception as ex:
            logger.error(f"Impersonation load error: {ex}")

    def impersonate_user(self):
        data = self.impersonation_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        # reload relevant tabs
        logger.info(f"Now impersonating user_id={new_uid}, group={new_group}")
        self.approvals_tab.logged_in_username = self.fetch_username(new_uid)
        self.approvals_tab.user_group = new_group
        self.approvals_tab.load_approvals()
        self.biz_rules_tab.user_id = new_uid
        self.biz_rules_tab.user_group = new_group
        self.biz_rules_tab.load_rules()  # assume there's a load method
        # hide or show admin tab
        # ...
        QMessageBox.information(self, "Impersonated", f"Now acting as user_id={new_uid}, group={new_group}.")

    def logout(self):
        self.close()

    def open_help(self):
        # jump to help tab
        idx = self.tabs.indexOf(self.help_tab)
        if idx >= 0:
            self.tabs.setCurrentIndex(idx)

    def refresh_all(self):
        try:
            # refresh approvals, rules, notifications
            self.approvals_tab.load_approvals()
            self.biz_rules_tab.load_rules()
            self.notifications_widget.check_alerts()
        except Exception as ex:
            logger.error(f"Refresh error: {ex}")

    # def setup_advanced_search(self):
    #   # placeholders for multi-criteria search across rules, logs, or schedules
    #   pass
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 5
(Integrated codebase, chunk 5)

Focus:
 • BFS-based rule execution logic (execute_rules_unified_bfs, etc.)
 • Decision table execution
 • Data validations expansions
 • Snapshots & tags advanced capabilities
 • Additional placeholders for concurrency, conflict resolution, etc.
"""

import sys
import os
import json
import math
import logging
from datetime import datetime, timedelta
from collections import defaultdict

import pyodbc
import sqlparse
import re

from PyQt5 import QtCore, QtWidgets

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# LockManager expansions (if not already included in chunk)
###############################################################################
# (In some builds, LockManager was partially defined earlier. 
#  If so, treat these as expansions/overrides for force-unlock or concurrency enhancements.)

class LockManager:
    """
    Manages the BRM_RULE_LOCKS table and rule concurrency:
      - auto_unlock_expired_locks
      - rule_current_lock_owner
      - lock_rule_for_edit
      - unlock_rule_for_edit
      - optional expansions for forced unlock or parallel approvals
    """
    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            rc = c.rowcount
            conn.commit()
            if rc > 0:
                logger.info(f"Auto-unlocked {rc} expired rule locks.")
        except Exception as ex:
            logger.error(f"Error auto-unlocking expired locks: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag = row
        now = datetime.now()
        if et and now > et:
            # Expire lock
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except Exception as ex:
                logger.error(f"Error expiring lock for rule {rule_id}: {ex}")
            return None
        return (locked_by, lts, et, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()

        if info is not None:
            (locked_by, old_ts, old_exp, fflag) = info
            if locked_by == user_id:
                # refresh lock
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock for rule {rule_id} refreshed by {user_id}. force={force}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly re-locked by {user_id}.")
                    return
        else:
            # no existing lock
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return  # not locked or expired
        (locked_by, lts, et, fflag) = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}. cannot unlock.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by {user_id}, force={force}.")

###############################################################################
# BFS-based rule execution & Decision tables
###############################################################################
def detect_operation_type(sql_text: str):
    """
    Return INSERT, UPDATE, DELETE, SELECT, DECISION_TABLE, or OTHER
    (some calls to this also consider the rule's DECISION_TABLE_ID).
    """
    # A simplified approach
    stripped = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or '', flags=re.MULTILINE|re.DOTALL).strip()
    up = stripped.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text: str):
    """
    Using sqlparse to identify table references, columns, etc.
    In the full code, we handle CTEs, alias maps, sub-selects, etc.
    """
    try:
        statements = sqlparse.parse(sql_text or "")
    except:
        return {"tables": [], "cte_tables": [], "alias_map": {}, "columns": []}

    all_tables = []
    # a minimal approach: searching for FROM or JOIN tokens
    # for demonstration
    for stmt in statements:
        for token in stmt.tokens:
            if token.is_group:
                for sub in token.tokens:
                    if sub.ttype is sqlparse.tokens.Keyword and sub.value.upper() in ("FROM","JOIN","INNER JOIN","LEFT JOIN"):
                        # next token might be table name
                        pass
    # This is a placeholder snippet. Full logic is typically more robust.
    # ...
    return {"tables": list(set(all_tables)), "cte_tables": [], "alias_map": {}, "columns": []}

def run_data_validations(conn):
    """
    Looks up DATA_VALIDATIONS, runs each validation, logs results.
    Example checks: NOT NULL, RANGE, UNIQUE, etc.
    """
    c = conn.cursor()
    try:
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS")
        val_rows = c.fetchall()
    except Exception as e:
        logger.error(f"Error fetching validations: {e}")
        return

    for row in val_rows:
        vid, tbl, col, vtype, params = row
        result_flag = "PASS"
        details = ""
        try:
            if vtype.upper() == "NOT NULL":
                q = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(q)
                count = c.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} rows have NULL in {col}."
                else:
                    details = "All rows have non-null values."
            elif vtype.upper() == "RANGE":
                # expecting something like "min=0;max=100" in params
                min_val, max_val = None, None
                if params:
                    for part in params.split(";"):
                        if part.strip().lower().startswith("min="):
                            min_val = float(part.split("=")[1])
                        elif part.strip().lower().startswith("max="):
                            max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid range params."
                else:
                    q = f"""
                    SELECT COUNT(*) FROM {tbl}
                    WHERE TRY_CAST({col} as float) IS NOT NULL
                      AND (TRY_CAST({col} as float) < {min_val} OR TRY_CAST({col} as float) > {max_val})
                    """
                    c.execute(q)
                    out = c.fetchone()[0]
                    if out > 0:
                        result_flag = "FAIL"
                        details = f"{out} rows outside range [{min_val}, {max_val}]"
                    else:
                        details = f"All rows in range [{min_val}, {max_val}]"
            elif vtype.upper() == "UNIQUE":
                q = f"""
                SELECT COUNT(*) FROM (
                  SELECT {col}, COUNT(*) as c
                  FROM {tbl}
                  GROUP BY {col}
                  HAVING COUNT(*)>1
                ) as t
                """
                c.execute(q)
                out = c.fetchone()[0]
                if out > 0:
                    result_flag = "FAIL"
                    details = f"{out} duplicate values found in {col}."
                else:
                    details = f"All values in {col} are unique."
            else:
                result_flag = "FAIL"
                details = f"Validation type '{vtype}' not recognized."
        except Exception as ex:
            result_flag = "FAIL"
            details = f"Error: {ex}"

        # log result
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP)
                VALUES(?, ?, ?, GETDATE())
            """, (vid, result_flag, details))
            conn.commit()
        except Exception as ex2:
            logger.error(f"Error logging validation {vid}: {ex2}")

def execute_decision_table(conn, dt_id, dry_run=True):
    """
    For a rule that references DECISION_TABLES. 
    DECISION_QUERY is run in a transaction, expecting to return 1 or 0 as pass/fail.
    If dry_run, always rollback.
    """
    c_dt = conn.cursor()
    c_dt.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c_dt.fetchone()
    if not row:
        return (False, f"Decision table {dt_id} not found", 0)
    decision_query = row[0] or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Transaction start error for DT {dt_id}: {ex}")
        return (False, str(ex), 0)

    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(decision_query)
        rows = []
        try:
            rows = c.fetchall()
        except:
            pass
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Decision table returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        # always rollback if dry_run
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Logs each BFS execution or single-run attempt into RULE_EXECUTION_LOGS 
    (with expansions for CPU, MEM, or time).
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
              CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting rule execution log {rule_id}: {ex}")

def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    A single rule’s SQL is run in a transaction. If no row returns or first col =1 => PASS, else FAIL.
    For DECISION_TABLE, calls execute_decision_table.
    """
    op_type = rule_info.get("OPERATION_TYPE","OTHER")
    dt_id = rule_info.get("DECISION_TABLE_ID")
    if op_type.upper() == "DECISION_TABLE":
        if not dt_id:
            return (False, "No DECISION_TABLE_ID set", 0)
        (ok, msg, rec_count) = execute_decision_table(conn, dt_id, dry_run=True)
        return (ok, msg, rec_count)

    sql_ = rule_info.get("RULE_SQL") or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Transaction start error for rule {rule_info.get('RULE_ID')}: {ex}")
        return (False, str(ex), 0)

    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        rows = []
        try:
            rows = c.fetchall()
        except:
            pass
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

def get_all_rules_map(conn):
    """
    Return RULE_ID -> row dict from BRM_RULES
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    out = {}
    for r in rows:
        d = dict(zip(colnames, r))
        out[d["RULE_ID"]] = d
    return out

def load_rule_relationships(conn):
    """
    Return adjacency dict, root_list, parent_map. Merges child relationships, conflicts, global links, composite references, etc.
    For simplicity, we show a minimal BFS.
    """
    adjacency = {}
    parent_map = {}
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    all_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid
    # conflicts, global links, composite sub-rules, etc. can also be appended to adjacency
    # ...
    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]
    return (adjacency, roots, parent_map)

def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch in adjacency[cur]:
                stack.append(ch)

def execute_rules_unified_bfs(conn, dry_run=False):
    """
    BFS-based rule execution. 
    1) runs data validations first
    2) processes each rule in BFS order
    3) if a CRITICAL or GLOBAL rule fails => skip its descendants
    4) logs into RULE_EXECUTION_LOGS
    """
    run_data_validations(conn)
    adjacency, roots, pmap = load_rule_relationships(conn)
    rule_map = get_all_rules_map(conn)
    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue

        info = rule_map[rid]
        (ok, msg, rec_count) = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # if CRITICAL or GLOBAL => skip descendants
            crit = (info.get("CRITICAL_RULE",0)==1 or info.get("IS_GLOBAL",0)==1)
            if crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            # skip normal children anyway
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))

###############################################################################
# Simulations for chain BFS or custom group sets
###############################################################################
def dry_run_rule_sql(conn, sql_text: str):
    """
    Minimal approach: run in transaction, if row[0]==1 => pass else fail.
    Always rollback.
    """
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False, f"Transaction error: {ex}")
    success = True
    msg = ""
    try:
        c.execute(sql_text)
        rows = []
        try:
            rows = c.fetchall()
        except:
            pass
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg)

def simulate_chain_bfs(conn, parent_rule_id):
    """
    BFS dry-run starting from parent_rule_id. 
    If a rule fails, skip all children (and grandchildren).
    For DECISION_TABLE, run decision_table logic. 
    """
    adjacency, roots, pmap = load_rule_relationships(conn)
    r_map = get_all_rules_map(conn)
    executed = []
    skipped = set()
    queue = [parent_rule_id]

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in r_map:
            skipped.add(rid)
            continue
        info = r_map[rid]
        if (info.get("OPERATION_TYPE","OTHER")).upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, info.get("DECISION_TABLE_ID"), dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, info.get("RULE_SQL") or "")
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            # if critical => skip all
            crit = (info.get("CRITICAL_RULE",0)==1 or info.get("IS_GLOBAL",0)==1)
            if rid in adjacency:
                for cc in adjacency[rid]:
                    skip_all_descendants(cc, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))

def simulate_custom_group_rules(conn, custom_group_id):
    """
    For each rule in BRM_CUSTOM_GROUP_MEMBERS, do a single dry-run (DECISION_TABLE or normal).
    Return (passed, failed).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    members = [r[0] for r in c.fetchall()]
    r_map = get_all_rules_map(conn)
    passed, failed = [], []
    for rid in members:
        if rid not in r_map:
            failed.append(rid)
            continue
        info = r_map[rid]
        if (info.get("OPERATION_TYPE","OTHER")).upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, info.get("DECISION_TABLE_ID"), dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, info.get("RULE_SQL") or "")
        if ok:
            passed.append(rid)
        else:
            failed.append(rid)
    return (passed, failed)

###############################################################################
# Snapshot & Tag expansions
###############################################################################
# In an integrated code, we might define:
def create_snapshot(conn, snapshot_name, created_by="SnapshotUser"):
    """
    Takes snapshot of all rules from BRM_RULES into RULE_SNAPSHOTS (JSON).
    """
    c = conn.cursor()
    try:
        c.execute("SELECT * FROM BRM_RULES")
        rows = c.fetchall()
        colnames = [desc[0] for desc in c.description]
        data_list = [dict(zip(colnames, row)) for row in rows]
        snap_json = json.dumps(data_list, indent=2)
        c.execute("""
            INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
            VALUES(?,?,?)
        """, (snapshot_name, created_by, snap_json))
        conn.commit()
        logger.info(f"Snapshot '{snapshot_name}' created.")
    except Exception as ex:
        logger.error(f"Snapshot creation error: {ex}")

def diff_snapshots(conn, snap_id1, snap_id2):
    """
    Return a diff (list of changed, added, removed) between two snapshots for advanced UI compare.
    """
    c = conn.cursor()
    def load_snap(snap_id):
        c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
        row = c.fetchone()
        if not row:
            return []
        try:
            return json.loads(row[0])
        except:
            return []
    data1 = load_snap(snap_id1)
    data2 = load_snap(snap_id2)
    # do some dictionary-based comparison
    # ...
    result = {
        "added": [],
        "removed": [],
        "modified": []
    }
    # real logic might do keyed comparison by RULE_ID
    # ...
    return result

def assign_rule_tag(conn, rule_id, tag_name):
    c = conn.cursor()
    try:
        c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?, ?)", (rule_id, tag_name))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error assigning tag {tag_name} to rule {rule_id}: {ex}")

def remove_rule_tag(conn, tag_id):
    c = conn.cursor()
    try:
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error removing tag {tag_id}: {ex}")

# end of chunk 5
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 6
(Integrated codebase, chunk 6)

Focus:
 • Global/Critical Admin Tab with forced activation/deactivation
 • Visually Rich Approval Pipeline (multi-step approval pipeline UI)
 • Conflict Resolution expansions: conflict maps, priorities
 • Hierarchy & Lineage expansions: advanced interactive graph
 • Collaboration & notifications (threading, mention/tagging stubs)
"""

import sys
import os
import json
import logging
import re
from datetime import datetime, timedelta
from collections import defaultdict, deque

# PyQt5 modules
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox, QTableWidget,
    QTableWidgetItem, QAbstractItemView, QMessageBox, QInputDialog, QListWidget,
    QListWidgetItem, QSplitter, QPlainTextEdit, QDockWidget, QGraphicsView, QGraphicsScene,
    QGraphicsItem, QGraphicsEllipseItem, QGraphicsLineItem, QFileDialog
)
from PyQt5.QtGui import QPen, QBrush, QColor, QFont

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# Collaboration expansions: Threading, mention, etc.
###############################################################################
class CollaborationThreadedDialog(QtWidgets.QDialog):
    """
    Example dialog for threaded collaboration:
     - supports mention/tagging, per-rule or per-conversation ID
     - placeholders for expansions
    """
    def __init__(self, connection, conversation_id=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.conversation_id = conversation_id
        self.setWindowTitle("Threaded Collaboration – Example")
        self.resize(700, 500)
        main_layout = QVBoxLayout(self)

        self.thread_list = QListWidget()
        main_layout.addWidget(self.thread_list)

        mention_layout = QHBoxLayout()
        self.mention_edit = QLineEdit()
        self.mention_edit.setPlaceholderText("Type message... (use @username to mention)")
        mention_layout.addWidget(self.mention_edit)
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.post_message)
        mention_layout.addWidget(send_btn)
        main_layout.addLayout(mention_layout)

        self.setLayout(main_layout)
        self.load_thread()

    def load_thread(self):
        # load messages from a hypothetical "COLLABORATION_THREADS" table
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT MESSAGE, SENDER, TIMESTAMP
                FROM COLLABORATION_THREADS
                WHERE CONVERSATION_ID=?
                ORDER BY TIMESTAMP DESC
            """, (self.conversation_id,))
            rows = c.fetchall()
            self.thread_list.clear()
            for row in rows:
                msg, sender, ts = row
                txt = f"[{ts}] {sender}: {msg}"
                item = QListWidgetItem(txt)
                self.thread_list.addItem(item)
        except Exception as ex:
            logger.error(f"Error loading collaboration thread {self.conversation_id}: {ex}")

    def post_message(self):
        msg_txt = self.mention_edit.text().strip()
        if not msg_txt:
            return
        c = self.connection.cursor()
        try:
            # detect mention
            # e.g., search for @someUser
            # for now, we just store the message
            c.execute("""
                INSERT INTO COLLABORATION_THREADS(CONVERSATION_ID, MESSAGE, SENDER, TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """, (self.conversation_id, msg_txt, "CurrentUser"))
            self.connection.commit()
            self.mention_edit.clear()
            self.load_thread()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


###############################################################################
# Visually Rich Approval Pipeline
###############################################################################
class ApprovalPipelineWidget(QWidget):
    """
    A custom widget that displays a multi-stage pipeline of approvals in a visual manner.
    Each stage is shown as a node with lines connecting them, with color-coding for completed vs. pending.
    Example usage:
      pipeline = [("BG1", True), ("BG2", False), ("BG3", False), ("Global", False)]
    """
    def __init__(self, pipeline_data=None, parent=None):
        super().__init__(parent)
        self.pipeline_data = pipeline_data or []  # list of (stageName, completedFlag)
        self.setMinimumHeight(80)

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        rect = self.rect()
        stage_count = len(self.pipeline_data)
        if stage_count < 1:
            return

        # spacing
        margin = 20
        segment_width = (rect.width() - 2*margin) / (stage_count - 1) if stage_count > 1 else 1
        y_center = rect.height() / 2

        # draw lines + circles
        pen_line = QPen(QColor(100,100,100), 3)
        pen_circle_pending = QPen(QColor(150,150,150), 2)
        brush_circle_pending = QBrush(QColor(230,230,230))
        pen_circle_complete = QPen(QColor(40,180,40), 2)
        brush_circle_complete = QBrush(QColor(80,220,80))

        for i in range(stage_count-1):
            x1 = margin + i*segment_width
            x2 = margin + (i+1)*segment_width
            # check if stage i is complete -> color line
            stage1_complete = self.pipeline_data[i][1]
            stage2_complete = self.pipeline_data[i+1][1]
            # if both are complete => green line, else grey line
            if stage1_complete and stage2_complete:
                pen_line.setColor(QColor(60,200,60))
            else:
                pen_line.setColor(QColor(150,150,150))
            painter.setPen(pen_line)
            painter.drawLine(x1, y_center, x2, y_center)

        # draw circles
        for i, (stageName, completed) in enumerate(self.pipeline_data):
            xC = margin + i*segment_width
            radius = 10
            if completed:
                painter.setPen(pen_circle_complete)
                painter.setBrush(brush_circle_complete)
            else:
                painter.setPen(pen_circle_pending)
                painter.setBrush(brush_circle_pending)
            painter.drawEllipse(QtCore.QPointF(xC, y_center), radius, radius)

            # text
            text_rect = QtCore.QRectF(xC-50, y_center+15, 100, 20)
            painter.setPen(QColor(0,0,0))
            painter.drawText(text_rect, Qt.AlignCenter, stageName)


class VisualApprovalTab(QWidget):
    """
    A replacement/augmentation for the multi-step approval tab that includes a pipeline widget for each rule's approvals.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)

        self.approval_table = QTableWidget(0, 5)
        self.approval_table.setHorizontalHeaderLabels(["RuleID", "RuleName", "StagePipeline", "Approve", "Reject"])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approval_table)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)
        layout.addStretch()
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            # For demonstration, let's fetch rules that haven't been fully approved or rejected
            # We'll build a pipeline from the BRM_RULE_APPROVALS table
            c.execute("""
                SELECT R.RULE_ID, R.RULE_NAME
                FROM BRM_RULES R
                WHERE R.APPROVAL_STATUS IN ('APPROVAL_IN_PROGRESS', 'REJECTED')
                ORDER BY R.RULE_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                rule_id, rule_name = row
                # build pipeline data
                pipeline_data = self.get_pipeline_data(rule_id)
                row_index = self.approval_table.rowCount()
                self.approval_table.insertRow(row_index)
                self.approval_table.setItem(row_index, 0, QTableWidgetItem(str(rule_id)))
                self.approval_table.setItem(row_index, 1, QTableWidgetItem(rule_name))
                pipeline_widget = ApprovalPipelineWidget(pipeline_data)
                self.approval_table.setCellWidget(row_index, 2, pipeline_widget)

                # Approve/Reject button
                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, rid=rule_id: self.approve_rule(rid))
                self.approval_table.setCellWidget(row_index, 3, approve_btn)
                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, rid=rule_id: self.reject_rule(rid))
                self.approval_table.setCellWidget(row_index, 4, reject_btn)

        except Exception as ex:
            QMessageBox.critical(self, "Load Approvals Error", str(ex))

    def get_pipeline_data(self, rule_id):
        """
        Query BRM_RULE_APPROVALS for all stages of this rule, building a pipeline list of (stageName, boolCompleted).
        For example, [("BG1", True), ("BG2", False), ("Global", False)].
        """
        pipeline = []
        c = self.connection.cursor()
        c.execute("""
            SELECT GROUP_NAME, APPROVED_FLAG, APPROVAL_STAGE
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=?
            ORDER BY APPROVAL_STAGE
        """, (rule_id,))
        rows = c.fetchall()
        for row in rows:
            group_name, approved_flag, stage = row
            completed = (approved_flag == 1)
            # could rename or label the stage with something else
            label = f"{group_name} (S{stage})"
            pipeline.append((label, completed))
        return pipeline

    def approve_rule(self, rule_id):
        # For demonstration: mark your group’s stage as approved if pending
        c = self.connection.cursor()
        try:
            # find your stage
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=?
                  AND GROUP_NAME=?
                  AND APPROVED_FLAG=0
            """, (rule_id, self.user_group))
            c.execute("""
                SELECT COUNT(*) FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """, (rule_id,))
            remain = c.fetchone()[0]
            if remain == 0:
                # all approved
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                    WHERE RULE_ID=?
                """, (rule_id,))
            c.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} was approved by {self.user_group}.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Approve Error", str(ex))

    def reject_rule(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=?
                  AND GROUP_NAME=?
                  AND APPROVED_FLAG=0
            """, (rule_id, self.user_group))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """, (rule_id,))
            c.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} was rejected by {self.user_group}.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Reject Error", str(ex))


###############################################################################
# Global/Critical Admin Tab expansions
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    Enhanced with forced activation/deactivation, plus optional forced approval override, and advanced link management.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        # filter bar
        filter_layout = QHBoxLayout()
        self.show_only_global_crit = QCheckBox("Show only global or critical")
        self.show_only_global_crit.setChecked(True)
        filter_layout.addWidget(self.show_only_global_crit)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_rule_list)
        filter_layout.addWidget(refresh_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "RuleName", "OwnerGroup", "IS_GLOBAL", "CRITICAL_RULE",
            "CRITICAL_SCOPE", "Status", "Forcing", "Actions"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        # link management
        link_layout = QHBoxLayout()
        link_layout.addWidget(QLabel("Parent GCR Rule:"))
        self.parent_combo = QComboBox()
        link_layout.addWidget(self.parent_combo)
        link_layout.addWidget(QLabel("Child Rule:"))
        self.child_combo = QComboBox()
        link_layout.addWidget(self.child_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child_rule)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child_rule)
        link_layout.addWidget(link_btn)
        link_layout.addWidget(unlink_btn)
        link_layout.addStretch()
        layout.addLayout(link_layout)

        # GCR link table
        self.link_table = QTableWidget(0, 2)
        self.link_table.setHorizontalHeaderLabels(["ParentGCR", "ChildRule"])
        self.link_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_table)

        layout.addStretch()
        self.setLayout(layout)
        self.refresh_link_data()
        self.load_rule_list()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            if self.show_only_global_crit.isChecked():
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                           CRITICAL_SCOPE, STATUS
                    FROM BRM_RULES
                    WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                    ORDER BY RULE_ID DESC
                """)
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                           CRITICAL_SCOPE, STATUS
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                """)
            rows = c.fetchall()
            for row in rows:
                row_idx = self.rule_table.rowCount()
                self.rule_table.insertRow(row_idx)
                (rid, rname, og, isg, crit, scope, stat) = row
                self.rule_table.setItem(row_idx, 0, QTableWidgetItem(str(rid)))
                self.rule_table.setItem(row_idx, 1, QTableWidgetItem(rname))
                self.rule_table.setItem(row_idx, 2, QTableWidgetItem(og))
                self.rule_table.setItem(row_idx, 3, QTableWidgetItem(str(isg)))
                self.rule_table.setItem(row_idx, 4, QTableWidgetItem(str(crit)))
                self.rule_table.setItem(row_idx, 5, QTableWidgetItem(str(scope)))
                self.rule_table.setItem(row_idx, 6, QTableWidgetItem(str(stat)))
                forcing_item = QTableWidgetItem("")
                self.rule_table.setItem(row_idx, 7, forcing_item)  # future expansions
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                act_btn1 = QPushButton("ForceActivate")
                act_btn1.clicked.connect(lambda _, r_id=rid: self.force_activate(r_id))
                act_btn2 = QPushButton("ForceDeactivate")
                act_btn2.clicked.connect(lambda _, r_id=rid: self.force_deactivate(r_id))
                action_layout.addWidget(act_btn1)
                action_layout.addWidget(act_btn2)
                action_layout.addStretch()
                action_widget.setLayout(action_layout)
                self.rule_table.setCellWidget(row_idx, 8, action_widget)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def force_activate(self, rule_id):
        # forcibly sets rule to ACTIVE, ignoring approvals
        confirm = QMessageBox.question(self, "Force Activate", f"Really force-activate rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE', APPROVAL_STATUS='FORCE_ACTIVATED'
                WHERE RULE_ID=?
            """, (rule_id,))
            c.execute("""
                DELETE FROM BRM_RULE_LOCKS
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """, (rule_id,))
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=?
            """, (rule_id,))
            c.commit()
            QMessageBox.information(self, "ForceActivated", f"Rule {rule_id} is now active.")
            self.load_rule_list()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def force_deactivate(self, rule_id):
        confirm = QMessageBox.question(self, "Force Deactivate", f"Really force-deactivate rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE', APPROVAL_STATUS='FORCE_DEACTIVATED'
                WHERE RULE_ID=?
            """, (rule_id,))
            # optionally skip children or forcibly remove locks
            c.execute("""
                DELETE FROM BRM_RULE_LOCKS
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """, (rule_id,))
            c.commit()
            QMessageBox.information(self, "ForceDeactivated", f"Rule {rule_id} is now inactive.")
            self.load_rule_list()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def refresh_link_data(self):
        self.link_table.setRowCount(0)
        self.parent_combo.clear()
        self.child_combo.clear()
        c = self.connection.cursor()
        try:
            # load links
            c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
            links = c.fetchall()
            for lrow in links:
                pr, ch = lrow
                row_idx = self.link_table.rowCount()
                self.link_table.insertRow(row_idx)
                self.link_table.setItem(row_idx, 0, QTableWidgetItem(str(pr)))
                self.link_table.setItem(row_idx, 1, QTableWidgetItem(str(ch)))
            # load combos
            c.execute("""
                SELECT RULE_ID, RULE_NAME 
                FROM BRM_RULES
                WHERE CRITICAL_RULE=1 OR IS_GLOBAL=1
                ORDER BY RULE_ID
            """)
            for rr in c.fetchall():
                self.parent_combo.addItem(f"{rr[0]} - {rr[1]}", rr[0])
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rr in c.fetchall():
                self.child_combo.addItem(f"{rr[0]} - {rr[1]}", rr[0])
        except Exception as ex:
            logger.error(f"Error loading link data: {ex}")

    def link_child_rule(self):
        parent_id = self.parent_combo.currentData()
        child_id = self.child_combo.currentData()
        if not parent_id or not child_id:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID)
                VALUES(?,?)
            """, (parent_id, child_id))
            c.commit()
            QMessageBox.information(self, "Linked", f"Child rule {child_id} linked to GCR {parent_id}.")
            self.refresh_link_data()
        except Exception as ex:
            QMessageBox.critical(self, "Link Error", str(ex))

    def unlink_child_rule(self):
        parent_id = self.parent_combo.currentData()
        child_id = self.child_combo.currentData()
        if not parent_id or not child_id:
            return
        confirm = QMessageBox.question(self, "Confirm", f"Unlink {child_id} from {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
                WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
            """, (parent_id, child_id))
            c.commit()
            QMessageBox.information(self, "Unlinked", f"{child_id} unlinked from {parent_id}.")
            self.refresh_link_data()
        except Exception as ex:
            QMessageBox.critical(self, "Unlink Error", str(ex))


###############################################################################
# Conflict resolution expansions
###############################################################################
class ConflictResolutionTab(QWidget):
    """
    Visual conflict map + triage approach
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.conflict_table = QTableWidget(0, 5)
        self.conflict_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority", "Actions"])
        self.conflict_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.conflict_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        triage_btn = QPushButton("Open Visual Triage")
        triage_btn.clicked.connect(self.open_visual_conflict_map)
        btn_layout.addWidget(triage_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.conflict_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows = c.fetchall()
            for row in rows:
                cf_id, r1, r2, prio = row
                row_idx = self.conflict_table.rowCount()
                self.conflict_table.insertRow(row_idx)
                self.conflict_table.setItem(row_idx, 0, QTableWidgetItem(str(cf_id)))
                self.conflict_table.setItem(row_idx, 1, QTableWidgetItem(str(r1)))
                self.conflict_table.setItem(row_idx, 2, QTableWidgetItem(str(r2)))
                self.conflict_table.setItem(row_idx, 3, QTableWidgetItem(str(prio)))
                # action cell
                action_w = QWidget()
                action_l = QHBoxLayout(action_w)
                setp_btn = QPushButton("Set Priority")
                setp_btn.clicked.connect(lambda _, cfid=cf_id: self.set_priority(cfid))
                del_btn = QPushButton("Delete")
                del_btn.clicked.connect(lambda _, cfid=cf_id: self.delete_conflict(cfid))
                action_l.addWidget(setp_btn)
                action_l.addWidget(del_btn)
                action_l.addStretch()
                action_w.setLayout(action_l)
                self.conflict_table.setCellWidget(row_idx, 4, action_w)
        except Exception as ex:
            QMessageBox.critical(self, "Conflict Load Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self, conflict_id):
        new_p, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {conflict_id}:", value=1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_p, conflict_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_conflict(self, conflict_id):
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete conflict {conflict_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (conflict_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Conflict {conflict_id} removed.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def open_visual_conflict_map(self):
        dlg = VisualConflictMapDialog(self.connection, self)
        dlg.exec_()


class VisualConflictMapDialog(QtWidgets.QDialog):
    """
    A minimal approach to show conflict pairs in a QGraphicsScene with lines between them. 
    For advanced usage, consider re-using the EnhancedLineageGraph approach.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Visual Conflict Map")
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        self.scene = QGraphicsScene()
        self.view = QGraphicsView(self.scene)
        layout.addWidget(self.view)
        btn_layout = QHBoxLayout()
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.scene.clear()
        # fetch conflict pairs
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
            conflicts = c.fetchall()
            # we'll arrange them in a naive circle
            rule_nodes = {}
            all_rules = set()
            for cf in conflicts:
                _, r1, r2, _ = cf
                all_rules.add(r1)
                all_rules.add(r2)
            rule_list = sorted(list(all_rules))
            import math
            radius = 200
            center_x = 400
            center_y = 300
            step_angle = 2*math.pi / (len(rule_list) if len(rule_list)>0 else 1)
            for i, rr in enumerate(rule_list):
                angle = i*step_angle
                x = center_x + radius*math.cos(angle)
                y = center_y + radius*math.sin(angle)
                node = ConflictNodeItem(rr)
                node.setPos(x, y)
                self.scene.addItem(node)
                rule_nodes[rr] = node

            # draw lines
            for cfid, r1, r2, prio in conflicts:
                if r1 in rule_nodes and r2 in rule_nodes:
                    edge = ConflictEdgeItem(rule_nodes[r1], rule_nodes[r2], priority=prio)
                    self.scene.addItem(edge)
        except Exception as ex:
            logger.error(f"Conflict map error: {ex}")

class ConflictNodeItem(QGraphicsEllipseItem):
    """
    A circle to represent a rule in the conflict map.
    """
    def __init__(self, rule_id):
        super().__init__(-20, -20, 40, 40)
        self.rule_id = rule_id
        self.setPen(QPen(QColor(0,0,0), 2))
        self.setBrush(QBrush(QColor(255,230,230)))
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable)
        # text label
        self.text_item = QGraphicsTextItem(str(rule_id), self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setPos(-10, -10)

class ConflictEdgeItem(QGraphicsLineItem):
    """
    A line connecting two conflict nodes, color-coded by priority
    """
    def __init__(self, source_node, dest_node, priority=1):
        super().__init__()
        self.source = source_node
        self.dest = dest_node
        self.priority = priority
        self.updatePosition()

        # choose color
        color_map = {
            1: QColor(255,0,0),
            2: QColor(255,120,0),
            3: QColor(255,180,0),
        }
        col = color_map.get(priority, QColor(180,180,180))
        pen = QPen(col, 2)
        self.setPen(pen)

    def updatePosition(self):
        line = QtCore.QLineF(self.source.pos(), self.dest.pos())
        self.setLine(line)


###############################################################################
# Hierarchy & Interactive Graph expansions
###############################################################################
# (See earlier chunk for HierarchyViewTab, EnhancedLineageGraphWidget, etc.)

# End of chunk 6
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 7
(Integrated codebase, chunk 7)

Focus:
 • Parallel vs. Serial Approvals expansions (with partial DB model changes)
 • Task & Notification Center expansions for "My Tasks"
 • Preliminary stubs for advanced RBAC/ABAC checks
"""

import sys
import os
import json
import logging
from datetime import datetime, timedelta
from collections import defaultdict, deque

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox, QLineEdit,
    QListWidget, QListWidgetItem, QTableWidget, QTableWidgetItem, QMessageBox, QInputDialog
)

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# Extended DB / Model Notes (for parallel approvals, advanced RBAC)
###############################################################################
"""
In a real implementation, you may need new DB fields such as:
 - BRM_RULE_APPROVALS.PARALLEL_GROUP or STAGE_GROUP to allow multiple rows
   of the same 'stage' to be approved in parallel.
 - A 'minimum_approvals' or 'quorum' concept if you want, e.g., 2 of 3 must approve.

For advanced RBAC/ABAC, we might have tables:
 - RBAC_ROLES (ROLE_ID, ROLE_NAME)
 - RBAC_USER_ROLES (USER_ID, ROLE_ID)
 - PERMISSIONS or POLICIES that map roles to certain actions or attributes.

We can only place stubs in code here, because your environment might vary.
"""


###############################################################################
# Parallel vs. Serial Approvals
###############################################################################
class ParallelApprovalManager:
    """
    Demonstration of an approval manager that supports either serial or parallel logic:
      - 'SERIAL': Each stage's approvals must fully complete before next stage starts.
      - 'PARALLEL': The group(s) at the current stage can each independently set approval flags,
        but the rule can proceed to next stage if a required quorum or set of parallel groups is done.

    For demonstration, we store some 'approval_mode' in the DB, or pass as argument.
    """

    @staticmethod
    def check_approval_status(conn, rule_id):
        """
        Returns a dict summarizing the approval status: { 'complete': bool, 'stage': X, 'parallel_done': bool }
        Real logic might be more advanced depending on the DB schema.
        """
        c = conn.cursor()
        # Example: if all rows in BRM_RULE_APPROVALS for rule_id have APPROVED_FLAG in (1 or 2), then it's done.
        # We'll say if any is 2 => REJECT => entire rule is REJECTED.
        # If 'SERIAL', we need to check the highest stage that has not completed.
        # If 'PARALLEL', we might check how many approvals are required for the stage, etc.
        # For demonstration, we do a simple check:
        c.execute("""
            SELECT APPROVAL_STAGE, APPROVED_FLAG
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=?
        """, (rule_id,))
        rows = c.fetchall()
        if not rows:
            return {"complete": True, "stage": 0, "parallel_done": True}

        # If any APPROVED_FLAG=2 => REJECT
        if any(r[1] == 2 for r in rows):
            return {"complete": True, "stage": -1, "parallel_done": False}  # or something

        # let's find the max stage
        max_stage = max(r[0] for r in rows)
        # check if all are flagged 1 or 2 => done
        all_done = all(r[1] in (1,2) for r in rows)
        # for parallel, we might do partial check
        return {
            "complete": all_done,
            "stage": max_stage,
            "parallel_done": all_done
        }


###############################################################################
# My Tasks / Task & Notification Center expansions
###############################################################################
class MyTasksPanel(QWidget):
    """
    An example panel that consolidates tasks:
      - approvals pending
      - conflicts to triage
      - stale locks, etc.
    This is a simplified demonstration. 
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        title = QLabel(f"Tasks for {self.user_group} / user={self.user_id}")
        title.setStyleSheet("font-weight: bold; font-size: 14px;")
        layout.addWidget(title)

        self.task_list = QListWidget()
        layout.addWidget(self.task_list)

        refresh_btn = QPushButton("Refresh Tasks")
        refresh_btn.clicked.connect(self.load_tasks)
        layout.addWidget(refresh_btn)
        layout.addStretch()
        self.setLayout(layout)
        self.load_tasks()

    def load_tasks(self):
        self.task_list.clear()
        # example: load pending approvals for user
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT A.RULE_ID, R.RULE_NAME, A.APPROVAL_STAGE
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.GROUP_NAME=? AND A.APPROVED_FLAG=0
                ORDER BY A.APPROVAL_STAGE
            """, (self.user_group,))
            approvals = c.fetchall()
            if approvals:
                self.task_list.addItem("=== Pending Approvals ===")
                for ap in approvals:
                    rid, rname, stg = ap
                    self.task_list.addItem(f"Rule {rid} - {rname} [Stage {stg}] pending your approval")

            # conflicts assigned to user or group?
            c.execute("""
                SELECT C.CONFLICT_ID, C.RULE_ID1, C.RULE_ID2, C.PRIORITY
                FROM RULE_CONFLICTS C
                JOIN BUSINESS_GROUPS G ON G.GROUP_NAME=?
                -- some join logic or ownership logic if needed
                ORDER BY C.CONFLICT_ID
            """, (self.user_group,))
            confs = c.fetchall()
            if confs:
                self.task_list.addItem("=== Conflicts to Triage ===")
                for cf in confs:
                    cfid, r1, r2, pr = cf
                    self.task_list.addItem(f"Conflict {cfid} => R{r1} vs. R{r2}, priority={pr}")

            # stale locks that the user might handle
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, EXPIRY_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < GETDATE()
            """)
            stales = c.fetchall()
            if stales:
                self.task_list.addItem("=== Stale Locks ===")
                for st in stales:
                    rid, lby, expt = st
                    # if user is admin or if user is same as locked_by, they can fix
                    if (self.user_group == "Admin") or (lby == self.get_username()):
                        self.task_list.addItem(f"Rule {rid} locked by {lby}, expired {expt} => fix?")
        except Exception as ex:
            self.task_list.addItem(f"Error loading tasks: {ex}")

    def get_username(self):
        # fetch from DB
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = c.fetchone()
            return row[0] if row else "UnknownUser"
        except:
            return "UnknownUser"


###############################################################################
# RBAC / ABAC stubs
###############################################################################
def user_has_permission(conn, user_id, action, resource):
    """
    Example check if a user can 'action' a 'resource', using a table or ABAC logic.
    Returns True/False.
    In real code, we'd query RBAC_ROLES, user->role mappings, or custom policy logic.
    """
    c = conn.cursor()
    try:
        # for demonstration, assume if user is Admin => always true
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if row and row[0].upper() == "ADMIN":
            return True

        # else do custom checks
        # placeholder
        return True
    except:
        return False

# End of chunk 7
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 8
(Integrated codebase, chunk 8)

Focus:
 • Visual Approval Pipeline (multi-step, possibly parallel)
 • AIOps expansions (anomaly detection stubs, auto-escalation)
 • Extended RBAC examples (e.g., column-level security stubs)
 • Heatmap usage analytics
"""

import sys
import os
import json
import logging
from datetime import datetime, timedelta
import math
import numpy as np  # For possible heatmaps or anomaly detection placeholders

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QPainter, QColor, QBrush, QFont
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QLineEdit, QComboBox,
    QTableWidget, QTableWidgetItem, QPlainTextEdit, QGraphicsView, QGraphicsScene,
    QGraphicsItem, QGraphicsRectItem, QMessageBox, QInputDialog
)

logger = logging.getLogger("brm_core_foundation")

###############################################################################
# 1) Visual Approval Pipeline
###############################################################################
class ApprovalPipelineWidget(QWidget):
    """
    A visually richer pipeline for multi-step approvals.
    This widget expects data about the rule’s approval stages and current statuses.
    Example pipeline:
        Stage 1 (BG1) -> Stage 2 (BG2) -> Stage 3 (GlobalApprovers)
    Each stage is rendered as a box or node, with arrows between them. 
    If parallel, it might branch or show multiple lines.

    This is a conceptual demonstration. Real usage might require a separate canvas or scene.
    """
    def __init__(self, stages_info, parent=None):
        super().__init__(parent)
        self.stages_info = stages_info  # e.g. list of dicts: [ { 'stage':1, 'group':'BG1', 'status':'APPROVED' }, ... ]
        self.setMinimumHeight(120)
        self.setMinimumWidth(600)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        if not self.stages_info:
            painter.drawText(10, 20, "No pipeline data available.")
            return

        # For demonstration, draw each stage as a rectangle, horizontally spaced.
        margin = 50
        spacing = 200
        top_y = 40
        rect_w = 120
        rect_h = 50

        for i, stage in enumerate(self.stages_info):
            # x position
            x = margin + i * spacing
            # pick color based on status
            status = stage.get('status', '').upper()
            if status == 'APPROVED':
                color = QColor(144, 238, 144)
            elif status == 'REJECTED':
                color = QColor(255, 182, 193)
            elif status == 'PENDING':
                color = QColor(255, 255, 153)
            else:
                color = QColor(200, 200, 200)

            painter.setBrush(QBrush(color))
            painter.drawRect(x, top_y, rect_w, rect_h)

            # stage text
            stage_label = f"Stage {stage['stage']}"
            group_label = stage['group']
            painter.drawText(x+5, top_y+20, stage_label)
            painter.drawText(x+5, top_y+40, f"({group_label})")

            # arrow to next stage
            if i < len(self.stages_info)-1:
                arrow_start_x = x + rect_w
                arrow_start_y = top_y + rect_h/2
                arrow_end_x = arrow_start_x + (spacing - rect_w)
                arrow_end_y = arrow_start_y
                painter.drawLine(arrow_start_x, arrow_start_y, arrow_end_x, arrow_end_y)
                # draw arrow head
                painter.drawLine(arrow_end_x, arrow_end_y, arrow_end_x - 10, arrow_end_y - 5)
                painter.drawLine(arrow_end_x, arrow_end_y, arrow_end_x - 10, arrow_end_y + 5)


def fetch_approval_pipeline_data(conn, rule_id):
    """
    Example function that returns pipeline data in structured format.
    E.g. [ { 'stage':1, 'group':'BG1', 'status':'APPROVED' }, ... ]
    Real logic depends on your BRM_RULE_APPROVALS schema, parallel flags, etc.
    """
    c = conn.cursor()
    c.execute("""
        SELECT APPROVAL_STAGE, GROUP_NAME, APPROVED_FLAG
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=?
        ORDER BY APPROVAL_STAGE
    """, (rule_id,))
    rows = c.fetchall()
    pipeline_data = []
    for r in rows:
        stg = r[0]
        grp = r[1]
        flg = r[2]
        if flg == 1:
            st = "APPROVED"
        elif flg == 2:
            st = "REJECTED"
        else:
            st = "PENDING"
        pipeline_data.append({
            "stage": stg,
            "group": grp,
            "status": st
        })
    return pipeline_data


class VisualApprovalDialog(QtWidgets.QDialog):
    """
    Demonstrates showing the visual pipeline for a single rule.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Approval Pipeline for Rule {rule_id}")
        self.resize(800, 200)
        vbox = QVBoxLayout(self)

        # fetch data
        pipeline_data = fetch_approval_pipeline_data(self.connection, self.rule_id)
        self.pipeline_widget = ApprovalPipelineWidget(pipeline_data)
        vbox.addWidget(self.pipeline_widget)

        btn = QPushButton("Close")
        btn.clicked.connect(self.close)
        vbox.addWidget(btn)
        self.setLayout(vbox)

###############################################################################
# 2) AIOps expansions: anomaly detection stubs, auto-escalation
###############################################################################
def detect_rule_anomalies(conn, rule_id):
    """
    Placeholder: Analyzes RULE_EXECUTION_LOGS or RULE_PERF_STATS for anomalies in pass/fail or resource usage.

    For example: If fail rates spiked over the last 7 days, or average exec time is 2 stddev above baseline.
    Returns dict with 'anomaly_found': bool, 'detail': str
    """
    c = conn.cursor()
    try:
        # Simplistic approach: check fail ratio in last 30 runs vs. historical average
        c.execute("""
            SELECT TOP 30 PASS_FLAG
            FROM RULE_EXECUTION_LOGS
            WHERE RULE_ID=?
            ORDER BY EXECUTION_TIMESTAMP DESC
        """, (rule_id,))
        recent_runs = c.fetchall()
        if not recent_runs:
            return {"anomaly_found": False, "detail": "No runs found."}
        total_runs = len(recent_runs)
        fails = sum(1 for r in recent_runs if r[0] == 0)
        fail_ratio = fails / total_runs

        # For demonstration, if fail_ratio > 0.5 => anomaly
        if fail_ratio > 0.5:
            return {"anomaly_found": True, "detail": f"Fail ratio {fail_ratio:.2f} in last {total_runs} runs."}
        return {"anomaly_found": False, "detail": f"Fail ratio {fail_ratio:.2f} seems normal."}
    except Exception as ex:
        return {"anomaly_found": False, "detail": f"Error detecting anomalies: {ex}"}


def auto_escalate_issue(conn, rule_id, issue_detail):
    """
    Placeholder: escalates an anomaly to a queue or triggers an auto-healing script.
    Might send an email or create a ticket in an external system. 
    """
    # Example: we just log it
    logger.warning(f"[AUTO-ESCALATE] Rule {rule_id} => {issue_detail}")
    # Could do something else, like update a table or call an API.


###############################################################################
# 3) Extended RBAC examples
###############################################################################
def check_column_security(conn, user_id, column_name):
    """
    Example stub that checks if user can see or reference a given column.
    Could store row in a table like 'COLUMN_SECURITY_POLICIES'.
    """
    c = conn.cursor()
    try:
        # e.g. if column_name is "Sensitive_Data" and user is not in 'FinanceGroup', deny.
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if row and row[0].upper() == "ADMIN":
            return True
        # Example check
        if "sensitive" in column_name.lower():
            # maybe only finance or admin can see
            if row and "Finance" in row[0]:
                return True
            else:
                return False
        return True
    except:
        return True


###############################################################################
# 4) Heatmap usage analytics
###############################################################################
class TimeOfDayHeatmapWidget(QWidget):
    """
    Simple placeholder to show rule usage or pass/fail data in a time-of-day matrix.
    For demonstration, it randomly draws squares in color-coded intensities.
    """
    def __init__(self, usage_data=None, parent=None):
        super().__init__(parent)
        self.usage_data = usage_data or {}  # e.g. dict {(hour, day_of_week): count}

        self.setMinimumSize(400, 300)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        # Suppose we want a 7 (days) x 24 (hours) grid
        # usage_data might be usage_data[(h, d)] => count
        cell_w = self.width() / 24
        cell_h = self.height() / 7

        # find max usage to scale color
        if not self.usage_data:
            max_usage = 1
        else:
            max_usage = max(self.usage_data.values())

        for d in range(7):
            for h in range(24):
                usage_val = self.usage_data.get((h, d), 0)
                # color scale
                intensity = int((usage_val / max_usage) * 255)
                color = QColor(255, 255 - intensity, 255 - intensity)
                painter.setBrush(QBrush(color))
                x = h * cell_w
                y = d * cell_h
                painter.drawRect(x, y, cell_w, cell_h)

        # optionally draw axis labels
        painter.setPen(Qt.black)
        # hour labels along top
        for h in range(24):
            label = f"{h}"
            painter.drawText(h*cell_w+2, 10, label)
        # day labels along left side
        day_labels = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
        for d in range(7):
            painter.drawText(2, d*cell_h+15, day_labels[d % 7])

def load_time_of_day_usage_data(conn, rule_id=None):
    """
    Example method: query RULE_EXECUTION_LOGS or RULE_PERF_STATS to find usage count by hour of day + day of week.
    Return dict {(hour, dayOfWeek): usage_count}
    """
    data = {}
    c = conn.cursor()
    try:
        if rule_id:
            c.execute("""
                SELECT DATEPART(HOUR, EXECUTION_TIMESTAMP) as hr,
                       DATEPART(WEEKDAY, EXECUTION_TIMESTAMP) as wd,
                       COUNT(*) as cnt
                FROM RULE_EXECUTION_LOGS
                WHERE RULE_ID=?
                GROUP BY DATEPART(HOUR, EXECUTION_TIMESTAMP),
                         DATEPART(WEEKDAY, EXECUTION_TIMESTAMP)
            """, (rule_id,))
        else:
            # all rules
            c.execute("""
                SELECT DATEPART(HOUR, EXECUTION_TIMESTAMP) as hr,
                       DATEPART(WEEKDAY, EXECUTION_TIMESTAMP) as wd,
                       COUNT(*) as cnt
                FROM RULE_EXECUTION_LOGS
                GROUP BY DATEPART(HOUR, EXECUTION_TIMESTAMP),
                         DATEPART(WEEKDAY, EXECUTION_TIMESTAMP)
            """)
        rows = c.fetchall()
        for r in rows:
            hr = r[0]
            wd = r[1]
            cnt = r[2]
            # note: T-SQL WEEKDAY=1 means Sunday by default, but let's just store raw
            # or map to 0-based
            # For demonstration, let's map: Sunday=6, Monday=0, etc., or you can keep as is
            day_index = (wd + 5) % 7  # simple shift so that Monday=0
            data[(hr, day_index)] = cnt
        return data
    except Exception as ex:
        logger.error(f"Error loading time-of-day usage: {ex}")
        return {}


###############################################################################
# Example usage of advanced expansions
###############################################################################
class AIOpsInspectorDialog(QtWidgets.QDialog):
    """
    Show anomalies or triggers for a given rule, optionally auto-escalate if found.
    Also includes a small usage heatmap for the rule’s execution times.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"AIOps Inspector for Rule {rule_id}")
        self.resize(600, 500)
        main_layout = QVBoxLayout(self)

        # anomaly check
        anom_btn = QPushButton("Check for Anomalies")
        anom_btn.clicked.connect(self.do_check_anomalies)
        main_layout.addWidget(anom_btn)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        main_layout.addWidget(self.result_text)

        # usage heatmap
        usage_data = load_time_of_day_usage_data(self.connection, self.rule_id)
        self.heatmap = TimeOfDayHeatmapWidget(usage_data)
        main_layout.addWidget(self.heatmap)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        main_layout.addWidget(close_btn)

        self.setLayout(main_layout)

    def do_check_anomalies(self):
        info = detect_rule_anomalies(self.connection, self.rule_id)
        if info["anomaly_found"]:
            self.result_text.appendPlainText(f"Anomaly found: {info['detail']}")
            # auto-escalate if we want
            auto_escalate_issue(self.connection, self.rule_id, info["detail"])
        else:
            self.result_text.appendPlainText(f"No anomaly: {info['detail']}")


# End of chunk 8
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 9
(Integrated codebase, chunk 9)

Focus:
 • Parallel approvals & pipeline logic
 • Extended RBAC integration (table-level & partial column security)
 • Enhanced “What-If” Testing UI with inline data editor
 • Snapshot Compare or “Diff Wizard” placeholders
 • Minor fix-ups from the final test pass
"""

import sys
import os
import json
import logging
from datetime import datetime, timedelta

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QComboBox, QLineEdit, QFileDialog, QPlainTextEdit,
    QMessageBox, QInputDialog, QWidget
)

logger = logging.getLogger("brm_master_part9")


###############################################################################
# 1) Parallel Approvals logic (placeholder)
###############################################################################
def load_rule_approvals(conn, rule_id):
    """
    For demonstration, fetch all approvals for a rule, possibly including parallel stages.
    This might involve columns like: APPROVAL_STAGE, PARALLEL_GROUP, APPROVED_FLAG, etc.

    Returns a structure like:
        [
          { 'stage':1, 'group':'BG1', 'parallel_key':None, 'approved_flag':0, 'username':'alice' },
          { 'stage':1, 'group':'BG2', 'parallel_key':None, 'approved_flag':1, 'username':'bob' },
          ...
        ]
    """
    c = conn.cursor()
    c.execute("""
        SELECT APPROVAL_STAGE, GROUP_NAME, USERNAME, APPROVED_FLAG, PARALLEL_KEY
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=?
        ORDER BY APPROVAL_STAGE, PARALLEL_KEY
    """, (rule_id,))
    rows = c.fetchall()
    results = []
    for (stg, grp, usr, flg, par) in rows:
        results.append({
            "stage": stg,
            "group": grp,
            "username": usr,
            "approved_flag": flg,
            "parallel_key": par
        })
    return results


def can_rule_advance_to_next_stage(approvals_list, stage):
    """
    Example logic: if any parallel approvals exist at the given stage, 
    we require them ALL to be approved (flag=1) before advancing the rule.

    If any single approval in that stage is REJECTED (flag=2),
    the rule is considered rejected overall.
    """
    stage_approvals = [ap for ap in approvals_list if ap["stage"] == stage]
    if not stage_approvals:
        return True  # no approvals at that stage -> skip

    # if any is REJECTED => rule is rejected
    if any(ap["approved_flag"] == 2 for ap in stage_approvals):
        return False
    # else we require all to be APPROVED
    if all(ap["approved_flag"] == 1 for ap in stage_approvals):
        return True
    return False


###############################################################################
# 2) Additional RBAC expansions
###############################################################################
def rbac_can_user_execute_rule(conn, user_id, rule_id):
    """
    Example function verifying that the user can execute (simulate, run BFS, etc.) a given rule.
    Possibly check group membership, rule ownership, or special roles in a table like GROUP_PERMISSIONS.
    """
    c = conn.cursor()
    # demonstration only: user group must match rule's OWNER_GROUP or user is Admin
    c.execute("SELECT R.OWNER_GROUP, U.USER_GROUP FROM BRM_RULES R JOIN USERS U ON U.USER_ID=? WHERE R.RULE_ID=?",
              (user_id, rule_id))
    row = c.fetchone()
    if not row:
        return False
    rule_owner_group, user_grp = row
    if user_grp.upper() == "ADMIN":
        return True
    return (rule_owner_group.lower() == user_grp.lower())


###############################################################################
# 3) Enhanced "What-If" tab: inline data editor
###############################################################################
class InlineTestDataEditorDialog(QDialog):
    """
    Provides a small table to input or edit test data (similar to a spreadsheet).
    We only store the data in memory for the “What-If” scenario. 
    Optionally, we can allow CSV import/export.
    """
    def __init__(self, column_headers=None, initial_data=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Test Data Editor")
        self.resize(600, 400)
        self.column_headers = column_headers or ["Column1","Column2","Column3"]
        self.initial_data = initial_data or []

        main_layout = QVBoxLayout(self)
        self.table = QTableWidget(0, len(self.column_headers))
        self.table.setHorizontalHeaderLabels(self.column_headers)
        main_layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        add_row_btn = QPushButton("Add Row")
        add_row_btn.clicked.connect(self.add_row)
        btn_layout.addWidget(add_row_btn)
        del_row_btn = QPushButton("Delete Row")
        del_row_btn.clicked.connect(self.delete_row)
        btn_layout.addWidget(del_row_btn)
        import_btn = QPushButton("Import CSV")
        import_btn.clicked.connect(self.import_csv)
        btn_layout.addWidget(import_btn)
        export_btn = QPushButton("Export CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addWidget(export_btn)

        apply_btn = QPushButton("Apply")
        apply_btn.clicked.connect(self.apply_changes)
        btn_layout.addWidget(apply_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)

        btn_layout.addStretch()
        main_layout.addLayout(btn_layout)
        self.setLayout(main_layout)

        # load initial data
        for row_data in self.initial_data:
            self._append_row_data(row_data)

    def add_row(self):
        row_i = self.table.rowCount()
        self.table.insertRow(row_i)

    def delete_row(self):
        row = self.table.currentRow()
        if row >= 0:
            self.table.removeRow(row)

    def import_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                lines = f.read().splitlines()
            # simple approach: first line might be headers
            # or skip if you want to keep existing columns
            self.table.setRowCount(0)
            for idx, line in enumerate(lines):
                parts = line.split(",")
                # if idx=0 might be header => skip or parse
                # for demonstration, let's parse data as rows
                row_i = self.table.rowCount()
                self.table.insertRow(row_i)
                for col_i in range(min(len(parts), self.table.columnCount())):
                    self.table.setItem(row_i, col_i, QTableWidgetItem(parts[col_i]))
        except Exception as ex:
            QMessageBox.critical(self, "Import Error", str(ex))

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                # optionally write column_headers
                f.write(",".join(self.column_headers) + "\n")
                for r in range(self.table.rowCount()):
                    row_vals = []
                    for c in range(self.table.columnCount()):
                        it = self.table.item(r, c)
                        row_vals.append(it.text() if it else "")
                    f.write(",".join(row_vals) + "\n")
            QMessageBox.information(self, "Exported", f"CSV exported to {path}")
        except Exception as ex:
            QMessageBox.critical(self, "Export Error", str(ex))

    def apply_changes(self):
        # gather data from the table
        row_list = []
        for r in range(self.table.rowCount()):
            row_vals = []
            for c in range(self.table.columnCount()):
                it = self.table.item(r, c)
                row_vals.append(it.text() if it else "")
            row_list.append(row_vals)
        # store in some attribute
        self.result_data = row_list
        self.accept()

    def _append_row_data(self, row_data):
        row_i = self.table.rowCount()
        self.table.insertRow(row_i)
        for c, val in enumerate(row_data):
            self.table.setItem(row_i, c, QTableWidgetItem(str(val)))


###############################################################################
# 4) Snapshot compare / Diff Wizard (placeholder)
###############################################################################
class SnapshotCompareDialog(QDialog):
    """
    Allows picking two snapshots (or snapshot vs. current) and shows a diff of rules.
    For demonstration, we just show text-based diffs or a list of changed/added/removed rule IDs.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Snapshot Compare Wizard")
        self.resize(700, 500)
        main_layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        self.snap_combo_1 = QComboBox()
        self.snap_combo_2 = QComboBox()
        top_layout.addWidget(QLabel("Snapshot A:"))
        top_layout.addWidget(self.snap_combo_1)
        top_layout.addWidget(QLabel("Snapshot B:"))
        top_layout.addWidget(self.snap_combo_2)
        btn_load = QPushButton("Load Snapshots")
        btn_load.clicked.connect(self.load_snapshots)
        top_layout.addWidget(btn_load)
        main_layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        main_layout.addWidget(self.result_text)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        main_layout.addWidget(close_btn)
        self.setLayout(main_layout)

        self.init_snapshot_combos()

    def init_snapshot_combos(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows = c.fetchall()
            for r in rows:
                snap_id, snap_n = r
                disp = f"{snap_id} - {snap_n}"
                self.snap_combo_1.addItem(disp, snap_id)
                self.snap_combo_2.addItem(disp, snap_id)
        except Exception as ex:
            logger.error(f"Error loading snapshot combos: {ex}")

    def load_snapshots(self):
        sid1 = self.snap_combo_1.currentData()
        sid2 = self.snap_combo_2.currentData()
        if sid1 is None or sid2 is None:
            return
        # fetch JSON from both
        c = self.connection.cursor()
        try:
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (sid1,))
            row1 = c.fetchone()
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (sid2,))
            row2 = c.fetchone()
            if not row1 or not row2:
                self.result_text.setPlainText("Snapshots not found.")
                return
            data1 = json.loads(row1[0] or "[]")
            data2 = json.loads(row2[0] or "[]")
            # let's gather rule_ids from both
            set1 = set(d["RULE_ID"] for d in data1)
            set2 = set(d["RULE_ID"] for d in data2)
            added = set2 - set1
            removed = set1 - set2
            intersection = set1 & set2
            changed = []
            for rid in intersection:
                # find the rule in data1 & data2, compare e.g. RULE_SQL or version
                old_obj = next((x for x in data1 if x["RULE_ID"]==rid), None)
                new_obj = next((x for x in data2 if x["RULE_ID"]==rid), None)
                if old_obj and new_obj:
                    if old_obj.get("RULE_SQL") != new_obj.get("RULE_SQL"):
                        changed.append(rid)
            msg = []
            msg.append(f"Added rule IDs: {sorted(list(added))}")
            msg.append(f"Removed rule IDs: {sorted(list(removed))}")
            msg.append(f"Changed rule IDs: {sorted(list(changed))}")
            self.result_text.setPlainText("\n".join(msg))
        except Exception as ex:
            self.result_text.setPlainText(f"Error comparing snapshots: {ex}")


###############################################################################
# 5) Minor bug fixes or final changes from test pass
###############################################################################
# Example: unify table name references or fix a known bug:
# e.g. "RULE_CUSTOM_GROUPS" vs. "BRM_CUSTOM_RULE_GROUPS"
# Please ensure these references match your actual DB schema.


# End of chunk 9
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – PART 10
(Integrated codebase, chunk 10)

Focus:
 • Final finishing touches and optional enhancements
 • Additional references or stubs that might be missing from the previous chunks
 • Helper “Database Health Check” for system readiness
 • Potential unified main run script or packaging notes
"""

import sys
import os
import logging
import json
import traceback
import pyodbc

from datetime import datetime, timedelta
from PyQt5 import QtCore, QtGui, QtWidgets

logger = logging.getLogger("brm_master_part10")


###############################################################################
# 1) Database Health Check (Optional)
###############################################################################
def run_database_health_check(conn):
    """
    Optional method that checks the presence of required DB objects and 
    logs warnings if something is missing or out-of-date.
    E.g. verifying certain tables: BRM_RULES, RULE_SNAPSHOTS, 
    or columns like DECISION_TABLE_ID, etc.
    """
    required_tables = [
        "BRM_RULES", "BRM_RULE_LOCKS", "BRM_RULE_APPROVALS",
        "DATA_VALIDATIONS", "RULE_SCHEDULES", "USERS"
    ]
    missing = []
    c = conn.cursor()
    for tbl in required_tables:
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            # even if no data, if no error => table is present
        except:
            missing.append(tbl)

    if missing:
        logger.warning(f"Database check: Missing tables => {missing}")

    # Example: check columns
    # We can do more advanced checks if needed
    # ...
    return missing


###############################################################################
# 2) Unified Application Runner or “Main”
###############################################################################
class BRMApplication:
    """
    A wrapper that can handle launching the PyQt5 UI, 
    loading config, logging in a user, etc.
    This is optional if you prefer a more direct approach.
    """

    def __init__(self):
        self.config = {}
        self.connection = None

    def load_config(self, path="brm_config.json"):
        if os.path.exists(path):
            try:
                with open(path,"r",encoding="utf-8") as f:
                    self.config = json.load(f)
                logger.info(f"Loaded config from {path}")
            except Exception as ex:
                logger.error(f"Error loading config: {ex}")
        else:
            logger.warning("No config file found. Using defaults.")

    def connect_db(self):
        try:
            conn_str = self.config.get("connection_string")
            if not conn_str:
                # fallback or prompt
                conn_str = "DSN=MyODBC;Trusted_Connection=yes;"
            self.connection = pyodbc.connect(conn_str)
            logger.info("Database connected successfully.")
            # run an optional health check
            missing = run_database_health_check(self.connection)
            if missing:
                logger.warning(f"Missing some required tables => {missing}")
        except Exception as ex:
            logger.error(f"DB connection error: {ex}")
            traceback.print_exc()
            self.connection = None

    def run_ui(self):
        if not self.connection:
            logger.error("No database connection. Exiting.")
            return

        from PyQt5.QtWidgets import QApplication
        app = QApplication(sys.argv)

        # from chunk 1 or chunk 2:
        #  - we have DatabaseConnectionDialog, LoginDialog, MainWindow, etc.
        # For demonstration, we simply launch the MainWindow:
        user_id = 1
        user_group = "Admin"
        # or fetch from a real login flow
        from some_module_or_chunk import MainWindow  # Pseudocode
        mw = MainWindow(self.connection, user_id, user_group)
        mw.show()

        sys.exit(app.exec_())

    def run(self):
        self.load_config()
        self.connect_db()
        self.run_ui()


###############################################################################
# 3) Potential Additional Utility or Testing Methods
###############################################################################
def bulk_export_rules_to_csv(conn, csv_path):
    """
    Example method: exports all rules to a CSV for external archiving or batch analysis.
    """
    c = conn.cursor()
    try:
        c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, OWNER_GROUP, VERSION
            FROM BRM_RULES
        """)
        rows = c.fetchall()
        with open(csv_path, "w", encoding="utf-8") as f:
            f.write("RULE_ID,RULE_NAME,RULE_SQL,STATUS,OWNER_GROUP,VERSION\n")
            for r in rows:
                rvals = [str(x).replace(",",";") for x in r]  # naive CSV escape
                f.write(",".join(rvals)+"\n")
        logger.info(f"Exported {len(rows)} rules to {csv_path}")
    except Exception as ex:
        logger.error(f"Error exporting rules to CSV: {ex}")

def bulk_import_rules_from_csv(conn, csv_path):
    """
    Example method: imports rules from a CSV. For demonstration only.
    """
    try:
        with open(csv_path, "r", encoding="utf-8") as f:
            lines = f.read().splitlines()
        # skip header
        c = conn.cursor()
        inserted_count = 0
        for idx, line in enumerate(lines[1:], start=2):
            parts = line.split(",")
            if len(parts)<6:
                logger.warning(f"Skipping line {idx} => not enough columns.")
                continue
            rule_id, rule_name, rule_sql, status, owner_grp, ver = parts
            # Insert or upsert logic
            try:
                c.execute("""
                    INSERT INTO BRM_RULES(RULE_ID, RULE_NAME, RULE_SQL, STATUS, OWNER_GROUP, VERSION)
                    VALUES(?,?,?,?,?,?)
                """, (int(rule_id), rule_name, rule_sql, status, owner_grp, int(ver)))
                inserted_count+=1
            except Exception as subex:
                logger.error(f"Line {idx} error: {subex}")
        conn.commit()
        logger.info(f"Imported {inserted_count} rules from {csv_path}")
    except Exception as ex:
        logger.error(f"Error importing rules from CSV: {ex}")


###############################################################################
# 4) Example “closing” or final chunk
###############################################################################
def run_full_brm_tool():
    """
    Optional single-run function if you want to unify everything into 
    a single main script. This would:
      1) Prompt DB connection or read config
      2) Show login
      3) Launch main UI
    For now, it’s just a placeholder.
    """
    # in real usage, you might do:
    # brm_app = BRMApplication()
    # brm_app.run()
    pass


# End of chunk 10