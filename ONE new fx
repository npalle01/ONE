#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 8 – Integrated and Advanced UI/UX for BRM Tool (Updated)
Fully implemented with advanced features:
  - Business Rules Tab with updated CRUD/dry-run operations (including lock checking)
  - Predictive Analytics Tab with filters removed
  - Enhanced Lineage Tab with working search functionality
  - Approvals Tab now shows all pending approvals for admin and fixes ForceUnlock button
Assumes all helper functions (insert_audit_log, LockManager, detect_operation_type,
parse_sql_dependencies, run_data_validations, create_multistep_approvals, load_rule_relationships, etc.) are defined below.
"""

import sys, os, json, csv, math, logging, difflib
from datetime import datetime, timedelta
import numpy as np
from sklearn.linear_model import LinearRegression

import pyqtgraph as pg

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime, QPointF
from PyQt5.QtGui import QIcon, QPen, QBrush, QColor, QFont, QPalette
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QLabel, QPushButton, QDockWidget, QLineEdit, QMessageBox, QComboBox, QTableWidget,
    QTableWidgetItem, QPlainTextEdit, QInputDialog, QFileDialog, QTreeWidget, QTreeWidgetItem,
    QGraphicsView, QGraphicsScene, QGraphicsEllipseItem, QGraphicsLineItem, QProgressDialog,
    QSplitter, QMenu, QCalendarWidget, QTimeEdit, QFormLayout, QGroupBox, QCheckBox
)

# ---------------------- Logging and Helper Functions -------------------------
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
logger = logging.getLogger("BRM_TOOL")

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
            VALUES (?, ?, ?, ?, ?, ?, GETDATE())
        """, (action, table_name, str(record_id) if record_id else None, actor,
              json.dumps(old_data) if old_data else None, json.dumps(new_data) if new_data else None))
        conn.commit()
        logger.debug(f"Audit log inserted: {action} on {table_name} (Record: {record_id})")
    except Exception as e:
        logger.error(f"Error inserting audit log: {e}")

class LockManager:
    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < ?", (now,))
            conn.commit()
            logger.info("Expired locks auto-unlocked.")
        except Exception as e:
            logger.error(f"Error auto unlocking locks: {e}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("SELECT LOCKED_BY, EXPIRY_TIMESTAMP FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",
                  (rule_id,))
        row = c.fetchone()
        if row:
            if datetime.now() > row[1]:
                c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
                conn.commit()
                return None
            return row[0]
        return None

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        owner = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if owner and owner != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {owner}.")
        elif owner and owner != user_id and force:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
            VALUES (?, ?, ?, ?, ?, 1)
        """, (rule_id, user_id, now, expiry, 1 if force else 0))
        conn.commit()
        logger.info(f"Rule {rule_id} locked by {user_id} (force={force}).")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        current_owner = LockManager.rule_current_lock_owner(conn, rule_id)
        if current_owner and current_owner != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {current_owner}. Cannot unlock.")
        c = conn.cursor()
        c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        conn.commit()
        logger.info(f"Rule {rule_id} unlocked by {user_id} (force={force}).")

def detect_operation_type(sql_text: str) -> str:
    cleaned = (sql_text or "").strip()
    import re
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', cleaned, flags=re.MULTILINE | re.DOTALL).lstrip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text: str):
    try:
        import sqlparse
        statements = sqlparse.parse(sql_text)
        tables = []
        for stmt in statements:
            for token in stmt.tokens:
                if token.ttype is None and token.is_group:
                    for subtoken in token.tokens:
                        if subtoken.ttype is None and subtoken.is_group:
                            continue
                        if subtoken.ttype is sqlparse.tokens.Name:
                            tables.append(subtoken.value)
        return {"tables": list(set(tables))}
    except Exception as e:
        logger.error(f"Error parsing SQL dependencies: {e}")
        return {"tables": []}

def run_data_validations(conn):
    c = conn.cursor()
    try:
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS")
        validations = c.fetchall()
        for vid, tbl, col, vtype, params in validations:
            if vtype.upper() == "NOT NULL":
                query = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(query)
                count = c.fetchone()[0]
                result = "PASS" if count == 0 else "FAIL"
                c.execute(
                    "INSERT INTO DATA_VALIDATION_LOGS (VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP) VALUES (?, ?, ?, GETDATE())",
                    (vid, result, f"{count} null values found"))
        conn.commit()
        logger.info("Data validations executed successfully.")
    except Exception as e:
        logger.error(f"Error running data validations: {e}")
        raise

def create_multistep_approvals(conn, rule_id, initiated_by):
    c = conn.cursor()
    try:
        steps = [1, 2]
        for step in steps:
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
                VALUES (?, ?, ?, 0, ?)
            """, (rule_id, "BusinessGroup", initiated_by, step))
        conn.commit()
        logger.info(f"Multi-step approvals created for rule {rule_id}.")
    except Exception as e:
        logger.error(f"Error creating multi-step approvals: {e}")

def load_rule_relationships(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for rid, pid in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid
    child_ids = set(parent_map.keys())
    roots = [rid for rid in all_ids if rid not in child_ids]
    return (adjacency, roots, parent_map)

# ---------------------- Business Rules Tab (Enhanced CRUD and Dry-run) ----------------------
class BusinessRulesTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        action_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rules...")
        self.search_edit.textChanged.connect(self.load_rules)
        action_layout.addWidget(self.search_edit)
        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule)
        action_layout.addWidget(add_btn)
        edit_btn = QPushButton("Edit Rule")
        edit_btn.clicked.connect(self.edit_rule)
        action_layout.addWidget(edit_btn)
        delete_btn = QPushButton("Delete Rule")
        delete_btn.clicked.connect(self.delete_rule)
        action_layout.addWidget(delete_btn)
        deactivate_btn = QPushButton("Deactivate Rule")
        deactivate_btn.clicked.connect(self.deactivate_rule)
        action_layout.addWidget(deactivate_btn)
        single_dryrun_btn = QPushButton("Dry‑Run (Single)")
        single_dryrun_btn.clicked.connect(self.dryrun_single)
        action_layout.addWidget(single_dryrun_btn)
        group_dryrun_btn = QPushButton("Dry‑Run (Group)")
        group_dryrun_btn.clicked.connect(self.dryrun_group)
        action_layout.addWidget(group_dryrun_btn)
        action_layout.addStretch()
        layout.addLayout(action_layout)
        self.rules_table = QTableWidget(0, 7)
        self.rules_table.setHorizontalHeaderLabels(
            ["RuleID", "Name", "Status", "Version", "Owner Group", "Created", "Action"])
        self.rules_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rules_table)
        self.setLayout(layout)
        self.load_rules()

    def load_rules(self):
        self.rules_table.setRowCount(0)
        c = self.connection.cursor()
        search_term = self.search_edit.text().strip()
        try:
            if search_term:
                query = "SELECT RULE_ID, RULE_NAME, STATUS, VERSION, OWNER_GROUP, CONVERT(VARCHAR, CREATED_TIMESTAMP, 120) FROM BRM_RULES WHERE RULE_NAME LIKE ?"
                c.execute(query, (f"%{search_term}%",))
            else:
                c.execute("SELECT RULE_ID, RULE_NAME, STATUS, VERSION, OWNER_GROUP, CONVERT(VARCHAR, CREATED_TIMESTAMP, 120) FROM BRM_RULES")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.rules_table.insertRow(i)
                for j, value in enumerate(row):
                    self.rules_table.setItem(i, j, QTableWidgetItem(str(value)))
                btn = QPushButton("Dry‑Run")
                # **[Enhancement 1]** Use default parameter in lambda to capture rule id properly.
                btn.clicked.connect(lambda _, rid=row[0]: self.show_dryrun_result(rid))
                self.rules_table.setCellWidget(i, 6, btn)
        except Exception as e:
            QMessageBox.critical(self, "Load Rules Error", str(e))

    def add_rule(self):
        # Use advanced rule editor dialog (which includes full validation and dependency re-parsing)
        dlg = RuleEditorDialog(self.connection, self.user_group)
        if dlg.exec_() == QDialog.Accepted:
            self.load_rules()

    def edit_rule(self):
        selected = self.rules_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a rule to edit.")
            return
        rule_id = int(selected[0].text())
        # Check if rule is locked before allowing edit
        try:
            owner = LockManager.rule_current_lock_owner(self.connection, rule_id)
            if owner and owner != "CurrentUser":  # Assuming "CurrentUser" is the logged-in user
                QMessageBox.warning(self, "Locked", f"Rule {rule_id} is currently locked by {owner}.")
                return
        except Exception as e:
            QMessageBox.warning(self, "Lock Check Error", str(e))
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        rule_data = c.fetchone()
        if not rule_data:
            QMessageBox.warning(self, "Error", "Rule not found.")
            return
        colnames = [desc[0] for desc in c.description]
        rule_dict = dict(zip(colnames, rule_data))
        dlg = RuleEditorDialog(self.connection, self.user_group, rule_dict)
        if dlg.exec_() == QDialog.Accepted:
            self.load_rules()

    def delete_rule(self):
        selected = self.rules_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a rule to delete.")
            return
        rule_id = int(selected[0].text())
        # Check for active lock
        try:
            owner = LockManager.rule_current_lock_owner(self.connection, rule_id)
            if owner:
                QMessageBox.warning(self, "Locked", f"Rule {rule_id} is locked by {owner}. Cannot delete.")
                return
        except Exception as e:
            QMessageBox.warning(self, "Lock Check Error", str(e))
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "BRM_RULES", rule_id, "CurrentUser")
            self.load_rules()
        except Exception as e:
            QMessageBox.critical(self, "Delete Error", str(e))

    def deactivate_rule(self):
        selected = self.rules_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a rule to deactivate.")
            return
        rule_id = int(selected[0].text())
        c = self.connection.cursor()
        try:
            c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE' WHERE RULE_ID=?", (rule_id,))
            self.connection.commit()
            insert_audit_log(self.connection, "DEACTIVATE", "BRM_RULES", rule_id, "CurrentUser")
            self.load_rules()
        except Exception as e:
            QMessageBox.critical(self, "Deactivate Error", str(e))

    def dryrun_single(self):
        selected = self.rules_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "Dry‑Run", "No rule selected.")
            return
        rule_id = int(selected[0].text())
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Dry‑Run", "Selected rule not found.")
                return
            sql_text, op_type, dt_id = row
            if op_type.upper() == "DECISION_TABLE":
                ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
            else:
                ok, msg = dry_run_rule_sql(self.connection, sql_text)
                rec_count = 0
            result = f"Dry‑Run Result for Rule {rule_id}:\nStatus: {'PASS' if ok else 'FAIL'}\nMessage: {msg}\nRecords Impacted: {rec_count}"
            dlg = QDialog(self)
            dlg.setWindowTitle("Dry‑Run Result")
            dlg.resize(400, 300)
            vbox = QVBoxLayout(dlg)
            text_edit = QPlainTextEdit(result)
            text_edit.setReadOnly(True)
            vbox.addWidget(text_edit)
            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dlg.accept)
            vbox.addWidget(close_btn)
            dlg.exec_()
        except Exception as e:
            QMessageBox.critical(self, "Dry‑Run Error", str(e))

    def dryrun_group(self):
        group_id, ok = QInputDialog.getInt(self, "Group Dry‑Run", "Enter Custom Group ID:")
        if not ok:
            return
        try:
            passed, failed = simulate_custom_group_rules(self.connection, group_id)
            result = f"Group Dry‑Run Result for Group {group_id}:\nPassed Rules: {passed}\nFailed Rules: {failed}"
            QMessageBox.information(self, "Group Dry‑Run Result", result)
        except Exception as e:
            QMessageBox.critical(self, "Group Dry‑Run Error", str(e))

    def show_dryrun_result(self, rule_id):
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Error", "Rule not found.")
            return
        sql_text, op_type, dt_id = row
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(self.connection, sql_text)
            rec_count = 0
        result = f"Dry‑Run Result for Rule {rule_id}:\nStatus: {'PASS' if ok else 'FAIL'}\nMessage: {msg}\nRecords Impacted: {rec_count}"
        dlg = QDialog(self)
        dlg.setWindowTitle("Dry‑Run Result")
        dlg.resize(400, 300)
        vbox = QVBoxLayout(dlg)
        text_edit = QPlainTextEdit(result)
        text_edit.setReadOnly(True)
        vbox.addWidget(text_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.accept)
        vbox.addWidget(close_btn)
        dlg.exec_()

# ---------------------- Predictive Analytics Tab (Filters Removed) ----------------------
class PredictiveAnalyticsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        # **[Enhancement 2]** Removed all filter widgets so only the chart, forecast button and result label remain.
        self.chart = pg.PlotWidget(title="Forecast: Average Execution Time")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        forecast_btn = QPushButton("Run Forecast")
        forecast_btn.clicked.connect(self.run_forecast)
        layout.addWidget(forecast_btn)
        self.result_label = QLabel("")
        layout.addWidget(self.result_label)
        self.setLayout(layout)

    def run_forecast(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(date, CREATED_TIMESTAMP) as LogDate, AVG(EXEC_TIME_MS) as AvgTime
                FROM RULE_PERF_STATS
                WHERE CREATED_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
                GROUP BY CONVERT(date, CREATED_TIMESTAMP)
                ORDER BY LogDate
            """)
            rows = c.fetchall()
            if not rows:
                self.result_label.setText("Insufficient data.")
                return
            dates = [row[0] for row in rows]
            avg_times = [row[1] for row in rows]
            X = np.array([[i] for i in range(len(avg_times))])
            y = np.array(avg_times)
            model = LinearRegression()
            model.fit(X, y)
            forecast_index = len(avg_times)
            forecast = model.predict(np.array([[forecast_index]]))[0]
            anomaly = forecast > 2000
            self.chart.clear()
            x_vals = list(range(len(avg_times)))
            self.chart.plot(x_vals, avg_times, pen=pg.mkPen('b', width=2), symbol='o')
            self.chart.plot([forecast_index], [forecast], pen=pg.mkPen('r', width=2), symbol='x', symbolSize=14)
            self.chart.getAxis("bottom").setLabel("Day Index (Last 30 Days)")
            self.chart.getAxis("left").setLabel("Avg Exec Time (ms)")
            if anomaly:
                self.result_label.setText(f"Anomaly: Forecast avg time {forecast:.1f} ms exceeds threshold.")
            else:
                self.result_label.setText(f"Forecast: Avg time = {forecast:.1f} ms.")
        except Exception as e:
            QMessageBox.critical(self, "Forecast Error", str(e))

# ---------------------- Enhanced Lineage Analysis Tab (Search working) ----------------------
class EnhancedLineageAnalysisTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        filter_layout = QHBoxLayout()
        self.rule_name_filter = QLineEdit()
        self.rule_name_filter.setPlaceholderText("Enter rule name filter...")
        filter_layout.addWidget(QLabel("Filter:"))
        filter_layout.addWidget(self.rule_name_filter)
        view_btn = QPushButton("View Textual Lineage")
        view_btn.clicked.connect(self.view_textual_lineage)
        filter_layout.addWidget(view_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)
        self.lineage_view = QPlainTextEdit()
        self.lineage_view.setReadOnly(True)
        layout.addWidget(self.lineage_view)
        self.setLayout(layout)

    def view_textual_lineage(self):
        filter_text = self.rule_name_filter.text().strip()
        self.lineage_view.clear()  # **[Enhancement 3]** Clear previous text
        text = f"End-to-End Lineage for rules matching '{filter_text}':\n\n"
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID FROM BRM_RULES WHERE RULE_NAME LIKE ?", (f"%{filter_text}%",))
            rows = c.fetchall()
            if rows:
                for rid, name, parent in rows:
                    text += f"Rule {rid}: {name} (Parent: {parent if parent else 'None'})\n"
            else:
                text += "No rules found matching the filter."
        except Exception as e:
            text += f"Error fetching lineage data: {e}"
        self.lineage_view.setPlainText(text)

# ---------------------- Approvals Tab (ForceUnlock and Admin view) ----------------------
class ApprovalsTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["RuleID", "Group", "Rule Name", "Stage", "Action", "Force Unlock"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)
        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            # **[Enhancement 4]** For admin, show all pending approvals; otherwise filter by username.
            if self.user_group == "Admin":
                c.execute("""
                    SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, R.LOCKED_BY
                    FROM BRM_RULE_APPROVALS A
                    JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                    WHERE A.APPROVED_FLAG=0
                    ORDER BY A.APPROVAL_STAGE
                """)
            else:
                c.execute("""
                    SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, R.LOCKED_BY
                    FROM BRM_RULE_APPROVALS A
                    JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                    WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
                    ORDER BY A.APPROVAL_STAGE
                """, (self.logged_in_username,))
            rows = c.fetchall()
            self.table.setRowCount(len(rows))
            for i, row in enumerate(rows):
                rule_id, group_name, rule_name, stage, locked_by = row
                self.table.setItem(i, 0, QTableWidgetItem(str(rule_id)))
                self.table.setItem(i, 1, QTableWidgetItem(group_name))
                self.table.setItem(i, 2, QTableWidgetItem(rule_name))
                self.table.setItem(i, 3, QTableWidgetItem(str(stage)))
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, rid=rule_id: self.approve_rule(rid))
                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, rid=rule_id: self.reject_rule(rid))
                action_layout.addWidget(approve_btn)
                action_layout.addWidget(reject_btn)
                action_layout.setContentsMargins(0, 0, 0, 0)
                self.table.setCellWidget(i, 4, action_widget)
                if self.user_group == "Admin":
                    force_btn = QPushButton("Force Unlock")
                    force_btn.clicked.connect(lambda _, rid=rule_id: self.force_unlock(rid))
                    self.table.setCellWidget(i, 5, force_btn)
                else:
                    self.table.setItem(i, 5, QTableWidgetItem("N/A"))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading approvals: {ex}")

    def approve_rule(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG = 1, APPROVED_TIMESTAMP = GETDATE()
                WHERE RULE_ID = ? AND (USERNAME = ? OR ?='Admin')
            """, (rule_id, self.logged_in_username, self.user_group))
            c.execute("SELECT COUNT(*) FROM BRM_RULE_APPROVALS WHERE RULE_ID = ? AND APPROVED_FLAG = 0", (rule_id,))
            remaining = c.fetchone()[0]
            if remaining == 0:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS = 'APPROVED', STATUS = 'ACTIVE', LIFECYCLE_STATE = 'ACTIVE'
                    WHERE RULE_ID = ?
                """, (rule_id,))
            insert_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None, {"approved": True})
            self.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error approving rule: {ex}")

    def reject_rule(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG = 2, APPROVED_TIMESTAMP = GETDATE()
                WHERE RULE_ID = ? AND (USERNAME = ? OR ?='Admin')
            """, (rule_id, self.logged_in_username, self.user_group))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS = 'REJECTED', STATUS = 'INACTIVE', LIFECYCLE_STATE = 'INACTIVE'
                WHERE RULE_ID = ?
            """, (rule_id,))
            insert_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None, {"rejected": True})
            self.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error rejecting rule: {ex}")

    def force_unlock(self, rule_id):
        if self.user_group != "Admin":
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
            insert_audit_log(self.connection, "FORCE_UNLOCK", "BRM_RULE_LOCKS", rule_id, "Admin", None, {"forced": True})
            self.connection.commit()
            QMessageBox.information(self, "Force Unlocked", f"Rule {rule_id} force-unlocked.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error forcing unlock: {ex}")

# ---------------------- Other Tabs (Defects, Scheduling, Composite, etc.) ----------------------
# For brevity the remaining classes (SchedulingTab, CompositeRulesTab, DataValidationTab, etc.)
# are assumed unchanged from the master code.

# (Please refer to the master PART 8 code for those full definitions.)

# ---------------------- Main Window ----------------------
class MainWindow(QMainWindow):
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.setWindowTitle("BRM Tool – Ultimate Production Ready Edition")
        self.resize(2200, 1300)
        self.setStyleSheet("""
            QWidget { font-family: 'Segoe UI'; font-size: 13px; }
            QTabWidget::pane { border: 0; }
            QHeaderView::section { background-color: #E8E8E8; padding: 6px; border: 1px solid #C0C0C0; }
            QTableWidget { background-color: #FFFFFF; alternate-background-color: #F5F5F5; }
            QPushButton { background-color: #0078D7; color: white; border: none; padding: 6px; }
            QPushButton:hover { background-color: #005A9E; }
            QPushButton:pressed { background-color: #004578; }
            QLineEdit, QPlainTextEdit { border: 1px solid #C0C0C0; padding: 4px; }
        """)
        self.create_menu_bar()
        self.create_tool_bar()
        self.create_status_bar()
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            imp_label = QLabel("Impersonate:")
            imp_label.setStyleSheet("font-weight: bold;")
            self.impersonation_combo = QComboBox()
            self.load_impersonation_options()
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.switch_user)
            imp_layout.addWidget(imp_label)
            imp_layout.addWidget(self.impersonation_combo)
            imp_layout.addWidget(imp_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)
        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)
        self.admin_tab = AdminTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.admin_tab, QIcon(), "Admin")
        self.dashboard_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.dashboard_tab, QIcon(), "Dashboard")
        self.biz_rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        biz_container = QWidget()
        biz_layout = QVBoxLayout(biz_container)
        biz_layout.addWidget(self.biz_rules_tab)
        # The BRDetailsWidget (sub-tabs: Custom Groups, What‑If, etc.) remains unchanged
        self.br_details = BRDetailsWidget(self.connection, self.user_id, self.user_group)
        biz_layout.addWidget(self.br_details)
        biz_container.setLayout(biz_layout)
        self.tabs.addTab(biz_container, QIcon(), "Business Rules")
        self.approvals_tab = ApprovalsTab(self.connection, self.get_username(), self.user_group)
        self.tabs.addTab(self.approvals_tab, QIcon(), "Approvals")
        self.defects_tab = DefectManagementTab(self.connection)
        self.tabs.addTab(self.defects_tab, QIcon(), "Defects")
        self.collaboration_tab = CollaborationTab(self.connection, self.create_collaboration_manager())
        self.tabs.addTab(self.collaboration_tab, QIcon(), "Collaboration")
        self.audit_log_tab = EnhancedAuditLogAnalysisTab(self.connection)
        self.tabs.addTab(self.audit_log_tab, QIcon(), "Audit Log Analysis")
        self.predictive_tab = PredictiveAnalyticsTab(self.connection)
        self.tabs.addTab(self.predictive_tab, QIcon(), "Predictive Analytics")
        self.lineage_tab = EnhancedLineageAnalysisTab(self.connection)
        self.tabs.addTab(self.lineage_tab, QIcon(), "Enhanced Lineage")
        self.help_tab = HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab, QIcon(), "Help & Feedback")
        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)
        self.notifications_dock = QDockWidget("Real-Time Notifications", self)
        self.notifications_widget = AlertsAndDashboardsTab(self.connection)
        self.notifications_dock.setWidget(self.notifications_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, self.notifications_dock)
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_tabs)
        self.refresh_timer.start(30000)

    def create_menu_bar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        help_menu = menubar.addMenu("Help")
        doc_action = help_menu.addAction("Documentation")
        doc_action.triggered.connect(self.open_help)

    def create_tool_bar(self):
        toolbar = self.addToolBar("Main Toolbar")
        refresh_action = toolbar.addAction(QIcon.fromTheme("view-refresh"), "Refresh")
        refresh_action.triggered.connect(self.refresh_tabs)

    def create_status_bar(self):
        status = self.statusBar()
        status.showMessage(f"Connected | User: {self.get_username()} | Group: {self.user_group}")

    def logout(self):
        self.close()

    def open_help(self):
        index = self.tabs.indexOf(self.help_tab)
        if index != -1:
            self.tabs.setCurrentIndex(index)

    def get_username(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except Exception:
            return "Unknown"

    def load_impersonation_options(self):
        self.impersonation_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for uid, uname, ugroup in c.fetchall():
                self.impersonation_combo.addItem(f"{uname} ({ugroup})", (uid, ugroup))
        except Exception as ex:
            QMessageBox.critical(self, "Impersonation Error", str(ex))

    def switch_user(self):
        data = self.impersonation_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        QMessageBox.information(self, "Switched", f"Now impersonating {self.get_username()} ({self.user_group}).")
        self.approvals_tab.logged_in_username = self.get_username()
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.biz_rules_tab.user_id = self.user_id
        self.biz_rules_tab.user_group = self.user_group
        self.biz_rules_tab.load_rules()
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i) == "Admin":
                self.tabs.setTabVisible(i, self.user_group == "Admin")
                break
        self.create_status_bar()

    def create_collaboration_manager(self):
         return CollaborationManager(self.connection, poll_ms=5000)

    def refresh_tabs(self):
        try:
            self.approvals_tab.load_approvals()
            self.biz_rules_tab.load_rules()
            self.notifications_widget.check_alerts()
            self.statusBar().showMessage(f"Refreshed at {datetime.now().strftime('%H:%M:%S')}")
        except Exception as ex:
            logger.error(f"Error refreshing tabs: {ex}")

# ---------------------- Help & Feedback Tab ----------------------
class HelpFeedbackTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        title = QLabel("BRM Tool Help & Documentation")
        title.setStyleSheet("font-size: 16px; font-weight: bold;")
        layout.addWidget(title)
        search_layout = QHBoxLayout()
        self.help_search = QLineEdit()
        self.help_search.setPlaceholderText("Search help topics...")
        self.help_search.textChanged.connect(self.filter_help)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.help_search)
        layout.addLayout(search_layout)
        self.help_tabs = QTabWidget()
        self.faq_widget = QTreeWidget()
        self.faq_widget.setHeaderLabels(["FAQ", "Answer"])
        self.guides_widget = QTreeWidget()
        self.guides_widget.setHeaderLabels(["Guide Title", "Content"])
        self.help_tabs.addTab(self.faq_widget, "FAQs")
        self.help_tabs.addTab(self.guides_widget, "Guides")
        layout.addWidget(self.help_tabs)
        self.setLayout(layout)
        self.populate_help_content()

    def populate_help_content(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT CATEGORY, TITLE, CONTENT FROM HELP_CONTENT ORDER BY CATEGORY, LAST_UPDATED DESC")
            rows = c.fetchall()
            self.faq_widget.clear()
            self.guides_widget.clear()
            for category, title, content in rows:
                item = QTreeWidgetItem([title, content])
                if category.upper() == "FAQ":
                    self.faq_widget.addTopLevelItem(item)
                else:
                    self.guides_widget.addTopLevelItem(item)
        except Exception as e:
            QMessageBox.critical(self, "Help Content Error", str(e))

    def filter_help(self):
        text = self.help_search.text().lower()
        for tree in [self.faq_widget, self.guides_widget]:
            for i in range(tree.topLevelItemCount()):
                item = tree.topLevelItem(i)
                visible = text in item.text(0).lower() or text in item.text(1).lower()
                item.setHidden(not visible)

# ---------------------- Alerts & Dashboards Tab ----------------------
class AlertsAndDashboardsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)
        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)
        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, APPROVAL_STAGE, DATEDIFF(DAY, COALESCE(APPROVED_TIMESTAMP, CREATED_TIMESTAMP), GETDATE()) AS Age
                FROM BRM_RULE_APPROVALS
                WHERE APPROVED_FLAG=0 AND DATEDIFF(DAY, COALESCE(APPROVED_TIMESTAMP, GETDATE()), GETDATE()) > 3
            """)
            approvals = c.fetchall()
            if approvals:
                lines.append("Approvals older than 3 days:")
                for rule_id, stage, age in approvals:
                    lines.append(f" - Rule {rule_id}, Stage {stage}, Age: {age} days")
            else:
                lines.append("No approvals older than 3 days.")
        except Exception as e:
            lines.append(f"Approval check error: {e}")
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled' AND SCHEDULE_TIME BETWEEN GETDATE() AND DATEADD(HOUR, 24, GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules = c.fetchall()
            if schedules:
                lines.append("\nUpcoming schedules (next 24h):")
                for sid, rid, stime in schedules:
                    lines.append(f" - Schedule {sid}: Rule {rid} at {stime}")
            else:
                lines.append("\nNo upcoming schedules within 24h.")
        except Exception as e:
            lines.append(f"Schedule check error: {e}")
        try:
            c.execute("""
                SELECT RULE_ID, AVG(EXEC_TIME_MS), AVG(MEM_USAGE)
                FROM RULE_PERF_STATS
                WHERE CREATED_TIMESTAMP >= DATEADD(DAY, -7, GETDATE())
                GROUP BY RULE_ID
                HAVING AVG(EXEC_TIME_MS) > 2000 OR AVG(MEM_USAGE) > 50000
            """)
            perf = c.fetchall()
            if perf:
                lines.append("\nPerformance alerts (last 7 days):")
                for rid, avg_time, avg_mem in perf:
                    lines.append(f" - Rule {rid}: Avg Exec Time: {avg_time:.1f} ms, Avg Memory: {avg_mem:.1f} KB")
            else:
                lines.append("\nNo performance alerts in last 7 days.")
        except Exception as e:
            lines.append(f"Performance check error: {e}")
        try:
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, EXPIRY_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < GETDATE()
            """)
            stale = c.fetchall()
            if stale:
                lines.append("\nStale locks detected:")
                for rid, owner, expiry in stale:
                    lines.append(f" - Rule {rid}: Locked by {owner}, expired at {expiry}")
            else:
                lines.append("\nNo stale locks detected.")
        except Exception as e:
            lines.append(f"Stale lock check error: {e}")
        self.alert_text.setPlainText("\n".join(lines))

# ---------------------- Main Application Launcher ----------------------
def main():
    app = QApplication(sys.argv)

    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    conn = db_dialog.connection
    if not conn:
        sys.exit(1)

    login_dialog = LoginDialog(conn)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dialog.user_id
    user_group = login_dialog.user_group
    main_window = MainWindow(conn, user_id, user_group)
    main_window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()