Below is a sample set of DDL statements for Microsoft SQL Server (or a similar RDBMS) that supports the BRM Tool database schema without using any REFERENCES (i.e., no foreign-key constraints). These DDLs match all the tables used by the code in Parts 1–8. You can adjust data types or indexing as needed.

	Important:
		•	The code below omits foreign-key REFERENCES clauses to meet your “no references” request, but keeps columns that store related IDs.
	•	Primary keys or unique constraints are added for typical usage, but you can modify as you see fit.
	•	Some columns (e.g. VERSION, PERF_USAGE_COUNTER, etc.) may be optional or may appear in the code. Adjust as needed.
	•	Data types are typical suggestions; you can adapt them for your environment.

1. USERS

Stores application user accounts.

CREATE TABLE USERS (
    USER_ID     INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    USERNAME    VARCHAR(100) NOT NULL,
    PASSWORD    VARCHAR(256) NOT NULL,
    USER_GROUP  VARCHAR(100) NOT NULL
);

2. BUSINESS_GROUPS

Stores “business groups” (distinct from “custom rule groups”).

CREATE TABLE BUSINESS_GROUPS (
    GROUP_NAME   VARCHAR(100) NOT NULL PRIMARY KEY,
    DESCRIPTION  VARCHAR(500) NULL,
    EMAIL        VARCHAR(200) NULL
);

3. GROUP_PERMISSIONS

Which group has permission to which table.

CREATE TABLE GROUP_PERMISSIONS (
    GROUP_NAME     VARCHAR(100) NOT NULL,
    TARGET_TABLE   VARCHAR(200) NOT NULL,
    -- No foreign keys used here
    CONSTRAINT PK_GROUP_PERMISSIONS PRIMARY KEY (GROUP_NAME, TARGET_TABLE)
);

4. BRM_RULE_TYPES

List of possible rule types.

CREATE TABLE BRM_RULE_TYPES (
    RULE_TYPE_ID   INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_TYPE_NAME VARCHAR(100) NOT NULL
);

5. BRM_RULE_GROUPS

Stores “rule groups” (different from business groups or custom groups).

CREATE TABLE BRM_RULE_GROUPS (
    GROUP_ID    INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    GROUP_NAME  VARCHAR(100) NOT NULL,
    DESCRIPTION VARCHAR(500) NULL,
    EMAIL       VARCHAR(200) NULL
);

6. BRM_RULES

Core table storing each rule.

CREATE TABLE BRM_RULES (
    RULE_ID                INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    GROUP_ID               INT NULL,               -- no FK
    PARENT_RULE_ID         INT NULL,               -- no FK
    RULE_TYPE_ID           INT NULL,               -- no FK
    RULE_NAME              VARCHAR(200) NOT NULL,
    RULE_SQL               VARCHAR(MAX) NULL,
    EFFECTIVE_START_DATE   DATETIME NULL,
    EFFECTIVE_END_DATE     DATETIME NULL,
    STATUS                 VARCHAR(50) NOT NULL DEFAULT('INACTIVE'),
    VERSION                INT NOT NULL DEFAULT(1),
    CREATED_BY             VARCHAR(100) NULL,
    DESCRIPTION            VARCHAR(1000) NULL,
    OPERATION_TYPE         VARCHAR(50) NULL,
    BUSINESS_JUSTIFICATION VARCHAR(1000) NULL,
    CREATED_TIMESTAMP      DATETIME NOT NULL DEFAULT(GETDATE()),
    UPDATED_BY             VARCHAR(100) NULL,
    OWNER_GROUP            VARCHAR(100) NOT NULL,
    CLUSTER_NAME           VARCHAR(100) NULL,
    APPROVAL_STATUS        VARCHAR(50) NULL,
    IS_GLOBAL              BIT NOT NULL DEFAULT(0),
    CRITICAL_RULE          BIT NOT NULL DEFAULT(0),
    CRITICAL_SCOPE         VARCHAR(50) NULL,
    CDC_TYPE               VARCHAR(50) NULL,
    LIFECYCLE_STATE        VARCHAR(50) NULL,
    DECISION_TABLE_ID      INT NULL,        -- no FK
    PERF_USAGE_COUNTER     INT NOT NULL DEFAULT(0)
);

7. BRM_RULE_TABLE_DEPENDENCIES

Tracks each rule’s table references.

CREATE TABLE BRM_RULE_TABLE_DEPENDENCIES (
    DEPENDENCY_ID  INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_ID        INT NOT NULL,         -- no FK
    DATABASE_NAME  VARCHAR(100) NULL,
    TABLE_NAME     VARCHAR(200) NULL,
    COLUMN_NAME    VARCHAR(200) NULL,
    COLUMN_OP      VARCHAR(10) NULL,     -- 'READ','WRITE'
    TABLE_STATUS   VARCHAR(50) NULL      -- e.g. 'OK','MISSING', etc.
);

8. BRM_AUDIT_LOG

Stores audit events.

CREATE TABLE BRM_AUDIT_LOG (
    AUDIT_ID        INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    ACTION          VARCHAR(50) NOT NULL,
    TABLE_NAME      VARCHAR(100) NULL,
    RECORD_ID       VARCHAR(100) NULL, -- storing as string for flexibility
    ACTION_BY       VARCHAR(100) NULL,
    OLD_DATA        VARCHAR(MAX) NULL,
    NEW_DATA        VARCHAR(MAX) NULL,
    ACTION_TIMESTAMP DATETIME NOT NULL DEFAULT(GETDATE()),
    PERF_MS         DECIMAL(10,2) NULL
);

9. BRM_COLUMN_MAPPING

Possible column-level mappings between rules.

CREATE TABLE BRM_COLUMN_MAPPING (
    MAPPING_ID      INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    SOURCE_RULE_ID  INT NOT NULL,   -- no FK
    TARGET_RULE_ID  INT NOT NULL,   -- no FK
    SOURCE_COLUMN   VARCHAR(200) NULL,
    TARGET_COLUMN   VARCHAR(200) NULL
);

10. BRM_CUSTOM_RULE_GROUPS

“Custom” groups separate from business or rule groups.

CREATE TABLE BRM_CUSTOM_RULE_GROUPS (
    CUSTOM_GROUP_ID         INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    CUSTOM_GROUP_NAME       VARCHAR(200) NOT NULL,
    OWNER_BUSINESS_GROUP    VARCHAR(100) NOT NULL,
    CREATED_BY              VARCHAR(100) NULL,
    CREATED_TIMESTAMP       DATETIME NOT NULL DEFAULT(GETDATE())
);

11. BRM_CUSTOM_GROUP_MEMBERS

Links a custom group to the rules it contains.

CREATE TABLE BRM_CUSTOM_GROUP_MEMBERS (
    CUSTOM_GROUP_ID   INT NOT NULL,  -- no FK
    RULE_ID           INT NOT NULL,  -- no FK
    CONSTRAINT PK_BRM_CUSTOM_GROUP_MEMBERS PRIMARY KEY (CUSTOM_GROUP_ID, RULE_ID)
);

12. BUSINESS_GROUP_APPROVERS

Which users can approve for each group.

CREATE TABLE BUSINESS_GROUP_APPROVERS (
    APPROVER_ID  INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    GROUP_NAME   VARCHAR(100) NOT NULL,
    USERNAME     VARCHAR(100) NOT NULL
);

13. BRM_RULE_APPROVALS

Multi-step approvals for each rule.

CREATE TABLE BRM_RULE_APPROVALS (
    RULE_ID          INT NOT NULL,      -- no FK
    GROUP_NAME       VARCHAR(100) NULL,
    USERNAME         VARCHAR(100) NULL,
    APPROVED_FLAG    INT NOT NULL DEFAULT(0),  -- 0=Pending,1=Approved,2=Rejected
    APPROVED_TIMESTAMP DATETIME NULL,
    APPROVAL_STAGE   INT NOT NULL,
    CONSTRAINT IDX_BRM_RULE_APPROVALS UNIQUE (RULE_ID, GROUP_NAME, USERNAME, APPROVAL_STAGE)
);

14. BRM_GLOBAL_CRITICAL_LINKS

Links a “global/critical rule” to other target rules.

CREATE TABLE BRM_GLOBAL_CRITICAL_LINKS (
    GCR_RULE_ID   INT NOT NULL,   -- no FK
    TARGET_RULE_ID INT NOT NULL   -- no FK
    -- PK if desired
);

15. RULE_SCHEDULES

Stores scheduled runs.

CREATE TABLE RULE_SCHEDULES (
    SCHEDULE_ID      INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_ID          INT NOT NULL,     -- no FK
    SCHEDULE_TIME    DATETIME NOT NULL,
    STATUS           VARCHAR(50) NOT NULL DEFAULT('Scheduled'),
    CREATED_TIMESTAMP DATETIME NOT NULL DEFAULT(GETDATE())
);

16. BRM_RULE_COMMENTS

(Optional; if you store user comments on rules.)

CREATE TABLE BRM_RULE_COMMENTS (
    COMMENT_ID     INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_ID        INT NOT NULL,   -- no FK
    COMMENT_TEXT   VARCHAR(2000) NOT NULL,
    COMMENT_BY     VARCHAR(100) NOT NULL,
    COMMENT_DATE   DATETIME NOT NULL DEFAULT(GETDATE())
);

17. DECISION_TABLES

Stores each decision table definition.

CREATE TABLE DECISION_TABLES (
    DECISION_TABLE_ID  INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    TABLE_NAME         VARCHAR(200) NOT NULL,
    DESCRIPTION        VARCHAR(1000) NULL
);

18. RULE_CONFLICTS

Tracks conflicts between two rules.

CREATE TABLE RULE_CONFLICTS (
    CONFLICT_ID  INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_ID1     INT NOT NULL,  -- no FK
    RULE_ID2     INT NOT NULL,  -- no FK
    PRIORITY     INT NOT NULL
);

19. COMPOSITE_RULES

For “composite” rules referencing sub-rules in a logic expression.

CREATE TABLE COMPOSITE_RULES (
    COMPOSITE_RULE_ID INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    CRULE_NAME        VARCHAR(200) NOT NULL,
    LOGIC_EXPR        VARCHAR(MAX) NULL,
    ACTION_ON_PASS    VARCHAR(200) NULL
);

20. RULE_SNAPSHOTS

Stores entire BRM_RULES as JSON snapshots.

CREATE TABLE RULE_SNAPSHOTS (
    SNAPSHOT_ID    INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    SNAPSHOT_NAME  VARCHAR(200) NOT NULL,
    CREATED_BY     VARCHAR(100) NOT NULL,
    CREATED_TIMESTAMP DATETIME NOT NULL DEFAULT(GETDATE()),
    SNAPSHOT_JSON  VARCHAR(MAX) NOT NULL
);

21. RULE_TAGS

Simple tags assigned to rules.

CREATE TABLE RULE_TAGS (
    TAG_ID   INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_ID  INT NOT NULL,  -- no FK
    TAG_NAME VARCHAR(100) NOT NULL
);

22. DATA_VALIDATIONS

Rules for validating data in tables/columns.

CREATE TABLE DATA_VALIDATIONS (
    VALIDATION_ID   INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    TABLE_NAME      VARCHAR(200) NOT NULL,
    COLUMN_NAME     VARCHAR(200) NOT NULL,
    VALIDATION_TYPE VARCHAR(50) NOT NULL,   -- e.g. 'NOT NULL','RANGE'
    PARAMS          VARCHAR(200) NULL
);

23. RULE_EXECUTION_LOGS

Logs each rule’s execution result/performance.

CREATE TABLE RULE_EXECUTION_LOGS (
    RULE_EXEC_LOG_ID  INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    RULE_ID           INT NOT NULL,    -- no FK
    EXECUTION_TIMESTAMP DATETIME NOT NULL DEFAULT(GETDATE()),
    PASS_FLAG         BIT NOT NULL DEFAULT(0),
    MESSAGE           VARCHAR(2000) NULL,
    RECORD_COUNT      INT NOT NULL DEFAULT(0),
    EXECUTION_TIME_SEC DECIMAL(10,3) NOT NULL DEFAULT(0)
);

24. BRM_RULE_LOCKS

Manages concurrency locks for rules (30-min expiry).

CREATE TABLE BRM_RULE_LOCKS (
    RULE_ID       INT NOT NULL,   -- no FK
    LOCKED_BY     VARCHAR(100) NOT NULL,
    LOCK_TIMESTAMP DATETIME NOT NULL DEFAULT(GETDATE()),
    CONSTRAINT PK_BRM_RULE_LOCKS PRIMARY KEY (RULE_ID)
);

25. BRM_CUSTOM_GROUP_BACKUPS

Stores backup versions of a custom group.

CREATE TABLE BRM_CUSTOM_GROUP_BACKUPS (
    BACKUP_ID       INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    CUSTOM_GROUP_ID INT NOT NULL,  -- no FK
    BACKUP_TIMESTAMP DATETIME NOT NULL DEFAULT(GETDATE()),
    BACKUP_VERSION  INT NOT NULL,
    BACKUP_JSON     VARCHAR(MAX) NOT NULL
    -- Could have a unique constraint on (CUSTOM_GROUP_ID, BACKUP_VERSION) if desired
);

Notes
	1.	No Foreign Keys: Each table with a column like RULE_ID, GROUP_NAME, or CUSTOM_GROUP_ID does not include a foreign-key constraint. They are merely columns storing the ID or name. This satisfies the “no references” requirement.
	2.	Primary Keys: Where obvious, we used an IDENTITY primary key (e.g., for logs or many-to-many link IDs). Where the logical primary key is a single column (like GROUP_NAME in BUSINESS_GROUPS), we used that. Where we have a composite key (like BRM_CUSTOM_GROUP_MEMBERS), we declared a combined PRIMARY KEY (CUSTOM_GROUP_ID, RULE_ID).
	3.	Data Types: Adjust the lengths (VARCHAR(...), etc.) if your environment or usage requires.
	4.	Defaults: Some columns use default constraints for common values or timestamps.
	5.	Optional Tables: Some tables (like BRM_RULE_COMMENTS or PERF_MS in BRM_AUDIT_LOG) are shown for completeness, but can be omitted if you do not use them.
	6.	Optional Columns: Some columns (e.g., CDC_TYPE, CRITICAL_SCOPE, PERF_USAGE_COUNTER) appear in the code but may be optional. Remove or adjust as needed.

With these DDL statements, you can create the schema for the entire BRM Tool. This setup works with the Parts 1–8 code base, ignoring foreign-key references while still preserving the column relationships in your application logic.