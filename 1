#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8 (CORE COMPONENTS)
-----------------------------------------
This module provides the core functionalities:
  • Logging setup and email sending function.
  • Database connection dialog.
  • Database helper functions (fetch_all_dict, fetch_one_dict, insert_audit_log).
  • Login dialog.
  • SQL parsing helpers (detect_operation_type, parse_sql_dependencies and its helpers).
  • Rule lifecycle constants.
  • Optional OnboardingWizard.
  • Lock/Unlock functions including auto_unlock_expired_locks.
"""

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re
import csv
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtWidgets import (
    QApplication, QDialog, QMessageBox, QLineEdit, QComboBox, QLabel,
    QPushButton, QVBoxLayout, QHBoxLayout
)
from PyQt5.QtCore import Qt, QDateTime

# ---------------------------------------------------------------------------
# LOGGING SETUP
# ---------------------------------------------------------------------------
logging.basicConfig(
    filename='brm_tool_production.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# EMAIL SENDING FUNCTION
# ---------------------------------------------------------------------------
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "YOUR_SMTP_USERNAME",
    "smtp_password": "YOUR_SMTP_PASSWORD",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """Send an email using the defined SMTP settings."""
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email: {ex}")

# ---------------------------------------------------------------------------
# DATABASE CONNECTION DIALOG
# ---------------------------------------------------------------------------
class DatabaseConnectionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – PART 1")
        self.resize(400, 200)
        layout = QVBoxLayout(self)
        
        prompt = QLabel("Select an ODBC DSN (SQL Server) or enter a custom connection string:")
        layout.addWidget(prompt)
        
        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error(f"Error listing DSNs: {e}")
        layout.addWidget(self.dsn_combo)
        
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom connection string")
        layout.addWidget(self.conn_str_edit)
        
        btn_layout = QHBoxLayout()
        connect_btn = QPushButton("Connect")
        connect_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(connect_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            dsn = self.dsn_combo.currentData()
            if not dsn:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={dsn};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

# ---------------------------------------------------------------------------
# DATABASE HELPER FUNCTIONS
# ---------------------------------------------------------------------------
def fetch_all_dict(cursor):
    rows = cursor.fetchall()
    if cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return [dict(zip(cols, row)) for row in rows]
    return rows

def fetch_one_dict(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return dict(zip(cols, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO BRM_AUDIT_LOG (ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
        VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (
        action,
        table_name,
        str(record_id) if record_id else None,
        actor,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

# ---------------------------------------------------------------------------
# LOGIN DIALOG
# ---------------------------------------------------------------------------
class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – PART 1")
        self.resize(300, 150)
        layout = QVBoxLayout(self)
        self.username_edit = QLineEdit()
        self.username_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.username_edit)
        self.password_edit = QLineEdit()
        self.password_edit.setPlaceholderText("Password")
        self.password_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.password_edit)
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        layout.addWidget(login_btn)
        self.setLayout(layout)
    
    def do_login(self):
        username = self.username_edit.text().strip()
        password = self.password_edit.text().strip()
        if not username or not password:
            QMessageBox.warning(self, "Error", "Enter both username and password.")
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME = ? AND PASSWORD = ?", (username, password))
        result = fetch_one_dict(cursor)
        if result:
            self.user_id = result["USER_ID"]
            self.user_group = result["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")

# ---------------------------------------------------------------------------
# DETECT OPERATION TYPE
# ---------------------------------------------------------------------------
def detect_operation_type(rule_sql: str) -> str:
    sql_upper = rule_sql.strip().upper()
    if sql_upper.startswith("INSERT"):
        return "INSERT"
    elif sql_upper.startswith("UPDATE"):
        return "UPDATE"
    elif sql_upper.startswith("DELETE"):
        return "DELETE"
    elif sql_upper.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

# ---------------------------------------------------------------------------
# SQL PARSING HELPERS
# ---------------------------------------------------------------------------
def parse_sql_dependencies(sql_text: str):
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_tables = []
    alias_map = {}
    columns = []
    for stmt in statements:
        cte = extract_with_clauses(stmt)
        for cte_name, refs in cte.items():
            cte_tables.append((cte_name, refs))
        main_refs, local_alias = extract_main_from(stmt.tokens, set(cte.keys()))
        all_tables.extend(main_refs)
        alias_map.update(local_alias)
        cols = extract_columns(stmt)
        columns.extend(cols)
    unique_tables = list({x for x in all_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_tables,
        "alias_map": alias_map,
        "columns": columns
    }

def extract_with_clauses(statement):
    cte_dict = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is sqlparse.tokens.Keyword and token.value.upper() == "WITH":
            i += 1
            i = parse_cte_block(tokens, i, cte_dict)
            continue
        i += 1
    return cte_dict

def parse_cte_block(tokens, i, cte_dict):
    while i < len(tokens):
        token = tokens[i]
        if isinstance(token, sqlparse.sql.Identifier):
            cte_name = token.get_real_name()
            i += 1
            i = parse_cte_as_clause(tokens, i, cte_name, cte_dict)
        elif token.ttype is sqlparse.tokens.Keyword and token.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i

def parse_cte_as_clause(tokens, i, cte_name, cte_dict):
    while i < len(tokens):
        token = tokens[i]
        if token.value.upper() == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, sqlparse.sql.Parenthesis):
                    sub_refs = extract_subselect_tokens(sub.tokens)
                    cte_dict[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.is_group and is_subselect(token):
            results.extend(extract_subselect_tokens(token.tokens))
        if token.ttype is sqlparse.tokens.Keyword:
            if token.value.upper() in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(token, sqlparse.sql.IdentifierList):
                for identifier in token.get_identifiers():
                    parsed = parse_identifier(identifier, set())
                    results.append(parsed)
            elif isinstance(token, sqlparse.sql.Identifier):
                parsed = parse_identifier(token, set())
                results.append(parsed)
        i += 1
    return results

def is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is sqlparse.tokens.DML and sub.value.upper() == "SELECT":
            return True
    return False

def extract_main_from(token_list, known_cte_names):
    results = []
    alias_map = {}
    tokens = list(token_list)
    from_seen = False
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.is_group and is_subselect(token):
            results.extend(extract_subselect_tokens(token.tokens))
        if token.ttype is sqlparse.tokens.Keyword:
            if token.value.upper() in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(token, sqlparse.sql.IdentifierList):
                for identifier in token.get_identifiers():
                    parsed = parse_identifier(identifier, known_cte_names)
                    results.append(parsed)
                    if parsed[2]:
                        alias_map[parsed[2]] = (parsed[0], parsed[1])
            elif isinstance(token, sqlparse.sql.Identifier):
                parsed = parse_identifier(token, known_cte_names)
                results.append(parsed)
                if parsed[2]:
                    alias_map[parsed[2]] = (parsed[0], parsed[1])
        i += 1
    return (results, alias_map)

def parse_identifier(identifier, known_cte_names):
    alias = identifier.get_alias()
    real_name = identifier.get_real_name()
    schema = identifier.get_parent_name()
    if real_name and any(real_name.upper() == name.upper() for name in known_cte_names):
        return (None, f"(CTE) {real_name}", alias)
    return (schema, real_name, alias)

def extract_columns(statement):
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is sqlparse.tokens.DML:
            dml_word = token.value.upper()
            if dml_word == "SELECT":
                cols = parse_select_list(tokens, i + 1)
                for col in cols:
                    results.append((col, False, True))
            elif dml_word in ("INSERT", "UPDATE"):
                cols = parse_dml_columns(tokens, i, dml_word)
                for col in cols:
                    results.append((col, True, False))
        i += 1
    return results

def parse_select_list(tokens, start_idx):
    columns = []
    i = start_idx
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is sqlparse.tokens.Keyword and token.value.upper() in ("FROM", "JOIN", "WHERE", "GROUP", "ORDER", "UNION", "INTERSECT"):
            break
        if isinstance(token, sqlparse.sql.IdentifierList):
            for identifier in token.get_identifiers():
                col_name = identifier.get_name()
                if col_name and col_name.upper() not in ("DISTINCT", "TOP", "ALL"):
                    columns.append(col_name)
        elif isinstance(token, sqlparse.sql.Identifier):
            col_name = token.get_name()
            if col_name and col_name.upper() not in ("DISTINCT", "TOP", "ALL"):
                columns.append(col_name)
        i += 1
    return columns

def parse_dml_columns(tokens, start_idx, dml_word):
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            token = tokens[i]
            if token.is_group and isinstance(token, sqlparse.sql.Parenthesis):
                for sub in token.tokens:
                    if isinstance(sub, sqlparse.sql.IdentifierList):
                        for identifier in sub.get_identifiers():
                            columns.append(identifier.get_name())
                    elif isinstance(sub, sqlparse.sql.Identifier):
                        columns.append(sub.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        i = start_idx
        while i < len(tokens):
            token = tokens[i]
            if token.ttype is sqlparse.tokens.Keyword and token.value.upper() == "SET":
                i += 1
                columns.extend(parse_update_set_list(tokens, i))
                break
            i += 1
    return columns

def parse_update_set_list(tokens, start_index):
    columns = []
    i = start_index
    while i < len(tokens):
        token = tokens[i]
        if token.ttype is sqlparse.tokens.Keyword and token.value.upper() in ("WHERE", "FROM"):
            break
        if isinstance(token, sqlparse.sql.Identifier):
            columns.append(token.get_name())
        i += 1
    return columns

# ---------------------------------------------------------------------------
# RULE LIFECYCLE CONSTANTS
# ---------------------------------------------------------------------------
RULE_LIFECYCLE_STATES = ["DRAFT", "UNDER_APPROVAL", "APPROVED", "ACTIVE", "INACTIVE", "ARCHIVED"]

# ---------------------------------------------------------------------------
# OPTIONAL ONBOARDING WIZARD
# ---------------------------------------------------------------------------
class OnboardingWizard(QDialog):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Welcome Wizard (PART 1)")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        self.label = QLabel("Welcome to the BRM Onboarding Wizard!")
        layout.addWidget(self.label)
        self.current_step = 0
        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_next)
        layout.addWidget(self.next_button)
        self.setLayout(layout)
    def go_next(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Go to 'Group Management' to add a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Go to 'Business Rules' to add a new rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Go to 'Scheduling' to add a schedule.")
        else:
            self.label.setText("All done. Enjoy the BRM Tool.")
            self.accept()

# ---------------------------------------------------------------------------
# LOCK/UNLOCK FUNCTIONS (INCLUDING AUTO-UNLOCK)
# ---------------------------------------------------------------------------
def rule_current_lock_owner(conn, rule_id):
    cursor = conn.cursor()
    cursor.execute("""
        SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
        FROM BRM_RULE_LOCKS
        WHERE RULE_ID = ? AND ACTIVE_LOCK = 1
    """, (rule_id,))
    row = cursor.fetchone()
    if not row:
        return None
    locked_by, lock_ts, expiry_ts, force_lock, active_lock = row
    if not active_lock:
        return None
    if expiry_ts is not None and datetime.now() > expiry_ts:
        cursor2 = conn.cursor()
        cursor2.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK = 0 WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
        conn.commit()
        return None
    return (locked_by, lock_ts, expiry_ts, force_lock)

def lock_rule_for_edit(conn, rule_id, user_id, force=False, user_group=None, admin_override=False):
    info = rule_current_lock_owner(conn, rule_id)
    now = datetime.now()
    expiry = now + timedelta(minutes=30)
    cursor = conn.cursor()
    if info:
        current_locked_by = info[0]
        if current_locked_by == user_id:
            cursor.execute("""
                UPDATE BRM_RULE_LOCKS
                SET EXPIRY_TIMESTAMP = ?, LOCK_TIMESTAMP = ?, FORCE_LOCK = ?
                WHERE RULE_ID = ? AND ACTIVE_LOCK = 1
            """, (expiry, now, 1 if (force or admin_override) else 0, rule_id))
            conn.commit()
            logger.debug(f"Lock refreshed for rule {rule_id} by user {user_id}.")
            return (True, f"Lock refreshed for rule {rule_id}.")
        else:
            if not force and not admin_override:
                raise ValueError(f"Rule {rule_id} is already locked by user {current_locked_by}.")
            else:
                cursor.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK = 0 WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
                cursor.execute("""
                    INSERT INTO BRM_RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
                    VALUES (?, ?, ?, ?, ?, 1)
                """, (rule_id, user_id, now, expiry, 1 if (force or admin_override) else 0))
                conn.commit()
                logger.debug(f"Rule {rule_id} forcibly locked by user {user_id}.")
                return (True, f"Rule {rule_id} forcibly locked by user {user_id}.")
    else:
        cursor.execute("""
            INSERT INTO BRM_RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
            VALUES (?, ?, ?, ?, ?, 1)
        """, (rule_id, user_id, now, expiry, 1 if (force or admin_override) else 0))
        conn.commit()
        logger.debug(f"Rule {rule_id} locked by user {user_id}.")
        return (True, f"Rule {rule_id} locked by user {user_id}.")

def unlock_rule_for_edit(conn, rule_id, user_id=None, force=False, admin_override=False, user_group=None):
    info = rule_current_lock_owner(conn, rule_id)
    if not info:
        return
    locked_by = info[0]
    if not force and not admin_override:
        if user_id and locked_by != user_id:
            raise ValueError("Cannot unlock: rule locked by another user.")
    cursor = conn.cursor()
    cursor.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK = 0 WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
    conn.commit()
    logger.debug(f"Rule {rule_id} unlocked by user {user_id} (admin_override={admin_override}).")

def auto_unlock_expired_locks(conn):
    now = datetime.now()
    cursor = conn.cursor()
    cursor.execute("""
        UPDATE BRM_RULE_LOCKS
        SET ACTIVE_LOCK = 0
        WHERE ACTIVE_LOCK = 1 AND EXPIRY_TIMESTAMP < ?
    """, (now,))
    unlocked = cursor.rowcount
    conn.commit()
    if unlocked > 0:
        logger.debug(f"Auto-unlocked {unlocked} expired locks.")

# End of PART 1
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 2 of 8 (ADVANCED BFS, CRUD, VALIDATIONS, LOCKS, PERMISSIONS)
----------------------------------------------------------------------------
This module builds on PART 1’s core functions (DB connection, SQL parsing, lock/unlock,
audit logging, etc.) and provides advanced functionalities:
  • Permission checks on table usage.
  • Data validations:
       - load_data_validations_for_table
       - run_single_data_validation
       - run_data_validations_for_table
  • Multi-step approvals creation (create_multistep_approvals)
  • BFS logic and rule relationships:
       - find_impacted_groups_bfs
       - load_rule_relationships
       - gather_all_related_rule_ids
       - skip_descendants
       - get_all_rules_map
       - execute_rules_with_conflicts_composites_bfs
       - run_single_rule (execution of a single rule)
       - insert_performance_log
  • Advanced CRUD functions:
       - add_rule
       - update_rule
       - force_activate_rule
       - force_deactivate_rule
       - deactivate_rule
       - delete_rule

Assumptions:
  - Core functions from PART 1 (e.g. rule_current_lock_owner, lock_rule_for_edit,
    unlock_rule_for_edit, fetch_all_dict, insert_audit_log, RULE_LIFECYCLE_STATES, etc.)
    are available.
"""

import json
import time
import re
from datetime import datetime, timedelta
from collections import deque

# -------------------------------
# PERMISSION CHECKS
# -------------------------------
def user_has_table_permission(conn, user_group, table_name):
    """
    Checks if user_group has permission for the specified table_name (schema.table).
    Returns True if permitted; False otherwise.
    """
    cursor = conn.cursor()
    normalized = table_name.lower()
    cursor.execute("""
        SELECT 1 FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME = ? AND LOWER(TARGET_TABLE) = ?
    """, (user_group, normalized))
    return bool(cursor.fetchone())

def enforce_table_permissions_for_rule(conn, user_group, rule_sql):
    """
    Parses rule_sql for table dependencies and verifies permissions.
    Raises ValueError if any table is not permitted.
    """
    deps = parse_sql_dependencies(rule_sql)
    for (schema, tbl, alias, is_subselect) in deps["tables"]:
        if tbl and not tbl.startswith("(CTE)"):
            db_name = schema if schema else "dbo"
            full_name = f"{db_name}.{tbl}".lower()
            if not user_has_table_permission(conn, user_group, full_name):
                raise ValueError(f"Group {user_group} lacks permission for table '{full_name}'.")

# -------------------------------
# DATA VALIDATIONS
# -------------------------------
def load_data_validations_for_table(conn, table_name):
    """
    Loads validation rules for the specified table_name from DATA_VALIDATIONS.
    Returns a list of dictionaries.
    """
    cursor = conn.cursor()
    cursor.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
        WHERE LOWER(TABLE_NAME) = LOWER(?)
    """, (table_name,))
    return fetch_all_dict(cursor)

def run_single_data_validation(validation_rule, conn):
    """
    Executes a single data validation rule.
    Returns True if the validation passes; otherwise, False.
    """
    vtype = (validation_rule["VALIDATION_TYPE"] or "").upper()
    table_ = validation_rule["TABLE_NAME"]
    column_ = validation_rule["COLUMN_NAME"]
    params_ = validation_rule["PARAMS"] or ""
    cursor = conn.cursor()
    try:
        if vtype == "NOT NULL":
            query = f"SELECT COUNT(*) FROM {table_} WHERE {column_} IS NULL"
            cursor.execute(query)
            count = cursor.fetchone()[0]
            return (count == 0)
        elif vtype == "RANGE":
            parts = params_.split(",")
            if len(parts) == 2:
                min_val = float(parts[0])
                max_val = float(parts[1])
                query = f"SELECT COUNT(*) FROM {table_} WHERE {column_} < {min_val} OR {column_} > {max_val}"
                cursor.execute(query)
                count = cursor.fetchone()[0]
                return (count == 0)
            else:
                return False
        elif vtype == "REGEX":
            # For production, implement regex validation if required.
            return True
        else:
            return False
    except Exception:
        return False

def run_data_validations_for_table(conn, table_name):
    """
    Executes all validation rules for a given table.
    Returns True only if all validations pass.
    """
    validations = load_data_validations_for_table(conn, table_name)
    for rule in validations:
        if not run_single_data_validation(rule, conn):
            return False
    return True

# -------------------------------
# MULTI-STEP APPROVALS
# -------------------------------
def create_multistep_approvals(conn, rule_id):
    """
    Creates a multi-step approval pipeline for the given rule_id.
    Example pipeline: BG1 -> BG2 (if needed) -> BG3 (if needed) -> FINAL.
    """
    impacted = find_impacted_groups_bfs(conn, rule_id)
    cursor = conn.cursor()
    cursor.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
    tables = cursor.fetchall()
    require_bg2 = any("finance" in (tbl or "").lower() or "credit" in (tbl or "").lower() for (tbl,) in tables)
    require_bg3 = any("sensitive" in (tbl or "").lower() or "personal_info" in (tbl or "").lower() for (tbl,) in tables)
    pipeline = ["BG1"]
    if require_bg2 or ("BG2" in impacted):
        pipeline.append("BG2")
    if require_bg3 or ("BG3" in impacted):
        pipeline.append("BG3")
    pipeline.append("FINAL")
    cursor.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID = ?", (rule_id,))
    stage = 1
    for grp in pipeline:
        if grp == "FINAL":
            cursor.execute("""
                INSERT INTO BRM_RULE_APPROVALS (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE)
                VALUES (?, ?, ?, 0, NULL, ?)
            """, (rule_id, "FINAL", "final_approver", stage))
        else:
            sub_cursor = conn.cursor()
            sub_cursor.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME = ?", (grp,))
            for (uname,) in sub_cursor.fetchall():
                cursor.execute("""
                    INSERT INTO BRM_RULE_APPROVALS (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE)
                    VALUES (?, ?, ?, 0, NULL, ?)
                """, (rule_id, grp, uname, stage))
        stage += 1
    conn.commit()

def find_impacted_groups_bfs(conn, start_rule_id):
    """
    Performs a BFS from start_rule_id and returns a set of OWNER_GROUP values.
    """
    visited = set()
    queue = [start_rule_id]
    adjacency, _, _ = load_rule_relationships(conn)
    cursor = conn.cursor()
    impacted = set()
    while queue:
        rid = queue.pop(0)
        if rid in visited:
            continue
        visited.add(rid)
        cursor.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID = ?", (rid,))
        row = cursor.fetchone()
        if row:
            impacted.add(row[0])
        if rid in adjacency:
            for child in adjacency[rid]:
                if child not in visited:
                    queue.append(child)
    return impacted

# -------------------------------
# BFS LOGIC & RULE RELATIONSHIPS
# -------------------------------
def load_rule_relationships(conn):
    """
    Builds an adjacency list, root rules list, and a parent mapping from the rules.
    Considers:
      - Parent-child relationships (PARENT_RULE_ID).
      - Global Critical Relationships (BRM_GLOBAL_CRITICAL_LINKS).
      - Conflicts (RULE_CONFLICTS, treated as symmetric).
      - Composite rules (parsing COMPOSITE_RULES.LOGIC_EXPR for references).
    Returns: (adjacency, roots, parent_mapping)
    """
    cursor = conn.cursor()
    cursor.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = cursor.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for rid, pid in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid
    # Global Critical Relationships
    cursor.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    for gcr, child in cursor.fetchall():
        adjacency.setdefault(gcr, set()).add(child)
    # Conflicts (symmetrical)
    cursor.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
    for r1, r2, _ in cursor.fetchall():
        adjacency.setdefault(r1, set()).add(r2)
        adjacency.setdefault(r2, set()).add(r1)
    # Composite rules: parse LOGIC_EXPR for references like "RuleX"
    cursor.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    pattern = re.compile(r"Rule(\d+)", re.IGNORECASE)
    for cid, expr in cursor.fetchall():
        if expr:
            matches = pattern.findall(expr)
            for m in matches:
                try:
                    sub_rule = int(m)
                    adjacency.setdefault(sub_rule, set()).add(cid)
                except Exception:
                    continue
    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]
    return (adjacency, roots, parent_map)

def gather_all_related_rule_ids(conn, start_rule_id):
    """
    Performs BFS starting from start_rule_id and returns all reachable rule IDs.
    """
    adjacency, _, _ = load_rule_relationships(conn)
    visited = set()
    queue = [start_rule_id]
    while queue:
        current = queue.pop(0)
        if current in visited:
            continue
        visited.add(current)
        if current in adjacency:
            for nxt in adjacency[current]:
                if nxt not in visited:
                    queue.append(nxt)
    return visited

def skip_descendants(start_id, adjacency, skipped):
    """
    Recursively mark all descendant rule IDs starting from start_id as skipped.
    """
    stack = [start_id]
    while stack:
        current = stack.pop()
        if current in skipped:
            continue
        skipped.add(current)
        if current in adjacency:
            for child in adjacency[current]:
                if child not in skipped:
                    stack.append(child)

def get_all_rules_map(conn):
    """
    Retrieves all rules and returns a mapping from RULE_ID to rule record (as a dict).
    """
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES")
    rows = cursor.fetchall()
    cols = [desc[0] for desc in cursor.description]
    rule_map = {}
    for row in rows:
        record = dict(zip(cols, row))
        rule_map[record["RULE_ID"]] = record
    return rule_map

def execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=None, skip_data_validation=False, measure_perf=False):
    """
    Executes BFS over rules considering child, global-critical, conflict, and composite relationships.
    If selected_rule_ids is provided, BFS starts from them; otherwise, from root rules.
    Optionally runs data validations.
    Returns a tuple (executed_rule_ids, skipped_rule_ids).
    """
    adjacency, roots, _ = load_rule_relationships(conn)
    rule_map = get_all_rules_map(conn)
    if not selected_rule_ids:
        queue = list(roots)
    else:
        queue = list(selected_rule_ids)
    executed = []
    skipped = set()
    start_time = time.time() if measure_perf else None
    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        rule_info = rule_map[rid]
        if not skip_data_validation:
            cursor = conn.cursor()
            cursor.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rid,))
            validation_failed = False
            for db_name, tbl in cursor.fetchall():
                if tbl:
                    full_table = (db_name + "." + tbl).lower()
                    if not run_data_validations_for_table(conn, full_table):
                        validation_failed = True
                        break
            if validation_failed:
                skipped.add(rid)
                if rid in adjacency:
                    for child in adjacency[rid]:
                        skip_descendants(child, adjacency, skipped)
                continue
        success, msg, rec_count, elapsed = run_single_rule(conn, rule_info, is_dry_run=False)
        insert_performance_log(conn, rid, success, msg, rec_count, elapsed)
        if success:
            executed.append(rid)
            if rid in adjacency:
                for child in adjacency[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            # For critical rules, skip their descendants
            is_critical = (rule_info.get("CRITICAL_RULE") == 1 or rule_info.get("IS_GLOBAL") == 1)
            critical_scope = (rule_info.get("CRITICAL_SCOPE") or "NONE").upper()
            if is_critical and critical_scope != "NONE":
                if rid in adjacency:
                    for child in adjacency[rid]:
                        skip_descendants(child, adjacency, skipped)
            skipped.add(rid)
    if measure_perf and start_time:
        total_elapsed = time.time() - start_time
        logger.debug(f"BFS execution total elapsed: {total_elapsed:.4f} seconds")
    return (executed, skipped)

def run_single_rule(conn, rule_info, is_dry_run=False):
    """
    Executes a single rule's SQL.
    If the result's first column equals 1, the rule passes.
    Rolls back if the rule fails or if it's a dry run.
    Returns (success_flag, message, record_count, elapsed_seconds).
    """
    start_time = time.time()
    sql_stmt = (rule_info.get("RULE_SQL") or "").strip()
    cursor = conn.cursor()
    cursor.execute("BEGIN TRANSACTION")
    success = False
    message = ""
    record_count = 0
    try:
        cursor.execute(sql_stmt)
        rows = cursor.fetchall()
        if rows:
            record_count = len(rows)
            value = rows[0][0]
            success = (value == 1)
            message = f"Returned: {value}"
        else:
            success = True
            message = "No rows returned => PASS"
        if not success or is_dry_run:
            cursor.execute("ROLLBACK")
        else:
            cursor.execute("COMMIT")
    except Exception as ex:
        cursor.execute("ROLLBACK")
        success = False
        message = str(ex)
    elapsed = round(time.time() - start_time, 4)
    return (success, message, record_count, elapsed)

def insert_performance_log(conn, rule_id, pass_flag, message, record_count, elapsed):
    """
    Inserts performance metrics into RULE_EXECUTION_LOGS.
    """
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO RULE_EXECUTION_LOGS (RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS)
        VALUES (?, GETDATE(), ?, ?, ?, ?)
    """, (rule_id, 1 if pass_flag else 0, message, record_count, int(elapsed * 1000)))
    conn.commit()

# -------------------------------
# ADVANCED CRUD FUNCTIONS
# -------------------------------
def add_rule(conn, rule_data, created_by_user_id, created_by_group):
    """
    Adds a new rule:
      - Checks table permissions.
      - Parses SQL dependencies.
      - Checks for duplicates.
      - Sets lifecycle state to DRAFT.
      - Inserts rule and its table dependencies.
      - Logs the insertion.
      - Creates multi-step approvals.
    """
    rule_sql = rule_data.get("RULE_SQL", "").strip()
    if rule_sql:
        enforce_table_permissions_for_rule(conn, created_by_group, rule_sql)
    op_type = detect_operation_type(rule_sql)
    deps = parse_sql_dependencies(rule_sql)
    cursor = conn.cursor()
    cursor.execute("""
        SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP = ? AND RULE_NAME = ?
    """, (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if cursor.fetchone():
        raise ValueError("Duplicate rule name in that group.")
    if rule_sql:
        cursor.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL = ?", (rule_sql,))
        if cursor.fetchone():
            raise ValueError("A rule with the exact same SQL already exists.")
    if rule_data.get("IS_GLOBAL", 0) == 1 and created_by_group != "Admin":
        raise ValueError("Only Admin can create a global rule.")
    rule_data["LIFECYCLE_STATE"] = "DRAFT"
    now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    # Insert rule and return the new RULE_ID (assumes OUTPUT clause supported)
    row = cursor.execute("""
        INSERT INTO BRM_RULES(
            GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID,
            RULE_NAME, RULE_SQL,
            EFFECTIVE_START_DATE, EFFECTIVE_END_DATE,
            STATUS, VERSION, CREATED_BY,
            DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
            CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP,
            APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE,
            CRITICAL_SCOPE, CDC_TYPE, LIFECYCLE_STATE
        )
        OUTPUT inserted.RULE_ID
        VALUES (?, ?, ?, ?, ?,
                ?, ?,
                ?, 1,
                ?,
                ?, ?, ?,
                ?, ?, ?,
                'APPROVAL_IN_PROGRESS', ?, ?, ?, ?, ?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        rule_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS", "INACTIVE"),
        str(created_by_user_id),
        rule_data.get("DESCRIPTION", ""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        now_str,
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("IS_GLOBAL", 0),
        rule_data.get("CRITICAL_RULE", 0),
        rule_data.get("CRITICAL_SCOPE", "NONE"),
        rule_data.get("CDC_TYPE", "NONE"),
        rule_data["LIFECYCLE_STATE"]
    )).fetchone()
    if not row:
        raise ValueError("Insertion failed: no RULE_ID returned.")
    new_rule_id = row[0]
    col_op = "READ" if op_type == "SELECT" else "WRITE"
    for (schema, table, alias, is_subselect) in deps["tables"]:
        if table and not table.startswith("(CTE)"):
            db_name = schema if schema else "dbo"
            cursor.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                    RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES (?, ?, ?, ?, ?)
            """, (new_rule_id, db_name, table, "AutoCol", col_op))
    insert_audit_log(conn, "INSERT", "BRM_RULES", new_rule_id, str(created_by_user_id), None, rule_data)
    conn.commit()
    create_multistep_approvals(conn, new_rule_id)
    return new_rule_id

def update_rule(conn, rule_data, updated_by_user_id, updated_by_group):
    """
    Updates an existing rule:
      - Checks that the rule is locked by the current user (unless admin).
      - Validates new SQL and parses dependencies.
      - Updates the rule, sets status to INACTIVE, lifecycle to UNDER_APPROVAL, and increments version.
      - Deletes and re-inserts table dependencies.
      - Logs the update.
      - Re-creates the approval pipeline.
    """
    rule_id = rule_data["RULE_ID"]
    lock_info = rule_current_lock_owner(conn, rule_id)
    if lock_info:
        if lock_info[0] != updated_by_user_id and updated_by_group != "Admin":
            raise ValueError(f"Rule {rule_id} is locked by user {lock_info[0]}; update not permitted.")
    else:
        if updated_by_group != "Admin":
            raise ValueError(f"Rule {rule_id} is not locked; update not permitted (unless admin).")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [desc[0] for desc in cursor.description]
    old_data = dict(zip(cols, old_row))
    if old_data.get("IS_GLOBAL", 0) == 1 and updated_by_group != "Admin":
        raise ValueError("Only Admin can update a global rule.")
    new_sql = rule_data.get("RULE_SQL", "").strip()
    if new_sql and new_sql != old_data.get("RULE_SQL", ""):
        enforce_table_permissions_for_rule(conn, updated_by_group, new_sql)
        cursor.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL = ?", (new_sql,))
        row2 = cursor.fetchone()
        if row2 and row2[0] != rule_id:
            raise ValueError("Another rule with identical SQL exists.")
    op_type = detect_operation_type(new_sql)
    deps = parse_sql_dependencies(new_sql)
    cursor.execute("""
        UPDATE BRM_RULES
        SET GROUP_ID = ?,
            PARENT_RULE_ID = ?,
            RULE_TYPE_ID = ?,
            RULE_NAME = ?,
            RULE_SQL = ?,
            EFFECTIVE_START_DATE = ?,
            EFFECTIVE_END_DATE = ?,
            STATUS = 'INACTIVE',
            VERSION = VERSION + 1,
            UPDATED_BY = ?,
            DESCRIPTION = ?,
            OPERATION_TYPE = ?,
            BUSINESS_JUSTIFICATION = ?,
            OWNER_GROUP = ?,
            APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
            IS_GLOBAL = ?,
            CRITICAL_RULE = ?,
            CRITICAL_SCOPE = ?,
            CDC_TYPE = ?,
            LIFECYCLE_STATE = 'UNDER_APPROVAL'
        WHERE RULE_ID = ?
    """, (
        rule_data.get("GROUP_ID", old_data.get("GROUP_ID")),
        rule_data.get("PARENT_RULE_ID", old_data.get("PARENT_RULE_ID")),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data.get("EFFECTIVE_START_DATE"),
        rule_data.get("EFFECTIVE_END_DATE"),
        str(updated_by_user_id),
        rule_data.get("DESCRIPTION", old_data.get("DESCRIPTION")),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data.get("BUSINESS_JUSTIFICATION")),
        rule_data.get("OWNER_GROUP", old_data.get("OWNER_GROUP")),
        rule_data.get("IS_GLOBAL", old_data.get("IS_GLOBAL")),
        rule_data.get("CRITICAL_RULE", old_data.get("CRITICAL_RULE")),
        rule_data.get("CRITICAL_SCOPE", old_data.get("CRITICAL_SCOPE")),
        rule_data.get("CDC_TYPE", old_data.get("CDC_TYPE")),
        rule_id
    ))
    conn.commit()
    # Refresh table dependencies
    cursor.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
    col_op = "READ" if op_type == "SELECT" else "WRITE"
    for (schema, table, alias, is_subselect) in deps["tables"]:
        if table and not table.startswith("(CTE)"):
            db_name = schema if schema else "dbo"
            cursor.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES (RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP)
                VALUES (?, ?, ?, ?, ?)
            """, (rule_id, db_name, table, "AutoCol", col_op))
    conn.commit()
    new_data = dict(old_data)
    new_data.update(rule_data)
    new_data["VERSION"] = old_data.get("VERSION", 1) + 1
    new_data["STATUS"] = "INACTIVE"
    new_data["LIFECYCLE_STATE"] = "UNDER_APPROVAL"
    insert_audit_log(conn, "UPDATE", "BRM_RULES", rule_id, str(updated_by_user_id), old_data, new_data)
    create_multistep_approvals(conn, rule_id)
    return

def force_activate_rule(conn, rule_id, user_id, user_group):
    """
    Force-activates a rule, bypassing normal approval.
    For non-admin users, the rule must be locked by the user.
    """
    if user_group != "Admin":
        info = rule_current_lock_owner(conn, rule_id)
        if not info:
            raise ValueError(f"Rule {rule_id} is not locked; force activation not allowed.")
        if info[0] != user_id:
            raise ValueError(f"Rule {rule_id} is locked by {info[0]}; you cannot force activate.")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    cursor.execute("""
        UPDATE BRM_RULES
        SET STATUS = 'ACTIVE',
            LIFECYCLE_STATE = 'ACTIVE',
            APPROVAL_STATUS = 'FORCE_ACTIVATED'
        WHERE RULE_ID = ?
    """, (rule_id,))
    new_data = dict(old_data)
    new_data["STATUS"] = "ACTIVE"
    new_data["LIFECYCLE_STATE"] = "ACTIVE"
    new_data["APPROVAL_STATUS"] = "FORCE_ACTIVATED"
    insert_audit_log(conn, "FORCE_ACTIVATE", "BRM_RULES", rule_id, str(user_id), old_data, new_data)
    conn.commit()

def force_deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Force-deactivates a rule.
    For non-admin users, the rule must be locked by the user.
    """
    if user_group != "Admin":
        info = rule_current_lock_owner(conn, rule_id)
        if not info:
            raise ValueError(f"Rule {rule_id} is not locked; cannot force deactivate.")
        if info[0] != user_id:
            raise ValueError(f"Rule {rule_id} is locked by {info[0]}; cannot force deactivate.")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    cursor.execute("""
        UPDATE BRM_RULES
        SET STATUS = 'INACTIVE',
            LIFECYCLE_STATE = 'INACTIVE',
            APPROVAL_STATUS = 'FORCE_DEACTIVATED'
        WHERE RULE_ID = ?
    """, (rule_id,))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["LIFECYCLE_STATE"] = "INACTIVE"
    new_data["APPROVAL_STATUS"] = "FORCE_DEACTIVATED"
    insert_audit_log(conn, "FORCE_DEACTIVATE", "BRM_RULES", rule_id, str(user_id), old_data, new_data)
    conn.commit()

def deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Deactivates a rule normally.
    Ensures rule is fully approved, has no active children, and if global,
    only an Admin can perform deactivation.
    """
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    if old_data.get("APPROVAL_STATUS") != "APPROVED":
        raise ValueError("Rule is not fully approved; cannot deactivate.")
    if old_data.get("IS_GLOBAL", 0) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate a global rule.")
    if user_group != "Admin":
        info = rule_current_lock_owner(conn, rule_id)
        if not info or info[0] != user_id:
            raise ValueError("Rule is not locked by you; cannot deactivate.")
    cursor.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID = ? AND STATUS = 'ACTIVE'", (rule_id,))
    if cursor.fetchone():
        raise ValueError("Active child rules exist; deactivate them first.")
    cursor.execute("""
        UPDATE BRM_RULES
        SET STATUS = 'INACTIVE',
            UPDATED_BY = ?,
            VERSION = VERSION + 1,
            LIFECYCLE_STATE = 'INACTIVE'
        WHERE RULE_ID = ?
    """, (str(user_id), rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old_data.get("VERSION", 1) + 1
    new_data["LIFECYCLE_STATE"] = "INACTIVE"
    insert_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, str(user_id), old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Deletes a rule.
    Rule must be fully approved, inactive, have no active children,
    and no references (e.g., in BRM_COLUMN_MAPPING).
    """
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    old_row = cursor.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols = [d[0] for d in cursor.description]
    old_data = dict(zip(cols, old_row))
    if old_data.get("IS_GLOBAL", 0) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old_data.get("APPROVAL_STATUS") != "APPROVED":
        raise ValueError("Rule is not fully approved; cannot delete.")
    if old_data.get("STATUS") != "INACTIVE":
        raise ValueError("Rule must be inactive before deletion.")
    if user_group != "Admin":
        info = rule_current_lock_owner(conn, rule_id)
        if not info or info[0] != action_by:
            raise ValueError("Rule is not locked by you; deletion not allowed.")
    cursor.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID = ?", (rule_id,))
    if cursor.fetchone():
        raise ValueError("Child rules exist; remove them first.")
    cursor.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID = ? OR RULE_ID = ?", (rule_id, rule_id))
    if cursor.fetchone():
        raise ValueError("References exist in BRM_COLUMN_MAPPING; remove them first.")
    cursor.execute("DELETE FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    insert_audit_log(conn, "DELETE", "BRM_RULES", rule_id, str(action_by), old_data, None)
    conn.commit()

# End of PART 2
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 3 of 8 (SCHEDULING, SYNC METADATA, SIMULATIONS, ADVANCED FEATURE TABS)
----------------------------------------------------------------------------
This module builds on PART 1 & PART 2 components and provides:
  • sync_metadata_improved: Synchronizes metadata from system tables to BRM_RULE_TABLE_DEPENDENCIES.
  • EnhancedScheduleDialog: A dialog for scheduling rule execution.
  • ScheduleManagementTab: A tab to view, add, update, and delete rule schedules.
  • Simulation functions for BFS-based rule execution:
         - simulate_single_rule_bfs
         - simulate_chain_bfs
         - simulate_custom_group_bfs
  • Simulation dialogs:
         - SingleRuleSimulationDialog
         - ChainSimulationDialog
         - GroupSimulationDialog
  • Fully implemented advanced feature tabs:
         - DecisionTablesTab
         - ConflictPriorityManagerTab
         - CompositeRulesTab
         - SnapshotManagerTab
         - TagsManagerTab
         - DataValidationTab
         - WhatIfTestTab

Note: This module assumes that helper functions such as fetch_all_dict, fetch_one_dict,
      insert_audit_log, parse_sql_dependencies, detect_operation_type,
      rule_current_lock_owner, lock_rule_for_edit, unlock_rule_for_edit,
      auto_unlock_expired_locks, and execute_rules_with_conflicts_composites_bfs
      (from PART 1 and PART 2) are available.
"""

import sys
import json
import math
import csv
import time
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel,
    QPushButton, QPlainTextEdit, QLineEdit, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QFileDialog, QCheckBox
)
from PyQt5.QtCore import Qt, QDate, QTime

import pyqtgraph as pg

# -------------------------------
# SYNC METADATA FUNCTION (from PART 1)
# -------------------------------
def sync_metadata_improved(conn):
    cursor = conn.cursor()
    cursor.execute("""
        SELECT 
            s.name AS schema_name,
            t.name AS table_name,
            c.name AS column_name,
            typ.name AS data_type
        FROM sys.columns c
        JOIN sys.tables t ON c.object_id = t.object_id
        JOIN sys.schemas s ON t.schema_id = s.schema_id
        JOIN sys.types typ ON c.user_type_id = typ.user_type_id
        ORDER BY s.name, t.name, c.column_id
    """)
    actual_columns = []
    for row in cursor.fetchall():
        schema_name, table_name, column_name, data_type = row
        full_table = f"{schema_name}.{table_name}".lower()
        actual_columns.append((full_table, column_name.lower(), data_type.lower()))
    table_map = {}
    for full_table, col_name, data_type in actual_columns:
        table_map.setdefault(full_table, {})[col_name] = data_type
    cursor.execute("SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    dependencies = cursor.fetchall()
    missing_count = 0
    updated_count = 0
    for dep in dependencies:
        dep_id, db_name, tbl_name, col_name = dep
        full_tbl = f"{db_name}.{tbl_name}".lower().strip(".")
        if full_tbl not in table_map:
            if not tbl_name.startswith("MISSING_"):
                cursor.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET TABLE_NAME = 'MISSING_' + TABLE_NAME WHERE DEPENDENCY_ID = ?", (dep_id,))
                missing_count += 1
        else:
            if col_name:
                col_lower = col_name.lower()
                if col_lower in table_map[full_tbl]:
                    dt_value = table_map[full_tbl][col_lower]
                    try:
                        cursor.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET DATA_TYPE = ? WHERE DEPENDENCY_ID = ?", (dt_value, dep_id))
                        updated_count += 1
                    except Exception:
                        pass
    conn.commit()
    msg = (f"Metadata sync complete.\nFound {len(table_map)} tables.\nScanned {len(dependencies)} dependencies.\n"
           f"Marked {missing_count} missing; updated {updated_count} data types.")
    QMessageBox.information(None, "Sync Metadata", msg)

# -------------------------------
# SCHEDULING COMPONENTS
# -------------------------------
class EnhancedScheduleDialog(QDialog):
    """
    Dialog for scheduling rule execution.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Enhanced Scheduling")
        self.resize(420, 320)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.rule_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            self.rule_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
        form.addRow("Select Rule:", self.rule_combo)
        self.calendar = QCalendarWidget()
        self.calendar.setGridVisible(True)
        self.calendar.setSelectedDate(QDate.currentDate())
        form.addRow("Select Date:", self.calendar)
        self.time_edit = QLineEdit()
        self.time_edit.setPlaceholderText("HH:mm:ss (24-hour)")
        form.addRow("Select Time:", self.time_edit)
        self.validation_cb = QCheckBox("Run Data Validations?")
        form.addRow("Options:", self.validation_cb)
        layout.addLayout(form)
        btn_layout = QHBoxLayout()
        schedule_btn = QPushButton("Schedule")
        schedule_btn.clicked.connect(self.schedule_rule)
        btn_layout.addWidget(schedule_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.close)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def schedule_rule(self):
        rule_id = self.rule_combo.currentData()
        date_str = self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str = self.time_edit.text().strip() or "00:00:00"
        qtime = QTime.fromString(time_str, "HH:mm:ss")
        if not qtime.isValid():
            QMessageBox.warning(self, "Invalid Time", "Enter time in HH:mm:ss format.")
            return
        schedule_dt = f"{date_str} {qtime.toString('HH:mm:ss')}"
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO RULE_SCHEDULES (RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, VALIDATION_FLAG)
            VALUES (?, ?, 'Scheduled', GETDATE(), ?)
        """, (rule_id, schedule_dt, 1 if self.validation_cb.isChecked() else 0))
        self.conn.commit()
        QMessageBox.information(self, "Scheduled", f"Rule {rule_id} scheduled at {schedule_dt}.")
        self.close()

class ScheduleManagementTab(QWidget):
    """
    Tab for managing rule schedules.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 6)
        self.schedule_table.setHorizontalHeaderLabels(["ScheduleID", "RuleID", "ScheduleTime", "Status", "Validate?", "Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(refresh_btn)
        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_schedules()
    
    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT TOP 1000 SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, VALIDATION_FLAG
            FROM RULE_SCHEDULES
            ORDER BY SCHEDULE_TIME DESC
        """)
        for row in cursor.fetchall():
            row_idx = self.schedule_table.rowCount()
            self.schedule_table.insertRow(row_idx)
            for col_idx, val in enumerate(row):
                self.schedule_table.setItem(row_idx, col_idx, QTableWidgetItem(str(val)))
            action_widget = QWidget()
            act_layout = QHBoxLayout(action_widget)
            act_layout.setContentsMargins(0, 0, 0, 0)
            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, idx=row_idx: self.update_schedule(idx))
            act_layout.addWidget(upd_btn)
            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, idx=row_idx: self.delete_schedule(idx))
            act_layout.addWidget(del_btn)
            act_layout.addStretch()
            self.schedule_table.setCellWidget(row_idx, 5, action_widget)
        self.schedule_table.resizeColumnsToContents()
    
    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.conn, self)
        dlg.exec_()
        self.load_schedules()
    
    def update_schedule(self, row_idx):
        item = self.schedule_table.item(row_idx, 0)
        if not item:
            return
        schedule_id = int(item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME = ? WHERE SCHEDULE_ID = ?", (new_dt.strip(), schedule_id))
            self.conn.commit()
            QMessageBox.information(self, "Updated", f"Schedule {schedule_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()
    
    def delete_schedule(self, row_idx):
        item = self.schedule_table.item(row_idx, 0)
        if not item:
            return
        schedule_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {schedule_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID = ?", (schedule_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", f"Schedule {schedule_id} deleted.")
        self.load_schedules()

# -------------------------------
# SIMULATION FUNCTIONS
# -------------------------------
def simulate_single_rule_bfs(conn, rule_id, skip_data_validation=False):
    """
    Runs BFS simulation starting from a single rule.
    """
    return execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=[rule_id], skip_data_validation=skip_data_validation, measure_perf=False)

def simulate_chain_bfs(conn, parent_rule_id, skip_data_validation=False):
    """
    Runs BFS simulation starting from the given parent rule.
    """
    return execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=[parent_rule_id], skip_data_validation=skip_data_validation, measure_perf=False)

def simulate_custom_group_bfs(conn, custom_group_id, skip_data_validation=False):
    """
    Runs BFS simulation for all rules in the specified custom group.
    """
    cursor = conn.cursor()
    cursor.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (custom_group_id,))
    rows = cursor.fetchall()
    if not rows:
        return ([], set())
    rule_ids = [r[0] for r in rows]
    return execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=rule_ids, skip_data_validation=skip_data_validation, measure_perf=False)

# -------------------------------
# SIMULATION DIALOGS
# -------------------------------
class SingleRuleSimulationDialog(QDialog):
    """
    Dialog for simulating a single rule execution using BFS.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Single Rule Simulation")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.rule_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            self.rule_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
        form.addRow("Select Rule:", self.rule_combo)
        self.skip_validation_cb = QCheckBox("Skip Data Validations?")
        form.addRow(self.skip_validation_cb)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Run BFS Simulation")
        run_btn.clicked.connect(self.run_simulation)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def run_simulation(self):
        rule_id = self.rule_combo.currentData()
        skip_val = self.skip_validation_cb.isChecked()
        executed, skipped = simulate_single_rule_bfs(self.conn, rule_id, skip_val)
        result = f"Executed: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(result)

class ChainSimulationDialog(QDialog):
    """
    Dialog for simulating BFS from a parent rule.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Chain Simulation")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.parent_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            self.parent_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
        form.addRow("Parent Rule:", self.parent_combo)
        self.skip_validation_cb = QCheckBox("Skip Data Validations?")
        form.addRow(self.skip_validation_cb)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        sim_btn = QPushButton("Simulate BFS Chain")
        sim_btn.clicked.connect(self.run_simulation)
        btn_layout.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def run_simulation(self):
        parent_rule_id = self.parent_combo.currentData()
        skip_val = self.skip_validation_cb.isChecked()
        executed, skipped = simulate_chain_bfs(self.conn, parent_rule_id, skip_val)
        result = f"Chain BFS starting from {parent_rule_id}\nExecuted: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(result)

class GroupSimulationDialog(QDialog):
    """
    Dialog for simulating BFS for a custom group.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Custom Group Simulation")
        self.resize(500, 400)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.group_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for group_id, group_name in cursor.fetchall():
            self.group_combo.addItem(f"{group_id} - {group_name}", group_id)
        form.addRow("Custom Group:", self.group_combo)
        self.skip_validation_cb = QCheckBox("Skip Data Validations?")
        form.addRow(self.skip_validation_cb)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        sim_btn = QPushButton("Simulate BFS Group")
        sim_btn.clicked.connect(self.run_simulation)
        btn_layout.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def run_simulation(self):
        group_id = self.group_combo.currentData()
        skip_val = self.skip_validation_cb.isChecked()
        executed, skipped = simulate_custom_group_bfs(self.conn, group_id, skip_val)
        result = f"Group BFS for group {group_id}\nExecuted: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(result)

# -------------------------------
# ADVANCED FEATURE TABS (FULLY IMPLEMENTED)
# -------------------------------
class DecisionTablesTab(QWidget):
    """
    Manages decision tables.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["DecisionTableID", "TableName", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add DecisionTable")
        add_btn.clicked.connect(self.add_decision_table)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete DecisionTable")
        del_btn.clicked.connect(self.delete_decision_table)
        btn_layout.addWidget(del_btn)
        run_btn = QPushButton("Run DecisionTable")
        run_btn.clicked.connect(self.run_decision_table)
        btn_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_decision_tables)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_decision_tables()

    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in cursor.fetchall():
            row_idx = self.dt_table.rowCount()
            self.dt_table.insertRow(row_idx)
            for col, val in enumerate(row):
                self.dt_table.setItem(row_idx, col, QTableWidgetItem(str(val) if val else ""))

    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add DecisionTable", "TableName:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES (?, ?)", (name.strip(), desc.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Decision table created.")
        self.load_decision_tables()

    def delete_decision_table(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        item = self.dt_table.item(row, 0)
        dt_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete decision table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID = ?", (dt_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Decision table deleted.")
        self.load_decision_tables()

    def run_decision_table(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        item = self.dt_table.item(row, 0)
        dt_id = int(item.text())
        # For full implementation, decision logic would run here.
        QMessageBox.information(self, "Run DecisionTable", f"Decision table {dt_id} executed (stub success).")

class ConflictPriorityManagerTab(QWidget):
    """
    Manages rule conflicts.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "RuleID1", "RuleID2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        set_priority_btn = QPushButton("Set Priority")
        set_priority_btn.clicked.connect(self.set_priority)
        btn_layout.addWidget(set_priority_btn)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        for row in cursor.fetchall():
            row_idx = self.cf_table.rowCount()
            self.cf_table.insertRow(row_idx)
            for col, val in enumerate(row):
                self.cf_table.setItem(row_idx, col, QTableWidgetItem(str(val)))
    
    def add_conflict(self):
        rule1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        rule2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Enter integer priority:")
        if not ok3:
            return
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO RULE_CONFLICTS (RULE_ID1, RULE_ID2, PRIORITY) VALUES (?, ?, ?)", (rule1, rule2, priority))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Conflict added.")
        self.load_conflicts()
    
    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            return
        item = self.cf_table.item(row, 0)
        conflict_id = int(item.text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {conflict_id}:")
        if not ok:
            return
        cursor = self.conn.cursor()
        cursor.execute("UPDATE RULE_CONFLICTS SET PRIORITY = ? WHERE CONFLICT_ID = ?", (new_priority, conflict_id))
        self.conn.commit()
        QMessageBox.information(self, "Updated", "Conflict priority updated.")
        self.load_conflicts()
    
    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            return
        item = self.cf_table.item(row, 0)
        conflict_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {conflict_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID = ?", (conflict_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Conflict deleted.")
        self.load_conflicts()

class CompositeRulesTab(QWidget):
    """
    Manages composite rules.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["CompositeRuleID", "CompositeName", "LogicExpr", "ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete Composite")
        del_btn.clicked.connect(self.delete_composite)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_composites)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        for row in cursor.fetchall():
            row_idx = self.cr_table.rowCount()
            self.cr_table.insertRow(row_idx)
            for col, val in enumerate(row):
                self.cr_table.setItem(row_idx, col, QTableWidgetItem(str(val) if val else ""))

    def add_composite(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Composite Name:")
        if not ok or not name.strip():
            return
        logic_expr, ok2 = QInputDialog.getText(self, "Logic Expression", "Enter logic expression (e.g., 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            logic_expr = ""
        action, ok3 = QInputDialog.getText(self, "Action On Pass", "Optional action (e.g., 'SendEmail'):")
        if not ok3:
            action = ""
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO COMPOSITE_RULES (CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS) VALUES (?, ?, ?)", (name.strip(), logic_expr.strip(), action.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Composite rule created.")
        self.load_composites()

    def delete_composite(self):
        row = self.cr_table.currentRow()
        if row < 0:
            return
        item = self.cr_table.item(row, 0)
        composite_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {composite_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID = ?", (composite_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Composite rule deleted.")
        self.load_composites()

class SnapshotManagerTab(QWidget):
    """
    Manages snapshots of BRM_RULES.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapshotID", "SnapshotName", "CreatedBy", "CreatedTS", "SnapshotJSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)
        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_layout.addWidget(take_btn)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
            FROM RULE_SNAPSHOTS
            ORDER BY SNAPSHOT_ID DESC
        """)
        for row in cursor.fetchall():
            row_idx = self.ss_table.rowCount()
            self.ss_table.insertRow(row_idx)
            for col, val in enumerate(row):
                self.ss_table.setItem(row_idx, col, QTableWidgetItem(str(val) if val else ""))
    
    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Snapshot Name:")
        if not ok or not name.strip():
            return
        cursor = self.conn.cursor()
        cursor.execute("SELECT * FROM BRM_RULES")
        rows = cursor.fetchall()
        cols = [desc[0] for desc in cursor.description]
        snapshot_data = [dict(zip(cols, row)) for row in rows]
        snapshot_json = json.dumps(snapshot_data, indent=2)
        cursor.execute("""
            INSERT INTO RULE_SNAPSHOTS (SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
            VALUES (?, 'SnapshotUser', ?)
        """, (name.strip(), snapshot_json))
        self.conn.commit()
        QMessageBox.information(self, "Snapshot", "Snapshot taken.")
        self.load_snapshots()

    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            return
        item = self.ss_table.item(row, 0)
        snapshot_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snapshot_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID = ?", (snapshot_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Snapshot deleted.")
        self.load_snapshots()

class TagsManagerTab(QWidget):
    """
    Manages textual tags associated with rules.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        btn_layout.addWidget(add_btn)
        rem_btn = QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        btn_layout.addWidget(rem_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tags)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        for row in cursor.fetchall():
            row_idx = self.tags_table.rowCount()
            self.tags_table.insertRow(row_idx)
            for col, val in enumerate(row):
                self.tags_table.setItem(row_idx, col, QTableWidgetItem(str(val) if val else ""))

    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "Enter Rule ID:")
        if not ok:
            return
        tag_name, ok2 = QInputDialog.getText(self, "Tag", "Enter tag name:")
        if not ok2 or not tag_name.strip():
            return
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO RULE_TAGS (RULE_ID, TAG_NAME) VALUES (?, ?)", (rule_id, tag_name.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Tag added.")
        self.load_tags()

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            return
        item = self.tags_table.item(row, 0)
        tag_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_TAGS WHERE TAG_ID = ?", (tag_id,))
        self.conn.commit()
        QMessageBox.information(self, "Removed", "Tag removed.")
        self.load_tags()

class DataValidationTab(QWidget):
    """
    Manages data validation rules and allows manual execution of validations.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.dv_table = QTableWidget(0, 5)
        self.dv_table.setHorizontalHeaderLabels(["ValidationID", "TableName", "ColumnName", "ValidationType", "Params"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_layout.addWidget(add_btn)
        rem_btn = QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_validation)
        btn_layout.addWidget(rem_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        btn_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        for row in cursor.fetchall():
            row_idx = self.dv_table.rowCount()
            self.dv_table.insertRow(row_idx)
            for col, val in enumerate(row):
                self.dv_table.setItem(row_idx, col, QTableWidgetItem(str(val) if val else ""))

    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Table name (e.g., 'dbo.Customers'):")
        if not ok or not table_name.strip():
            return
        column_name, ok2 = QInputDialog.getText(self, "Column", "Column name:")
        if not ok2 or not column_name.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "Type (e.g., 'NOT NULL', 'RANGE', 'REGEX'):")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "Optional parameters (e.g., '0,100'):")
        if not ok4:
            params = ""
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO DATA_VALIDATIONS (TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS) VALUES (?, ?, ?, ?)",
                       (table_name.strip(), column_name.strip(), vtype.strip(), params.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Validation rule added.")
        self.load_validations()

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            return
        item = self.dv_table.item(row, 0)
        validation_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation {validation_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID = ?", (validation_id,))
        self.conn.commit()
        QMessageBox.information(self, "Removed", "Validation rule removed.")
        self.load_validations()

    def run_all_validations(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        tables = cursor.fetchall()
        failed = []
        for (table_name,) in tables:
            if table_name and not run_data_validations_for_table(self.conn, table_name.lower()):
                failed.append(table_name)
        if failed:
            QMessageBox.warning(self, "Validation Results", "Validations failed for: " + ", ".join(failed))
        else:
            QMessageBox.information(self, "Validation Results", "All validations passed.")

class WhatIfTestTab(QWidget):
    """
    Provides What-If testing for a rule.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.csv_path = None
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            self.rule_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)
        self.bfs_cb = QCheckBox("Use BFS Execution?")
        top_layout.addWidget(self.bfs_cb)
        self.skip_val_cb = QCheckBox("Skip Validations?")
        top_layout.addWidget(self.skip_val_cb)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        mid_layout = QHBoxLayout()
        upload_btn = QPushButton("Upload CSV")
        upload_btn.clicked.connect(self.upload_csv)
        mid_layout.addWidget(upload_btn)
        run_btn = QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        mid_layout.addWidget(run_btn)
        mid_layout.addStretch()
        layout.addLayout(mid_layout)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        self.setLayout(layout)
    
    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if path:
            self.csv_path = path
            QMessageBox.information(self, "CSV Uploaded", f"CSV file '{path}' selected.")
        else:
            self.csv_path = None
    
    def run_test(self):
        rule_id = self.rule_combo.currentData()
        use_bfs = self.bfs_cb.isChecked()
        skip_val = self.skip_val_cb.isChecked()
        if use_bfs:
            executed, skipped = execute_rules_with_conflicts_composites_bfs(self.conn, selected_rule_ids=[rule_id], skip_data_validation=skip_val, measure_perf=False)
            result = f"BFS Simulation:\nExecuted: {executed}\nSkipped: {list(skipped)}\nCSV: {self.csv_path or 'None'}"
        else:
            cursor = self.conn.cursor()
            cursor.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
            row = cursor.fetchone()
            if not row:
                self.result_text.setPlainText(f"Rule {rule_id} not found.")
                return
            sql_stmt = row[0]
            if not skip_val:
                cursor2 = self.conn.cursor()
                cursor2.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
                for db_name, tbl in cursor2.fetchall():
                    if tbl:
                        full_table = (db_name + "." + tbl).lower()
                        if not run_data_validations_for_table(self.conn, full_table):
                            self.result_text.setPlainText(f"Data validation failed for {full_table}.")
                            return
            from time import perf_counter
            start = perf_counter()
            try:
                cursor.execute("BEGIN TRANSACTION")
                cursor.execute(sql_stmt)
                rows = cursor.fetchall()
                if rows:
                    rec_count = len(rows)
                    success = (rows[0][0] == 1)
                    msg = f"Returned: {rows[0][0]}"
                else:
                    success = True
                    rec_count = 0
                    msg = "No rows returned => PASS"
                cursor.execute("ROLLBACK")
            except Exception as ex:
                cursor.execute("ROLLBACK")
                success = False
                rec_count = 0
                msg = str(ex)
            elapsed_ms = int((perf_counter() - start) * 1000)
            result = (f"Single Run Simulation:\nSuccess: {success}\nMessage: {msg}\n"
                      f"Records: {rec_count}\nTime: {elapsed_ms} ms\nCSV: {self.csv_path or 'None'}")
        self.result_text.setPlainText(result)

# ──────────────────────────────────────────────
# End of PART 3
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 4 of 8 (AUDIT LOG VIEWER, RULE SEARCH, VERSION HISTORY, RULE DASHBOARD, RULE EDITOR)
---------------------------------------------------------------------------------------------
This module provides:
  • AuditLogViewer – a QDialog to display audit logs from BRM_AUDIT_LOG with search and CSV export.
  • RuleSearchDialog – a QDialog to search rules by name, SQL snippet, or tags.
  • VersionHistoryDialog – a QDialog showing version history for a rule with diff view and rollback option.
  • RuleDashboard – a QGroupBox displaying a paginated table of rules with filtering and performance stats.
  • RuleEditorDialog – a QDialog for adding or updating rules with integrated lock/unlock and approval triggers.

Note: This module assumes that core helper functions from PART 1 and PART 2 (e.g.:
      fetch_all_dict, fetch_one_dict, insert_audit_log, parse_sql_dependencies, detect_operation_type,
      rule_current_lock_owner, lock_rule_for_edit, unlock_rule_for_edit, add_rule, update_rule, delete_rule,
      auto_unlock_expired_locks, and the constant RULE_LIFECYCLE_STATES)
      are available in the runtime.
"""

import sys
import json
import csv
import difflib
from datetime import datetime

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QLineEdit, QMessageBox, QFileDialog, QPlainTextEdit,
    QInputDialog, QComboBox, QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox, QWidget
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

# -------------------------------
# AUDIT LOG VIEWER
# -------------------------------
class AuditLogViewer(QDialog):
    """
    Displays audit logs from BRM_AUDIT_LOG.
    Provides search functionality and CSV export.
    """
    def __init__(self, conn, user_group, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.user_group = user_group
        self.setWindowTitle("Audit Logs (PART 4)")
        self.resize(900, 600)
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search in action, table, actor, or data...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        layout.addLayout(top_layout)
        self.log_table = QTableWidget(0, 8)
        self.log_table.setHorizontalHeaderLabels(["AuditID", "Action", "Table", "RecordID", "ActionBy", "OldData", "NewData", "Timestamp"])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_layout.addWidget(refresh_btn)
        export_btn = QPushButton("Export CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addWidget(export_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT TOP 1000 AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
        """)
        for row in cursor.fetchall():
            row_idx = self.log_table.rowCount()
            self.log_table.insertRow(row_idx)
            for col_idx, value in enumerate(row):
                # If column is OLD_DATA or NEW_DATA, format JSON if possible
                if col_idx in (5, 6) and value:
                    try:
                        parsed = json.loads(value)
                        value = json.dumps(parsed, indent=2)
                    except Exception:
                        pass
                item = QTableWidgetItem(str(value) if value is not None else "")
                if col_idx == 1:
                    # Highlight actions like DELETE, REJECT, FORCE_DEACTIVATE
                    action_val = (str(value) or "").upper()
                    if action_val in ("DELETE", "REJECT", "FORCE_DEACTIVATE"):
                        item.setBackground(QColor(255, 215, 0))
                self.log_table.setItem(row_idx, col_idx, item)
        self.log_table.resizeColumnsToContents()

    def perform_search(self, text):
        txt = text.lower()
        for row in range(self.log_table.rowCount()):
            visible = False
            for col in range(self.log_table.columnCount()):
                item = self.log_table.item(row, col)
                if item and txt in item.text().lower():
                    visible = True
                    break
            self.log_table.setRowHidden(row, not visible)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Audit Logs", "", "CSV Files (*.csv)")
        if not path:
            return
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row):
                    continue
                row_data = []
                for col in range(self.log_table.columnCount()):
                    item = self.log_table.item(row, col)
                    row_data.append(item.text() if item else "")
                writer.writerow(row_data)
        QMessageBox.information(self, "Exported", f"Audit logs exported to {path}.")

# -------------------------------
# RULE SEARCH DIALOG
# -------------------------------
class RuleSearchDialog(QDialog):
    """
    Allows searching for rules by name, SQL snippet, or tag.
    """
    def __init__(self, conn, user_group, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.user_group = user_group
        self.setWindowTitle("Rule Search (PART 4)")
        self.resize(900, 600)
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Name, SQL snippet, or tag...")
        self.search_edit.textChanged.connect(self.load_results)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        layout.addLayout(top_layout)
        self.result_table = QTableWidget(0, 8)
        self.result_table.setHorizontalHeaderLabels(["RuleID", "Name", "SQL", "Status", "Version", "OwnerGroup", "Tags", "CreatedBy"])
        self.result_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.result_table)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_results)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt = self.search_edit.text().strip()
        cursor = self.conn.cursor()
        if txt:
            cursor.execute("""
                SELECT DISTINCT TOP 1000
                    R.RULE_ID, R.RULE_NAME, R.RULE_SQL, R.STATUS,
                    R.VERSION, R.OWNER_GROUP,
                    (SELECT STRING_AGG(T.TAG_NAME, ',') FROM RULE_TAGS T WHERE T.RULE_ID = R.RULE_ID) AS TAGS,
                    R.CREATED_BY
                FROM BRM_RULES R
                LEFT JOIN RULE_TAGS TT ON TT.RULE_ID = R.RULE_ID
                WHERE (R.RULE_NAME LIKE ? OR R.RULE_SQL LIKE ? OR TT.TAG_NAME LIKE ?)
                ORDER BY R.RULE_ID DESC
            """, (f"%{txt}%", f"%{txt}%", f"%{txt}%"))
        else:
            cursor.execute("""
                SELECT TOP 1000
                    R.RULE_ID, R.RULE_NAME, R.RULE_SQL, R.STATUS,
                    R.VERSION, R.OWNER_GROUP,
                    (SELECT STRING_AGG(T.TAG_NAME, ',') FROM RULE_TAGS T WHERE T.RULE_ID = R.RULE_ID) AS TAGS,
                    R.CREATED_BY
                FROM BRM_RULES R
                ORDER BY R.RULE_ID DESC
            """)
        self.result_table.setRowCount(0)
        for row in cursor.fetchall():
            idx = self.result_table.rowCount()
            self.result_table.insertRow(idx)
            for col, val in enumerate(row):
                self.result_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
        self.result_table.resizeColumnsToContents()

# -------------------------------
# VERSION HISTORY DIALOG
# -------------------------------
class VersionHistoryDialog(QDialog):
    """
    Displays the version history of a rule.
    Provides a diff view and an option to rollback.
    """
    def __init__(self, conn, rule_id, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (PART 4)")
        self.resize(900, 500)
        layout = QVBoxLayout(self)
        self.history_table = QTableWidget(0, 6)
        self.history_table.setHorizontalHeaderLabels(["AuditID", "Action", "Timestamp", "OldData", "NewData", "Compare"])
        self.history_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.history_table)
        btn_layout = QHBoxLayout()
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.rollback_version)
        btn_layout.addWidget(rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        self.history_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
            FROM BRM_AUDIT_LOG
            WHERE TABLE_NAME = 'BRM_RULES' AND RECORD_ID = ? AND ACTION IN ('INSERT','UPDATE')
            ORDER BY ACTION_TIMESTAMP DESC
        """, (self.rule_id,))
        for row in cursor.fetchall():
            idx = self.history_table.rowCount()
            self.history_table.insertRow(idx)
            for col, val in enumerate(row):
                if col in (3, 4) and val:
                    try:
                        parsed = json.loads(val)
                        val = json.dumps(parsed, indent=2)
                    except Exception:
                        pass
                self.history_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
            diff_btn = QPushButton("Diff")
            diff_btn.clicked.connect(lambda _, row_idx=idx: self.show_diff(row_idx))
            self.history_table.setCellWidget(idx, 5, diff_btn)
        self.history_table.resizeColumnsToContents()

    def show_diff(self, row_idx):
        old_item = self.history_table.item(row_idx, 3)
        new_item = self.history_table.item(row_idx, 4)
        old_text = old_item.text() if old_item else ""
        new_text = new_item.text() if new_item else ""
        diff_lines = list(difflib.unified_diff(old_text.splitlines(), new_text.splitlines(),
                                               fromfile="OldData", tofile="NewData", lineterm=""))
        diff_text = "\n".join(diff_lines)
        dlg = QDialog(self)
        dlg.setWindowTitle("Line-by-Line Diff")
        dlg.resize(800, 600)
        vlayout = QVBoxLayout(dlg)
        diff_edit = QPlainTextEdit()
        diff_edit.setReadOnly(True)
        diff_edit.setPlainText(diff_text)
        vlayout.addWidget(diff_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        vlayout.addWidget(close_btn)
        dlg.setLayout(vlayout)
        dlg.exec_()

    def rollback_version(self):
        selected = self.history_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a row to rollback.")
            return
        row_idx = selected[0].row()
        old_item = self.history_table.item(row_idx, 3)
        if not old_item or not old_item.text().strip():
            QMessageBox.warning(self, "Missing Data", "No old data available; cannot rollback.")
            return
        confirm = QMessageBox.question(self, "Confirm Rollback", "Rollback to this version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_item.text().strip())
        except Exception as ex:
            QMessageBox.critical(self, "JSON Error", str(ex))
            return
        if self.perform_rollback(old_data):
            QMessageBox.information(self, "Rollback", "Rollback successful.")
            self.load_history()
        else:
            QMessageBox.warning(self, "Rollback", "Rollback failed.")

    def perform_rollback(self, old_data):
        rule_id = old_data.get("RULE_ID")
        if not rule_id:
            return False
        cursor = self.conn.cursor()
        cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
        row = cursor.fetchone()
        if not row:
            return False
        old_sql = old_data.get("RULE_SQL", "")
        op_type = detect_operation_type(old_sql)
        deps = parse_sql_dependencies(old_sql)
        cursor.execute("BEGIN TRANSACTION")
        try:
            cursor.execute("""
                UPDATE BRM_RULES
                SET RULE_NAME = ?,
                    RULE_SQL = ?,
                    OWNER_GROUP = ?,
                    STATUS = 'INACTIVE',
                    VERSION = VERSION + 1,
                    UPDATED_BY = 'Rollback',
                    APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
                    LIFECYCLE_STATE = 'UNDER_APPROVAL'
                WHERE RULE_ID = ?
            """, (old_data.get("RULE_NAME", "RolledBack"), old_sql, old_data.get("OWNER_GROUP", "BG1"), rule_id))
            cursor.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
            col_op = "READ" if op_type == "SELECT" else "WRITE"
            for (schema, table, alias, is_subselect) in deps["tables"]:
                if table and not table.startswith("(CTE)"):
                    db_name = schema if schema else "dbo"
                    cursor.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES (RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP)
                        VALUES (?, ?, ?, ?, ?)
                    """, (rule_id, db_name, table, "RolledBackCol", col_op))
            cursor.execute("COMMIT")
            return True
        except Exception:
            cursor.execute("ROLLBACK")
            return False

# -------------------------------
# RULE DASHBOARD
# -------------------------------
class RuleDashboard(QGroupBox):
    """
    Displays a paginated, filterable table of rules along with performance stats.
    """
    def __init__(self, conn, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.conn = conn
        self.user_id = user_id
        self.user_group = user_group
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by name or SQL...")
        self.search_edit.textChanged.connect(self.load_rules)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_layout.addWidget(QLabel("Status:"))
        top_layout.addWidget(self.status_filter)
        layout.addLayout(top_layout)
        self.rule_table = QTableWidget(0, 10)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "Name", "SQL", "Status", "Version", "OwnerGroup",
            "LockStatus", "Perf(ms avg)", "CreatedTS", "ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)
        nav_layout = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.page_label = QLabel("Page 1/1")
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        nav_layout.addWidget(self.prev_btn)
        nav_layout.addWidget(self.page_label)
        nav_layout.addWidget(self.next_btn)
        nav_layout.addStretch()
        layout.addLayout(nav_layout)
        self.setLayout(layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.load_rules()

    def build_filter_clause(self):
        filters = []
        params = []
        text = self.search_edit.text().strip()
        if text:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{text}%", f"%{text}%"])
        status = self.status_filter.currentData()
        if status:
            filters.append("STATUS = ?")
            params.append(status)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params

    def load_rules(self):
        cursor = self.conn.cursor()
        clause, params = self.build_filter_clause()
        count_query = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        cursor.execute(count_query, params)
        total = cursor.fetchone()[0]
        self.total_pages = max(1, -(-total // self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        if self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page
        data_query = f"""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
                   LOCK_STATUS, PERF_MS_AVG, CREATED_TIMESTAMP, APPROVAL_STATUS
            FROM BRM_RULES
            WHERE {clause}
            ORDER BY RULE_ID DESC
            OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        cursor.execute(data_query, (*params, offset, self.records_per_page))
        self.rule_table.setRowCount(0)
        for row in cursor.fetchall():
            idx = self.rule_table.rowCount()
            self.rule_table.insertRow(idx)
            for col, val in enumerate(row):
                item = QTableWidgetItem(str(val) if val is not None else "")
                if col == 6 and val and str(val).upper() == "LOCKED":
                    item.setBackground(QColor(255, 160, 160))
                self.rule_table.setItem(idx, col, item)
        self.rule_table.resizeColumnsToContents()

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

    def get_selected_rule_ids(self):
        selected = []
        for index in self.rule_table.selectionModel().selectedRows():
            row = index.row()
            item = self.rule_table.item(row, 0)
            if item:
                selected.append(int(item.text()))
        return selected

# -------------------------------
# RULE EDITOR DIALOG
# -------------------------------
class RuleEditorDialog(QDialog):
    """
    Dialog for adding or updating a rule.
    Implements lock/unlock logic, permission checks, and triggers re-approval.
    """
    def __init__(self, conn, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = rule_data is not None
        self.rule_locked = False
        title = "Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(f"{title} (PART 4)")
        self.resize(850, 650)
        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.group_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        for gid, gname in cursor.fetchall():
            self.group_combo.addItem(f"{gname} (ID={gid})", gid)
        form.addRow("Rule Group:", self.group_combo)

        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rid, rname in cursor.fetchall():
            self.parent_combo.addItem(f"{rname} (ID={rid})", rid)
        form.addRow("Parent Rule:", self.parent_combo)

        self.name_edit = QLineEdit()
        form.addRow("Rule Name:", self.name_edit)

        self.rule_type_combo = QComboBox()
        cursor.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for rt_id, rt_name in cursor.fetchall():
            self.rule_type_combo.addItem(rt_name, rt_id)
        form.addRow("Rule Type:", self.rule_type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE", "ACTIVE"])
        form.addRow("Status:", self.status_combo)

        self.start_datetime_edit = QDateTimeEdit()
        self.start_datetime_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_datetime_edit.setCalendarPopup(True)
        form.addRow("Effective Start:", self.start_datetime_edit)

        self.end_datetime_edit = QDateTimeEdit()
        self.end_datetime_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_datetime_edit.setCalendarPopup(True)
        form.addRow("Effective End:", self.end_datetime_edit)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "UPSERT", "INSERT_ONLY"])
        form.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => pass, else 0 => fail.")
        form.addRow("Rule SQL:", self.sql_edit)

        self.description_edit = QTextEdit()
        form.addRow("Description:", self.description_edit)

        self.justification_edit = QTextEdit()
        form.addRow("Business Justification:", self.justification_edit)

        self.global_cb = QCheckBox("Global?")
        form.addRow("Global:", self.global_cb)

        self.critical_cb = QCheckBox("Critical Rule?")
        form.addRow("Critical:", self.critical_cb)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        form.addRow("Critical Scope:", self.scope_combo)

        layout.addLayout(form)
        btn_layout = QHBoxLayout()
        self.save_btn = QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        btn_layout.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        if self.is_update:
            self.lock_btn = QPushButton("Lock for Edit")
            self.lock_btn.clicked.connect(self.lock_rule)
            btn_layout.addWidget(self.lock_btn)
            self.unlock_btn = QPushButton("Unlock")
            self.unlock_btn.setEnabled(False)
            self.unlock_btn.clicked.connect(self.unlock_rule)
            btn_layout.addWidget(self.unlock_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        if self.is_update and self.rule_data:
            self.load_existing_rule()

    def load_existing_rule(self):
        rd = self.rule_data
        gid = rd.get("GROUP_ID")
        if gid:
            idx = self.group_combo.findData(gid)
            if idx >= 0:
                self.group_combo.setCurrentIndex(idx)
        pid = rd.get("PARENT_RULE_ID")
        if pid:
            idx = self.parent_combo.findData(pid)
            if idx >= 0:
                self.parent_combo.setCurrentIndex(idx)
        self.name_edit.setText(rd.get("RULE_NAME", ""))
        rt_id = rd.get("RULE_TYPE_ID")
        if rt_id:
            idx = self.rule_type_combo.findData(rt_id)
            if idx >= 0:
                self.rule_type_combo.setCurrentIndex(idx)
        status = rd.get("STATUS", "INACTIVE")
        idx_status = self.status_combo.findText(status)
        if idx_status >= 0:
            self.status_combo.setCurrentIndex(idx_status)
        fmt = "%Y-%m-%d %H:%M:%S"
        sd = rd.get("EFFECTIVE_START_DATE", "")
        ed = rd.get("EFFECTIVE_END_DATE", "")
        if sd:
            try:
                dt_s = datetime.strptime(sd, fmt)
                self.start_datetime_edit.setDateTime(dt_s)
            except Exception:
                pass
        if ed:
            try:
                dt_e = datetime.strptime(ed, fmt)
                self.end_datetime_edit.setDateTime(dt_e)
            except Exception:
                pass
        cdc_val = rd.get("CDC_TYPE", "NONE").upper()
        idx_cdc = self.cdc_combo.findText(cdc_val)
        if idx_cdc >= 0:
            self.cdc_combo.setCurrentIndex(idx_cdc)
        if rd.get("RULE_SQL"):
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        self.global_cb.setChecked(bool(rd.get("IS_GLOBAL", 0)))
        self.critical_cb.setChecked(bool(rd.get("CRITICAL_RULE", 0)))
        scope_val = rd.get("CRITICAL_SCOPE", "NONE").upper()
        idx_scope = self.scope_combo.findText(scope_val)
        if idx_scope >= 0:
            self.scope_combo.setCurrentIndex(idx_scope)

    def save_rule(self):
        rule_name = self.name_edit.text().strip()
        if not rule_name:
            QMessageBox.warning(self, "Error", "Rule name is required.")
            return
        rule_sql = self.sql_edit.toPlainText().strip()
        group_id = self.group_combo.currentData()
        parent_id = self.parent_combo.currentData()
        rt_id = self.rule_type_combo.currentData()
        status = self.status_combo.currentText()
        start_dt = self.start_datetime_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_dt = self.end_datetime_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_type = self.cdc_combo.currentText().upper()
        description = self.description_edit.toPlainText().strip()
        justification = self.justification_edit.toPlainText().strip()
        is_global = 1 if self.global_cb.isChecked() else 0
        is_critical = 1 if self.critical_cb.isChecked() else 0
        scope_val = self.scope_combo.currentText().upper()
        cursor = self.conn.cursor()
        cursor.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID = ?", (group_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Error", "Group not found.")
            return
        owner_group = row[0]
        rule_dict = {
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": rule_name,
            "RULE_SQL": rule_sql,
            "EFFECTIVE_START_DATE": start_dt,
            "EFFECTIVE_END_DATE": end_dt,
            "STATUS": status,
            "DESCRIPTION": description,
            "BUSINESS_JUSTIFICATION": justification,
            "IS_GLOBAL": is_global,
            "CRITICAL_RULE": is_critical,
            "CRITICAL_SCOPE": scope_val,
            "CDC_TYPE": cdc_type,
            "OWNER_GROUP": owner_group
        }
        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm", "Update rule now?")
            if confirm != QMessageBox.Yes:
                return
            try:
                update_rule(self.conn, rule_dict, "CurrentUserID", self.user_group)
                QMessageBox.information(self, "Updated", "Rule updated and re-approval triggered.")
                if self.rule_locked:
                    self.unlock_rule()
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
        else:
            confirm = QMessageBox.question(self, "Confirm", "Add new rule now?")
            if confirm != QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.conn, rule_dict, "CurrentUserID", self.user_group)
                QMessageBox.information(self, "Created", f"New rule created with ID {new_id}.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))

    def lock_rule(self):
        if not self.is_update or not self.rule_data:
            QMessageBox.warning(self, "Error", "Lock applicable only for existing rules.")
            return
        rule_id = self.rule_data["RULE_ID"]
        try:
            lock_rule_for_edit(self.conn, rule_id, "CurrentUserID", force=False, user_group=self.user_group)
            QMessageBox.information(self, "Locked", f"Rule {rule_id} locked.")
            self.rule_locked = True
            self.lock_btn.setEnabled(False)
            self.unlock_btn.setEnabled(True)
        except Exception as ex:
            QMessageBox.critical(self, "Lock Error", str(ex))

    def unlock_rule(self):
        if not self.is_update or not self.rule_data:
            return
        rule_id = self.rule_data["RULE_ID"]
        try:
            unlock_rule_for_edit(self.conn, rule_id, "CurrentUserID", force=False, admin_override=False, user_group=self.user_group)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} unlocked.")
            self.rule_locked = False
            self.lock_btn.setEnabled(True)
            self.unlock_btn.setEnabled(False)
        except Exception as ex:
            QMessageBox.critical(self, "Unlock Error", str(ex))

# ──────────────────────────────────────────────
# End of PART 4
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 5 of 8 (APPROVALS, GLOBAL/CRITICAL ADMIN, HIERARCHY, ENHANCED LINEAGE)
-----------------------------------------------------------------------------
This module provides advanced functionality:
  • multi_step_approval_tab: Displays pending approvals with a color‐coded pipeline.
    – Users can Approve or Reject; Admins see an enabled “ForceUnlock” button.
  • global_critical_admin_tab: Allows Admin users to set global/critical flags on rules,
    and to link or unlink child rules via BRM_GLOBAL_CRITICAL_LINKS.
  • hierarchy_view_tab: Shows a tree view of groups and rules. Drag‑and‑drop changes a rule’s parent and group,
    triggering a database update and re‑approval.
  • enhanced_lineage_graph_widget: Draws an ER‑style diagram of rules (as boxes) and table dependencies.
    Nodes are color‑coded by status; double‐clicking a node shows details; and search highlighting is supported.
    
Assumptions:
  – Helper functions such as rule_current_lock_owner, lock_rule_for_edit,
    unlock_rule_for_edit, insert_audit_log, parse_sql_dependencies, detect_operation_type,
    execute_rules_with_conflicts_composites_bfs, run_data_validations_for_table, and auto_unlock_expired_locks
    are available from PART 1–PART 2.
"""

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QAbstractItemView, QMessageBox, QComboBox, QLabel,
    QLineEdit, QDialog, QTreeWidget, QTreeWidgetItem, QMenu,
    QInputDialog, QFileDialog, QGraphicsView, QGraphicsScene, QGraphicsItem, QPlainTextEdit
)
from PyQt5.QtCore import Qt, QPoint, QRectF
from PyQt5.QtGui import QBrush, QColor, QPen, QPainter

import re, difflib, time

# -------------------------------
# MULTI-STEP APPROVAL TAB
# -------------------------------
class MultiStepApprovalTab(QWidget):
    """
    Displays pending approvals for the current user.
    Shows a color‑coded approval pipeline (e.g. "[1] BG1:User(PEND) -> [2] BG2:User(PEND) -> [3] FINAL")
    Provides buttons to Approve, Reject, and, for Admin users, ForceUnlock.
    """
    def __init__(self, conn, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.approval_table = QTableWidget(0, 9)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID", "Group", "RuleName", "Stage", "Approved?",
            "Pipeline", "Approve", "Reject", "ForceUnlock"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        self.approval_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.approval_table)

        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, 
                   A.APPROVAL_STAGE, R.RULE_NAME
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
            WHERE A.USERNAME = ? AND A.APPROVED_FLAG = 0
            ORDER BY A.RULE_ID
        """, (self.logged_in_username,))
        rows = cursor.fetchall()
        # Determine minimal unapproved stage per rule.
        minimal_stage = {}
        rule_rows = {}
        for row in rows:
            rule_id = row[0]
            rule_rows.setdefault(rule_id, []).append(row)
        for rule_id, recs in rule_rows.items():
            cursor.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID = ? AND APPROVED_FLAG = 0
            """, (rule_id,))
            min_stage = cursor.fetchone()[0]
            minimal_stage[rule_id] = min_stage

        display = []
        for row in rows:
            rule_id, group_name, username, approved_flag, stage, rule_name = row
            if stage == minimal_stage.get(rule_id):
                display.append((rule_id, group_name, rule_name, stage, approved_flag, username))

        for rec in display:
            rule_id, group_name, rule_name, stage, approved_flag, username = rec
            row_idx = self.approval_table.rowCount()
            self.approval_table.insertRow(row_idx)
            self.approval_table.setItem(row_idx, 0, QTableWidgetItem(str(rule_id)))
            self.approval_table.setItem(row_idx, 1, QTableWidgetItem(group_name))
            self.approval_table.setItem(row_idx, 2, QTableWidgetItem(rule_name))
            self.approval_table.setItem(row_idx, 3, QTableWidgetItem(str(stage)))
            self.approval_table.setItem(row_idx, 4, QTableWidgetItem(str(approved_flag)))
            pipeline_text = self._build_pipeline_text(rule_id)
            self.approval_table.setItem(row_idx, 5, QTableWidgetItem(pipeline_text))
            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, idx=row_idx: self.do_approve(idx))
            self.approval_table.setCellWidget(row_idx, 6, approve_btn)
            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, idx=row_idx: self.do_reject(idx))
            self.approval_table.setCellWidget(row_idx, 7, reject_btn)
            force_btn = QPushButton("ForceUnlock")
            # Enable FORCE unlock button only for Admin users.
            if self.user_group.upper() == "ADMIN":
                force_btn.setEnabled(True)
                force_btn.clicked.connect(lambda _, idx=row_idx: self.do_force_unlock(idx))
            else:
                force_btn.setEnabled(False)
            self.approval_table.setCellWidget(row_idx, 8, force_btn)
        self.approval_table.resizeColumnsToContents()

    def _build_pipeline_text(self, rule_id):
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID = ?
            ORDER BY APPROVAL_STAGE, USERNAME
        """, (rule_id,))
        rows = cursor.fetchall()
        stage_map = {}
        for group, username, approved_flag, stage in rows:
            stage_map.setdefault(stage, []).append((group, username, approved_flag))
        parts = []
        for st in sorted(stage_map.keys()):
            items = []
            for group, username, approved_flag in stage_map[st]:
                status = "OK" if approved_flag == 1 else "PEND"
                items.append(f"{group}:{username}({status})")
            parts.append(f"[{st}] " + " / ".join(items))
        return " -> ".join(parts)

    def do_approve(self, row_idx):
        rule_item = self.approval_table.item(row_idx, 0)
        group_item = self.approval_table.item(row_idx, 1)
        if not rule_item or not group_item:
            return
        rule_id = int(rule_item.text())
        group_name = group_item.text()
        cursor = self.conn.cursor()
        cursor.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG = 1, APPROVED_TIMESTAMP = GETDATE()
            WHERE RULE_ID = ? AND GROUP_NAME = ? AND USERNAME = ? AND APPROVED_FLAG = 0
        """, (rule_id, group_name, self.logged_in_username))
        # Check if any approvals remain for this rule.
        cursor.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID = ? AND APPROVED_FLAG = 0
        """, (rule_id,))
        next_stage = cursor.fetchone()[0]
        if next_stage is None:
            cursor.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS = 'APPROVED', STATUS = 'ACTIVE', LIFECYCLE_STATE = 'ACTIVE'
                WHERE RULE_ID = ?
            """, (rule_id,))
        else:
            cursor.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS', STATUS = 'INACTIVE'
                WHERE RULE_ID = ?
            """, (rule_id,))
        insert_audit_log(self.conn, "APPROVE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, {"approved_flag": 0}, {"approved_flag": 1})
        self.conn.commit()
        QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
        self.load_approvals()

    def do_reject(self, row_idx):
        rule_item = self.approval_table.item(row_idx, 0)
        group_item = self.approval_table.item(row_idx, 1)
        if not rule_item or not group_item:
            return
        rule_id = int(rule_item.text())
        group_name = group_item.text()
        confirm = QMessageBox.question(self, "Confirm", f"Reject rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG = 2, APPROVED_TIMESTAMP = GETDATE()
            WHERE RULE_ID = ? AND GROUP_NAME = ? AND USERNAME = ? AND APPROVED_FLAG = 0
        """, (rule_id, group_name, self.logged_in_username))
        cursor.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS = 'REJECTED', STATUS = 'INACTIVE', LIFECYCLE_STATE = 'INACTIVE'
            WHERE RULE_ID = ?
        """, (rule_id,))
        insert_audit_log(self.conn, "REJECT", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None, {"rejected": True})
        self.conn.commit()
        QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
        self.load_approvals()

    def do_force_unlock(self, row_idx):
        rule_item = self.approval_table.item(row_idx, 0)
        if not rule_item:
            return
        rule_id = int(rule_item.text())
        confirm = QMessageBox.question(self, "Force Unlock", f"Force unlock rule {rule_id}? (Admin only)")
        if confirm != QMessageBox.Yes:
            return
        try:
            unlock_rule_for_edit(self.conn, rule_id, "AdminOverride", force=True, admin_override=True, user_group=self.user_group)
            QMessageBox.information(self, "Force Unlock", f"Rule {rule_id} forcibly unlocked.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Unlock Error", str(ex))

# -------------------------------
# GLOBAL/CRITICAL ADMIN TAB
# -------------------------------
class GlobalCriticalAdminTab(QWidget):
    """
    Admin-only tab for managing global/critical flags on rules.
    Allows setting IS_GLOBAL and CRITICAL_RULE, specifying CRITICAL_SCOPE,
    and linking/unlinking rules via BRM_GLOBAL_CRITICAL_LINKS.
    """
    def __init__(self, parent, conn, user_group, parent_widget=None):
        super().__init__(parent_widget)
        self.conn = conn
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group.upper() != "ADMIN":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_layout = QHBoxLayout()
        self.show_only_gcr_cb = QCheckBox("Show only GCR rules")
        self.show_only_gcr_cb.setChecked(True)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_rule_list)
        top_layout.addWidget(self.show_only_gcr_cb)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "RuleName", "OwnerGroup", "IS_GLOBAL", "CRITICAL_RULE",
            "CRITICAL_SCOPE", "STATUS", "LOCK_STATUS", "UpdatedBy"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        flags_layout = QHBoxLayout()
        self.global_cb = QCheckBox("Set Global?")
        flags_layout.addWidget(self.global_cb)
        self.critical_cb = QCheckBox("Set Critical?")
        flags_layout.addWidget(self.critical_cb)
        flags_layout.addWidget(QLabel("Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        flags_layout.addWidget(self.scope_combo)
        apply_btn = QPushButton("Apply to Selected")
        apply_btn.clicked.connect(self.apply_flags)
        flags_layout.addWidget(apply_btn)
        flags_layout.addStretch()
        layout.addLayout(flags_layout)

        link_layout = QHBoxLayout()
        self.gcr_parent_combo = QComboBox()
        link_layout.addWidget(QLabel("Parent GCR:"))
        link_layout.addWidget(self.gcr_parent_combo)
        self.gcr_child_combo = QComboBox()
        link_layout.addWidget(QLabel("Child:"))
        link_layout.addWidget(self.gcr_child_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_layout.addWidget(link_btn)
        link_layout.addWidget(unlink_btn)
        link_layout.addStretch()
        layout.addLayout(link_layout)

        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["ParentGCR", "ChildRule"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        refresh_all_btn = QPushButton("Refresh All")
        refresh_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(refresh_all_btn)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_parent_combo()
        self.populate_child_combo()
        self.load_links()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        cursor = self.conn.cursor()
        if self.show_only_gcr_cb.isChecked():
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       CRITICAL_SCOPE, STATUS, LOCK_STATUS, UPDATED_BY
                FROM BRM_RULES
                WHERE IS_GLOBAL = 1 OR CRITICAL_RULE = 1
                ORDER BY RULE_ID DESC
            """)
        else:
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       CRITICAL_SCOPE, STATUS, LOCK_STATUS, UPDATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
        for row in cursor.fetchall():
            idx = self.rule_table.rowCount()
            self.rule_table.insertRow(idx)
            for col, val in enumerate(row):
                self.rule_table.setItem(idx, col, QTableWidgetItem(str(val) if val is not None else ""))
    
    def populate_parent_combo(self):
        self.gcr_parent_combo.clear()
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT RULE_ID, RULE_NAME
            FROM BRM_RULES
            WHERE IS_GLOBAL = 1 OR CRITICAL_RULE = 1
            ORDER BY RULE_ID
        """)
        for rule_id, rule_name in cursor.fetchall():
            self.gcr_parent_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
    
    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            self.gcr_child_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
    
    def load_links(self):
        self.link_view.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        for row in cursor.fetchall():
            idx = self.link_view.rowCount()
            self.link_view.insertRow(idx)
            self.link_view.setItem(idx, 0, QTableWidgetItem(str(row[0])))
            self.link_view.setItem(idx, 1, QTableWidgetItem(str(row[1])))
    
    def get_selected_rules(self):
        selected = []
        for index in self.rule_table.selectionModel().selectedRows():
            row = index.row()
            item = self.rule_table.item(row, 0)
            if item:
                selected.append(int(item.text()))
        return selected

    def apply_flags(self):
        selected = self.get_selected_rules()
        if not selected:
            QMessageBox.warning(self, "None", "No rules selected.")
            return
        is_global = 1 if self.global_cb.isChecked() else 0
        is_critical = 1 if self.critical_cb.isChecked() else 0
        scope_val = self.scope_combo.currentText().upper()
        confirm = QMessageBox.question(self, "Confirm", f"Set IS_GLOBAL={is_global}, CRITICAL_RULE={is_critical}, CRITICAL_SCOPE={scope_val} for {len(selected)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        for rule_id in selected:
            # Force unlock before updating
            try:
                unlock_rule_for_edit(self.conn, rule_id, "AdminOverride", force=True, admin_override=True, user_group=self.user_group)
            except Exception:
                pass
            cursor.execute("""
                UPDATE BRM_RULES
                SET IS_GLOBAL = ?, CRITICAL_RULE = ?, CRITICAL_SCOPE = ?
                WHERE RULE_ID = ?
            """, (is_global, is_critical, scope_val, rule_id))
        self.conn.commit()
        QMessageBox.information(self, "Updated", f"Flags updated for {len(selected)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Select both parent and child rules.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Link child rule {child_id} to parent rule {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS (GCR_RULE_ID, TARGET_RULE_ID) VALUES (?, ?)", (parent_id, child_id))
        insert_audit_log(self.conn, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_id}->{child_id}", "Admin", None, {"parent": parent_id, "child": child_id})
        self.conn.commit()
        QMessageBox.information(self, "Linked", f"Child rule {child_id} linked to parent rule {parent_id}.")
        self.load_links()

    def unlink_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Select both parent and child rules.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Unlink child rule {child_id} from parent rule {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID = ? AND TARGET_RULE_ID = ?", (parent_id, child_id))
        insert_audit_log(self.conn, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_id}->{child_id}", "Admin", {"parent": parent_id, "child": child_id}, None)
        self.conn.commit()
        QMessageBox.information(self, "Unlinked", f"Child rule {child_id} unlinked from parent rule {parent_id}.")
        self.load_links()

# -------------------------------
# HIERARCHY VIEW TAB
# -------------------------------
class HierarchyViewTab(QTreeWidget):
    """
    Displays groups and their rules in a tree.
    Supports drag-and-drop to update a rule's parent and group.
    On drop, the rule's GROUP_ID and PARENT_RULE_ID are updated, and an audit log is created.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setHeaderLabels(["Group / Rule (Hierarchy)"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        cursor = self.conn.cursor()
        cursor.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        group_map = {}
        for group_id, group_name in cursor.fetchall():
            top_item = QTreeWidgetItem([f"{group_name} (ID={group_id})"])
            top_item.setData(0, Qt.UserRole, ("group", group_id))
            self.addTopLevelItem(top_item)
            group_map[group_id] = top_item
        cursor.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rule_map = {}
        for rule_id, rule_name, group_id, parent_rule_id in cursor.fetchall():
            rule_map[rule_id] = (rule_name, group_id, parent_rule_id)
        for rule_id, (rule_name, group_id, parent_rule_id) in rule_map.items():
            if not parent_rule_id:
                if group_id in group_map:
                    parent_item = group_map[group_id]
                    child = QTreeWidgetItem([f"Rule {rule_id}: {rule_name}"])
                    child.setData(0, Qt.UserRole, ("rule", rule_id))
                    parent_item.addChild(child)
        self.expandAll()

    def dropEvent(self, event):
        source_item = self.currentItem()
        if not source_item:
            super().dropEvent(event)
            return
        data = source_item.data(0, Qt.UserRole)
        if not data or data[0] != "rule":
            super().dropEvent(event)
            return
        super().dropEvent(event)
        new_parent = source_item.parent()
        if not new_parent:
            QMessageBox.information(self, "Invalid", "Cannot move rule to top-level. Reverting.")
            self.load_hierarchy()
            return
        parent_data = new_parent.data(0, Qt.UserRole)
        rule_id = data[1]
        cursor = self.conn.cursor()
        if parent_data[0] == "group":
            new_group_id = parent_data[1]
            try:
                unlock_rule_for_edit(self.conn, rule_id, "HierarchyDrag", force=True, admin_override=True, user_group="Admin")
            except Exception:
                pass
            old_data = self.get_rule_dict(rule_id)
            cursor.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID = ?, PARENT_RULE_ID = NULL,
                    STATUS = 'INACTIVE', APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
                    VERSION = VERSION + 1, UPDATED_BY = 'HierarchyView'
                WHERE RULE_ID = ?
            """, (new_group_id, rule_id))
            new_data = dict(old_data)
            new_data["GROUP_ID"] = new_group_id
            new_data["PARENT_RULE_ID"] = None
            new_data["STATUS"] = "INACTIVE"
            new_data["APPROVAL_STATUS"] = "APPROVAL_IN_PROGRESS"
            insert_audit_log(self.conn, "HIERARCHY_MOVE", "BRM_RULES", rule_id, "HierarchyDrag", old_data, new_data)
            self.conn.commit()
        elif parent_data[0] == "rule":
            parent_rule_id = parent_data[1]
            try:
                unlock_rule_for_edit(self.conn, rule_id, "HierarchyDrag", force=True, admin_override=True, user_group="Admin")
            except Exception:
                pass
            parent_info = self.get_rule_dict(parent_rule_id)
            if not parent_info:
                self.load_hierarchy()
                return
            new_group_id = parent_info["GROUP_ID"]
            old_data = self.get_rule_dict(rule_id)
            cursor.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID = ?, PARENT_RULE_ID = ?,
                    STATUS = 'INACTIVE', APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
                    VERSION = VERSION + 1, UPDATED_BY = 'HierarchyView'
                WHERE RULE_ID = ?
            """, (new_group_id, parent_rule_id, rule_id))
            new_data = dict(old_data)
            new_data["GROUP_ID"] = new_group_id
            new_data["PARENT_RULE_ID"] = parent_rule_id
            new_data["STATUS"] = "INACTIVE"
            new_data["APPROVAL_STATUS"] = "APPROVAL_IN_PROGRESS"
            insert_audit_log(self.conn, "HIERARCHY_MOVE", "BRM_RULES", rule_id, "HierarchyDrag", old_data, new_data)
            self.conn.commit()
        else:
            QMessageBox.warning(self, "Invalid", "Cannot move under the selected item. Reverting.")
            self.load_hierarchy()

    def get_rule_dict(self, rule_id):
        cursor = self.conn.cursor()
        cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
        row = cursor.fetchone()
        if not row:
            return None
        cols = [d[0] for d in cursor.description]
        return dict(zip(cols, row))

# -------------------------------
# ENHANCED LINEAGE GRAPH WIDGET
# -------------------------------
class EnhancedLineageGraphWidget(QGraphicsView):
    """
    Draws an ER‑style diagram of rules and table dependencies.
    Nodes are represented as boxes with color-coding.
    Double-clicking a node shows details.
    Provides search highlighting.
    """
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.node_map = {}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, CRITICAL_RULE, IS_GLOBAL, CRITICAL_SCOPE, LOCK_STATUS
            FROM BRM_RULES
            ORDER BY RULE_ID
        """)
        rules = cursor.fetchall()
        children_map = {}
        parent_map = {}
        all_ids = set()
        for rid, rname, pid, status, crit, glob, scope, lock_status in rules:
            all_ids.add(rid)
            if pid:
                children_map.setdefault(pid, set()).add(rid)
                parent_map[rid] = pid
        roots = [r for r in all_ids if r not in parent_map]
        from collections import deque
        queue = deque()
        for r in roots:
            queue.append((r, 0))
        level_count = {}
        rule_data_map = {}
        for rid, rname, pid, status, crit, glob, scope, lock_status in rules:
            rule_data_map[rid] = {
                "RULE_ID": rid,
                "RULE_NAME": rname,
                "PARENT_RULE_ID": pid,
                "STATUS": status,
                "CRITICAL_RULE": crit,
                "IS_GLOBAL": glob,
                "CRITICAL_SCOPE": scope,
                "LOCK_STATUS": lock_status
            }
        while queue:
            rid, depth = queue.popleft()
            level_count[depth] = level_count.get(depth, 0) + 1
            x = depth * 220
            y = (level_count[depth] - 1) * 160
            node = RuleNodeItem(rule_data_map[rid])
            node.setPos(x, y)
            self.scene.addItem(node)
            self.node_map[rid] = node
            if rid in children_map:
                for child in children_map[rid]:
                    queue.append((child, depth + 1))
        # Draw edges for parent-child
        for rid in all_ids:
            pid = rule_data_map[rid]["PARENT_RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid], QColor("darkGray"))
        # Draw Global Critical Links
        cursor.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        for parent, child in cursor.fetchall():
            if parent in self.node_map and child in self.node_map:
                self.draw_edge(self.node_map[parent], self.node_map[child], QColor("blue"))
        # Draw Conflicts (dotted lines)
        cursor.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
        for r1, r2, _ in cursor.fetchall():
            if r1 in self.node_map and r2 in self.node_map:
                self.draw_edge(self.node_map[r1], self.node_map[r2], QColor("magenta"), dashed=True)
        # Draw Composite rule links
        cursor.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
        pat = re.compile(r"Rule(\d+)", re.IGNORECASE)
        for cid, expr in cursor.fetchall():
            if expr:
                matches = pat.findall(expr)
                for m in matches:
                    try:
                        sub = int(m)
                        if sub in self.node_map and cid in self.node_map:
                            self.draw_edge(self.node_map[sub], self.node_map[cid], QColor("green"))
                    except Exception:
                        continue
        # Draw table dependencies
        cursor.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        table_map = {}
        table_x = 1000
        table_y = 0
        for rid, db, tbl, col_op in cursor.fetchall():
            if not tbl:
                continue
            key = f"{db}.{tbl}".lower()
            if key not in table_map:
                tnode = TableNodeItem(key)
                tnode.setPos(table_x, table_y)
                table_y += 120
                self.scene.addItem(tnode)
                table_map[key] = tnode
            if rid in self.node_map:
                edge_color = QColor("red") if col_op.upper() == "WRITE" else QColor("blue")
                self.draw_edge(self.node_map[rid], table_map[key], edge_color)
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.reset_view()

    def draw_edge(self, item1, item2, color, dashed=False):
        p1 = item1.sceneBoundingRect().center()
        p2 = item2.sceneBoundingRect().center()
        edge = LineageEdgeItem(p1, p2, color, dashed)
        self.scene.addItem(edge)

    def reset_view(self):
        rect = self.scene.itemsBoundingRect()
        if rect.isValid():
            self.fitInView(rect, Qt.KeepAspectRatio)

    def search_and_highlight(self, text):
        text_lower = text.lower()
        for item in self.scene.items():
            item.setOpacity(0.3)
        for item in self.scene.items():
            if isinstance(item, RuleNodeItem):
                if text_lower in item.rule_data["RULE_NAME"].lower() or text_lower in (item.rule_data["STATUS"] or "").lower():
                    item.setOpacity(1.0)
            elif isinstance(item, TableNodeItem):
                if text_lower in item.table_key.lower():
                    item.setOpacity(1.0)

    def mouseDoubleClickEvent(self, event):
        item = self.itemAt(event.pos())
        if isinstance(item, RuleNodeItem):
            info = item.rule_data
            detail = (f"Rule {info['RULE_ID']}:\nName: {info['RULE_NAME']}\nStatus: {info['STATUS']}\n"
                      f"Lock: {info['LOCK_STATUS']}\nGlobal: {info['IS_GLOBAL']}, Critical: {info['CRITICAL_RULE']}\n"
                      f"Scope: {info['CRITICAL_SCOPE']}")
            QMessageBox.information(self, "Rule Details", detail)
        elif isinstance(item, TableNodeItem):
            key = item.table_key
            dlg = QMessageBox(self)
            dlg.setWindowTitle("Table Details")
            dlg.setText(f"Table: {key}\nClick 'Run Validation' to validate this table.")
            run_btn = dlg.addButton("Run Validation", QMessageBox.AcceptRole)
            dlg.addButton("Close", QMessageBox.RejectRole)
            dlg.exec_()
            if dlg.clickedButton() == run_btn:
                if run_data_validations_for_table(self.conn, key):
                    QMessageBox.information(self, "Validation", "All validations passed.")
                else:
                    QMessageBox.warning(self, "Validation", "Validation failed.")
        super().mouseDoubleClickEvent(event)

# -------------------------------
# GRAPHICS ITEMS FOR LINEAGE
# -------------------------------
class RuleNodeItem(QGraphicsItem):
    """
    Graphical box representing a rule.
    Colors:
      - PaleGreen for ACTIVE
      - LightPink for INACTIVE
      - LightGray otherwise.
    If locked, border becomes red.
    If critical or global, border is dashed.
    """
    def __init__(self, rule_data, width=150, height=80):
        super().__init__()
        self.rule_data = rule_data
        self.width = width
        self.height = height
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)

    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)

    def paint(self, painter, option, widget=None):
        status = (self.rule_data.get("STATUS") or "").upper()
        if status == "ACTIVE":
            fill = QColor("palegreen")
        elif status == "INACTIVE":
            fill = QColor("lightpink")
        else:
            fill = QColor("lightgray")
        pen = QPen(Qt.black, 2)
        if (self.rule_data.get("LOCK_STATUS") or "").upper() == "LOCKED":
            pen.setColor(QColor("red"))
            pen.setWidth(3)
        if self.rule_data.get("CRITICAL_RULE") == 1 or self.rule_data.get("IS_GLOBAL") == 1:
            pen.setStyle(Qt.DashLine)
        painter.setPen(pen)
        painter.setBrush(QBrush(fill))
        painter.drawRect(0, 0, self.width, self.height)
        text = f"R{self.rule_data['RULE_ID']}: {self.rule_data['RULE_NAME']}"
        painter.drawText(0, 0, self.width, self.height, Qt.AlignCenter, text)

class TableNodeItem(QGraphicsItem):
    """
    Graphical box representing a table dependency.
    """
    def __init__(self, table_key, width=180, height=60):
        super().__init__()
        self.table_key = table_key
        self.width = width
        self.height = height
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)

    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)

    def paint(self, painter, option, widget=None):
        pen = QPen(Qt.darkBlue, 2)
        painter.setPen(pen)
        painter.setBrush(QBrush(QColor("lightblue")))
        painter.drawRect(0, 0, self.width, self.height)
        painter.drawText(0, 0, self.width, self.height, Qt.AlignCenter, self.table_key)

class LineageEdgeItem(QGraphicsItem):
    """
    Draws an edge between two nodes.
    Supports dashed lines if required.
    """
    def __init__(self, p1, p2, color=QColor("black"), dashed=False):
        super().__init__()
        self.p1 = p1
        self.p2 = p2
        self.color = color
        self.dashed = dashed

    def boundingRect(self):
        min_x = min(self.p1.x(), self.p2.x())
        min_y = min(self.p1.y(), self.p2.y())
        return QRectF(min_x, min_y, abs(self.p2.x() - self.p1.x()), abs(self.p2.y() - self.p1.y()))

    def paint(self, painter, option, widget=None):
        pen = QPen(self.color, 2)
        if self.dashed:
            pen.setStyle(Qt.DashLine)
        painter.setPen(pen)
        painter.drawLine(self.p1, self.p2)

# ──────────────────────────────────────────────
# End of PART 5
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 6 of 8 (METRICS, CONTROL TABLES, GROUPS, USERS)
----------------------------------------------------------------
This module provides:
  • Metrics_dashboard_tab: Displays rule metrics (status counts, execution trends, validation ratios)
     using pyqtgraph charts.
  • Ctrl_tables_tab: Enables users (Admins can edit) to view data from key administrative tables.
  • Group_management_tab: For managing business groups, membership, group permissions, and group approvers.
  • User_management_tab: For managing user accounts (using plain-text passwords for demonstration).
Assumptions:
  – Core functions from PART 1 and advanced functions from PART 2 are available.
"""

import sys
import math
import csv
import json
import logging
from datetime import datetime, timedelta
from collections import defaultdict

import pyodbc

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget, QFileDialog
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

import pyqtgraph as pg

# -------------------------------
# METRICS DASHBOARD TAB
# -------------------------------
class Metrics_dashboard_tab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        # Bar chart for rule counts by status.
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        layout.addWidget(self.status_chart)

        # Line chart for daily execution counts (last 7 days).
        self.execution_chart = pg.PlotWidget(title="Executions per Day (Last 7 Days)")
        self.execution_chart.setBackground('w')
        layout.addWidget(self.execution_chart)

        # Bar chart for data validation pass/fail ratio (last 30 days).
        self.validation_chart = pg.PlotWidget(title="Data Validation Pass/Fail (Last 30 Days)")
        self.validation_chart.setBackground('w')
        layout.addWidget(self.validation_chart)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        btn_layout.addWidget(refresh_btn)
        export_btn = QPushButton("Export Metrics CSV")
        export_btn.clicked.connect(self.export_metrics_csv)
        btn_layout.addWidget(export_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        self.load_status_bar()
        self.load_execution_line()
        self.load_validation_ratio()

    def load_status_bar(self):
        cursor = self.connection.cursor()
        cursor.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        rows = cursor.fetchall()
        statuses = [row[0] for row in rows]
        counts = [row[1] for row in rows]
        self.status_chart.clear()
        if statuses:
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left", "Count")
            self.status_chart.setLabel("bottom", "Status")
            self.status_chart.showGrid(x=True, y=True)

    def load_execution_line(self):
        self.execution_chart.clear()
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120) AS exec_date,
                   COUNT(*) AS exec_count
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(day, -7, GETDATE())
            GROUP BY CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120)
            ORDER BY exec_date
        """)
        rows = cursor.fetchall()
        if not rows:
            return
        x_labels = [row[0] for row in rows]
        y_counts = [row[1] for row in rows]
        x_vals = list(range(len(x_labels)))
        self.execution_chart.plot(x_vals, y_counts, pen='b', symbol='o')
        self.execution_chart.getAxis("bottom").setTicks([list(zip(x_vals, x_labels))])
        self.execution_chart.setLabel("left", "Executions")
        self.execution_chart.setLabel("bottom", "Date")
        self.execution_chart.showGrid(x=True, y=True)

    def load_validation_ratio(self):
        self.validation_chart.clear()
        cursor = self.connection.cursor()
        try:
            cursor.execute("""
                SELECT RESULT_FLAG, COUNT(*)
                FROM DATA_VALIDATION_LOGS
                WHERE VALIDATION_TIMESTAMP >= DATEADD(day, -30, GETDATE())
                GROUP BY RESULT_FLAG
            """)
            rows = cursor.fetchall()
            pass_count = 0
            fail_count = 0
            for flag, count in rows:
                if str(flag).upper() == "PASS":
                    pass_count += count
                else:
                    fail_count += count
            if pass_count + fail_count > 0:
                x_vals = [0, 1]
                y_vals = [pass_count, fail_count]
                colors = ["green", "red"]
                bar_item = pg.BarGraphItem(x=x_vals, height=y_vals, width=0.6, brushes=colors)
                self.validation_chart.addItem(bar_item)
                self.validation_chart.getAxis("bottom").setTicks([[(0, "Pass"), (1, "Fail")]])
                self.validation_chart.setLabel("left", "Count")
                self.validation_chart.showGrid(x=True, y=True)
        except Exception:
            pass

    def export_metrics_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Metrics", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["Metric", "Value"])
                cursor = self.connection.cursor()
                cursor.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
                for status, count in cursor.fetchall():
                    writer.writerow([f"RuleStatus_{status}", count])
                cursor.execute("""
                    SELECT CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120), COUNT(*)
                    FROM RULE_EXECUTION_LOGS
                    WHERE EXECUTION_TIMESTAMP >= DATEADD(day, -7, GETDATE())
                    GROUP BY CONVERT(VARCHAR(10), EXECUTION_TIMESTAMP, 120)
                    ORDER BY 1
                """)
                for date_str, count in cursor.fetchall():
                    writer.writerow([f"Execution_{date_str}", count])
                try:
                    cursor.execute("""
                        SELECT RESULT_FLAG, COUNT(*)
                        FROM DATA_VALIDATION_LOGS
                        WHERE VALIDATION_TIMESTAMP >= DATEADD(day, -30, GETDATE())
                        GROUP BY RESULT_FLAG
                    """)
                    for flag, count in cursor.fetchall():
                        writer.writerow([f"DataValidation_{flag}", count])
                except Exception:
                    pass
            QMessageBox.information(self, "Exported", f"Metrics exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

# -------------------------------
# CTRL TABLES TAB
# -------------------------------
class Ctrl_tables_tab(QWidget):
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS", "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE", "BRM_GROUP_BACKUPS", "BRM_COLUMN_MAPPING", "BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS", "BUSINESS_GROUP_APPROVERS", "BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS", "BRM_GLOBAL_CRITICAL_LINKS", "RULE_SCHEDULES",
            "BRM_RULE_COMMENTS", "DECISION_TABLES", "RULE_CONFLICTS", "COMPOSITE_RULES",
            "RULE_SNAPSHOTS", "RULE_TAGS", "DATA_VALIDATIONS", "RULE_EXECUTION_LOGS",
            "DATA_VALIDATION_LOGS"
        ]
        top_layout = QHBoxLayout()
        self.table_combo = QComboBox()
        for tbl in self.table_list:
            self.table_combo.addItem(tbl)
        top_layout.addWidget(QLabel("Select Admin Table:"))
        top_layout.addWidget(self.table_combo)
        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_table_data)
        top_layout.addWidget(load_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.data_table = QTableWidget(0, 0)
        if self.user_group == "Admin":
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.data_table)
        self.setLayout(layout)
        self.columns = []
        self.current_table = None

    def load_table_data(self):
        tbl = self.table_combo.currentText()
        self.current_table = tbl
        self.data_table.setRowCount(0)
        cursor = self.connection.cursor()
        try:
            cursor.execute(f"SELECT TOP 1 * FROM {tbl}")
            self.columns = [desc[0] for desc in cursor.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error retrieving columns: {ex}")
            return
        try:
            cursor.execute(f"SELECT TOP 500 * FROM {tbl}")
            rows = cursor.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error retrieving data: {ex}")
            return
        self.data_table.setColumnCount(len(self.columns))
        self.data_table.setHorizontalHeaderLabels(self.columns)
        for row in rows:
            idx = self.data_table.rowCount()
            self.data_table.insertRow(idx)
            for col, val in enumerate(row):
                self.data_table.setItem(idx, col, QTableWidgetItem(str(val) if val is not None else ""))
        self.data_table.resizeColumnsToContents()

# -------------------------------
# GROUP MANAGEMENT TAB
# -------------------------------
class Group_management_tab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group.lower() != "admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Groups & Membership Tab
        groups_tab = QWidget()
        groups_layout = QVBoxLayout(groups_tab)

        groups_box = QGroupBox("Groups")
        groups_box_layout = QVBoxLayout(groups_box)
        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName", "Description", "Email"])
        groups_box_layout.addWidget(self.groups_table)
        grp_btn_layout = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.add_group)
        grp_btn_layout.addWidget(add_grp_btn)
        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.rename_group)
        grp_btn_layout.addWidget(rename_grp_btn)
        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.delete_group)
        grp_btn_layout.addWidget(del_grp_btn)
        grp_btn_layout.addStretch()
        groups_box_layout.addLayout(grp_btn_layout)
        groups_layout.addWidget(groups_box)

        membership_box = QGroupBox("Membership")
        membership_layout = QVBoxLayout(membership_box)
        self.users_table = QTableWidget(0, 3)
        self.users_table.setHorizontalHeaderLabels(["UserID", "Username", "Group"])
        membership_layout.addWidget(self.users_table)
        memb_btn_layout = QHBoxLayout()
        add_user_btn = QPushButton("Add User to Group")
        add_user_btn.clicked.connect(self.add_user_to_group)
        memb_btn_layout.addWidget(add_user_btn)
        rm_user_btn = QPushButton("Remove User from Group")
        rm_user_btn.clicked.connect(self.remove_user_from_group)
        memb_btn_layout.addWidget(rm_user_btn)
        memb_btn_layout.addStretch()
        membership_layout.addLayout(memb_btn_layout)
        groups_layout.addWidget(membership_box)
        groups_tab.setLayout(groups_layout)
        self.tabs.addTab(groups_tab, "Groups & Membership")

        # Permissions Tab
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        perm_box = QGroupBox("Group Permissions")
        perm_box_layout = QVBoxLayout(perm_box)
        top_perm_layout = QHBoxLayout()
        self.perm_group_combo = QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_perm_layout.addWidget(QLabel("Select Group:"))
        top_perm_layout.addWidget(self.perm_group_combo)
        top_perm_layout.addStretch()
        perm_box_layout.addLayout(top_perm_layout)
        self.perm_table = QTableWidget(0, 1)
        self.perm_table.setHorizontalHeaderLabels(["TargetTable"])
        perm_box_layout.addWidget(self.perm_table)
        perm_btn_layout = QHBoxLayout()
        add_perm_btn = QPushButton("Add Permission")
        add_perm_btn.clicked.connect(self.add_permission)
        perm_btn_layout.addWidget(add_perm_btn)
        rem_perm_btn = QPushButton("Remove Permission")
        rem_perm_btn.clicked.connect(self.remove_permission)
        perm_btn_layout.addWidget(rem_perm_btn)
        perm_btn_layout.addStretch()
        perm_box_layout.addLayout(perm_btn_layout)
        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab, "Permissions")

        # Approvers Tab
        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        top_appr_layout = QHBoxLayout()
        self.appr_group_combo = QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        top_appr_layout.addWidget(QLabel("Group:"))
        top_appr_layout.addWidget(self.appr_group_combo)
        top_appr_layout.addStretch()
        appr_layout.addLayout(top_appr_layout)
        self.appr_table = QTableWidget(0, 2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID", "Username"])
        appr_layout.addWidget(self.appr_table)
        appr_btn_layout = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.add_approver)
        appr_btn_layout.addWidget(add_appr_btn)
        del_appr_btn = QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.remove_approver)
        appr_btn_layout.addWidget(del_appr_btn)
        appr_btn_layout.addStretch()
        appr_layout.addLayout(appr_btn_layout)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab, "Approvers")

        refresh_all_btn = QPushButton("Refresh All")
        refresh_all_btn.clicked.connect(self.load_all_data)
        layout.addWidget(refresh_all_btn)
        self.setLayout(layout)
        self.load_all_data()

    def load_all_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in cursor.fetchall():
            idx = self.groups_table.rowCount()
            self.groups_table.insertRow(idx)
            for col, val in enumerate(row):
                self.groups_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def get_selected_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            return None
        item = self.groups_table.item(row, 0)
        return item.text().strip() if item else None
    def add_group(self):
        group_name, ok = QInputDialog.getText(self, "Add Group", "Group Name:")
        if not ok or not group_name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        email, ok3 = QInputDialog.getText(self, "Email", "Optional:")
        if not ok3:
            email = ""
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME = ?", (group_name.strip(),))
        if cursor.fetchone():
            QMessageBox.warning(self, "Error", "Group already exists.")
            return
        cursor.execute("INSERT INTO BUSINESS_GROUPS (GROUP_NAME, DESCRIPTION, EMAIL) VALUES (?, ?, ?)",
                       (group_name.strip(), desc.strip(), email.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Group created.")
        self.load_all_data()
    def rename_group(self):
        group_name = self.get_selected_group()
        if not group_name:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for '{group_name}':")
        if not ok or not new_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME = ?", (new_name.strip(),))
        if cursor.fetchone():
            QMessageBox.warning(self, "Error", "Another group with that name exists.")
            return
        old_data = {"GROUP_NAME": group_name}
        new_data = {"GROUP_NAME": new_name.strip()}
        try:
            cursor.execute("BEGIN TRANSACTION")
            cursor.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME = ? WHERE GROUP_NAME = ?", (new_name.strip(), group_name))
            cursor.execute("UPDATE BRM_RULES SET OWNER_GROUP = ? WHERE OWNER_GROUP = ?", (new_name.strip(), group_name))
            cursor.execute("COMMIT")
            insert_audit_log(self.connection, "RENAME_GROUP", "BUSINESS_GROUPS", group_name, self.user_id, old_data, new_data)
            QMessageBox.information(self, "Renamed", f"Group '{group_name}' renamed to '{new_name}'.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.load_all_data()
    def delete_group(self):
        group_name = self.get_selected_group()
        if not group_name:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{group_name}'?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        try:
            old_data = {"GROUP_NAME": group_name}
            cursor.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME = ?", (group_name,))
            cursor.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME = ?", (group_name,))
            cursor.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME = ?", (group_name,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE_GROUP", "BUSINESS_GROUPS", group_name, self.user_id, old_data, None)
            QMessageBox.information(self, "Deleted", f"Group '{group_name}' deleted.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.load_all_data()
    def load_users(self):
        self.users_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in cursor.fetchall():
            idx = self.users_table.rowCount()
            self.users_table.insertRow(idx)
            for col, val in enumerate(row):
                self.users_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def get_selected_user_id(self):
        row = self.users_table.currentRow()
        if row < 0:
            return None
        item = self.users_table.item(row, 0)
        return int(item.text()) if item else None
    def add_user_to_group(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        group_name, ok = QInputDialog.getText(self, "Assign Group", "Enter group name (existing):")
        if not ok or not group_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME = ?", (group_name.strip(),))
        if not cursor.fetchone():
            QMessageBox.warning(self, "Error", "Group not found.")
            return
        cursor.execute("UPDATE USERS SET USER_GROUP = ? WHERE USER_ID = ?", (group_name.strip(), user_id))
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"User {user_id} assigned to group {group_name}.")
        self.load_all_data()
    def remove_user_from_group(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Remove user {user_id} (assign to BG1)?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("UPDATE USERS SET USER_GROUP = 'BG1' WHERE USER_ID = ?", (user_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", f"User {user_id} reassigned to BG1.")
        self.load_all_data()
    def load_perm_group_combo(self):
        self.perm_group_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for (group_name,) in cursor.fetchall():
            self.perm_group_combo.addItem(group_name, group_name)
    def load_approvers_combo(self):
        self.appr_group_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for (group_name,) in cursor.fetchall():
            self.appr_group_combo.addItem(group_name, group_name)
    def load_permissions(self):
        group_name = self.perm_group_combo.currentData()
        self.perm_table.setRowCount(0)
        if not group_name:
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME = ?", (group_name,))
        for row in cursor.fetchall():
            idx = self.perm_table.rowCount()
            self.perm_table.insertRow(idx)
            self.perm_table.setItem(idx, 0, QTableWidgetItem(str(row[0])))
    def add_permission(self):
        group_name = self.perm_group_combo.currentData()
        if not group_name:
            return
        table_name, ok = QInputDialog.getText(self, "Add Permission", "Enter table name (e.g., 'dbo.Customers'):")
        if not ok or not table_name.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO GROUP_PERMISSIONS (GROUP_NAME, TARGET_TABLE) VALUES (?, ?)", (group_name, table_name.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", f"Permission added for {group_name} on {table_name}.")
        self.load_permissions()
    def remove_permission(self):
        group_name = self.perm_group_combo.currentData()
        row = self.perm_table.currentRow()
        if row < 0 or not group_name:
            return
        item = self.perm_table.item(row, 0)
        table_name = item.text().strip()
        confirm = QMessageBox.question(self, "Confirm", f"Remove permission for {group_name} on {table_name}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME = ? AND TARGET_TABLE = ?", (group_name, table_name))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Permission removed.")
        self.load_permissions()
    def load_approvers(self):
        group_name = self.appr_group_combo.currentData()
        self.appr_table.setRowCount(0)
        if not group_name:
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT APPROVER_ID, USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME = ?", (group_name,))
        for row in cursor.fetchall():
            idx = self.appr_table.rowCount()
            self.appr_table.insertRow(idx)
            self.appr_table.setItem(idx, 0, QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(idx, 1, QTableWidgetItem(str(row[1])))
    def add_approver(self):
        group_name = self.appr_group_combo.currentData()
        if not group_name:
            return
        username, ok = QInputDialog.getText(self, "Add Approver", f"Enter username for group {group_name}:")
        if not ok or not username.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("INSERT INTO BUSINESS_GROUP_APPROVERS (GROUP_NAME, USERNAME) VALUES (?, ?)", (group_name, username.strip()))
        self.connection.commit()
        insert_audit_log(self.connection, "ADD_APPROVER", "BUSINESS_GROUP_APPROVERS", group_name, self.user_id, None, {"approver": username})
        QMessageBox.information(self, "Added", f"Approver {username} added to group {group_name}.")
        self.load_approvers()
    def remove_approver(self):
        group_name = self.appr_group_combo.currentData()
        row = self.appr_table.currentRow()
        if row < 0:
            return
        item = self.appr_table.item(row, 0)
        approver_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove approver {approver_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID = ?", (approver_id,))
        self.connection.commit()
        insert_audit_log(self.connection, "REMOVE_APPROVER", "BUSINESS_GROUP_APPROVERS", approver_id, self.user_id, {"approver_id": approver_id}, None)
        QMessageBox.information(self, "Removed", "Approver removed.")
        self.load_approvers()

# -------------------------------
# USER MANAGEMENT TAB
# -------------------------------
class User_management_tab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["UserID", "Username", "Password", "UserGroup"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_layout.addWidget(add_btn)
        delete_btn = QPushButton("Delete User")
        delete_btn.clicked.connect(self.delete_user)
        btn_layout.addWidget(delete_btn)
        change_pwd_btn = QPushButton("Change Password")
        change_pwd_btn.clicked.connect(self.change_password)
        btn_layout.addWidget(change_pwd_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in cursor.fetchall():
            idx = self.user_table.rowCount()
            self.user_table.insertRow(idx)
            for col, val in enumerate(row):
                self.user_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def get_selected_user_id(self):
        row = self.user_table.currentRow()
        if row < 0:
            return None
        item = self.user_table.item(row, 0)
        return int(item.text()) if item else None
    def add_user(self):
        username, ok = QInputDialog.getText(self, "Add User", "Username:")
        if not ok or not username.strip():
            return
        password, ok2 = QInputDialog.getText(self, "Password", "Plain text password:")
        if not ok2 or not password.strip():
            return
        group, ok3 = QInputDialog.getText(self, "User Group", "Enter user group (e.g., BG1 or Admin):")
        if not ok3 or not group.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT 1 FROM USERS WHERE USERNAME = ?", (username.strip(),))
        if cursor.fetchone():
            QMessageBox.warning(self, "Error", "Username already exists.")
            return
        cursor.execute("INSERT INTO USERS (USERNAME, PASSWORD, USER_GROUP) VALUES (?, ?, ?)",
                       (username.strip(), password.strip(), group.strip()))
        self.connection.commit()
        insert_audit_log(self.connection, "ADD_USER", "USERS", username, "AdminUser", None, {"username": username})
        QMessageBox.information(self, "Added", "User added with plain-text password.")
        self.load_users()
    def delete_user(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete user {user_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME, PASSWORD, USER_GROUP FROM USERS WHERE USER_ID = ?", (user_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", "User not found.")
            return
        old_data = {"USERNAME": row[0], "PASSWORD": row[1], "USER_GROUP": row[2]}
        cursor.execute("DELETE FROM USERS WHERE USER_ID = ?", (user_id,))
        self.connection.commit()
        insert_audit_log(self.connection, "DELETE_USER", "USERS", user_id, "AdminUser", old_data, None)
        QMessageBox.information(self, "Deleted", f"User {user_id} deleted.")
        self.load_users()
    def change_password(self):
        user_id = self.get_selected_user_id()
        if not user_id:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        new_pwd, ok = QInputDialog.getText(self, "Change Password", "Enter new plain-text password:")
        if not ok or not new_pwd.strip():
            return
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME, PASSWORD, USER_GROUP FROM USERS WHERE USER_ID = ?", (user_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", "User not found.")
            return
        old_data = {"PASSWORD": row[1]}
        cursor.execute("UPDATE USERS SET PASSWORD = ? WHERE USER_ID = ?", (new_pwd.strip(), user_id))
        self.connection.commit()
        insert_audit_log(self.connection, "CHANGE_PASSWORD", "USERS", user_id, "AdminUser", old_data, {"PASSWORD": new_pwd.strip()})
        QMessageBox.information(self, "Updated", "Password updated.")
        self.load_users()

# ──────────────────────────────────────────────
# End of PART 6
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 7 of 8 (CUSTOM GROUPS + ALERTS)
----------------------------------------------
This module provides:
  • CustomRuleGroupEnhancedTab: Manages custom rule groups.
      - Create, rename, delete custom groups.
      - Backup and restore group membership.
      - Display groups and their assigned rules in a tree view.
      - Provide a searchable list of available (unassigned) rules.
      - Allow assignment and removal of rules from a group.
  • AlertsAndDashboardsTab: Displays alerts including:
      - Old pending approvals (> 3 days)
      - Stale locks (> 6 hours)
      - Upcoming schedules (next 24 hours)
      - Performance outliers (> 5 seconds in last 7 days)
      
Assumptions:
  – Helper functions (insert_audit_log, run_data_validations_for_table, rule_current_lock_owner,
    unlock_rule_for_edit, execute_rules_with_conflicts_composites_bfs, etc.) are available.
"""

import sys
import json
import re
from datetime import datetime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox,
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QSplitter, QMenu
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor

# -------------------------------
# CUSTOM RULE GROUP ENHANCED TAB
# -------------------------------
class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, conn, user_id, user_group, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.user_id = user_id
        self.user_group = user_group
        
        main_layout = QVBoxLayout(self)
        
        # Top controls for group operations
        top_layout = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name...")
        top_layout.addWidget(self.new_group_edit)
        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_layout.addWidget(create_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_layout.addWidget(rename_btn)
        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        top_layout.addWidget(delete_btn)
        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_layout.addWidget(backup_btn)
        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_layout.addWidget(restore_btn)
        top_layout.addStretch()
        main_layout.addLayout(top_layout)
        
        # Splitter: left tree view and right available rules list
        splitter = QSplitter(Qt.Horizontal)
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.group_tree)
        
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search available rules by name or SQL...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search_edit)
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)
        assign_btn = QPushButton("Assign Selected to Group")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        right_layout.addStretch()
        right_widget.setLayout(right_layout)
        splitter.addWidget(right_widget)
        
        main_layout.addWidget(splitter)
        self.setLayout(main_layout)
        self.refresh_all()
    
    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()
    
    def load_group_tree(self):
        self.group_tree.clear()
        cursor = self.conn.cursor()
        cursor.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID DESC")
        for group_id, group_name, owner in cursor.fetchall():
            display = f"{group_name} (Owner: {owner})"
            group_item = QTreeWidgetItem([display])
            group_item.setData(0, Qt.UserRole, group_id)
            group_item.setBackground(0, QBrush(QColor("lightgray")))
            self.group_tree.addTopLevelItem(group_item)
            # Load assigned rules for this group.
            cursor2 = self.conn.cursor()
            cursor2.execute("""
                SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE, L.LOCKED_BY
                FROM BRM_CUSTOM_GROUP_MEMBERS M
                JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
                LEFT JOIN BRM_RULE_LOCKS L ON R.RULE_ID = L.RULE_ID AND L.ACTIVE_LOCK = 1
                WHERE M.CUSTOM_GROUP_ID = ?
            """, (group_id,))
            for rule_id, rule_name, is_global, critical_rule, locked_by in cursor2.fetchall():
                rule_display = f"Rule {rule_id}: {rule_name}"
                if locked_by:
                    rule_display += f" [LOCKED by {locked_by}]"
                rule_item = QTreeWidgetItem([rule_display])
                rule_item.setData(0, Qt.UserRole, rule_id)
                if is_global == 1:
                    rule_item.setBackground(0, QBrush(QColor("lightblue")))
                if critical_rule == 1:
                    rule_item.setBackground(0, QBrush(QColor("lightcoral")))
                group_item.addChild(rule_item)
        self.group_tree.expandAll()
    
    def load_available_rules(self):
        self.rule_list.clear()
        search_text = self.rule_search_edit.text().strip()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned_ids = {row[0] for row in cursor.fetchall()}
        if search_text:
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """, (f"%{search_text}%", f"%{search_text}%"))
        else:
            cursor.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        for rule_id, rule_name, owner in cursor.fetchall():
            if rule_id in assigned_ids:
                continue
            display = f"Rule {rule_id}: {rule_name} (Owner: {owner})"
            item = QListWidgetItem(display)
            item.setData(Qt.UserRole, rule_id)
            self.rule_list.addItem(item)
    
    def create_group(self):
        name = self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Error", "Custom group name is required.")
            return
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO BRM_CUSTOM_RULE_GROUPS (CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP) VALUES (?, ?, ?, GETDATE())",
                       (name, self.user_group, self.user_id))
        self.conn.commit()
        QMessageBox.information(self, "Created", f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()
    
    def rename_group(self):
        items = self.group_tree.selectedItems()
        if not items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = items[0]
        group_id = group_item.data(0, Qt.UserRole)
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for group {group_id}:")
        if not ok or not new_name.strip():
            return
        cursor = self.conn.cursor()
        try:
            cursor.execute("BEGIN TRANSACTION")
            cursor.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME = ? WHERE CUSTOM_GROUP_ID = ?", (new_name.strip(), group_id))
            cursor.execute("COMMIT")
            insert_audit_log(self.conn, "RENAME_CUSTOM_GROUP", "BRM_CUSTOM_RULE_GROUPS", group_id, str(self.user_id), None, {"new_name": new_name})
            QMessageBox.information(self, "Renamed", f"Group {group_id} renamed to '{new_name}'.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.refresh_all()
    
    def delete_group(self):
        items = self.group_tree.selectedItems()
        if not items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = items[0]
        group_id = group_item.data(0, Qt.UserRole)
        confirm = QMessageBox.question(self, "Confirm", f"Delete custom group {group_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        try:
            old_data = {"CUSTOM_GROUP_ID": group_id}
            cursor.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            cursor.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            self.conn.commit()
            insert_audit_log(self.conn, "DELETE_CUSTOM_GROUP", "BRM_CUSTOM_RULE_GROUPS", group_id, str(self.user_id), old_data, None)
            QMessageBox.information(self, "Deleted", f"Custom group {group_id} deleted.")
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
        self.refresh_all()
    
    def backup_group(self):
        items = self.group_tree.selectedItems()
        if not items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = items[0]
        group_id = group_item.data(0, Qt.UserRole)
        cursor = self.conn.cursor()
        cursor.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", "Group not found.")
            return
        group_name = row[0]
        cursor.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
        members = [r[0] for r in cursor.fetchall()]
        backup_data = {
            "group_name": group_name,
            "members": members,
            "backup_user": self.user_id,
            "backup_timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        cursor.execute("SELECT ISNULL(MAX(BACKUP_VERSION), 0) + 1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
        new_version = cursor.fetchone()[0]
        cursor.execute("""
            INSERT INTO BRM_CUSTOM_GROUP_BACKUPS (CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON)
            VALUES (?, GETDATE(), ?, ?)
        """, (group_id, new_version, json.dumps(backup_data)))
        self.conn.commit()
        insert_audit_log(self.conn, "BACKUP_CUSTOM_GROUP", "BRM_CUSTOM_GROUP_BACKUPS", group_id, str(self.user_id), None, {"version": new_version})
        QMessageBox.information(self, "Backup", f"Backup version {new_version} for group {group_id} saved.")
        self.refresh_all()
    
    def restore_group(self):
        items = self.group_tree.selectedItems()
        if not items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = items[0]
        group_id = group_item.data(0, Qt.UserRole)
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
            FROM BRM_CUSTOM_GROUP_BACKUPS
            WHERE CUSTOM_GROUP_ID = ?
            ORDER BY BACKUP_VERSION DESC
        """, (group_id,))
        backups = cursor.fetchall()
        if not backups:
            QMessageBox.information(self, "None", "No backups for this group.")
            return
        items_list = [f"Version {r[0]} (ts={r[1]})" for r in backups]
        selected, ok = QInputDialog.getItem(self, "Restore Backup", "Select version:", items_list, 0, False)
        if not ok or not selected:
            return
        match = re.search(r"Version\s+(\d+)", selected)
        if not match:
            return
        version = int(match.group(1))
        confirm = QMessageBox.question(self, "Confirm", f"Restore group {group_id} to version {version}?")
        if confirm != QMessageBox.Yes:
            return
        backup_json = None
        for r in backups:
            if r[0] == version:
                backup_json = r[2]
                break
        if not backup_json:
            QMessageBox.warning(self, "Missing", "Backup for the selected version not found.")
            return
        try:
            data = json.loads(backup_json)
            new_group_name = data["group_name"]
            members = data["members"]
            cursor.execute("BEGIN TRANSACTION")
            cursor.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME = ? WHERE CUSTOM_GROUP_ID = ?", (new_group_name, group_id))
            cursor.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ?", (group_id,))
            for rule_id in members:
                if self.is_rule_locked(rule_id):
                    continue
                cursor.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS (CUSTOM_GROUP_ID, RULE_ID) VALUES (?, ?)", (group_id, rule_id))
            cursor.execute("COMMIT")
            insert_audit_log(self.conn, "RESTORE_CUSTOM_GROUP", "BRM_CUSTOM_GROUP_BACKUPS", group_id, str(self.user_id), {"version": version}, data)
            QMessageBox.information(self, "Restored", f"Group {group_id} restored to version {version}.")
            self.refresh_all()
        except Exception as ex:
            cursor.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
    
    def is_rule_locked(self, rule_id):
        cursor = self.conn.cursor()
        cursor.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
        row = cursor.fetchone()
        return True if row and row[0] else False
    
    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            menu = QMenu()
            remove_action = menu.addAction("Remove Rule from Group")
            chosen = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if chosen == remove_action:
                group_id = parent.data(0, Qt.UserRole)
                rule_id = item.data(0, Qt.UserRole)
                self.remove_rule_from_group(group_id, rule_id)
    
    def remove_rule_from_group(self, group_id, rule_id):
        if self.is_rule_locked(rule_id):
            QMessageBox.warning(self, "Locked", f"Rule {rule_id} is locked; cannot remove.")
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID = ? AND RULE_ID = ?", (group_id, rule_id))
        self.conn.commit()
        QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
        self.refresh_all()
    
    def assign_rules(self):
        selected_tree = self.group_tree.selectedItems()
        if not selected_tree:
            QMessageBox.warning(self, "None", "Select a custom group on the left.")
            return
        group_item = selected_tree[0]
        if group_item.parent():
            group_item = group_item.parent()
        group_id = group_item.data(0, Qt.UserRole)
        if not group_id:
            QMessageBox.warning(self, "Error", "Selected group is invalid.")
            return
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "None", "No rules selected on the right.")
            return
        cursor = self.conn.cursor()
        count = 0
        for item in selected_rules:
            rule_id = item.data(Qt.UserRole)
            if self.is_rule_locked(rule_id):
                continue
            try:
                cursor.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS (CUSTOM_GROUP_ID, RULE_ID) VALUES (?, ?)", (group_id, rule_id))
                count += 1
            except Exception:
                continue
        self.conn.commit()
        QMessageBox.information(self, "Assigned", f"{count} rule(s) assigned to group {group_id}.")
        self.refresh_all()

# -------------------------------
# ALERTS & DASHBOARDS TAB
# -------------------------------
class AlertsAndDashboardsTab(QWidget):
    def __init__(self, conn, user_id, user_group, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)
        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)
        self.setLayout(layout)
        self.check_alerts()
    
    def check_alerts(self):
        lines = []
        cursor = self.conn.cursor()
        # 1) Old approvals (> 3 days)
        cursor.execute("""
            SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                   DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) AS age
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
            WHERE A.APPROVED_FLAG = 0
              AND A.APPROVAL_STAGE = (
                  SELECT MIN(APPROVAL_STAGE)
                  FROM BRM_RULE_APPROVALS
                  WHERE RULE_ID = A.RULE_ID AND APPROVED_FLAG = 0
              )
              AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) > 3
        """)
        old_appr = cursor.fetchall()
        if old_appr:
            lines.append("** Old Approvals (> 3 days) **")
            for rule_id, stage, rule_name, age in old_appr:
                lines.append(f" - Rule {rule_id} '{rule_name}', Stage {stage}, Age {age} days")
        else:
            lines.append("No old approvals (> 3 days) found.")
        lines.append("")
        # 2) Stale locks (> 6 hours)
        cursor.execute("""
            SELECT L.RULE_ID, L.LOCKED_BY, R.RULE_NAME,
                   DATEDIFF(HOUR, L.LOCK_TIMESTAMP, GETDATE()) AS locked_hours
            FROM BRM_RULE_LOCKS L
            JOIN BRM_RULES R ON L.RULE_ID = R.RULE_ID
            WHERE L.ACTIVE_LOCK = 1 AND DATEDIFF(HOUR, L.LOCK_TIMESTAMP, GETDATE()) > 6
        """)
        stale = cursor.fetchall()
        if stale:
            lines.append("** Stale Locks (> 6 hours) **")
            for rule_id, locked_by, rule_name, hours in stale:
                lines.append(f" - Rule {rule_id} '{rule_name}' locked by {locked_by} for {hours} hours")
        else:
            lines.append("No stale locks (> 6 hours) found.")
        lines.append("")
        # 3) Upcoming schedules (next 24 hours)
        cursor.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
            FROM RULE_SCHEDULES
            WHERE STATUS = 'Scheduled'
              AND SCHEDULE_TIME BETWEEN GETDATE() AND DATEADD(HOUR, 24, GETDATE())
            ORDER BY SCHEDULE_TIME
        """)
        upcoming = cursor.fetchall()
        if upcoming:
            lines.append("** Upcoming Schedules (Next 24 Hours) **")
            for sched_id, rule_id, sched_time in upcoming:
                lines.append(f" - Schedule {sched_id}: Rule {rule_id} at {sched_time}")
        else:
            lines.append("No upcoming schedules in the next 24 hours.")
        lines.append("")
        # 4) Performance outliers (> 5s in last 7 days)
        cursor.execute("""
            SELECT LOG_ID, RULE_ID, EXECUTION_TIME_MS, EXECUTION_TIMESTAMP
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIME_MS > 5000
              AND EXECUTION_TIMESTAMP >= DATEADD(day, -7, GETDATE())
            ORDER BY EXECUTION_TIMESTAMP DESC
        """)
        outliers = cursor.fetchall()
        if outliers:
            lines.append("** Performance Outliers (> 5s in last 7 days) **")
            for log_id, rule_id, exec_time, ts in outliers:
                lines.append(f" - Log {log_id}: Rule {rule_id}, {exec_time} ms at {ts}")
        else:
            lines.append("No performance outliers (> 5s in last 7 days) found.")
        self.alert_text.setPlainText("\n".join(lines))

# ──────────────────────────────────────────────
# End of PART 7
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 8 of 8 (MAIN WINDOW, FULL INTEGRATION)
------------------------------------------------------
This module integrates all previous parts into one cohesive, production‑ready application.
It includes:
  • Database connection and user login.
  • Business Rules Dashboard with CRUD operations.
  • Multi‑Step Approvals, Global/Critical Admin, Hierarchy View, and Enhanced Lineage Graph.
  • Custom Groups Management and Scheduling.
  • Control Tables, Metrics Dashboard, Alerts & Dashboard.
  • Group Management and User Management (Admin only).
  • An Advanced menu that opens additional feature tabs:
         – Decision Tables
         – Conflict Priority Manager
         – Composite Rules
         – Snapshot Manager
         – Tags Manager
         – Data Validation
         – What‑If Tests

Assumptions:
  – All helper functions and classes from PART 1–PART 7 (e.g. DatabaseConnectionDialog, LoginDialog,
    auto_unlock_expired_locks, sync_metadata_improved, add_rule, update_rule, delete_rule,
    force_activate_rule, force_deactivate_rule, execute_rules_with_conflicts_composites_bfs,
    RuleDashboard, RuleEditorDialog, MultiStepApprovalTab, GlobalCriticalAdminTab,
    HierarchyViewTab, EnhancedLineageGraphWidget, CustomRuleGroupEnhancedTab,
    Schedule_management_tab, Ctrl_tables_tab, Metrics_dashboard_tab, AlertsAndDashboardsTab,
    Group_management_tab, User_management_tab, Enhanced_schedule_dialog,
    Single_rule_simulation_dialog, Chain_simulation_dialog, Group_simulation_dialog,
    AuditLogViewer, RuleSearchDialog, VersionHistoryDialog) are available.
    
For demonstration, the advanced tabs are defined here inline.
"""

import sys
import json
import csv
import difflib
import re
import time
from datetime import datetime

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QComboBox, QPushButton, QLabel, QMessageBox, QDialog, QLineEdit, QTableWidget,
    QTableWidgetItem, QPlainTextEdit, QInputDialog, QFileDialog, QCalendarWidget,
    QTextEdit, QGroupBox, QTreeWidget, QTreeWidgetItem, QSplitter, QGraphicsView,
    QGraphicsScene, QGraphicsItem, QAbstractItemView, QMenu
)
from PyQt5.QtCore import Qt, QTimer, QRectF, QPoint
from PyQt5.QtGui import QColor, QPen, QBrush, QPainter

import pyqtgraph as pg

# =============================================================================
# Advanced Feature Tabs Definitions
# =============================================================================

# -- Decision Tables Tab --
class Decision_tables_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["DecisionTableID", "TableName", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add DecisionTable")
        add_btn.clicked.connect(self.add_decision_table)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete DecisionTable")
        del_btn.clicked.connect(self.delete_decision_table)
        btn_layout.addWidget(del_btn)
        run_btn = QPushButton("Run DecisionTable")
        run_btn.clicked.connect(self.run_decision_table)
        btn_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_decision_tables)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_decision_tables()

    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in cursor.fetchall():
            idx = self.dt_table.rowCount()
            self.dt_table.insertRow(idx)
            for col, val in enumerate(row):
                self.dt_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add DecisionTable", "TableName:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO DECISION_TABLES (TABLE_NAME, DESCRIPTION) VALUES (?, ?)", (name.strip(), desc.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Decision table created.")
        self.load_decision_tables()
    def delete_decision_table(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        item = self.dt_table.item(row, 0)
        dt_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete decision table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID = ?", (dt_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Decision table removed.")
        self.load_decision_tables()
    def run_decision_table(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        item = self.dt_table.item(row, 0)
        dt_id = int(item.text())
        QMessageBox.information(self, "Run DecisionTable", f"DecisionTable {dt_id} executed (stub).")

# -- Conflict Priority Manager Tab --
class Conflict_priority_manager_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "RuleID1", "RuleID2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        btn_layout.addWidget(set_btn)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        for row in cursor.fetchall():
            idx = self.cf_table.rowCount()
            self.cf_table.insertRow(idx)
            for col, val in enumerate(row):
                self.cf_table.setItem(idx, col, QTableWidgetItem(str(val)))
    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Enter integer priority:")
        if not ok3:
            return
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO RULE_CONFLICTS (RULE_ID1, RULE_ID2, PRIORITY) VALUES (?, ?, ?)", (r1, r2, priority))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Conflict added.")
        self.load_conflicts()
    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            return
        item = self.cf_table.item(row, 0)
        conflict_id = int(item.text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {conflict_id}:")
        if not ok:
            return
        cursor = self.conn.cursor()
        cursor.execute("UPDATE RULE_CONFLICTS SET PRIORITY = ? WHERE CONFLICT_ID = ?", (new_priority, conflict_id))
        self.conn.commit()
        QMessageBox.information(self, "Updated", "Conflict priority updated.")
        self.load_conflicts()
    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            return
        item = self.cf_table.item(row, 0)
        conflict_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {conflict_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID = ?", (conflict_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Conflict deleted.")
        self.load_conflicts()

# -- Composite Rules Tab --
class Composite_rules_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.comp_table = QTableWidget(0, 4)
        self.comp_table.setHorizontalHeaderLabels(["CompositeRuleID", "CompositeName", "LogicExpr", "ActionOnPass"])
        self.comp_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.comp_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete Composite")
        del_btn.clicked.connect(self.delete_composite)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_composites)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.comp_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        for row in cursor.fetchall():
            idx = self.comp_table.rowCount()
            self.comp_table.insertRow(idx)
            for col, val in enumerate(row):
                self.comp_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def add_composite(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Composite Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getText(self, "Logic Expression", "Enter logic expression (e.g., 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr = ""
        action, ok3 = QInputDialog.getText(self, "Action On Pass", "Optional action (e.g., 'SendEmail'):")
        if not ok3:
            action = ""
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO COMPOSITE_RULES (CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS) VALUES (?, ?, ?)",
                       (name.strip(), expr.strip(), action.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Composite rule created.")
        self.load_composites()
    def delete_composite(self):
        row = self.comp_table.currentRow()
        if row < 0:
            return
        item = self.comp_table.item(row, 0)
        comp_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {comp_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID = ?", (comp_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Composite rule deleted.")
        self.load_composites()

# -- Snapshot Manager Tab --
class Snapshot_manager_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.snap_table = QTableWidget(0, 5)
        self.snap_table.setHorizontalHeaderLabels(["SnapshotID", "SnapshotName", "CreatedBy", "CreatedTS", "SnapshotJSON"])
        self.snap_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.snap_table)
        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_layout.addWidget(take_btn)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.snap_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
        for row in cursor.fetchall():
            idx = self.snap_table.rowCount()
            self.snap_table.insertRow(idx)
            for col, val in enumerate(row):
                self.snap_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Snapshot name:")
        if not ok or not name.strip():
            return
        cursor = self.conn.cursor()
        cursor.execute("SELECT * FROM BRM_RULES")
        rows = cursor.fetchall()
        cols = [desc[0] for desc in cursor.description]
        data_list = [dict(zip(cols, row)) for row in rows]
        snap_json = json.dumps(data_list, indent=2)
        cursor.execute("INSERT INTO RULE_SNAPSHOTS (SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON) VALUES (?, ?, ?)",
                       (name.strip(), "SnapshotUser", snap_json))
        self.conn.commit()
        QMessageBox.information(self, "Snapshot", "Snapshot created.")
        self.load_snapshots()
    def delete_snapshot(self):
        row = self.snap_table.currentRow()
        if row < 0:
            return
        item = self.snap_table.item(row, 0)
        snap_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snap_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID = ?", (snap_id,))
        self.conn.commit()
        QMessageBox.information(self, "Deleted", "Snapshot deleted.")
        self.load_snapshots()

# -- Tags Manager Tab --
class Tags_manager_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        btn_layout.addWidget(add_btn)
        rem_btn = QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        btn_layout.addWidget(rem_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tags)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        for row in cursor.fetchall():
            idx = self.tags_table.rowCount()
            self.tags_table.insertRow(idx)
            for col, val in enumerate(row):
                self.tags_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "Enter Rule ID:")
        if not ok:
            return
        tag, ok2 = QInputDialog.getText(self, "Tag", "Enter tag name:")
        if not ok2 or not tag.strip():
            return
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO RULE_TAGS (RULE_ID, TAG_NAME) VALUES (?, ?)", (rule_id, tag.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Tag added.")
        self.load_tags()
    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            return
        item = self.tags_table.item(row, 0)
        tag_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM RULE_TAGS WHERE TAG_ID = ?", (tag_id,))
        self.conn.commit()
        QMessageBox.information(self, "Removed", "Tag removed.")
        self.load_tags()

# -- Data Validation Tab --
class Data_validation_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        layout = QVBoxLayout(self)
        self.val_table = QTableWidget(0, 5)
        self.val_table.setHorizontalHeaderLabels(["ValidationID", "TableName", "ColumnName", "ValidationType", "Params"])
        self.val_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.val_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_layout.addWidget(add_btn)
        rem_btn = QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_validation)
        btn_layout.addWidget(rem_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        btn_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.val_table.setRowCount(0)
        cursor = self.conn.cursor()
        cursor.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        for row in cursor.fetchall():
            idx = self.val_table.rowCount()
            self.val_table.insertRow(idx)
            for col, val in enumerate(row):
                self.val_table.setItem(idx, col, QTableWidgetItem(str(val) if val else ""))
    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Table name (e.g., 'dbo.Customers'):")
        if not ok or not table_name.strip():
            return
        column_name, ok2 = QInputDialog.getText(self, "Column", "Column name:")
        if not ok2 or not column_name.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "Type (e.g., 'NOT NULL', 'RANGE', 'REGEX'):")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "Optional parameters (e.g., '0,100'):")
        if not ok4:
            params = ""
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO DATA_VALIDATIONS (TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS) VALUES (?, ?, ?, ?)",
                       (table_name.strip(), column_name.strip(), vtype.strip(), params.strip()))
        self.conn.commit()
        QMessageBox.information(self, "Added", "Validation rule added.")
        self.load_validations()
    def remove_validation(self):
        row = self.val_table.currentRow()
        if row < 0:
            return
        item = self.val_table.item(row, 0)
        val_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation {val_id}?")
        if confirm != QMessageBox.Yes:
            return
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID = ?", (val_id,))
        self.conn.commit()
        QMessageBox.information(self, "Removed", "Validation rule removed.")
        self.load_validations()
    def run_all_validations(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        tables = cursor.fetchall()
        failed = []
        for (table_name,) in tables:
            if table_name and not run_data_validations_for_table(self.conn, table_name.lower()):
                failed.append(table_name)
        if failed:
            QMessageBox.warning(self, "Validations", "Failed for: " + ", ".join(failed))
        else:
            QMessageBox.information(self, "Validations", "All validations passed.")

# -- What-If Test Tab --
class What_if_test_tab(QWidget):
    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.csv_path = None
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        cursor = self.conn.cursor()
        cursor.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rule_id, rule_name in cursor.fetchall():
            self.rule_combo.addItem(f"{rule_id} - {rule_name}", rule_id)
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)
        self.bfs_cb = QCheckBox("Use BFS Execution?")
        top_layout.addWidget(self.bfs_cb)
        self.skip_val_cb = QCheckBox("Skip Validations?")
        top_layout.addWidget(self.skip_val_cb)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        mid_layout = QHBoxLayout()
        upload_btn = QPushButton("Upload CSV")
        upload_btn.clicked.connect(self.upload_csv)
        mid_layout.addWidget(upload_btn)
        run_btn = QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        mid_layout.addWidget(run_btn)
        mid_layout.addStretch()
        layout.addLayout(mid_layout)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        self.setLayout(layout)

    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if path:
            self.csv_path = path
            QMessageBox.information(self, "CSV Uploaded", f"CSV file '{path}' selected.")
        else:
            self.csv_path = None

    def run_test(self):
        rule_id = self.rule_combo.currentData()
        use_bfs = self.bfs_cb.isChecked()
        skip_val = self.skip_val_cb.isChecked()
        if use_bfs:
            executed, skipped = execute_rules_with_conflicts_composites_bfs(self.conn, selected_rule_ids=[rule_id], skip_data_validation=skip_val, measure_perf=False)
            result = f"BFS Simulation:\nExecuted: {executed}\nSkipped: {list(skipped)}\nCSV: {self.csv_path or 'None'}"
        else:
            cursor = self.conn.cursor()
            cursor.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
            row = cursor.fetchone()
            if not row:
                self.result_text.setPlainText(f"Rule {rule_id} not found.")
                return
            sql_stmt = row[0]
            if not skip_val:
                cursor2 = self.conn.cursor()
                cursor2.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
                for db_name, tbl in cursor2.fetchall():
                    if tbl:
                        full_table = (db_name + "." + tbl).lower()
                        if not run_data_validations_for_table(self.conn, full_table):
                            self.result_text.setPlainText(f"Validation failed for {full_table}.")
                            return
            from time import perf_counter
            start = perf_counter()
            success = False
            msg = ""
            rec_count = 0
            cursor.execute("BEGIN TRANSACTION")
            try:
                cursor.execute(sql_stmt)
                rows = cursor.fetchall()
                if rows:
                    rec_count = len(rows)
                    success = (rows[0][0] == 1)
                    msg = f"Returned: {rows[0][0]}"
                else:
                    success = True
                    msg = "No rows returned => PASS"
                cursor.execute("ROLLBACK")
            except Exception as ex:
                cursor.execute("ROLLBACK")
                success = False
                msg = str(ex)
            elapsed_ms = int((perf_counter() - start) * 1000)
            result = (f"Single Run Simulation:\nSuccess: {success}\nMessage: {msg}\n"
                      f"Records: {rec_count}\nTime: {elapsed_ms} ms\nCSV: {self.csv_path or 'None'}")
        self.result_text.setPlainText(result)

# =============================================================================
# MAIN WINDOW (BRMTool)
# =============================================================================
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Final Production Build")
        self.resize(1350, 900)
        self.connection = None
        self.user_id = None
        self.user_group = None
        self.logged_in_username = None

        # Database connection (assumes DatabaseConnectionDialog is defined in PART 1)
        db_dialog = DatabaseConnectionDialog()
        if db_dialog.exec_() == QDialog.Accepted:
            conn = db_dialog.get_connection()
            if not conn:
                sys.exit(1)
            self.connection = conn
        else:
            sys.exit(0)

        # User login (assumes LoginDialog is defined in PART 1)
        login_dialog = LoginDialog(self.connection)
        if login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dialog.user_id
        self.user_group = login_dialog.user_group
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME FROM USERS WHERE USER_ID = ?", (self.user_id,))
        row = cursor.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            QMessageBox.critical(self, "Error", "User not found in DB after login.")
            sys.exit(1)

        self.init_ui()

    def init_ui(self):
        menubar = self.menuBar()
        # File Menu
        file_menu = menubar.addMenu("File")
        sync_action = QAction("Sync Metadata", self)
        sync_action.triggered.connect(self.handle_sync_metadata)
        file_menu.addAction(sync_action)
        metrics_action = QAction("View Metrics Dashboard", self)
        metrics_action.triggered.connect(self.launch_metrics_dashboard)
        file_menu.addAction(metrics_action)
        schedule_action = QAction("New Schedule Dialog", self)
        schedule_action.triggered.connect(self.launch_schedule_dialog)
        file_menu.addAction(schedule_action)
        chain_sim_action = QAction("Simulate Parent Chain BFS", self)
        chain_sim_action.triggered.connect(self.launch_chain_simulation)
        file_menu.addAction(chain_sim_action)
        group_sim_action = QAction("Simulate Custom Group BFS", self)
        group_sim_action.triggered.connect(self.launch_group_simulation)
        file_menu.addAction(group_sim_action)
        # Help Menu
        help_menu = menubar.addMenu("Help")
        about_action = QAction("About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        # Tools Menu
        tools_menu = menubar.addMenu("Tools")
        audit_log_action = QAction("View Audit Logs", self)
        audit_log_action.triggered.connect(self.launch_audit_log_viewer)
        tools_menu.addAction(audit_log_action)
        rule_search_action = QAction("Search Rules", self)
        rule_search_action.triggered.connect(self.launch_rule_search_dialog)
        tools_menu.addAction(rule_search_action)
        version_history_action = QAction("Version History", self)
        version_history_action.triggered.connect(self.launch_version_history_dialog)
        tools_menu.addAction(version_history_action)
        validation_action = QAction("Run Data Validations", self)
        validation_action.triggered.connect(self.run_all_data_validations)
        tools_menu.addAction(validation_action)
        # Advanced Menu
        advanced_menu = menubar.addMenu("Advanced")
        decision_tables_action = QAction("Decision Tables", self)
        decision_tables_action.triggered.connect(lambda: self.open_tab(Decision_tables_tab(self.connection), "Decision Tables"))
        advanced_menu.addAction(decision_tables_action)
        conflict_priority_action = QAction("Conflict Priority Manager", self)
        conflict_priority_action.triggered.connect(lambda: self.open_tab(Conflict_priority_manager_tab(self.connection), "Conflict Priority"))
        advanced_menu.addAction(conflict_priority_action)
        composite_rules_action = QAction("Composite Rules", self)
        composite_rules_action.triggered.connect(lambda: self.open_tab(Composite_rules_tab(self.connection), "Composite Rules"))
        advanced_menu.addAction(composite_rules_action)
        snapshot_manager_action = QAction("Snapshot Manager", self)
        snapshot_manager_action.triggered.connect(lambda: self.open_tab(Snapshot_manager_tab(self.connection), "Snapshot Manager"))
        advanced_menu.addAction(snapshot_manager_action)
        tags_manager_action = QAction("Tags Manager", self)
        tags_manager_action.triggered.connect(lambda: self.open_tab(Tags_manager_tab(self.connection), "Tags Manager"))
        advanced_menu.addAction(tags_manager_action)
        data_validation_action = QAction("Data Validation", self)
        data_validation_action.triggered.connect(lambda: self.open_tab(Data_validation_tab(self.connection), "Data Validation"))
        advanced_menu.addAction(data_validation_action)
        what_if_action = QAction("What-If Tests", self)
        what_if_action.triggered.connect(lambda: self.open_tab(What_if_test_tab(self.connection), "What-If Tests"))
        advanced_menu.addAction(what_if_action)

        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        # Impersonation for Admin
        if self.user_group.lower() == "admin":
            imp_layout = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_button = QPushButton("Switch User")
            self.switch_button.clicked.connect(self.handle_switch_user)
            imp_layout.addWidget(QLabel("Impersonate:"))
            imp_layout.addWidget(self.switch_combo)
            imp_layout.addWidget(self.switch_button)
            imp_layout.addStretch()
            main_layout.addLayout(imp_layout)
            self.populate_switch_combo()
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)
        # Tab 1: Business Rules Dashboard
        br_widget = QWidget()
        br_layout = QVBoxLayout(br_widget)
        crud_layout = QHBoxLayout()
        add_rule_btn = QPushButton("Add Rule")
        add_rule_btn.clicked.connect(self.add_rule)
        crud_layout.addWidget(add_rule_btn)
        update_rule_btn = QPushButton("Update Rule")
        update_rule_btn.clicked.connect(self.update_rule)
        crud_layout.addWidget(update_rule_btn)
        force_activate_btn = QPushButton("Force Activate")
        force_activate_btn.clicked.connect(self.force_activate_rule)
        crud_layout.addWidget(force_activate_btn)
        force_deactivate_btn = QPushButton("Force Deactivate")
        force_deactivate_btn.clicked.connect(self.force_deactivate_rule)
        crud_layout.addWidget(force_deactivate_btn)
        delete_rule_btn = QPushButton("Delete Rule")
        delete_rule_btn.clicked.connect(self.delete_rule)
        crud_layout.addWidget(delete_rule_btn)
        run_bfs_btn = QPushButton("Run ETL BFS")
        run_bfs_btn.clicked.connect(self.run_bfs_etl)
        crud_layout.addWidget(run_bfs_btn)
        sim_single_btn = QPushButton("Simulate Single Rule")
        sim_single_btn.clicked.connect(self.simulate_single_rule)
        crud_layout.addWidget(sim_single_btn)
        crud_layout.addStretch()
        br_layout.addLayout(crud_layout)
        self.rule_dashboard = RuleDashboard(self.connection, self.user_id, self.user_group)
        br_layout.addWidget(self.rule_dashboard)
        br_widget.setLayout(br_layout)
        self.tabs.addTab(br_widget, "Business Rules")
        # Tab 2: Approvals
        approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(approvals_tab, "Approvals")
        # Tab 3: Global/Critical Admin (Admin only)
        if self.user_group.lower() == "admin":
            gcr_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(gcr_tab, "Global/Critical Admin")
        # Tab 4: Hierarchy View
        hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(hierarchy_tab, "Hierarchy")
        # Tab 5: Enhanced Lineage Graph
        lineage_widget = QWidget()
        lineage_layout = QVBoxLayout(lineage_widget)
        lineage_label = QLabel("Enhanced Lineage Graph")
        lineage_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        lineage_layout.addWidget(lineage_label)
        self.lineage_graph = EnhancedLineageGraphWidget(self.connection)
        lineage_layout.addWidget(self.lineage_graph)
        search_layout = QHBoxLayout()
        self.lineage_search_edit = QLineEdit()
        self.lineage_search_edit.setPlaceholderText("Search rule/table/column...")
        search_layout.addWidget(self.lineage_search_edit)
        search_btn = QPushButton("Search")
        search_btn.clicked.connect(self.lineage_search)
        search_layout.addWidget(search_btn)
        reset_btn = QPushButton("Reset View")
        reset_btn.clicked.connect(self.lineage_graph.reset_view)
        search_layout.addWidget(reset_btn)
        refresh_lineage_btn = QPushButton("Refresh Graph")
        refresh_lineage_btn.clicked.connect(self.lineage_graph.populate_graph)
        search_layout.addWidget(refresh_lineage_btn)
        search_layout.addStretch()
        lineage_layout.addLayout(search_layout)
        lineage_widget.setLayout(lineage_layout)
        self.tabs.addTab(lineage_widget, "Lineage")
        # Tab 6: Custom Groups
        custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(custom_groups_tab, "Custom Groups")
        # Tab 7: Scheduling
        schedule_tab = Schedule_management_tab(self.connection)
        self.tabs.addTab(schedule_tab, "Scheduling")
        # Tab 8: Control Tables
        ctrl_tab = Ctrl_tables_tab(self.connection, self.user_group)
        self.tabs.addTab(ctrl_tab, "Control Tables")
        # Tab 9: Metrics Dashboard
        metrics_tab = Metrics_dashboard_tab(self.connection)
        self.tabs.addTab(metrics_tab, "Metrics")
        # Tab 10: Alerts & Dashboard
        alerts_tab = AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(alerts_tab, "Alerts & Dashboard")
        # Tab 11: Group Management
        group_mgmt_tab = Group_management_tab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(group_mgmt_tab, "Group Management")
        # Tab 12: User Management (Admin only)
        if self.user_group.lower() == "admin":
            user_mgmt_tab = User_management_tab(self.connection)
            self.tabs.addTab(user_mgmt_tab, "User Management")
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)
        # Timers for auto-refresh
        self.approval_timer = QTimer(self)
        self.approval_timer.timeout.connect(lambda: self.tabs.widget(1).load_approvals())
        self.approval_timer.start(4000)
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)
        self.alerts_timer = QTimer(self)
        self.alerts_timer.timeout.connect(lambda: self.tabs.widget(9).check_alerts())
        self.alerts_timer.start(120000)
        self.unlock_timer = QTimer(self)
        self.unlock_timer.timeout.connect(lambda: auto_unlock_expired_locks(self.connection))
        self.unlock_timer.start(300000)
        self.show()

    def handle_sync_metadata(self):
        try:
            sync_metadata_improved(self.connection)
        except Exception as ex:
            QMessageBox.critical(self, "Sync Error", str(ex))

    def launch_metrics_dashboard(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800, 600)
        layout = QVBoxLayout(dlg)
        metrics_widget = Metrics_dashboard_tab(self.connection, dlg)
        layout.addWidget(metrics_widget)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        layout.addWidget(close_btn)
        dlg.exec_()

    def launch_schedule_dialog(self):
        dlg = Enhanced_schedule_dialog(self.connection, self)
        dlg.exec_()

    def launch_chain_simulation(self):
        dlg = Chain_simulation_dialog(self.connection, self)
        dlg.exec_()

    def launch_group_simulation(self):
        dlg = Group_simulation_dialog(self.connection, self)
        dlg.exec_()

    def show_about(self):
        about_text = (
            "BRM Tool – Final Integrated Version\n"
            "Includes BFS, advanced CRUD, data validations, multi-step approvals, scheduling, metadata sync, and more.\n"
            "No encryption references remain. Enjoy!"
        )
        QMessageBox.information(self, "About", about_text)

    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_rule_search_dialog(self):
        dlg = RuleSearchDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_version_history_dialog(self):
        rule_id, ok = QInputDialog.getInt(self, "Version History", "Enter Rule ID:")
        if ok:
            dlg = VersionHistoryDialog(self.connection, rule_id, self)
            dlg.exec_()

    def run_all_data_validations(self):
        cursor = self.connection.cursor()
        cursor.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        tables = cursor.fetchall()
        failed = []
        for (table_name,) in tables:
            if table_name and not run_data_validations_for_table(self.connection, table_name.lower()):
                failed.append(table_name)
        if failed:
            QMessageBox.warning(self, "Data Validations", "Validations failed for: " + ", ".join(failed))
        else:
            QMessageBox.information(self, "Data Validations", "All validations passed.")

    def handle_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_user_id, new_user_group = data
        if new_user_id == self.user_id and new_user_group == self.user_group:
            return
        self.user_id = new_user_id
        self.user_group = new_user_group
        cursor = self.connection.cursor()
        cursor.execute("SELECT USERNAME FROM USERS WHERE USER_ID = ?", (self.user_id,))
        row = cursor.fetchone()
        self.logged_in_username = row[0] if row else "Unknown"
        QMessageBox.information(self, "Switched", f"Now impersonating user {self.user_id} ({self.user_group}).")
        self.tabs.widget(1).logged_in_username = self.logged_in_username
        self.tabs.widget(1).user_group = self.user_group
        self.tabs.widget(1).load_approvals()
        self.rule_dashboard.user_id = self.user_id
        self.rule_dashboard.user_group = self.user_group
        self.rule_dashboard.load_rules()
        self.tabs.widget(9).user_id = self.user_id
        self.tabs.widget(9).user_group = self.user_group
        self.tabs.widget(9).check_alerts()

    def populate_switch_combo(self):
        self.switch_combo.clear()
        cursor = self.connection.cursor()
        cursor.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for user_id, username, user_group in cursor.fetchall():
            self.switch_combo.addItem(f"{username} ({user_group})", (user_id, user_group))

    def open_tab(self, widget, title):
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i) == title:
                self.tabs.setCurrentIndex(i)
                return
        self.tabs.addTab(widget, title)
        self.tabs.setCurrentIndex(self.tabs.count() - 1)

    def add_rule(self):
        dlg = RuleEditorDialog(self.connection, self.user_group, None, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dashboard.load_rules()

    def update_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if len(selected) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to update.")
            return
        rule_id = selected[0]
        cursor = self.connection.cursor()
        cursor.execute("SELECT * FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
        row = cursor.fetchone()
        if not row:
            QMessageBox.warning(self, "Missing", f"Rule {rule_id} not found.")
            return
        cols = [d[0] for d in cursor.description]
        rule_data = dict(zip(cols, row))
        dlg = RuleEditorDialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dashboard.load_rules()

    def force_activate_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Force activate {len(selected)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        errors = []
        for rule_id in selected:
            try:
                force_activate_rule(self.connection, rule_id, self.user_id, self.user_group)
                success += 1
            except Exception as ex:
                errors.append(str(ex))
        QMessageBox.information(self, "Force Activate", f"Force activated {success} rule(s). Errors: {errors}")
        self.rule_dashboard.load_rules()

    def force_deactivate_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Force deactivate {len(selected)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        errors = []
        for rule_id in selected:
            try:
                force_deactivate_rule(self.connection, rule_id, self.user_id, self.user_group)
                success += 1
            except Exception as ex:
                errors.append(str(ex))
        QMessageBox.information(self, "Force Deactivate", f"Force deactivated {success} rule(s). Errors: {errors}")
        self.rule_dashboard.load_rules()

    def delete_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if not selected:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(selected)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        errors = []
        for rule_id in selected:
            try:
                delete_rule(self.connection, rule_id, self.user_id, self.user_group)
                success += 1
            except Exception as ex:
                errors.append(str(ex))
        QMessageBox.information(self, "Delete", f"Deleted {success} rule(s). Errors: {errors}")
        self.rule_dashboard.load_rules()

    def run_bfs_etl(self):
        from time import perf_counter
        start = perf_counter()
        executed, skipped = execute_rules_with_conflicts_composites_bfs(self.connection, measure_perf=True)
        elapsed = (perf_counter() - start) * 1000
        QMessageBox.information(self, "ETL BFS", f"Executed: {executed}\nSkipped: {list(skipped)}\nElapsed: {elapsed:.2f} ms")
        self.rule_dashboard.load_rules()

    def simulate_single_rule(self):
        selected = self.rule_dashboard.get_selected_rule_ids()
        if len(selected) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule for simulation.")
            return
        rule_id = selected[0]
        dlg = Single_rule_simulation_dialog(self.connection, self)
        idx = dlg.rule_combo.findData(rule_id)
        if idx >= 0:
            dlg.rule_combo.setCurrentIndex(idx)
        dlg.exec_()

    def lineage_search(self):
        search_text = self.lineage_search_edit.text().strip()
        self.lineage_graph.search_and_highlight(search_text)

    def check_due_schedules(self):
        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        cursor = self.connection.cursor()
        cursor.execute("SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, VALIDATION_FLAG FROM RULE_SCHEDULES WHERE STATUS = 'Scheduled' AND SCHEDULE_TIME <= ?", (now_str,))
        for schedule_id, rule_id, sched_time, val_flag in cursor.fetchall():
            cursor2 = self.connection.cursor()
            cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'InProgress' WHERE SCHEDULE_ID = ?", (schedule_id,))
            self.connection.commit()
            cursor2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
            row = cursor2.fetchone()
            if not row:
                cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (schedule_id,))
                self.connection.commit()
                continue
            rule_sql = row[0]
            from time import perf_counter
            start_time = perf_counter()
            success = False
            msg = ""
            rec_count = 0
            cursor2.execute("BEGIN TRANSACTION")
            try:
                if val_flag:
                    cursor3 = self.connection.cursor()
                    cursor3.execute("SELECT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID = ?", (rule_id,))
                    validation_failed = False
                    for db_name, tbl in cursor3.fetchall():
                        if tbl:
                            full_table = (db_name + "." + tbl).lower()
                            if not run_data_validations_for_table(self.connection, full_table):
                                validation_failed = True
                                break
                    if validation_failed:
                        cursor2.execute("ROLLBACK")
                        cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (schedule_id,))
                        self.connection.commit()
                        continue
                cursor2.execute(rule_sql)
                rows = cursor2.fetchall()
                if rows:
                    rec_count = len(rows)
                    success = (rows[0][0] == 1)
                    msg = f"Returned: {rows[0][0]}"
                else:
                    success = True
                    msg = "No rows returned => PASS"
                if success:
                    cursor2.execute("COMMIT")
                else:
                    cursor2.execute("ROLLBACK")
            except Exception as ex:
                cursor2.execute("ROLLBACK")
                success = False
                msg = str(ex)
            elapsed_ms = int((perf_counter() - start_time) * 1000)
            if success:
                cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Executed' WHERE SCHEDULE_ID = ?", (schedule_id,))
            else:
                cursor2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (schedule_id,))
            cursor2.execute("""
                INSERT INTO RULE_EXECUTION_LOGS (RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS)
                VALUES (?, GETDATE(), ?, ?, ?, ?)
            """, (rule_id, 1 if success else 0, msg, rec_count, int(elapsed_ms)))
            self.connection.commit()
        for i in range(self.tabs.count()):
            widget = self.tabs.widget(i)
            if hasattr(widget, "load_schedules"):
                widget.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except Exception:
                pass
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    tool = BRMTool()
    sys.exit(app.exec_())

