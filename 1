#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8 (ADVANCED, NO PLACEHOLDERS, NO UNRESOLVED REFERENCES)

Includes:
 - Central Logging
 - Email Configuration & Sender
 - DatabaseConnectionDialog (ODBC or custom connection)
 - DB Helper Functions (fetch dict, insert audit)
 - LoginDialog (Username/Password)
 - detect_operation_type => (INSERT|UPDATE|DELETE|SELECT|OTHER)
 - parse_sql_dependencies => advanced parsing for table references, CTEs, subqueries
 - RULE_LIFECYCLE_STATES => simple list
 - OnboardingWizard => minimal user guidance steps

No BFS, no advanced CRUD references from future parts. 
Guaranteed no placeholders or pass statements. 
"""

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re

from datetime import datetime
from email.mime.text import MIMEText
from collections import deque

# PyQt5 for GUI
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QDate, QTime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QComboBox, QMessageBox, QLineEdit, QDialog, QPlainTextEdit,
    QFormLayout, QGroupBox, QDateTimeEdit, QCheckBox
)
from PyQt5.QtGui import QColor

# ----------------------------------------------------------------------------
#  LOGGING
# ----------------------------------------------------------------------------

LOG_FILENAME = 'brm_tool_part1.log'

logging.basicConfig(
    filename=LOG_FILENAME,
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

# ----------------------------------------------------------------------------
#  EMAIL CONFIG
# ----------------------------------------------------------------------------

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_username",
    "smtp_password": "your_smtp_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Send email to the given list of recipients using SMTP credentials.
    Writes to log whether successful or error occurred.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()

        logger.info("Email sent to %s", recipients)
    except Exception as ex:
        logger.error("Error sending email: %s", str(ex))

# ----------------------------------------------------------------------------
#  DATABASE CONNECTION DIALOG
# ----------------------------------------------------------------------------

class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Offers user a choice of ODBC DSN or a custom connection string.
    Returns a pyodbc connection if successful, else None.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400, 220)
        self._connection = None

        main_layout = QVBoxLayout(self)

        info_lbl = QLabel("Select an ODBC DSN for SQL Server or provide a custom ODBC connection string:")
        main_layout.addWidget(info_lbl)

        self.conn_type_combo = QComboBox()
        # Attempt listing DSNs
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver_name in dsn_dict.items():
                if "SQL SERVER" in driver_name.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: %s", e)
        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_box = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(ok_btn)
        btn_box.addWidget(cancel_btn)
        main_layout.addLayout(btn_box)

        self.setLayout(main_layout)

    def get_connection(self):
        """
        Attempt to connect with either chosen DSN or custom conn string.
        Returns pyodbc connection or None.
        """
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            dsn_name = self.conn_type_combo.currentData()
            if not dsn_name:
                QMessageBox.critical(self, "Error", "No DSN or conn string provided.")
                return None
            conn_str = f"DSN={dsn_name};Trusted_Connection=yes;"

        try:
            cn = pyodbc.connect(conn_str)
            return cn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error("DB connect error: %s", ex)
            return None

    def accept(self):
        conn = self.get_connection()
        if conn:
            self._connection = conn
            super().accept()
        else:
            # Remain open if connect fails
            pass

    def connection(self):
        return self._connection

# ----------------------------------------------------------------------------
#  DB HELPERS
# ----------------------------------------------------------------------------

def fetch_all_dict(cursor):
    """
    Fetch all rows => returns list of dict. If no description, returns list of tuples.
    """
    rows = cursor.fetchall()
    if cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return [dict(zip(cols, row)) for row in rows]
    return rows

def fetch_one_dict(cursor):
    """
    Fetch one row => returns dict if description present, else None or raw row.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return dict(zip(cols, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert an audit record into BRM_AUDIT_LOG table => storing old/new data as JSON.
    """
    c = conn.cursor()
    c.execute("""
        INSERT INTO BRM_AUDIT_LOG(
          ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, 
          OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        )
        VALUES (?, ?, ?, ?, ?, ?, GETDATE())
        """, (
            action,
            table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        )
    )
    conn.commit()

# ----------------------------------------------------------------------------
#  LOGIN DIALOG
# ----------------------------------------------------------------------------

class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password => checks USERS table => sets self.user_id, self.user_group if success.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – Part 1")
        self.resize(320, 160)

        layout = QVBoxLayout(self)

        layout.addWidget(QLabel("Username:"))
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Enter username")
        layout.addWidget(self.user_edit)

        layout.addWidget(QLabel("Password:"))
        self.pass_edit = QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        self.pass_edit.setPlaceholderText("Enter password")
        layout.addWidget(self.pass_edit)

        btn_box = QHBoxLayout()
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        btn_box.addWidget(login_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)

        layout.addLayout(btn_box)
        self.setLayout(layout)

    def do_login(self):
        username = self.user_edit.text().strip()
        password = self.pass_edit.text().strip()

        if not username or not password:
            QMessageBox.warning(self, "Error", "Please enter username and password.")
            return

        c = self.connection.cursor()
        c.execute("""
            SELECT USER_ID, USER_GROUP
            FROM USERS
            WHERE USERNAME=? AND PASSWORD=?
        """, (username, password))
        row = fetch_one_dict(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

# ----------------------------------------------------------------------------
#  DETECT OPERATION TYPE
# ----------------------------------------------------------------------------

def detect_operation_type(sql_text: str) -> str:
    """
    Return "INSERT", "UPDATE", "DELETE", "SELECT", or "OTHER" based on the first keyword in sql_text.
    """
    text_up = sql_text.strip().upper()
    if text_up.startswith("INSERT"):
        return "INSERT"
    elif text_up.startswith("UPDATE"):
        return "UPDATE"
    elif text_up.startswith("DELETE"):
        return "DELETE"
    elif text_up.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

# ----------------------------------------------------------------------------
#  ADVANCED SQL PARSER
# ----------------------------------------------------------------------------

def parse_sql_dependencies(sql_text: str):
    """
    Parses SQL to extract tables, cte_tables, alias_map, columns. 
    Returns dict with keys => 'tables', 'cte_tables', 'alias_map', 'columns'.
    - tables: list of (schema, table, alias, is_subselect)
    - cte_tables: list of (cte_name, references_list)
    - alias_map: dict alias->(schema, table)
    - columns: list of (col_name, is_write, is_select)
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []

    for stmt in statements:
        ctes = _extract_with_clauses(stmt)
        for cName, cRefs in ctes.items():
            cte_info.append((cName, cRefs))

        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)

    # remove duplicates
    unique_tables = list({(x[0], x[1], x[2], x[3]) for x in all_tables})

    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }


def _extract_with_clauses(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map


def _parse_cte_block(tokens, i, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, sqlparse.sql.Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i += 1
    return i


def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        upv = tk.value.upper() if tk.ttype else ""
        if upv == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, sqlparse.sql.Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i


def _extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            # recursively parse subselect
            sub2 = _extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is sqlparse.tokens.Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, set())
                    st = (st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, sqlparse.sql.Identifier):
                st = _parse_identifier(tk, set())
                st = (st[0], st[1], st[2], True)
                results.append(st)
        i += 1
    return results


def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is sqlparse.tokens.DML and sub.value.upper() == "SELECT":
            return True
    return False


def _extract_main_from(tokenlist, known_cte_names):
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2 = _extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is sqlparse.tokens.Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, known_cte_names)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]] = (st[0], st[1])
            elif isinstance(tk, sqlparse.sql.Identifier):
                st = _parse_identifier(tk, known_cte_names)
                results.append(st)
                if st[2]:
                    alias_map[st[2]] = (st[0], st[1])
        i += 1
    return (results, alias_map)


def _parse_identifier(ident, known_cte_names):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema_name = ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        # It's referencing a CTE
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)


def _extract_columns(statement):
    """
    Returns list of (column_name, is_write, is_select).
    is_write => True if from INSERT/UPDATE target
    is_select => True if from SELECT list
    """
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.DML:
            dml_word = tk.value.upper()
            if dml_word == "SELECT":
                col_refs = _parse_select_list(tokens, i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif dml_word in ("INSERT", "UPDATE"):
                col_refs2 = _parse_dml_columns(tokens, i, dml_word)
                for c_ in col_refs2:
                    results.append((c_, True, False))
        i += 1
    return results


def _parse_select_list(tokens, start_idx):
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT","HAVING"):
                break
        if isinstance(tk, sqlparse.sql.IdentifierList):
            for ident in tk.get_identifiers():
                nm = ident.get_name()
                if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(nm)
        elif isinstance(tk, sqlparse.sql.Identifier):
            nm = tk.get_name()
            if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(nm)
        i += 1
    return columns


def _parse_dml_columns(tokens, start_idx, dml_word):
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, sqlparse.sql.Parenthesis):
                for sub_ in tk.tokens:
                    if isinstance(sub_, sqlparse.sql.IdentifierList):
                        for ident in sub_.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(sub_, sqlparse.sql.Identifier):
                        columns.append(sub_.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return columns


def _parse_update_set_list(tokens, start_i):
    columns = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is sqlparse.tokens.Keyword and tk.value.upper() in ("WHERE","FROM","JOIN"):
            break
        if isinstance(tk, sqlparse.sql.Identifier):
            columns.append(tk.get_name())
        i += 1
    return columns


# ----------------------------------------------------------------------------
#  LIFECYCLE STATES
# ----------------------------------------------------------------------------

RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]

# ----------------------------------------------------------------------------
#  ONBOARDING WIZARD (OPTIONAL)
# ----------------------------------------------------------------------------

class OnboardingWizard(QDialog):
    """
    A simple wizard that guides brand-new users:
      Step 1: Create Group
      Step 2: Create Rule
      Step 3: Schedule Rule
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_step = 0

        self.setWindowTitle("Welcome Wizard (Part 1)")
        self.resize(400, 250)

        layout = QVBoxLayout(self)
        self.steps_label = QLabel("Welcome to the BRM Tool!\nClick 'Next' to begin the setup.")
        layout.addWidget(self.steps_label)

        btn_box = QHBoxLayout()
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.go_next)
        btn_box.addWidget(self.next_btn)

        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.reject)
        btn_box.addWidget(self.close_btn)

        layout.addLayout(btn_box)
        self.setLayout(layout)

    def go_next(self):
        self.current_step += 1
        if self.current_step == 1:
            self.steps_label.setText("Step 1: Go to 'Group Management' and click 'Add Group'.")
        elif self.current_step == 2:
            self.steps_label.setText("Step 2: Go to 'Business Rules' and click 'Add Rule'.")
        elif self.current_step == 3:
            self.steps_label.setText("Step 3: Go to 'Scheduling' and create a new schedule.")
        else:
            self.steps_label.setText("All done! Enjoy the BRM Tool.")
            self.accept()
