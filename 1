# Standard library imports
import csv
import difflib
import io
import json
import logging
import logging.config
import math
import os
import random
import re
import smtplib
import statistics
import sys
from collections import defaultdict, deque
from datetime import datetime, timedelta
from email.mime.text import MIMEText

# Third-party imports
import numpy as np
import pyodbc
import pyqtgraph as pg
import sqlparse

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDate, QDateTime, QPointF, QLineF, QRectF
from PyQt5.QtGui import QFont, QPen, QBrush, QColor, QPainter, QPolygonF
from PyQt5.QtWidgets import (
    QApplication, QAction, QAbstractItemView, QCalendarWidget, QCheckBox, QComboBox,
    QCompleter, QDialog, QFileDialog, QFormLayout, QGraphicsEllipseItem, QGraphicsItem,
    QGraphicsLineItem, QGraphicsScene, QGraphicsTextItem, QGraphicsView, QGroupBox,
    QHBoxLayout, QLabel, QLineEdit, QListWidget, QListWidgetItem, QMainWindow,
    QMessageBox, QInputDialog, QPlainTextEdit, QProgressDialog, QPushButton, QSplitter,
    QTabWidget, QTextEdit, QTableWidget, QTableWidgetItem, QToolBar, QTreeWidget,
    QTreeWidgetItem, QVBoxLayout, QWidget, QTimeEdit, QDateTimeEdit
)

LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_master.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_master")

# configured for advanced usage analytics, auto-healing thresholds, etc.
BRM_CONFIG = {
    "ENABLE_AIOPS": True,  # Toggle advanced anomaly detection
    "AUTO_HEALING_THRESHOLD": 5,  # For demonstration, number of consecutive fails triggers auto-healing
    "ALLOWED_SQL_KEYWORDS": [
        "SELECT", "INSERT", "UPDATE", "DELETE", "JOIN", "WHERE", "GROUP", "ORDER", "HAVING", "CTE", "WITH"
    ],
    "FORBIDDEN_SQL_KEYWORDS": [
        "DROP", "TRUNCATE", "SHUTDOWN", "ALTER SERVER", "RECONFIGURE"
    ],
    "REQUIRED_APPROVAL_STAGES": 2,  # Serial stages, can expand to parallel approvals
    "PARALLEL_APPROVAL_GROUPS": False,  # If True, BG1 & BG2 can approve simultaneously
    "RBAC_ENABLED": True,  # Toggle for new fine-grained role-based checks
    "TIMEZONE": "UTC"
}


########################################
# EMAIL NOTIFIER
########################################
class EmailNotifier:

    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("EmailNotifier: No recipients provided.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}. subject={subject}")
        except Exception as e:
            logger.error(f"Error sending email: {e}")
            raise



def check_user_permissions(connection, user_id, action_type, resource_name):
    """
    ACL: Check if a user (via user_id) has permission to perform
    action_type (e.g. 'EDIT_RULE', 'APPROVE', 'VIEW', 'EXECUTE') on resource_name
    (table, rule, or advanced scope).
    Example usage:
        if not check_user_permissions(conn, 123, 'EDIT_RULE', 'Credit_Portfolio'):
            raise PermissionError("User lacks permission.")
    This can be expanded to row/column-level security or ABAC logic.
    """
    if not BRM_CONFIG.get("RBAC_ENABLED", False):
        # Fallback: only check if user group is 'Admin' for critical ops.
        c = connection.cursor()
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if row and row[0] == "Admin":
            return True
        # Non-admin => limited
        # For demonstration, we allow 'Viewer' for everything except 'APPROVE' & 'EDIT_RULE'.
        if action_type in ("VIEW", "SIMULATE"):
            return True
        return False

    # If advanced RBAC is enabled, we do a fine-grained check:
    c = connection.cursor()
    try:
        c.execute("""
            SELECT COUNT(*)
            FROM GROUP_PERMISSIONS GP
            JOIN USERS U ON GP.GROUP_NAME=U.USER_GROUP
            WHERE U.USER_ID=? 
              AND (GP.TARGET_TABLE=? OR GP.TARGET_TABLE='*ANY*')
        """, (user_id, resource_name))
        row = c.fetchone()
        if row and row[0] > 0:

            return True
        else:
            logger.warning(
                f"Permission denied: user_id={user_id}, action={action_type}, resource={resource_name}"
            )
            return False
    except Exception as ex:
        logger.error(f"Error in check_user_permissions: {ex}")
        return False


class TaskNotificationCenterTab(QWidget):


    def __init__(self, connection, current_user_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_user_id = current_user_id

        # Dictionary to hold saved search filters; mapping name -> filter string.
        self.saved_searches = {}

        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)


        search_bar_layout = QHBoxLayout()

        # Saved searches dropdown
        self.saved_search_combo = QComboBox()
        self.saved_search_combo.addItem("Select Saved Filter", "")
        self.saved_search_combo.currentIndexChanged.connect(self.apply_saved_search)
        search_bar_layout.addWidget(QLabel("Saved Filters:"))
        search_bar_layout.addWidget(self.saved_search_combo)

        # Button to save the current filter
        self.save_filter_btn = QPushButton("Save Current Filter")
        self.save_filter_btn.clicked.connect(self.save_current_filter)
        search_bar_layout.addWidget(self.save_filter_btn)

        # Spacer
        search_bar_layout.addStretch()

        # Search filter field with autocomplete suggestions
        self.search_filter_edit = QLineEdit()
        self.search_filter_edit.setPlaceholderText("Filter tasks (e.g., 'Critical', 'Finance', etc.)")
        # Set up QCompleter with common keywords (extendable)
        keywords = ["Approval", "Stale Lock", "Critical", "Finance", "Under Approval", "Rejected", "Pending"]
        completer = QCompleter(keywords)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.search_filter_edit.setCompleter(completer)
        self.search_filter_edit.textChanged.connect(self.load_tasks)
        search_bar_layout.addWidget(QLabel("Search:"))
        search_bar_layout.addWidget(self.search_filter_edit)

        main_layout.addLayout(search_bar_layout)

        # --- Task Table ---
        self.task_table = QTableWidget(0, 5)
        self.task_table.setHorizontalHeaderLabels(["Task ID", "Type", "Rule ID", "Description", "Actions"])
        self.task_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.task_table)

        # Refresh button at bottom
        refresh_btn = QPushButton("Refresh Tasks")
        refresh_btn.clicked.connect(self.load_tasks)
        main_layout.addWidget(refresh_btn)

        self.setLayout(main_layout)
        self.load_tasks()

    def load_tasks(self):
        """Load tasks from the database, apply search filter if provided."""
        self.task_table.setRowCount(0)
        tasks = []
        c = self.connection.cursor()

        # 1. Load Pending Approval Tasks for current user
        try:
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME 
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
                ORDER BY A.APPROVAL_STAGE
            """, (self.current_user_id,))
            for row in c.fetchall():
                rule_id, stage, rule_name = row
                desc = f"Approval (Stage {stage}) for Rule '{rule_name}'"
                tasks.append({
                    "task_type": "Approval",
                    "rule_id": rule_id,
                    "description": desc
                })
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading approval tasks: {ex}")

        # 2. Load Stale Lock Tasks (locks that are expired)
        try:
            now = datetime.datetime.now()
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, EXPIRY_TIMESTAMP 
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            for row in c.fetchall():
                rule_id, locked_by, expiry = row
                desc = f"Stale Lock: Locked by {locked_by}, expired at {expiry}"
                tasks.append({
                    "task_type": "Stale Lock",
                    "rule_id": rule_id,
                    "description": desc
                })
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading stale lock tasks: {ex}")

        # Apply search filter if specified
        filter_text = self.search_filter_edit.text().strip().lower()
        if filter_text:
            tasks = [t for t in tasks if filter_text in t["description"].lower() or
                     filter_text in t["task_type"].lower() or
                     filter_text in str(t["rule_id"])]

        # Populate the table
        self.task_table.setRowCount(len(tasks))
        for i, task in enumerate(tasks):
            task_id_item = QTableWidgetItem(str(i + 1))
            task_type_item = QTableWidgetItem(task["task_type"])
            rule_id_item = QTableWidgetItem(str(task["rule_id"]))
            desc_item = QTableWidgetItem(task["description"])
            self.task_table.setItem(i, 0, task_id_item)
            self.task_table.setItem(i, 1, task_type_item)
            self.task_table.setItem(i, 2, rule_id_item)
            self.task_table.setItem(i, 3, desc_item)

            # Create action buttons based on task type
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            action_layout.setContentsMargins(0, 0, 0, 0)

            if task["task_type"] == "Approval":
                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, rid=task["rule_id"]: self.approve_task(rid))
                action_layout.addWidget(approve_btn)

                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, rid=task["rule_id"]: self.reject_task(rid))
                action_layout.addWidget(reject_btn)
            elif task["task_type"] == "Stale Lock":
                force_btn = QPushButton("Force Unlock")
                force_btn.clicked.connect(lambda _, rid=task["rule_id"]: self.force_unlock_task(rid))
                action_layout.addWidget(force_btn)
                dismiss_btn = QPushButton("Dismiss")
                dismiss_btn.clicked.connect(lambda _, row=i: self.dismiss_task(row))
                action_layout.addWidget(dismiss_btn)
            # Future task types (e.g., conflict resolution) can be added here.

            action_layout.addStretch()
            self.task_table.setCellWidget(i, 4, action_widget)

    def approve_task(self, rule_id):
        c = self.connection.cursor()
        try:
            # Mark the approval for the current user as approved.
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE(), COMMENT='Approved via Task Center'
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (rule_id, self.current_user_id))
            # If no pending approvals remain, mark the rule as approved.
            c.execute("SELECT COUNT(*) FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND APPROVED_FLAG=0", (rule_id,))
            if c.fetchone()[0] == 0:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                    WHERE RULE_ID=?
                """, (rule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
            self.load_tasks()
        except Exception as ex:
            QMessageBox.critical(self, "Approval Error", str(ex))

    def reject_task(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE(), COMMENT='Rejected via Task Center'
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (rule_id, self.current_user_id))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """, (rule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
            self.load_tasks()
        except Exception as ex:
            QMessageBox.critical(self, "Rejection Error", str(ex))

    def force_unlock_task(self, rule_id):
        try:
            # Use LockManager to force unlock. Adjust the import as per your project structure.

            LockManager.unlock_rule_for_edit(self.connection, rule_id, self.current_user_id, force=True)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} force unlocked.")
            self.load_tasks()
        except Exception as ex:
            QMessageBox.critical(self, "Force Unlock Error", str(ex))

    def dismiss_task(self, row):
        # Remove the task row from the table; optionally, update a flag in the DB.
        self.task_table.removeRow(row)
        QMessageBox.information(self, "Dismissed", "Task dismissed.")

    def apply_saved_search(self):
        # When a saved search is selected, set the search filter text.
        filter_text = self.saved_search_combo.currentData()
        if filter_text is not None:
            self.search_filter_edit.setText(filter_text)
        self.load_tasks()

    def save_current_filter(self):
        # Prompt the user for a name and save the current filter text.
        filter_text = self.search_filter_edit.text().strip()
        if not filter_text:
            QMessageBox.warning(self, "Empty Filter", "Please enter some filter text to save.")
            return
        name, ok = QInputDialog.getText(self, "Save Filter", "Enter a name for this filter:")
        if not ok or not name.strip():
            return

        self.saved_searches[name.strip()] = filter_text

        self.saved_search_combo.addItem(name.strip(), filter_text)
        QMessageBox.information(self, "Saved", f"Filter '{name.strip()}' saved.")


########################################
# 4) DATABASE CONNECTION DIALOG
########################################

class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    A user-facing dialog to pick an ODBC DSN or custom connection string.
    Enhanced with live testing of connectivity & optional constraints.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("Database Connection – BRM Master")
        self.resize(440, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            if not dsn_dict:
                # -- ADDED/CHANGED --
                logger.warning("No DSNs found in this system. DSN list is empty.")
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            test_conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully (test).")
            return test_conn
        except Exception as ex:
            logger.error(f"DB connection failed: {ex}")
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()
        else:
            logger.debug("Staying in DB dialog for correction.")


########################################
# LOGIN
########################################

class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password dialog that checks the USERS table.
    Enhanced to show advanced RBAC or disclaimers if needed.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login")
        self.resize(300, 160)

        main_layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)

        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()

        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password are required.")
            return

        try:
            logger.debug(f"Attempting login for user: {un}")
            c = self.connection.cursor()
            c.execute("""
                SELECT USER_ID, USER_GROUP 
                FROM USERS
                WHERE USERNAME = ? AND PASSWORD = ?
            """, (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in successfully. user_id={self.user_id}, group={self.user_group}")
                self.accept()
            else:
                logger.warning(f"Login failed for user: {un} => Invalid credentials.")
                QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
        except Exception as ex:
            logger.exception("Error during login:")
            QMessageBox.critical(self, "Database Error", f"An error occurred during login:\n{ex}")


def fetch_all_dict(cursor):
    """
    Fetch all rows into a list of dicts if description is present, else raw rows.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        out = []
        for r_ in rows:
            out.append(dict(zip(colnames, r_)))
        return out
    else:
        return rows


def fetch_one_dict(cursor):
    """
    Fetch the next row as dict (if present) or None.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None


def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert an audit record into BRM_AUDIT_LOG with optional old/new data as JSON.
    Enhanced for robust error handling and extended for partial diffs if needed.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action, table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"Audit log inserted => action={action}, table={table_name}, record_id={record_id}, actor={actor}")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")



class CollaborationManager(QtCore.QObject):
    """
    Polls collaboration messages from the DB. Provides mention-based notifications
    and threading support expansions. Signals newMessage whenever new DB entries appear.

    Consider expansions:
     • Threaded messages (e.g., each rule or topic = separate thread)
     • Mentions: detect @username references, generate direct notifications
    """
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.last_timestamp = None
        self.timer.start(self.poll_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            # Basic approach: read from COLLABORATION_LOGS
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE_ID, MESSAGE, SENDER, TIMESTAMP 
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE_ID, MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)
            rows = c.fetchall()
            if rows:
                for row in rows:
                    msg_id, message, sender, ts = row
                    payload = {
                        "message_id": msg_id,
                        "message": message,
                        "sender": sender,
                        "timestamp": ts
                    }
                    self.newMessage.emit(payload)
                    self.detect_mentions(payload)
                    self.last_timestamp = ts
        except Exception as ex:
            logger.error(f"Error polling collaboration messages: {ex}")

    def detect_mentions(self, msg_payload):
        """
        Parse the message for '@username' patterns. Possibly create direct notifications
        if needed. For demonstration, we just log it.
        """
        message = msg_payload.get("message", "")
        pattern = r'@(\w+)'
        mentions = re.findall(pattern, message)
        if mentions:
            logger.debug(f"Mentions detected => {mentions}")
            # Future expansion: send notifications, etc.


class LockManager:
    """
    A consolidated approach storing locks in BRM_RULE_LOCKS with expiry.
    Includes:
      • auto_unlock_expired_locks
      • rule_current_lock_owner
      • lock_rule_for_edit
      • unlock_rule_for_edit
      • forced unlock logic
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            rc = c.rowcount
            conn.commit()
            if rc > 0:
                logger.info(f"Auto-unlocked {rc} expired rule locks.")
        except Exception as ex:
            logger.error(f"Error auto-unlocking expired locks: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag = row
        now = datetime.now()
        if et and now > et:
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except Exception as ex:
                logger.error(f"Error expiring lock for rule {rule_id}: {ex}")
            return None
        return (locked_by, lts, et, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if info is not None:
            locked_by, old_ts, old_exp, fflag = info
            if locked_by == user_id:
                # Refresh lock
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock for rule {rule_id} refreshed by {user_id}. force={force}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    # Force unlock & re-lock
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly re-locked by {user_id}.")
                    return
        else:
            # No lock yet => insert
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return  # not locked
        locked_by, lts, et, fflag = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}, cannot unlock.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by {user_id}, force={force}.")


import sqlparse
from sqlparse.sql import IdentifierList, Identifier, Parenthesis, TokenList
from sqlparse.tokens import Keyword, DML, Whitespace, Newline, Punctuation, Name, Wildcard
import logging

logger = logging.getLogger("BRM_sql_parser")


# -----------------------------------------------------------------------------
# Helper Functions for Parsing
# -----------------------------------------------------------------------------
def is_subselect(parsed):
    """
    Return True if the parsed token (usually a Parenthesis) contains a SELECT.
    """
    if not parsed.is_group:
        return False
    for item in parsed.tokens:
        if item.ttype is DML and item.value.upper() == 'SELECT':
            return True
    return False


def extract_cte(tokens):
    """
    From a list of tokens starting with a WITH clause, extract CTE names.
    This function scans tokens until the main SELECT is encountered.
    """
    cte_names = []
    tokens = [token for token in tokens if not token.is_whitespace]
    if tokens and tokens[0].ttype is Keyword and tokens[0].value.upper() == "WITH":
        idx = 1
        while idx < len(tokens):
            token = tokens[idx]
            # An identifier represents the CTE name.
            if token.ttype in (Name,) or isinstance(token, Identifier):
                cte_name = token.get_real_name() if isinstance(token, Identifier) else token.value
                if cte_name:
                    cte_names.append(cte_name)
            # Once the main SELECT is encountered, stop.
            if token.ttype is DML and token.value.upper() == "SELECT":
                break
            idx += 1
    return cte_names


def extract_identifiers(token):
    """
    Recursively yield Identifier objects from a token.
    """
    if isinstance(token, Identifier):
        yield token
    elif isinstance(token, IdentifierList):
        for identifier in token.get_identifiers():
            yield identifier
    elif token.is_group:
        for subtoken in token.tokens:
            for identifier in extract_identifiers(subtoken):
                yield identifier


def recursive_token_process(token, result):
    """
    Recursively traverse tokens to update the result dictionary.
    It captures:
      - JOIN keywords,
      - Subqueries (raw text),
      - And further nested table/column identifiers.
    """
    # Process Parenthesis tokens (could be subqueries)
    if isinstance(token, Parenthesis):
        if is_subselect(token):
            subquery = token.value
            result["subqueries"].append(subquery)
            # Recursively parse the subquery text.
            sub_result = parse_sql_dependencies(subquery)
            result["tables"].update(sub_result["tables"])
            result["aliases"].update(sub_result["aliases"])
            result["cte"].update(sub_result["cte"])
            result["joins"].update(sub_result["joins"])
            result["columns"].update(sub_result["columns"])
        else:
            for t in token.tokens:
                recursive_token_process(t, result)
    elif token.is_group:
        for subtoken in token.tokens:
            recursive_token_process(subtoken, result)
    else:
        # Capture JOIN keywords.
        if token.ttype is Keyword and "JOIN" in token.value.upper():
            result["joins"].add(token.value.upper())


# -----------------------------------------------------------------------------
# Advanced SQL Dependency Parser Function
# -----------------------------------------------------------------------------
def parse_sql_dependencies(sql_text):
    """
    Parses the SQL text and returns a dictionary with dependencies:
      - "tables": set of table names used.
      - "cte": set of CTE names.
      - "aliases": dict mapping alias -> real table name.
      - "joins": set of JOIN keywords encountered.
      - "subqueries": list of subquery texts.
      - "columns": set of basic column references.
    """
    result = {
        "tables": set(),
        "cte": set(),
        "aliases": {},
        "joins": set(),
        "subqueries": [],
        "columns": set(),
    }
    try:
        statements = sqlparse.parse(sql_text)
        if not statements:
            return result

        for statement in statements:
            tokens = [token for token in statement.tokens if not token.is_whitespace]
            # Extract CTE names if WITH clause exists.
            cte_names = extract_cte(tokens)
            result["cte"].update(cte_names)

            # Process flattened tokens for identifiers and columns.
            for token in statement.flatten():
                if token.ttype in (Whitespace, Newline):
                    continue
                if token.ttype is Wildcard:
                    result["columns"].add(token.value)
                if isinstance(token, Identifier):
                    real_name = token.get_real_name()
                    if real_name:
                        result["tables"].add(real_name)
                    alias = token.get_alias()
                    if alias:
                        result["aliases"][alias] = real_name
                if token.ttype is Name:
                    result["columns"].add(token.value)
            # Use recursive processing for subqueries and JOINs.
            for token in statement.tokens:
                recursive_token_process(token, result)
        # Convert all sets to lists for consistency.
        for key in result:
            if isinstance(result[key], set):
                result[key] = list(result[key])
        return result
    except Exception as ex:
        logger.error(f"Advanced SQL parsing error: {ex}")
        return result


# -----------------------------------------------------------------------------
# Function to Update BRM Dependency Tables
# -----------------------------------------------------------------------------
def update_rule_dependencies(conn, rule_id, dependencies, default_db="dbo"):
    """
    Update dependency tables for the given rule_id using the parsed dependencies.
    This function deletes previous dependencies and inserts new ones.

    Parameters:
      - conn: database connection.
      - rule_id: the rule ID for which to update dependencies.
      - dependencies: a dictionary as returned by parse_sql_dependencies_advanced.
      - default_db: default database/schema name (default 'dbo').
    """
    c = conn.cursor()
    try:
        # Delete existing dependencies for this rule.
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
        c.execute("DELETE FROM BRM_RULE_CTE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
        c.execute("DELETE FROM BRM_RULE_ALIAS_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
        c.execute("DELETE FROM BRM_RULE_JOIN_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
        c.execute("DELETE FROM BRM_RULE_SUBQUERY_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
        c.execute("DELETE FROM BRM_RULE_COLUMN_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))

        # Insert table dependencies.
        # Determine column operation based on SQL (here a simple check; extend as needed)
        op_type = "READ"
        if dependencies.get("joins") or any(sqlparse.parse("INSERT")[0].tokens):
            op_type = "WRITE"
        for table in dependencies.get("tables", []):
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES (RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP)
                VALUES (?, ?, ?, ?, ?)
            """, (rule_id, default_db, table, "", op_type))

        # Insert CTE dependencies.
        for cte in dependencies.get("cte", []):
            c.execute("""
                INSERT INTO BRM_RULE_CTE_DEPENDENCIES (RULE_ID, CTE_NAME)
                VALUES (?, ?)
            """, (rule_id, cte))

        # Insert alias dependencies.
        for alias, real in dependencies.get("aliases", {}).items():
            c.execute("""
                INSERT INTO BRM_RULE_ALIAS_DEPENDENCIES (RULE_ID, ALIAS, REAL_TABLE)
                VALUES (?, ?, ?)
            """, (rule_id, alias, real))

        # Insert JOIN dependencies.
        for join_type in dependencies.get("joins", []):
            c.execute("""
                INSERT INTO BRM_RULE_JOIN_DEPENDENCIES (RULE_ID, JOIN_TYPE)
                VALUES (?, ?)
            """, (rule_id, join_type))

        # Insert subquery dependencies.
        for subq in dependencies.get("subqueries", []):
            c.execute("""
                INSERT INTO BRM_RULE_SUBQUERY_DEPENDENCIES (RULE_ID, SUBQUERY_TEXT)
                VALUES (?, ?)
            """, (rule_id, subq))

        # Insert column dependencies.
        for col in dependencies.get("columns", []):
            c.execute("""
                INSERT INTO BRM_RULE_COLUMN_DEPENDENCIES (RULE_ID, COLUMN_NAME)
                VALUES (?, ?)
            """, (rule_id, col))

        conn.commit()
        logger.info(f"Dependencies for rule {rule_id} updated successfully.")
    except Exception as ex:
        conn.rollback()
        logger.error(f"Error updating dependencies for rule {rule_id}: {ex}")
        raise

def detect_operation_type(sql_text: str) -> str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, or OTHER.
    Enhanced: remove comments/whitespace, check forbidden/allowed SQL.
    """
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or '', flags=re.MULTILINE | re.DOTALL).strip()
    up = cleaned.upper()
    # Also check for forbidden keywords
    for bad_kw in BRM_CONFIG.get("FORBIDDEN_SQL_KEYWORDS", []):
        if bad_kw.upper() in up:
            logger.warning(f"Forbidden keyword detected => {bad_kw}")
            return "OTHER"  # or raise an exception
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    return "OTHER"


def run_data_validations(conn):
    """
    Executes all data validations from DATA_VALIDATIONS table.
    Logs results in DATA_VALIDATION_LOGS.
    Enhancements:
      • Range checks
      • Not null
      • Unique
      • Summaries
    """
    c = conn.cursor()
    try:
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        validations = c.fetchall()
    except Exception as e:
        logger.error("Error fetching validations: %s", e)
        return

    for val in validations:
        validation_id, table_name, column_name, validation_type, params = val
        result_flag = "PASS"
        details = ""
        try:
            if validation_type.upper() == "NOT NULL":
                query = f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL"
                c.execute(query)
                count = c.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} NULLs found in column '{column_name}'."
                else:
                    details = f"No NULLs in column '{column_name}'."
            elif validation_type.upper() == "RANGE":
                min_val, max_val = None, None
                if params:
                    for part in params.split(";"):
                        part = part.strip().lower()
                        if part.startswith("min="):
                            min_val = float(part.split("=")[1])
                        elif part.startswith("max="):
                            max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid parameters for RANGE validation."
                else:
                    query = f"""
                        SELECT COUNT(*) 
                        FROM {table_name}
                        WHERE TRY_CAST({column_name} AS FLOAT) IS NOT NULL
                          AND (TRY_CAST({column_name} AS FLOAT) < {min_val}
                               OR TRY_CAST({column_name} AS FLOAT) > {max_val})
                    """
                    c.execute(query)
                    count = c.fetchone()[0]
                    if count > 0:
                        result_flag = "FAIL"
                        details = f"{count} values out of range [{min_val}, {max_val}]."
                    else:
                        details = f"All within range [{min_val}, {max_val}]."
            elif validation_type.upper() == "UNIQUE":
                query = f"""
                    SELECT COUNT(*) FROM (
                        SELECT {column_name}, COUNT(*) AS cnt
                        FROM {table_name}
                        GROUP BY {column_name}
                        HAVING COUNT(*) > 1
                    ) AS duplicates
                """
                c.execute(query)
                count = c.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} duplicate(s) found in '{column_name}'."
                else:
                    details = f"All values in '{column_name}' are unique."
            else:
                result_flag = "FAIL"
                details = f"Validation type '{validation_type}' not implemented."
        except Exception as ex:
            result_flag = "FAIL"
            details = f"Error => {ex}"

        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP)
                VALUES(?, ?, ?, GETDATE())
            """, (validation_id, result_flag, details))
            conn.commit()
        except Exception as log_ex:
            logger.error(f"Error logging validation {validation_id}: {log_ex}")


def execute_rules_unified_bfs(conn, dry_run=False, user_id=None):
    """
    Executes rules BFS-based, skipping child rules if a critical/global rule fails.
    Steps:
      1. Run data validations if needed.
      2. Build adjacency (rule->children) including conflicts and global-critical links.
      3. Execute BFS starting from root rules.
      4. Skip or proceed based on rule execution success.

    Returns a tuple: (list of executed rule IDs, list of skipped rule IDs)
    If user_id is provided, an ACL check is performed for each rule.
    """
    run_data_validations(conn)
    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_lookup = get_all_rules_map(conn)
    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue
        if user_id:
            rule_obj = rule_lookup[rid]
            rule_name = rule_obj.get("RULE_NAME", f"Rule{rid}")
            if not check_user_permissions(conn, user_id, "EXECUTE", rule_name):
                logger.warning(f"User {user_id} lacks EXECUTE permission on {rule_name}. Skipped.")
                skipped.add(rid)
                continue

        info = rule_lookup[rid]
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            is_crit = (info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1)
            if is_crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)

    return (executed, list(skipped))


def load_rule_relationships(conn):
    """
    Builds adjacency for BFS. Also could incorporate conflicts or composites.
    Returns a tuple: (adjacency_dict, list_of_root_rule_ids, parent_map)
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid

    c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
    conflict_rows = c.fetchall()
    for (r1, r2) in conflict_rows:
        adjacency.setdefault(r1, set()).add(r2)
        adjacency.setdefault(r2, set()).add(r1)

    child_ids = set(parent_map.keys())
    roots = [rid for rid in all_ids if rid not in child_ids]
    return (adjacency, roots, parent_map)


def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for child in adjacency[cur]:
                if child not in skipped:
                    stack.append(child)


def get_all_rules_map(conn):

    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    rule_map = {}
    for row in rows:
        d = dict(zip(colnames, row))
        rule_map[d["RULE_ID"]] = d
    return rule_map



def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    Executes a single rule. For decision tables, it uses a dedicated flow.
    Otherwise, it executes the RULE_SQL in a transaction.
    Returns a tuple: (success_flag, message, record_count)
    """
    op_type = rule_info.get("OPERATION_TYPE", "OTHER")
    if op_type.upper() == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False, "No DECISION_TABLE_ID provided", 0)
        ok, msg, rec_count = execute_decision_table(conn, dt_id, dry_run=True)
        return (ok, msg, rec_count)

    sql_ = rule_info.get("RULE_SQL") or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Error begin txn => {ex}")
        return (False, str(ex), 0)
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        try:
            rows = c.fetchall()
        except:
            rows = []
        if rows:
            rec_count = len(rows)
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned => {val}"
        else:
            success = True
            msg = "No rows => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)



def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Inserts a record into RULE_EXECUTION_LOGS, capturing execution details.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
              CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting rule exec log => {ex}")

def execute_decision_table(conn, dt_id, dry_run=True):
    """
    For a decision table, executes the DECISION_QUERY.
    Returns a tuple: (success_flag, message, record_count).
    Rolls back the transaction if dry_run is True.
    """
    c_dt = conn.cursor()
    c_dt.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c_dt.fetchone()
    if not row:
        return (False, f"DecisionTable {dt_id} not found.", 0)
    decision_query = row[0]
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False, f"Error begin txn => {ex}", 0)
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(decision_query)
        try:
            rows = c.fetchall()
        except:
            rows = []
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Decision returned {val}"
        else:
            success = True
            msg = "No rows => PASS"
        c.execute("ROLLBACK")  # always if dry_run
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

def insert_decision_table_log(conn, dt_id, pass_flag, message, record_count):
    """
    Inserts a log record into DECISION_TABLE_EXEC_LOGS.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO DECISION_TABLE_EXEC_LOGS(
              DECISION_TABLE_ID, EXEC_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
            )
            VALUES(?, GETDATE(), ?, ?, ?)
        """, (dt_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting decision table log => {ex}")

def dry_run_rule_sql(conn, sql_text, input_csv=None):
    """
    Runs the given SQL in a transaction and then rolls back.
    - If input_csv is provided, you could interpret or load that data into a temp table, etc. (Future extension).
    Checks if the first column of the result equals 1 (PASS).
    Returns a tuple: (bool, message, record_count).
    """
    # -- ADDED/CHANGED -- we now return record_count for uniformity
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False, f"Error start txn => {ex}", 0)
    success = False
    message = ""
    rec_count = 0
    try:
        # If you wanted to do something with input_csv, do it here.
        c.execute(sql_text)
        try:
            rows = c.fetchall()
        except:
            rows = []
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            message = f"Returned => {val}"
        else:
            success = True
            message = "No rows => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        message = str(ex)
    return (success, message, rec_count)

def simulate_chain_bfs(conn, parent_rule_id):
    adjacency, roots, parent_map = load_rule_relationships(conn)
    all_rules_map = get_all_rules_map(conn)
    executed = []
    skipped = set()
    queue = [parent_rule_id]

    # -- ADDED/CHANGED -- if adjacency is large, show a QProgressDialog
    total_nodes = len(all_rules_map)
    if total_nodes > 1000:
        logger.warning("simulate_chain_bfs: Large rule set detected. Using QProgressDialog for BFS progress.")
        progress_dlg = QProgressDialog("Simulating BFS...", "Cancel", 0, total_nodes)
        progress_dlg.setWindowTitle("Chain BFS Simulation")
        progress_dlg.setWindowModality(Qt.WindowModal)
        progress_dlg.show()
    else:
        progress_dlg = None

    processed_count = 0

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in all_rules_map:
            skipped.add(rid)
            continue
        rdata = all_rules_map[rid]
        op_type = rdata.get("OPERATION_TYPE", "OTHER")
        sql_text = rdata.get("RULE_SQL") or ""
        dt_id = rdata.get("DECISION_TABLE_ID")

        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg, rec_count = dry_run_rule_sql(conn, sql_text)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            is_crit = (rdata.get("CRITICAL_RULE", 0) == 1 or rdata.get("IS_GLOBAL", 0) == 1)
            if is_crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)

        processed_count += 1
        if progress_dlg:
            progress_dlg.setValue(processed_count)
            if progress_dlg.wasCanceled():
                logger.info("User canceled BFS simulation.")
                break

    if progress_dlg:
        progress_dlg.close()

    return (executed, list(skipped))


########################################################
# ENHANCED SCHEDULE DIALOG
########################################################

class EnhancedScheduleDialog(QtWidgets.QDialog):


    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling Dialog")
        self.resize(400, 300)
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.rule_combo = QComboBox()
        # Populate rule list
        c = connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            rows = c.fetchall()
            for (rid, rn) in rows:
                self.rule_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            logging.error(f"Error loading rules for scheduling => {ex}")
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        self.run_val_checkbox = QCheckBox("Run Data Validations Before Execution?")
        self.run_val_checkbox.setChecked(False)
        form.addRow(self.run_val_checkbox)

        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        btn_layout.addWidget(sch_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.reject)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_str = self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str = self.time_edit.time().toString("HH:mm:ss")
        dt_str = f"{date_str} {time_str}"
        run_val_flag = 1 if self.run_val_checkbox.isChecked() else 0
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(
                  RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, RUN_DATA_VALIDATIONS
                )
                VALUES(?, ?, 'Scheduled', GETDATE(), ?)
            """, (rid, dt_str, run_val_flag))
            self.connection.commit()
            QMessageBox.information(self, "Scheduled",
                                    f"Rule {rid} scheduled at {dt_str}, validations={bool(run_val_flag)}.")
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Schedule Error", str(ex))


########################################################
# SCHEDULE MANAGEMENT TAB
########################################################

class ScheduleManagementTab(QtWidgets.QWidget):
    """
    Displays the RULE_SCHEDULES table with functionality to refresh,
    add new schedules, update, and delete them.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID", "RuleID", "ScheduleTime", "Status", "RunVal?", "Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(refresh_btn)

        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS
                FROM RULE_SCHEDULES
                ORDER BY SCHEDULE_TIME DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                for col_index in range(5):
                    val = row[col_index]
                    self.table.setItem(row_index, col_index, QTableWidgetItem(str(val) if val is not None else ""))
                action_widget = QWidget()
                a_layout = QHBoxLayout(action_widget)
                a_layout.setContentsMargins(0, 0, 0, 0)
                update_btn = QPushButton("Update")
                update_btn.clicked.connect(lambda _, idx=row_index: self.update_schedule(idx))
                del_btn = QPushButton("Delete")
                del_btn.clicked.connect(lambda _, idx=row_index: self.delete_schedule(idx))
                a_layout.addWidget(update_btn)
                a_layout.addWidget(del_btn)
                a_layout.addStretch()
                self.table.setCellWidget(row_index, 5, action_widget)
            self.table.resizeColumnsToContents()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        if dlg.exec_() == QDialog.Accepted:
            self.load_schedules()

    def update_schedule(self, row_index):
        item = self.table.item(row_index, 0)
        if not item:
            return
        schedule_id = int(item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE RULE_SCHEDULES
                SET SCHEDULE_TIME = ?
                WHERE SCHEDULE_ID = ?
            """, (new_dt.strip(), schedule_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {schedule_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Update Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, row_index):
        item = self.table.item(row_index, 0)
        if not item:
            return
        schedule_id = int(item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {schedule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (schedule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Schedule {schedule_id} removed.")
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))
        self.load_schedules()


########################################################
# CHAIN / GROUP SIMULATION DIALOGS
########################################################

class ChainSimulationDialog(QDialog):
    """
    Simulates a BFS chain starting from a selected parent rule.
    Displays the list of executed and skipped rule IDs.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation (BFS)")
        self.resize(550, 400)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        c = connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for (rid, rn) in c.fetchall():
                self.rule_combo.addItem(f"{rid} - {rn}", rid)
        except:
            pass
        top_layout.addWidget(QLabel("Select Parent Rule:"))
        top_layout.addWidget(self.rule_combo)
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_h = QHBoxLayout()
        run_btn = QPushButton("Run Chain BFS (Dry-run)")
        run_btn.clicked.connect(self.do_simulation)
        btn_h.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_simulation(self):
        parent_rule_id = self.rule_combo.currentData()
        executed, skipped = simulate_chain_bfs(self.connection, parent_rule_id)
        msg = (f"Chain BFS from rule {parent_rule_id}:\n"
               f"Executed: {executed}\nSkipped: {skipped}")
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Chain BFS Simulation", msg)


def simulate_custom_group_rules(conn, custom_group_id):
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rule_ids = [r[0] for r in c.fetchall()]
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_type, dt_id) in rows:
        rule_map[rid] = (sql_ or "", op_type.upper(), dt_id)
    passed = []
    failed = []
    for rid in rule_ids:
        if rid not in rule_map:
            failed.append(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg, _ = dry_run_rule_sql(conn, sql_text)
        if ok:
            passed.append(rid)
        else:
            failed.append(rid)
    return (passed, failed)

class GroupSimulationDialog(QDialog):
    """
    Simulates a dry-run for all rules in a custom group.
    Displays lists of rule IDs that passed or failed.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation")
        self.resize(600, 450)
        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.group_combo = QComboBox()
        c = connection.cursor()
        try:
            c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            for (cid, gn) in c.fetchall():
                self.group_combo.addItem(f"{cid} - {gn}", cid)
        except:
            pass
        top_h.addWidget(QLabel("Select Custom Group:"))
        top_h.addWidget(self.group_combo)
        layout.addLayout(top_h)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_h = QHBoxLayout()
        run_btn = QPushButton("Run Group Simulation (Dry-run)")
        run_btn.clicked.connect(self.do_simulation)
        btn_h.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def do_simulation(self):
        gid = self.group_combo.currentData()
        passed, failed = simulate_custom_group_rules(self.connection, gid)
        msg = (f"Group Simulation for group {gid}:\n"
               f"Passed: {passed}\nFailed: {failed}")
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Group Simulation Result", msg)

# DECISION TABLES TAB

class DecisionTablesTab(QtWidgets.QWidget):
    """
    Manages decision tables: listing, adding, deleting, and executing queries.
    Logs execution results in DECISION_TABLE_EXEC_LOGS.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID", "Name", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_row = QHBoxLayout()
        add_btn = QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        btn_row.addWidget(add_btn)
        del_btn = QPushButton("Delete DT")
        del_btn.clicked.connect(self.delete_dt)
        btn_row.addWidget(del_btn)
        run_btn = QPushButton("Execute DT")
        run_btn.clicked.connect(self.run_dt)
        btn_row.addWidget(run_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        btn_row.addWidget(ref_btn)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.dt_table.rowCount()
                self.dt_table.insertRow(r_idx)
                for col, val in enumerate(row):
                    self.dt_table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        query_text, ok3 = QInputDialog.getMultiLineText(self, "Decision Query", "Enter SQL query (returns 1 or 0):")
        if not ok3 or not query_text.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION, DECISION_QUERY, CREATED_TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """, (name.strip(), desc.strip(), query_text.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision Table created.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No Decision Table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete Decision Table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision Table removed.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No Decision Table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        insert_decision_table_log(self.connection, dt_id, ok, msg, rec_count)
        txt = (f"Decision Table {dt_id} => PASS={ok}, message='{msg}', records={rec_count}")
        QMessageBox.information(self, "Execution Result", txt)


########################################################
# CONFLICT PRIORITY TAB
########################################################

class ConflictPriorityManagerTab(QtWidgets.QWidget):
    """
    Manages rule conflicts: add conflicts, update priority, and delete conflicts.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_h.addWidget(add_btn)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        btn_h.addWidget(set_btn)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        btn_h.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_h.addWidget(refresh_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows = c.fetchall()
            for row in rows:
                r_idx = self.cf_table.rowCount()
                self.cf_table.insertRow(r_idx)
                for col_i, val in enumerate(row):
                    self.cf_table.setItem(r_idx, col_i, QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:", value=1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_priority, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Conflict deleted.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


########################################################
# COMPOSITE RULES TAB
########################################################

class CompositeRulesTab(QtWidgets.QWidget):
    """
    Manages composite rules: allows adding new composite rules and deleting them.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["CompRuleID", "Name", "Logic Expression", "ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite)
        btn_h.addWidget(add_btn)
        del_btn = QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.delete_composite)
        btn_h.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_composites)
        btn_h.addWidget(refresh_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
                FROM COMPOSITE_RULES
                ORDER BY COMPOSITE_RULE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.cr_table.rowCount()
                self.cr_table.insertRow(r_idx)
                for col_i, val in enumerate(row):
                    self.cr_table.setItem(r_idx, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_composite(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getMultiLineText(self, "Logic Expression", "e.g. 'Rule10==PASS AND Rule20==PASS'")
        if not ok2:
            expr = ""
        action, ok3 = QInputDialog.getText(self, "Action on Pass", "Optional action (e.g., SendEmail)")
        if not ok3:
            action = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
                VALUES(?,?,?)
            """, (name.strip(), expr.strip(), action.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Composite rule added.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_composite(self):
        row = self.cr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No composite rule selected.")
            return
        comp_id = int(self.cr_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {comp_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (comp_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Composite rule deleted.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


########################################################
# SNAPSHOT MANAGER TAB
########################################################

class SnapshotManagerTab(QtWidgets.QWidget):
    """
    Displays snapshots of BRM_RULES (as JSON). Allows taking and deleting snapshots,
    and provides a button to compare snapshots.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID", "Name", "CreatedBy", "CreatedTS", "JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        btn_h = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_h.addWidget(take_btn)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_h.addWidget(del_btn)
        comp_btn = QPushButton("Compare Snapshots")
        comp_btn.clicked.connect(self.compare_snapshots)
        btn_h.addWidget(comp_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.ss_table.rowCount()
                self.ss_table.insertRow(r_idx)
                for col_i, val in enumerate(row):
                    self.ss_table.setItem(r_idx, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Enter snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            snapshot_data = [dict(zip(colnames, r)) for r in rows]
            snapshot_json = json.dumps(snapshot_data, indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
                VALUES(?, ?, ?)
            """, (name.strip(), "SnapshotUser", snapshot_json))
            self.connection.commit()
            QMessageBox.information(self, "Snapshot", "Snapshot created.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        snap_id = int(self.ss_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snap_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Snapshot deleted.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def compare_snapshots(self):
        # Let user pick two snapshots or current state
        c = self.connection.cursor()
        try:
            c.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID")
            snaps = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
            return
        if not snaps or len(snaps) < 2:
            QMessageBox.warning(self, "Insufficient", "Need at least 2 snapshots to compare.")
            return

        snap_ids = [f"{s[0]} - {s[1]}" for s in snaps]
        s1, ok1 = QInputDialog.getItem(self, "Compare Snapshots", "Select Snapshot #1:", snap_ids, 0, False)
        if not ok1 or not s1:
            return
        s2, ok2 = QInputDialog.getItem(self, "Compare Snapshots", "Select Snapshot #2:", snap_ids, 1, False)
        if not ok2 or not s2:
            return
        id1 = int(s1.split("-")[0].strip())
        id2 = int(s2.split("-")[0].strip())
        if id1 == id2:
            QMessageBox.warning(self, "Same Snap", "Cannot compare the same snapshot.")
            return
        c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (id1,))
        row1 = c.fetchone()
        c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (id2,))
        row2 = c.fetchone()
        if not row1 or not row2:
            QMessageBox.warning(self, "Missing", "One snapshot not found.")
            return
        snap_json_1 = row1[0] or "[]"
        snap_json_2 = row2[0] or "[]"
        try:
            data1 = json.loads(snap_json_1)
            data2 = json.loads(snap_json_2)
        except:
            QMessageBox.warning(self, "Error", "Invalid JSON in snapshot(s).")
            return
        index1 = {d["RULE_ID"]: d for d in data1}
        index2 = {d["RULE_ID"]: d for d in data2}
        added = []
        removed = []
        changed = []
        for rid, info in index1.items():
            if rid not in index2:
                removed.append(rid)
            else:
                if json.dumps(info, sort_keys=True) != json.dumps(index2[rid], sort_keys=True):
                    changed.append(rid)
        for rid in index2:
            if rid not in index1:
                added.append(rid)
        txt = (f"Comparing Snap #{id1} vs Snap #{id2}\n\n"
               f"Added: {added}\nRemoved: {removed}\nChanged: {changed}\n")
        diff_dlg = QDialog(self)
        diff_dlg.setWindowTitle("Snapshot Compare Result")
        diff_dlg.resize(800, 600)
        vbox = QVBoxLayout(diff_dlg)
        diff_edit = QPlainTextEdit()
        diff_edit.setReadOnly(True)
        diff_edit.setPlainText(txt)
        vbox.addWidget(diff_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(diff_dlg.accept)
        vbox.addWidget(close_btn)
        diff_dlg.exec_()


########################################################
# TAGS MANAGER TAB
########################################################

class TagsManagerTab(QtWidgets.QWidget):
    """
    Manages rule tags: allows adding or removing tags for rules.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        remove_btn = QPushButton("Remove Tag")
        remove_btn.clicked.connect(self.remove_tag)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(remove_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT TAG_ID, RULE_ID, TAG_NAME
                FROM RULE_TAGS
                ORDER BY TAG_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.tags_table.rowCount()
                self.tags_table.insertRow(r_idx)
                for col_i, val in enumerate(row):
                    self.tags_table.setItem(r_idx, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "RuleID:")
        if not ok:
            return
        tag_name, ok2 = QInputDialog.getText(self, "Tag", "Tag name:")
        if not ok2 or not tag_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?,?)", (rule_id, tag_name.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Tag assigned.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        tag_id = int(self.tags_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Tag removed.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


########################################################
# DATA VALIDATION TAB
########################################################

class DataValidationTab(QtWidgets.QWidget):
    """
    Provides management of data validations: list, add, remove, and run validations.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dv_table = QTableWidget(0, 6)
        self.dv_table.setHorizontalHeaderLabels([
            "ValID", "TableName", "ColumnName", "ValType", "Params", "LastResult"
        ])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        remove_btn = QPushButton("Remove Validation")
        remove_btn.clicked.connect(self.remove_validation)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_validations)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(remove_btn)
        btn_h.addWidget(run_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT V.VALIDATION_ID, V.TABLE_NAME, V.COLUMN_NAME, V.VALIDATION_TYPE,
                       V.PARAMS,
                       (SELECT TOP 1 DETAILS FROM DATA_VALIDATION_LOGS L
                        WHERE L.VALIDATION_ID=V.VALIDATION_ID
                        ORDER BY L.VALIDATION_TIMESTAMP DESC
                       ) AS LAST_RESULT
                FROM DATA_VALIDATIONS V
                ORDER BY V.VALIDATION_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.dv_table.rowCount()
                self.dv_table.insertRow(r_idx)
                for col_i, val in enumerate(row):
                    self.dv_table.setItem(r_idx, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Table name:")
        if not ok or not table_name.strip():
            return
        col_name, ok2 = QInputDialog.getText(self, "Add Validation", "Column name:")
        if not ok2 or not col_name.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Val Type", "e.g. NOT NULL, RANGE, UNIQUE:")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "e.g. min=0;max=100 (optional):")
        if not ok4:
            params = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP)
                VALUES(?,?,?,?,GETDATE())
            """, (table_name.strip(), col_name.strip(), vtype.strip(), params.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Data validation created.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        val_id = int(self.dv_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation ID {val_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (val_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Validation removed.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_all_validations(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Executed", "All validations run. Check logs.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_validations()


########################################################
# WHAT-IF TEST TAB
########################################################

class WhatIfTestTab(QWidget):
    """
    Enhanced What‑If Test Tab.

    Features:
      • Provides an inline test data editor (using QTableWidget) for manual entry.
      • Buttons to add rows, clear data, generate random test data, or upload CSV.
      • On clicking "Run Dry‑Run," the test data from the editor is converted to CSV and used
        for simulation.

    This component replaces your previous WhatIfTestTab and is designed to be future‑ready,
    interactive, and user‑friendly.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.csv_path = None  # Used if a CSV is uploaded
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)

        # Top: Rule selection
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        try:
            c = self.connection.cursor()
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rid, rn in c.fetchall():
                self.rule_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading rules: {ex}")
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)
        main_layout.addLayout(top_layout)

        # Test Data Editor Section
        editor_layout = QVBoxLayout()
        editor_label = QLabel("Test Data Editor: Enter sample data below (editable grid):")
        editor_layout.addWidget(editor_label)

        # Create a table widget as an inline test data editor (default 5 rows x 3 columns)
        self.data_table = QTableWidget(5, 3)
        self.data_table.setHorizontalHeaderLabels(["Column 1", "Column 2", "Column 3"])
        self.data_table.horizontalHeader().setStretchLastSection(True)
        self.data_table.verticalHeader().setVisible(True)
        self.data_table.setEditTriggers(QtWidgets.QAbstractItemView.AllEditTriggers)
        editor_layout.addWidget(self.data_table)

        # Buttons for the test data editor
        btn_layout = QHBoxLayout()
        add_row_btn = QPushButton("Add Row")
        add_row_btn.clicked.connect(self.add_row)
        btn_layout.addWidget(add_row_btn)

        clear_btn = QPushButton("Clear Data")
        clear_btn.clicked.connect(self.clear_data)
        btn_layout.addWidget(clear_btn)

        gen_btn = QPushButton("Generate Random Data")
        gen_btn.clicked.connect(self.generate_random_data)
        btn_layout.addWidget(gen_btn)

        upload_btn = QPushButton("Upload CSV")
        upload_btn.clicked.connect(self.upload_csv)
        btn_layout.addWidget(upload_btn)
        btn_layout.addStretch()
        editor_layout.addLayout(btn_layout)
        main_layout.addLayout(editor_layout)

        # Run Simulation Button and Result Display
        action_layout = QHBoxLayout()
        run_btn = QPushButton("Run Dry‑Run")
        run_btn.clicked.connect(self.run_simulation)
        action_layout.addWidget(run_btn)
        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        main_layout.addWidget(self.result_text)

        self.setLayout(main_layout)

    def add_row(self):
        current_rows = self.data_table.rowCount()
        self.data_table.insertRow(current_rows)

    def clear_data(self):
        self.data_table.clearContents()

    def generate_random_data(self):
        """Populate the test data editor with random integers between 1 and 100."""
        rows = self.data_table.rowCount()
        cols = self.data_table.columnCount()
        for i in range(rows):
            for j in range(cols):
                rand_val = random.randint(1, 100)
                self.data_table.setItem(i, j, QTableWidgetItem(str(rand_val)))

    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if path:
            self.csv_path = path
            try:
                with open(path, newline="", encoding="utf-8") as csvfile:
                    reader = csv.reader(csvfile)
                    data = list(reader)
                    if data:
                        self.data_table.setRowCount(len(data))
                        self.data_table.setColumnCount(len(data[0]))
                        self.data_table.setHorizontalHeaderLabels(
                            [f"Col {i + 1}" for i in range(len(data[0]))]
                        )
                        for i, row in enumerate(data):
                            for j, cell in enumerate(row):
                                self.data_table.setItem(i, j, QTableWidgetItem(cell))
                QMessageBox.information(self, "CSV Loaded", f"CSV data loaded from {path}.")
            except Exception as ex:
                QMessageBox.critical(self, "Error", f"Failed to load CSV: {ex}")

    def get_test_data_csv(self):
        """
        Extracts the contents of the test data editor and converts them to a CSV string.
        """
        rows = self.data_table.rowCount()
        cols = self.data_table.columnCount()
        output = io.StringIO()
        writer = csv.writer(output)
        for i in range(rows):
            row_data = []
            for j in range(cols):
                item = self.data_table.item(i, j)
                row_data.append(item.text() if item else "")
            writer.writerow(row_data)
        return output.getvalue()

    def run_simulation(self):
        """
        Runs a dry-run simulation of the selected rule using the test data.
        If inline test data exists, it is used; if not, then (if available) CSV-uploaded data is used;
        otherwise, the standard simulation (without test data) is executed.
        """
        rid = self.rule_combo.currentData()
        try:
            c = self.connection.cursor()
            c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            row = c.fetchone()
            if not row:
                self.result_text.setPlainText("Rule not found.")
                return
            rule_sql, op_type, dt_id = row
            # First, check if inline editor has test data
            test_data_csv = self.get_test_data_csv()
            if test_data_csv.strip():
                ok, msg, rec_count = dry_run_rule_sql(self.connection, rule_sql, test_data_csv)
            elif self.csv_path:
                # Fallback: load CSV-uploaded data if any
                with open(self.csv_path, newline="", encoding="utf-8") as f:
                    reader = csv.reader(f)
                    data = list(reader)
                    test_data_csv = "\n".join([",".join(row) for row in data])
                ok, msg, rec_count = dry_run_rule_sql(self.connection, rule_sql, test_data_csv)
            else:
                # No test data provided; perform a normal dry-run
                if op_type.upper() == "DECISION_TABLE":
                    ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
                else:
                    ok, msg = dry_run_rule_sql(self.connection, rule_sql)
                    rec_count = 0
            result_str = f"Rule {rid} => PASS={ok}\nMessage:\n{msg}\nRecords={rec_count}"
            self.result_text.setPlainText(result_str)
            QMessageBox.information(self, "Dry‑Run Simulation", result_str)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))



# -------------------------------
# Advanced Audit Log Viewer
# -------------------------------
class AuditLogViewer(QDialog):
    """
    Advanced Audit Log Viewer that displays the BRM_AUDIT_LOG table with search and export options.
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs – Advanced Viewer")
        self.resize(950, 650)
        layout = QVBoxLayout(self)

        # Filter controls
        filter_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action, Table, or Actor...")
        self.search_edit.textChanged.connect(self.perform_search)
        filter_layout.addWidget(QLabel("Search:"))
        filter_layout.addWidget(self.search_edit)
        layout.addLayout(filter_layout)

        # Table display
        self.log_table = QTableWidget(0, 8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID", "Action", "Table", "RecordID", "ActionBy", "OldData", "NewData", "Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        # Export buttons
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_layout.addWidget(refresh_btn)
        export_csv_btn = QPushButton("Export CSV")
        export_csv_btn.clicked.connect(lambda: self.export_logs("csv"))
        btn_layout.addWidget(export_csv_btn)
        export_json_btn = QPushButton("Export JSON")
        export_json_btn.clicked.connect(lambda: self.export_logs("json"))
        btn_layout.addWidget(export_json_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                       OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
                FROM BRM_AUDIT_LOG
                ORDER BY ACTION_TIMESTAMP DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.log_table.rowCount()
                self.log_table.insertRow(r_idx)
                for col in range(8):
                    val = row[col]
                    if col in (5, 6) and val:
                        try:
                            parsed = json.loads(val)
                            val = json.dumps(parsed, indent=2)
                        except Exception as e:
                            pass
                    self.log_table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def perform_search(self, text):
        text = text.lower()
        for row in range(self.log_table.rowCount()):
            visible = any(
                self.log_table.item(row, col) and text in self.log_table.item(row, col).text().lower()
                for col in (1, 2, 4)
            )
            self.log_table.setRowHidden(row, not visible)

    def export_logs(self, fmt="csv"):
        path, _ = QFileDialog.getSaveFileName(self, "Export Logs", "", "All Files (*)")
        if not path:
            return
        row_count = self.log_table.rowCount()
        col_count = self.log_table.columnCount()
        headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(col_count)]
        data = [headers]
        for row in range(row_count):
            if self.log_table.isRowHidden(row):
                continue
            row_data = []
            for col in range(col_count):
                item = self.log_table.item(row, col)
                row_data.append(item.text() if item else "")
            data.append(row_data)
        try:
            if fmt == "csv":
                with open(path, "w", newline="", encoding="utf-8") as f:
                    csv.writer(f).writerows(data)
                QMessageBox.information(self, "Exported", f"Logs exported as CSV to {path}.")
            elif fmt == "json":
                dict_data = [dict(zip(headers, row)) for row in data[1:]]
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(dict_data, f, indent=2)
                QMessageBox.information(self, "Exported", f"Logs exported as JSON to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Export Error", str(ex))


# -------------------------------
# Advanced Rule Search Dialog
# -------------------------------
class RuleSearchDialog(QDialog):
    """
    Provides advanced real-time rule search.
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Advanced Rule Search")
        self.resize(850, 550)
        layout = QVBoxLayout(self)

        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter rule name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)

        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["RuleID", "RuleName", "SQL", "Status", "Version", "CreatedBy"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_results)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        self.res_table.setRowCount(0)
        search_text = self.search_edit.text().strip()
        c = self.connection.cursor()
        try:
            if search_text:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                    FROM BRM_RULES
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """, (f"%{search_text}%", f"%{search_text}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """)
            for row in c.fetchall():
                r_idx = self.res_table.rowCount()
                self.res_table.insertRow(r_idx)
                for col, val in enumerate(row):
                    self.res_table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


# -------------------------------
# Version History Dialog
# -------------------------------
class VersionHistoryDialog(QDialog):
    """
    Displays version history for a rule (using audit log data), provides a line-by-line diff, and supports rollback.
    """

    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id}")
        self.resize(920, 600)
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["AuditID", "Action", "Timestamp", "OldData", "NewData", "Diff"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.do_rollback)
        btn_layout.addWidget(rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
                FROM BRM_AUDIT_LOG
                WHERE TABLE_NAME='BRM_RULES'
                  AND RECORD_ID=?
                  AND ACTION IN ('INSERT','UPDATE')
                ORDER BY ACTION_TIMESTAMP DESC
            """, (self.rule_id,))
            for row in c.fetchall():
                r_idx = self.table.rowCount()
                self.table.insertRow(r_idx)
                self.table.setItem(r_idx, 0, QTableWidgetItem(str(row[0])))
                self.table.setItem(r_idx, 1, QTableWidgetItem(str(row[1])))
                self.table.setItem(r_idx, 2, QTableWidgetItem(str(row[2])))
                old_data = row[3] or ""
                new_data = row[4] or ""
                try:
                    old_data = json.dumps(json.loads(old_data), indent=2)
                except:
                    pass
                try:
                    new_data = json.dumps(json.loads(new_data), indent=2)
                except:
                    pass
                self.table.setItem(r_idx, 3, QTableWidgetItem(old_data))
                self.table.setItem(r_idx, 4, QTableWidgetItem(new_data))
                diff_btn = QPushButton("Show Diff")
                diff_btn.clicked.connect(lambda _, idx=r_idx: self.show_diff(idx))
                self.table.setCellWidget(r_idx, 5, diff_btn)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def show_diff(self, row_index):
        old_item = self.table.item(row_index, 3)
        new_item = self.table.item(row_index, 4)
        if not old_item or not new_item:
            QMessageBox.warning(self, "No Data", "Missing data for diff.")
            return
        old_lines = old_item.text().splitlines()
        new_lines = new_item.text().splitlines()
        diff = difflib.unified_diff(old_lines, new_lines, fromfile="Old", tofile="New", lineterm="")
        diff_text = "\n".join(list(diff))
        diff_dlg = QDialog(self)
        diff_dlg.setWindowTitle("Line-by-Line Diff")
        diff_dlg.resize(850, 650)
        vbox = QVBoxLayout(diff_dlg)
        diff_edit = QPlainTextEdit()
        diff_edit.setReadOnly(True)
        diff_edit.setPlainText(diff_text if diff_text.strip() else "No differences.")
        vbox.addWidget(diff_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(diff_dlg.accept)
        vbox.addWidget(close_btn)
        diff_dlg.exec_()

    def do_rollback(self):
        selected = self.table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a version to rollback.")
            return
        row_index = selected[0].row()
        old_item = self.table.item(row_index, 3)
        if not old_item or not old_item.text().strip():
            QMessageBox.warning(self, "Empty Data", "Selected version has no rollback data.")
            return
        confirm = QMessageBox.question(self, "Confirm Rollback", "Rollback to this version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_item.text())
        except Exception as ex:
            QMessageBox.critical(self, "JSON Error", str(ex))
            return
        self.apply_rollback(old_data)
        QMessageBox.information(self, "Rolled Back", "Rollback applied.")
        self.load_history()

    def apply_rollback(self, old_data):
        rule_id = old_data.get("RULE_ID")
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        if not c.fetchone():
            raise ValueError("Rule not found; cannot rollback.")
        new_sql = old_data.get("RULE_SQL", "")
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("""
                UPDATE BRM_RULES
                SET RULE_NAME=?,
                    RULE_SQL=?,
                    OWNER_GROUP=?,
                    STATUS='INACTIVE',
                    VERSION=VERSION+1,
                    UPDATED_BY='Rollback',
                    APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
                WHERE RULE_ID=?
            """, (old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rule_id))
            c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
            parse_info = parse_sql_dependencies(new_sql)
            col_op = "WRITE" if detect_operation_type(new_sql).upper() in ("INSERT", "UPDATE", "DELETE") else "READ"
            for tb in parse_info["tables"]:
                c.execute("""
                    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                      RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                    )
                    VALUES(?,?,?,?,?)
                """, (rule_id, "dbo", tb, "RolledBackCol", col_op))
            c.execute("COMMIT")
        except Exception as ex:
            c.execute("ROLLBACK")
            raise ex


# -------------------------------
# Rule Dashboard (Paginated)
# -------------------------------
class RuleDashboard(QGroupBox):
    """
    A paginated dashboard for displaying rules with advanced search and filtering.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL...")
        self.search_edit.textChanged.connect(self.load_rules)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)

        main_layout.addLayout(top_h)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "Name", "SQL", "Status", "Version", "OwnerGroup",
            "CreatedTS", "ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        nav_h.addStretch()
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.load_rules()

    def build_filter_clause(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st_val = self.status_filter.currentData()
        if st_val:
            filters.append("STATUS=?")
            params.append(st_val)
        return (" AND ".join(filters) if filters else "1=1", params)

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_clause()
        try:
            c.execute(f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}", params)
            total = c.fetchone()[0]
            self.total_pages = max(1, math.ceil(total / self.records_per_page))
            if self.current_page > self.total_pages:
                self.current_page = self.total_pages
            self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
            offset = (self.current_page - 1) * self.records_per_page
            c.execute(f"""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
                       CREATED_TIMESTAMP, APPROVAL_STATUS
                FROM BRM_RULES
                WHERE {clause}
                ORDER BY RULE_ID DESC
                OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
            """, (*params, offset, self.records_per_page))
            rows = c.fetchall()
            self.rule_table.setRowCount(0)
            for row in rows:
                r_idx = self.rule_table.rowCount()
                self.rule_table.insertRow(r_idx)
                for col, val in enumerate(row):
                    item = QTableWidgetItem(str(val) if val else "")
                    if col == 3:
                        if str(val).upper() == "ACTIVE":
                            item.setBackground(QColor(144, 238, 144))
                        else:
                            item.setBackground(QColor(255, 182, 193))
                    self.rule_table.setItem(r_idx, col, item)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def update_selected_rule_id(self):
        items = self.rule_table.selectedItems()
        if items:
            self.selected_rule_id = int(self.rule_table.item(items[0].row(), 0).text())
        else:
            self.selected_rule_id = None

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()


# -------------------------------
# Multi-Step Approval Helper
# -------------------------------
def create_multistep_approvals(conn, rule_id, actor):
    """
    Creates multi-step approval records for the specified rule.
    This function can be extended to determine approval routing dynamically.
    """
    c = conn.cursor()
    try:
        required_stages = BRM_CONFIG.get("REQUIRED_APPROVAL_STAGES", 2)
        for stage in range(1, required_stages + 1):
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, APPROVAL_STAGE, USERNAME, APPROVED_FLAG, REQUEST_TIMESTAMP)
                VALUES(?, ?, ?, ?, 0, GETDATE())
            """, (rule_id, "ApproverGroup", stage, "ApproverUser"))
        conn.commit()
        logger.info(f"Multi-step approvals created for rule {rule_id} by {actor}.")
    except Exception as ex:
        logger.error(f"Error creating multi-step approvals for rule {rule_id}: {ex}")



# ----------------------------------------------------------------------
# Multi-Step Approval Tab (Enhanced for Parallel Approvals)
# ----------------------------------------------------------------------
class MultiStepApprovalTab(QWidget):
    """
    Displays pending approval requests for the logged-in user.
    Approvals are grouped by stage, so that parallel approvals for a given stage are shown together.
    Also shows a placeholder visual pipeline.
    """

    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.approvals_tree = QTreeWidget()
        self.approvals_tree.setHeaderLabels(["RuleID", "Group", "Rule Name", "Stage", "Status"])
        self.approvals_tree.setSelectionMode(QAbstractItemView.SingleSelection)
        layout.addWidget(self.approvals_tree)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        btn_layout.addWidget(refresh_btn)
        layout.addLayout(btn_layout)

        # Visual pipeline placeholder (could be replaced with an actual flow diagram)
        self.pipeline_label = QLabel("Approval Pipeline: [Stage 1 -> Stage 2 -> Final]\n(Current stage highlighted)")
        self.pipeline_label.setStyleSheet("background-color: #FFFACD; padding: 6px;")
        layout.addWidget(self.pipeline_label)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approvals_tree.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, GROUP_NAME, APPROVAL_STAGE, APPROVED_FLAG, R.LOCKED_BY, R.RULE_NAME
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
                ORDER BY APPROVAL_STAGE
            """, (self.logged_in_username,))
            rows = c.fetchall()
            stage_groups = defaultdict(list)
            for rule_id, group_name, stage, approved_flag, locked_by, rule_name in rows:
                stage_groups[stage].append({
                    "rule_id": rule_id,
                    "group": group_name,
                    "rule_name": rule_name,
                    "locked": bool(locked_by)
                })
            for stage in sorted(stage_groups.keys()):
                stage_item = QTreeWidgetItem([f"Stage {stage}", "", "", "", ""])
                stage_item.setForeground(0, QBrush(QColor("blue")))
                self.approvals_tree.addTopLevelItem(stage_item)
                for appr in stage_groups[stage]:
                    status = "Locked" if appr["locked"] else "Pending"
                    child = QTreeWidgetItem([
                        str(appr["rule_id"]),
                        appr["group"],
                        appr["rule_name"],
                        str(stage),
                        status
                    ])
                    stage_item.addChild(child)
            self.approvals_tree.expandAll()
        except Exception as ex:
            QMessageBox.critical(self, "Approval Load Error", str(ex))

    # Placeholder methods (actual UI actions could trigger these)
    def do_approve(self, rule_id, comment=""):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (comment, rule_id, self.logged_in_username))
            c.execute("""
                SELECT COUNT(*) FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """, (rule_id,))
            if c.fetchone()[0] == 0:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                    WHERE RULE_ID=?
                """, (rule_id,))
            self.connection.commit()
            logger.info(f"Rule {rule_id} approved by {self.logged_in_username}.")
        except Exception as ex:
            QMessageBox.critical(self, "Approval Error", str(ex))

    def do_reject(self, rule_id, comment=""):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (comment, rule_id, self.logged_in_username))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """, (rule_id,))
            self.connection.commit()
            logger.info(f"Rule {rule_id} rejected by {self.logged_in_username}.")
        except Exception as ex:
            QMessageBox.critical(self, "Rejection Error", str(ex))

    def do_forceunlock(self, rule_id):
        if self.user_group != "Admin":
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
            self.connection.commit()
            logger.info(f"Rule {rule_id} forcibly unlocked by Admin.")
        except Exception as ex:
            QMessageBox.critical(self, "Force Unlock Error", str(ex))


# ----------------------------------------------------------------------
# Global Critical Admin Tab (Enhanced)
# ----------------------------------------------------------------------
class GlobalCriticalAdminTab(QWidget):
    """
    Admin‑only interface to manage global‑critical rules.
      – Force activate/deactivate rules.
      – Manage global‑critical links.
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)

        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin Only"))
            self.setLayout(layout)
            return

        self.rule_tree = QTreeWidget()
        self.rule_tree.setHeaderLabels(["RuleID", "Rule Name", "Owner Group", "Status"])
        layout.addWidget(self.rule_tree)
        refresh_btn = QPushButton("Refresh Rule List")
        refresh_btn.clicked.connect(self.load_rule_list)
        layout.addWidget(refresh_btn)

        link_layout = QHBoxLayout()
        self.gcr_parent_combo = QComboBox()
        self.gcr_child_combo = QComboBox()
        link_layout.addWidget(QLabel("Parent GCR:"))
        link_layout.addWidget(self.gcr_parent_combo)
        link_layout.addWidget(QLabel("Child Rule:"))
        link_layout.addWidget(self.gcr_child_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_layout.addWidget(link_btn)
        link_layout.addWidget(unlink_btn)
        layout.addLayout(link_layout)

        self.link_tree = QTreeWidget()
        self.link_tree.setHeaderLabels(["Parent GCR", "Child Rule"])
        layout.addWidget(self.link_tree)

        self.setLayout(layout)
        self.refresh_all()

    def load_rule_list(self):
        self.rule_tree.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, STATUS
                FROM BRM_RULES
                WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                ORDER BY RULE_ID DESC
            """)
            for row in c.fetchall():
                item = QTreeWidgetItem([str(row[0]), row[1], row[2], row[3]])
                self.rule_tree.addTopLevelItem(item)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1 ORDER BY RULE_ID")
            for rid, name in c.fetchall():
                self.gcr_parent_combo.addItem(f"{rid} - {name}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rid, name in c.fetchall():
                self.gcr_child_combo.addItem(f"{rid} - {name}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def load_link_view(self):
        self.link_tree.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
            for row in c.fetchall():
                item = QTreeWidgetItem([str(row[0]), str(row[1])])
                self.link_tree.addTopLevelItem(item)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def link_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Both parent and child must be selected.")
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID) VALUES(?,?)",
                      (parent_id, child_id))
            insert_audit_log(self.connection, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_id}->{child_id}",
                             "Admin", None, {"parent": parent_id, "child": child_id})
            self.connection.commit()
            QMessageBox.information(self, "Linked", "Child rule linked to parent GCR rule.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def unlink_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Both parent and child must be selected.")
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",
                      (parent_id, child_id))
            insert_audit_log(self.connection, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_id}->{child_id}",
                             "Admin", {"parent": parent_id, "child": child_id}, None)
            self.connection.commit()
            QMessageBox.information(self, "Unlinked", "Child rule unlinked from parent GCR rule.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


# ----------------------------------------------------------------------
# Hierarchy View Tab (Drag-and-Drop Reparenting)
# ----------------------------------------------------------------------
class HierarchyViewTab(QTreeWidget):
    """
    Displays a hierarchical tree of rule groups and rules.
    Supports drag-and-drop reparenting and updates the database accordingly.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setHeaderLabels(["Group / Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        self.group_map = {}
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
            for gid, gname in c.fetchall():
                item = QTreeWidgetItem([f"{gname} (ID={gid})"])
                item.setData(0, Qt.UserRole, ("group", gid))
                self.addTopLevelItem(item)
                self.group_map[gid] = item
            c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
            rule_data = {}
            for rid, rn, grp_id, par_id in c.fetchall():
                rule_data[rid] = {"name": rn, "group_id": grp_id, "parent_id": par_id}
            self.rule_items = {}
            for rid, data in rule_data.items():
                if not data["parent_id"]:
                    if data["group_id"] in self.group_map:
                        item = QTreeWidgetItem([f"Rule {rid}: {data['name']}"])
                        item.setData(0, Qt.UserRole, ("rule", rid))
                        self.group_map[data["group_id"]].addChild(item)
                        self.rule_items[rid] = item
            for rid, data in rule_data.items():
                if data["parent_id"]:
                    parent_item = self.rule_items.get(data["parent_id"])
                    if parent_item:
                        item = QTreeWidgetItem([f"Rule {rid}: {data['name']}"])
                        item.setData(0, Qt.UserRole, ("rule", rid))
                        parent_item.addChild(item)
                        self.rule_items[rid] = item
            self.expandAll()
        except Exception as ex:
            QMessageBox.critical(self, "Hierarchy Load Error", str(ex))

    def dropEvent(self, event):
        super().dropEvent(event)
        self.update_database_reparenting()
        self.load_hierarchy()

    def update_database_reparenting(self):
        c = self.connection.cursor()
        for i in range(self.topLevelItemCount()):
            grp_item = self.topLevelItem(i)
            grp_data = grp_item.data(0, Qt.UserRole)
            if grp_data and grp_data[0] == "group":
                group_id = grp_data[1]
                for j in range(grp_item.childCount()):
                    child_item = grp_item.child(j)
                    self.recursive_update(child_item, None, group_id, c)
        c.commit()

    def recursive_update(self, item, parent_rule_id, group_id, cursor):
        data = item.data(0, Qt.UserRole)
        if data and data[0] == "rule":
            rid = data[1]
            try:
                cursor.execute("""
                    UPDATE BRM_RULES
                    SET PARENT_RULE_ID=?, GROUP_ID=?, STATUS='INACTIVE', APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                        UPDATED_BY='HierarchyDragDrop', VERSION=VERSION+1
                    WHERE RULE_ID=?
                """, (parent_rule_id, group_id, rid))
            except Exception as ex:
                logger.error(f"Error reparenting rule {rid}: {ex}")
            for i in range(item.childCount()):
                self.recursive_update(item.child(i), rid, group_id, cursor)


class LayeredLineageWidget(QGraphicsView):
    """
    A QGraphicsView that displays metadata lineage with:
      • Force-directed horizontal layout,
      • 'Layers' pinned by y-axis,
      • Color-coded node fill by type or status,
      • Red border or highlight if 'critical' or 'global'.
    """

    def __init__(self, lineage_nodes, lineage_edges, parent=None):
        """
        :param lineage_nodes: list of dict, e.g. [
            {
              "id": 101,
              "label": "Rule: Fraud Check",
              "type": "DATA_VALIDATION",         # or "TRANSFORMATION" / "MOVE" etc.
              "status": "ACTIVE",                # or "INACTIVE"
              "layer": "SOURCING",               # or "INTEGRATION"/"CURATION"
              "critical": True,                  # optional
              "global": False,                   # optional
              "tooltip": "some optional info"
            },
            ...
        ]
        :param lineage_edges: list of dict, e.g. [
            {"source_id": 101, "target_id": 202, "relation": "READS"},
            ...
        ]
        """
        super().__init__(parent)
        self.lineage_nodes = lineage_nodes
        self.lineage_edges = lineage_edges

        self.scene = QGraphicsScene()
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

        # Timer for the horizontal force layout
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_forces)
        self.timer.start(30)

        # Node + Edge storage
        self.nodes = {}   # node_id -> NodeItem
        self.edges = []

        # Build the scene
        self.setup_scene()

        # Zoom factor
        self.zoom_factor = 1.01

    def setup_scene(self):
        """Create items and place them in the scene."""
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()

        # 1) Create NodeItem
        for node_data in self.lineage_nodes:
            nid = node_data["id"]
            item = NodeItem(node_data)
            # We'll do random X, but Y is pinned by 'layer'
            x_rand = random.randint(50, 700)
            y_fixed = layer_to_y(node_data.get("layer", "SOURCING"))  # see function below
            item.setPos(x_rand, y_fixed)
            self.scene.addItem(item)
            self.nodes[nid] = item

        # 2) Create EdgeItem
        for e in self.lineage_edges:
            s_id = e["source_id"]
            t_id = e["target_id"]
            rel = e.get("relation", "")
            if s_id in self.nodes and t_id in self.nodes:
                edge_item = ArrowEdgeItem(self.nodes[s_id], self.nodes[t_id], rel)
                self.scene.addItem(edge_item)
                self.edges.append(edge_item)

    def update_forces(self):
        """
        We'll only do a 'horizontal' force layout:
          - We fix each node's Y to the pinned layer Y,
          - We only let them move along X to spread out.
        """
        # Force parameters
        repulsion = 9000.0
        spring_length = 130.0
        spring_strength = 0.08
        damping = 0.85

        # zero out forces
        node_list = list(self.nodes.values())
        for n in node_list:
            n.force = QPointF(0, 0)

        # pairwise repulsion (X dimension)
        for i in range(len(node_list)):
            for j in range(i+1, len(node_list)):
                a = node_list[i]
                b = node_list[j]
                # Only compute horizontal difference if they're in same layer:
                if a.layer_y == b.layer_y:
                    delta_x = a.x() - b.x()
                    dist_x = abs(delta_x)
                    dist_x = max(1.0, dist_x)
                    # repulsive force in X only
                    force_mag = repulsion / (dist_x * dist_x)
                    sign = 1 if delta_x > 0 else -1
                    fx = force_mag * sign
                    a.force += QPointF(fx, 0)
                    b.force -= QPointF(fx, 0)

        # edges -> spring forces
        for edge_item in self.edges:
            a = edge_item.source
            b = edge_item.dest
            # only in X dimension
            dx = a.x() - b.x()
            dist_x = max(1.0, abs(dx))
            displacement = dist_x - spring_length
            force_mag = spring_strength * displacement
            sign = 1 if dx > 0 else -1
            fx = force_mag * sign
            a.force -= QPointF(fx, 0)
            b.force += QPointF(fx, 0)

        # integrate velocity, respecting pinned Y
        for n in node_list:
            n.velocity = (n.velocity + n.force * 0.1) * damping
            new_x = n.x() + n.velocity.x()
            # keep Y fixed to layer
            new_y = n.layer_y
            n.setPos(new_x, new_y)

        # update edges
        for e in self.edges:
            e.updatePosition()

    def wheelEvent(self, event):
        factor = self.zoom_factor if event.angleDelta().y() > 0 else 1.0 / self.zoom_factor
        self.scale(factor, factor)

def layer_to_y(layer_name):
    """
    Simple function mapping layer strings to certain Y coords.
    """
    layer_map = {
        "SOURCING":  100,
        "INTEGRATION": 250,
        "CURATION": 400,
        "PRESENTATION": 550
    }
    return layer_map.get(layer_name.upper(), 100)

class NodeItem(QGraphicsEllipseItem):
    """
    A node that color-codes by 'type' or 'status',
    can highlight if 'critical' or 'global',
    and pins Y based on 'layer'.
    """

    def __init__(self, node_data, radius=35):
        super().__init__(-radius, -radius, radius*2, radius*2)
        self.data = node_data
        self.radius = radius
        self.setFlags(
            QGraphicsItem.ItemIsMovable |
            QGraphicsItem.ItemIsSelectable |
            QGraphicsItem.ItemSendsGeometryChanges
        )
        self.velocity = QPointF(0, 0)
        self.force = QPointF(0, 0)

        # layer pinned Y
        self.layer_y = layer_to_y(node_data.get("layer", "SOURCING"))

        # fill color depends on 'type'
        self.setBrush(self.color_for_type(node_data.get("type", ""), node_data.get("status", "ACTIVE")))
        # pen/border highlight if critical or global
        pen = QPen(Qt.darkGray)
        pen.setWidth(2)
        if node_data.get("critical", False) or node_data.get("global", False):
            # e.g. use red or orange border
            pen.setColor(QColor("#ff6666"))  # a bright color
            pen.setWidth(3)
        self.setPen(pen)

        # label
        label_text = node_data.get("label", f"Node {node_data.get('id')}")
        self.text_item = QGraphicsTextItem(label_text, self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setFont(QFont("Arial", 9, QFont.Bold))
        # center text
        text_rect = self.text_item.boundingRect()
        self.text_item.setPos(-text_rect.width()/2, -text_rect.height()/2)

        # tooltip
        tt = node_data.get("tooltip", "")
        if not tt:
            # build a default tooltip
            lines = [
                f"ID: {node_data['id']}",
                f"Type: {node_data.get('type', '')}",
                f"Status: {node_data.get('status', '')}",
                f"Layer: {node_data.get('layer','')}"
            ]
            if node_data.get("critical"):
                lines.append("CRITICAL = True")
            if node_data.get("global"):
                lines.append("GLOBAL = True")
            tt = "\n".join(lines)
        self.setToolTip(tt)

    def color_for_type(self, rule_type, status):
        """
        Return a pastel color brush based on 'type' or fallback to a status color.
        """
        # Could do a combined map. For simplicity, let's map 'type' to color:
        type_color_map = {
            "DATA_VALIDATION": "#a2d5f2",  # pastel blue
            "TRANSFORMATION":  "#ffc9de", # pastel pink
            "MOVE":            "#d7f9db", # pastel green
            # fallback
            "OTHER":           "#f9f7d9"
        }
        # If not found, fallback to a “status” color or "OTHER"
        c = type_color_map.get(rule_type.upper(), type_color_map["OTHER"])
        return QBrush(QColor(c))

    def itemChange(self, change, value):
        """
        If position changes, edges re-draw. We do not let Y float (the BFS layout logic pins it).
        """
        # If we wanted to forcibly keep Y pinned, we could do it here as well.
        return super().itemChange(change, value)

class ArrowEdgeItem(QGraphicsLineItem):
    """
    Pastel arrow connecting two nodes. Optionally label with relation name.
    """

    def __init__(self, source, dest, relation="", parent=None):
        super().__init__(parent)
        self.source = source
        self.dest = dest
        self.relation = relation
        self.arrow_size = 10

        pastel_pen = QPen(QColor("#bbb1fa"), 2)  # pastel lavender
        self.setPen(pastel_pen)
        self.updatePosition()

    def updatePosition(self):
        line = QLineF(self.source.pos(), self.dest.pos())
        self.setLine(line)
        self.prepareGeometryChange()

    def paint(self, painter, option, widget):
        line = self.line()
        if line.length() == 0:
            return
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setPen(self.pen())
        painter.drawLine(line)

        # arrowhead
        angle = math.atan2(-line.dy(), line.dx())
        arrow_p1 = line.p2() - QPointF(
            math.cos(angle + math.pi / 6) * self.arrow_size,
            -math.sin(angle + math.pi / 6) * self.arrow_size
        )
        arrow_p2 = line.p2() - QPointF(
            math.cos(angle - math.pi / 6) * self.arrow_size,
            -math.sin(angle - math.pi / 6) * self.arrow_size
        )
        arrow_head = QPolygonF([line.p2(), arrow_p1, arrow_p2])
        painter.setBrush(self.pen().color())
        painter.drawPolygon(arrow_head)

# ----------------------------------------------------------------------
# Metrics Dashboard Tab
# ----------------------------------------------------------------------
class MetricsDashboardTab(QWidget):
    """
    Displays operational and performance metrics using pyqtgraph.
    It shows:
      - A bar chart of rule counts by status.
      - A line chart of performance trending (e.g. average execution time and total usage).
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        # Horizontal layout for charts
        charts_layout = QHBoxLayout()
        # Bar chart: Rule counts by status
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        charts_layout.addWidget(self.status_chart)

        # Line chart: Performance trend over last 30 days
        self.perf_chart = pg.PlotWidget(title="Performance Trend (Avg Exec Time & Usage)")
        self.perf_chart.setBackground('w')
        charts_layout.addWidget(self.perf_chart)

        layout.addLayout(charts_layout)

        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        try:
            # Bar chart: Count of rules by status
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows = c.fetchall()
            statuses = [row[0] for row in rows]
            counts = [row[1] for row in rows]
            self.status_chart.clear()
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left", "Count")
            self.status_chart.setLabel("bottom", "Status")
            self.status_chart.showGrid(x=True, y=True)

            # Line chart: Performance trending (average execution time and total usage)
            c.execute("""
                SELECT DATE_KEY, AVG(EXECUTION_TIME_MS) AS avg_time, SUM(USAGE_COUNT) AS total_usage
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY,-30,GETDATE()),112)
                GROUP BY DATE_KEY
                ORDER BY DATE_KEY ASC
            """)
            perf_rows = c.fetchall()
            self.perf_chart.clear()
            if perf_rows:
                x_vals = list(range(len(perf_rows)))
                avg_times = [r[1] for r in perf_rows]
                usage_counts = [r[2] for r in perf_rows]
                self.perf_chart.plot(x_vals, avg_times, pen=pg.mkPen('r', width=2), name="Avg Exec Time (ms)")
                self.perf_chart.plot(x_vals, usage_counts, pen=pg.mkPen('b', width=2), name="Total Usage")
                self.perf_chart.setLabel("bottom", "Time Index (Last 30 Days)")
                self.perf_chart.setLabel("left", "Value")
                self.perf_chart.showGrid(x=True, y=True)
        except Exception as ex:
            QMessageBox.critical(self, "Metrics Error", str(ex))


# ----------------------------------------------------------------------
# Control Tables Tab
# ----------------------------------------------------------------------
class CtrlTablesTab(QWidget):
    """
    Provides a viewer for control/reference tables.
    Admin users can edit the data (double-click to edit), while non-admin users have read-only access.
    """

    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        # Define a list of control tables
        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES", "BRM_RULE_GROUPS",
            "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG", "BRM_RULE_LINEAGE",
            "BRM_COLUMN_MAPPING", "BRM_CUSTOM_GROUP_MEMBERS", "BRM_GLOBAL_CRITICAL_LINKS",
            "RULE_SCHEDULES", "BRM_RULE_COMMENTS", "DECISION_TABLES", "RULE_CONFLICTS",
            "COMPOSITE_RULES", "RULE_SNAPSHOTS", "RULE_TAGS", "DATA_VALIDATIONS",
            "RULE_EXECUTION_LOGS", "RULE_PERF_STATS", "BRM_RULE_APPROVALS"
        ]
        self.tbl_combo = QComboBox()
        for t in self.table_list:
            self.tbl_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table = QTableWidget(0, 0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        if self.user_group != "Admin":
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def load_data(self):
        table_name = self.tbl_combo.currentText()
        if not table_name:
            return
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {table_name}")
            colnames = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error retrieving columns from {table_name}: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {table_name}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading data from {table_name}: {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            r_idx = self.data_table.rowCount()
            self.data_table.insertRow(r_idx)
            for i, val in enumerate(row):
                self.data_table.setItem(r_idx, i, QTableWidgetItem(str(val) if val is not None else ""))


class TableStageManagerTab(QWidget):
    """
    Allows an admin to view all known tables, see their assigned pipeline stage,
    and update that stage (SOURCING, INTEGRATION, CURATION, etc.).
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)

        # If the user is not Admin, block
        if self.user_group != "Admin":
            layout.addWidget(QtWidgets.QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.stage_table = QTableWidget(0, 3)
        self.stage_table.setHorizontalHeaderLabels(["TableName", "Stage", "Description"])
        self.stage_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.stage_table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_data)
        btn_layout.addWidget(refresh_btn)
        update_btn = QPushButton("Update Stage")
        update_btn.clicked.connect(self.update_stage)
        btn_layout.addWidget(update_btn)
        add_btn = QPushButton("Add Table")
        add_btn.clicked.connect(self.add_table)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        """
        Query BRM_TABLE_METADATA (or BRM_TABLES) to display current pipeline stages.
        """
        self.stage_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            # If you store stage in BRM_TABLE_METADATA:
            c.execute("""
                SELECT TABLE_NAME, PIPELINE_STAGE, DESCRIPTION
                FROM BRM_TABLE_METADATA
                ORDER BY TABLE_NAME
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.stage_table.rowCount()
                self.stage_table.insertRow(r_idx)
                # fill columns
                for col_i, val in enumerate(row):
                    item = QTableWidgetItem(str(val if val else ""))
                    self.stage_table.setItem(r_idx, col_i, item)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def update_stage(self):
        """
        Prompt user to pick a new stage for the selected row, then update in DB.
        """
        row = self.stage_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "No Selection", "No table selected.")
            return
        table_name = self.stage_table.item(row, 0).text().strip()
        # Could prompt user for a stage from a known list:
        stages = ["SOURCING", "INTEGRATION", "CURATION", "PRESENTATION"]
        current_stage = self.stage_table.item(row, 1).text()
        stage, ok = QInputDialog.getItem(self, "Select Stage",
                                         f"New stage for {table_name}:",
                                         stages,
                                         stages.index(current_stage) if current_stage in stages else 0,
                                         False)
        if not ok:
            return

        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_TABLE_METADATA
                SET PIPELINE_STAGE = ?
                WHERE TABLE_NAME = ?
            """, (stage, table_name))
            self.connection.commit()
            QMessageBox.information(self, "Updated",
                                    f"Stage for table '{table_name}' set to '{stage}'.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self, "DB Error", str(ex))

    def add_table(self):
        """
        Insert a new row into BRM_TABLE_METADATA.
        For example, let admin input table name, stage, etc.
        """
        table_name, ok1 = QInputDialog.getText(self, "New Table", "Enter table name:")
        if not ok1 or not table_name.strip():
            return
        # stage
        stages = ["SOURCING", "INTEGRATION", "CURATION", "PRESENTATION"]
        stage, ok2 = QInputDialog.getItem(self, "Stage", "Pick stage:", stages, 0, False)
        if not ok2:
            return
        desc, ok3 = QInputDialog.getText(self, "Description", "Optional description:")
        if not ok3:
            desc = ""

        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_TABLE_METADATA (TABLE_NAME, PIPELINE_STAGE, DESCRIPTION)
                VALUES (?, ?, ?)
            """, (table_name.strip(), stage, desc.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added",
                f"Table '{table_name}' inserted with stage '{stage}'.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self, "DB Error", str(ex))


# ----------------------------------------------------------------------
# Group Management Tab
# ----------------------------------------------------------------------
class GroupManagementTab(QWidget):
    """
    Admin-only interface for managing business groups.
    Provides options to add, rename, and delete groups.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName", "Description", "Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.groups_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Group")
        add_btn.clicked.connect(self.add_group)
        btn_layout.addWidget(add_btn)
        ren_btn = QPushButton("Rename Group")
        ren_btn.clicked.connect(self.rename_group)
        btn_layout.addWidget(ren_btn)
        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        btn_layout.addWidget(del_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
            for r in c.fetchall():
                r_idx = self.groups_table.rowCount()
                self.groups_table.insertRow(r_idx)
                for col, val in enumerate(r):
                    self.groups_table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            return None
        item = self.groups_table.item(row, 0)
        return item.text().strip() if item else None

    def add_group(self):
        gname, ok = QInputDialog.getText(self, "Add Group", "Enter group name:")
        if not ok or not gname.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        email, ok3 = QInputDialog.getText(self, "Email", "Optional email:")
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (gname.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "Group already exists.")
                return
            c.execute("""
                INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL)
                VALUES(?,?,?)
            """, (gname.strip(), desc.strip() if desc else "", email.strip() if email else ""))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Group created.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def rename_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for '{grp}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "New group name already exists.")
                return
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), grp))
            c.execute("COMMIT")
            QMessageBox.information(self, "Renamed", f"Group '{grp}' renamed to '{new_name}'.")
            self.load_groups()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))

    def delete_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{grp}'?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (grp,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group '{grp}' deleted.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


# ----------------------------------------------------------------------
# User Management Tab
# ----------------------------------------------------------------------
class UserManagementTab(QWidget):
    """
    Advanced user management for Admins: add user, delete user, change password.
    This widget can be expanded to support fine‑grained roles/permissions.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["UserID", "Username", "Password", "User Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_layout.addWidget(del_btn)
        chg_btn = QPushButton("Change Password")
        chg_btn.clicked.connect(self.change_password)
        btn_layout.addWidget(chg_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
            for row in c.fetchall():
                r_idx = self.user_table.rowCount()
                self.user_table.insertRow(r_idx)
                for col, val in enumerate(row):
                    self.user_table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_user_id(self):
        items = self.user_table.selectedItems()
        if items:
            try:
                return int(items[0].text())
            except:
                return None
        return None

    def add_user(self):
        un, ok = QInputDialog.getText(self, "Add User", "Enter username:")
        if not ok or not un.strip():
            return
        pw, ok2 = QInputDialog.getText(self, "Add User", "Enter password:")
        if not ok2 or not pw.strip():
            return
        grp, ok3 = QInputDialog.getText(self, "Add User", "Enter User Group (e.g. BG1, Admin):")
        if not ok3 or not grp.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM USERS WHERE USERNAME=?", (un.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "User already exists.")
                return
            c.execute("INSERT INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?,?,?)",
                      (un.strip(), pw.strip(), grp.strip()))
            self.connection.commit()
            insert_audit_log(self.connection, "INSERT", "USERS", None, "Admin", None, {"username": un})
            QMessageBox.information(self, "Added", "User added successfully.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_user(self):
        uid = self.get_selected_user_id()
        if uid is None:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete user with ID {uid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?", (uid,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "USERS", uid, "Admin")
            QMessageBox.information(self, "Deleted", "User deleted successfully.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def change_password(self):
        uid = self.get_selected_user_id()
        if uid is None:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        new_pw, ok = QInputDialog.getText(self, "Change Password", "Enter new password:")
        if not ok or not new_pw.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?", (new_pw.strip(), uid))
            self.connection.commit()
            insert_audit_log(self.connection, "UPDATE", "USERS", uid, "Admin", None, {"password_changed": True})
            QMessageBox.information(self, "Updated", "Password updated successfully.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


# ----------------------------------------------------------------------
# Advanced ACL Manager for Fine-Grained Access Control (ABAC Ready)
# ----------------------------------------------------------------------
class ACLManager:
    """
    ACLManager provides advanced functions for checking fine-grained permissions.
    This implementation is a placeholder and should be extended to incorporate:
      - Attribute‑based access control (ABAC)
      - Contextual evaluation (e.g., time, location, device)
      - Integration with a detailed ROLE_PERMISSIONS and USER_ATTRIBUTES tables.
    """

    def __init__(self, conn):
        self.conn = conn

    def get_user_attributes(self, user_id):
        """
        Retrieve additional user attributes from a hypothetical table (e.g., USER_ATTRIBUTES).
        Expected columns: USER_ID, DEPARTMENT, CLEARANCE_LEVEL, TIMEZONE, etc.
        For demonstration, return a dummy dict.
        """
        # In a real implementation, you might query:
        # SELECT DEPARTMENT, CLEARANCE_LEVEL, ... FROM USER_ATTRIBUTES WHERE USER_ID=?
        # Here we return sample attributes.
        return {
            "department": "Finance",
            "clearance": 3,
            "timezone": "UTC",
            "access_hours": (8, 18)  # allowed between 8:00 and 18:00 local time
        }

    def get_role_permissions(self, user_group, resource, action):
        """
        Retrieve permissions from a hypothetical ROLE_PERMISSIONS table.
        Expected columns: USER_GROUP, RESOURCE, ACTION, ALLOWS (Boolean), CONDITIONS (JSON)
        For demonstration, we return a dummy value.
        """
        # In a real system, you might execute:
        # SELECT ALLOWS, CONDITIONS FROM ROLE_PERMISSIONS WHERE USER_GROUP=? AND RESOURCE=? AND ACTION=?
        # For now, return a dummy rule: non-admin users are allowed 'VIEW' and 'SIMULATE' only.
        if user_group == "Admin":
            return {"allows": True, "conditions": {}}
        if action in ("VIEW", "SIMULATE"):
            return {"allows": True, "conditions": {}}
        # Example: additional conditions could require clearance level >= 3, etc.
        return {"allows": False, "conditions": {}}

    def advanced_check_user_permission(self, user_id, action, resource, extra_context=None):
        """
        Check if the user is permitted to perform an action on a resource using an advanced ACL approach.

        Parameters:
          user_id      - ID of the user.
          action       - Action being performed (e.g., 'EDIT_RULE', 'EXECUTE').
          resource     - Resource identifier (e.g., rule name, table name).
          extra_context- Optional dictionary for additional context (e.g., current time, IP address).

        Returns:
          Boolean value: True if permitted, False otherwise.
        """
        try:
            c = self.conn.cursor()
            # Basic retrieval of user group; assumes USERS table has a USER_GROUP column.
            c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
            row = c.fetchone()
            if not row:
                logger.warning(f"ACL check: User {user_id} not found.")
                return False
            user_group = row[0]
            # Admin always allowed
            if user_group == "Admin":
                return True

            # Retrieve additional user attributes (for ABAC)
            user_attrs = self.get_user_attributes(user_id)
            # Retrieve role permissions for this group/resource/action
            role_perm = self.get_role_permissions(user_group, resource, action)
            if not role_perm.get("allows", False):
                logger.warning(f"ACL denied: user_group {user_group} not allowed {action} on {resource}")
                return False

            # Example of additional contextual checks:
            if extra_context and "current_time" in extra_context:
                current_hour = extra_context["current_time"].hour
            else:
                current_hour = datetime.utcnow().hour
            allowed_start, allowed_end = user_attrs.get("access_hours", (0, 24))
            if not (allowed_start <= current_hour < allowed_end):
                logger.warning(
                    f"ACL denied: current time {current_hour} not in allowed hours {allowed_start}-{allowed_end}")
                return False

            # Additional conditions can be evaluated here based on role_perm["conditions"]
            # For now, if we passed the above checks, we allow.
            logger.debug(f"ACL granted: user {user_id} in group {user_group} allowed {action} on {resource}.")
            return True
        except Exception as ex:
            logger.error(f"Advanced ACL check error for user {user_id}: {ex}")
            return False


# ----------------------------------------------------------------------
# Advanced AIOps Anomaly Detection Functions
# ----------------------------------------------------------------------
def detect_rule_execution_anomalies_advanced(conn, days=7):
    """
    Advanced anomaly detection in rule executions.
    This function queries the RULE_EXECUTION_LOGS table, computes the average and standard deviation
    for execution time and failure rates over the past 'days' days, and flags rules that are statistical outliers.

    Parameters:
      conn - Database connection.
      days - Look-back period in days.

    Returns:
      A list of anomalies as tuples: (rule_id, anomaly_description).

    Future Enhancements:
      - Integrate with a machine learning model for time-series forecasting.
      - Use advanced statistical tests or clustering to identify anomalies.
    """
    anomalies = []
    c = conn.cursor()
    try:
        # Retrieve execution times and failure flags per rule for the given period.
        c.execute("""
            SELECT RULE_ID,
                   EXECUTION_TIME_MS,
                   CASE WHEN PASS_FLAG = 0 THEN 1 ELSE 0 END AS failed
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -?, GETDATE())
        """, (days,))
        results = c.fetchall()
        # Organize data per rule
        data = {}
        for rule_id, exec_time, failed in results:
            data.setdefault(rule_id, {"times": [], "failures": []})
            data[rule_id]["times"].append(exec_time)
            data[rule_id]["failures"].append(failed)

        # Process each rule: compute mean and std deviation; flag if outlier
        for rule_id, metrics in data.items():
            times = metrics["times"]
            failures = metrics["failures"]
            if not times:
                continue
            mean_time = sum(times) / len(times)
            if len(times) > 1:
                std_time = statistics.stdev(times)
            else:
                std_time = 0
            # Compute failure rate
            fail_rate = sum(failures) / len(failures)
            # Determine thresholds (these values can be tuned or computed dynamically)
            exec_time_threshold = mean_time + (2 * std_time) if std_time > 0 else mean_time * 1.5
            # Flag anomalies based on failure rate and execution time
            if fail_rate > 0.2:
                anomalies.append((rule_id, f"High failure rate: {fail_rate * 100:.1f}%"))
            if mean_time > exec_time_threshold:
                anomalies.append(
                    (rule_id, f"Avg exec time {mean_time:.0f} ms exceeds threshold {exec_time_threshold:.0f} ms"))
        logger.debug(f"Advanced anomaly detection found: {anomalies}")
        return anomalies
    except Exception as ex:
        logger.error(f"Error in advanced anomaly detection: {ex}")
        return anomalies


def auto_heal_or_escalate_advanced(conn, anomalies):
    """
    For each detected anomaly, attempt to auto-heal or log for escalation.

    If a rule shows signs of a stale lock or similar easily auto-healable condition,
    attempt to clear the lock. Otherwise, log the anomaly for further manual escalation.

    Parameters:
      conn      - Database connection.
      anomalies - List of anomalies as returned by detect_rule_execution_anomalies_advanced.
    """
    c = conn.cursor()
    for rule_id, reason in anomalies:
        try:
            if "stale" in reason.lower():
                # Auto-unlock stale locks
                c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
                insert_audit_log(conn, "AUTO_HEAL_UNLOCK", "BRM_RULE_LOCKS", rule_id, "System", None,
                                 {"reason": reason})
                conn.commit()
                logger.info(f"Auto-healed stale lock for rule {rule_id}: {reason}")
            else:
                # For more complex anomalies, log for escalation (or trigger alerts)
                logger.warning(f"Escalate anomaly for rule {rule_id}: {reason}")
        except Exception as ex:
            logger.error(f"Failed to auto-heal anomaly for rule {rule_id}: {ex}")


# ----------------------------------------------------------------------
# Advanced Rule Editor Dialog
# ----------------------------------------------------------------------
class RuleEditorDialog(QtWidgets.QDialog):
    """
    A single-page dialog for adding or updating a rule.

    Features:
      • Real-time SQL validation (pink if empty, yellow if unknown, green if valid).
      • Duplicate rule check by name (if adding new).
      • Permission check before saving (via ACLManager).
      • Insert/Update in BRM_RULES, logs audit, triggers multi-step approvals.
      • Optional 'Global' checkbox if user is admin.
      • 'Approval Mode' combo (Serial/Parallel).
      • 'Owner Group' combo loaded from DB or placeholders.

    Parameters:
      connection       - The active DB connection
      user_group       - The group of current user
      current_user_id  - The integer ID of the user
      rule_data        - (Optional) dict with existing data if updating
    """

    def __init__(self, connection, user_group, current_user_id, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.current_user_id = current_user_id
        self.rule_data = rule_data  # If provided => update mode
        self.is_update = (rule_data is not None)

        self.setWindowTitle("Update Rule" if self.is_update else "Add Rule")
        self.resize(800, 700)

        self.init_ui()
        if self.is_update:
            self.load_existing()

    def init_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        # 1) Rule Name
        self.name_edit = QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        # 2) Rule SQL
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("Enter SQL here (must return 1 or 0)...")
        self.sql_edit.textChanged.connect(self.live_validate_sql)
        form_layout.addRow("Rule SQL:", self.sql_edit)

        # 3) Description
        self.desc_edit = QTextEdit()
        form_layout.addRow("Description:", self.desc_edit)

        # 4) Justification
        self.just_edit = QTextEdit()
        form_layout.addRow("Justification:", self.just_edit)

        # 5) Status
        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE", "ACTIVE"])  # default choices
        form_layout.addRow("Status:", self.status_combo)

        # 6) Owner Group
        self.group_combo = QComboBox()
        self.load_group_list()  # DB or placeholders
        form_layout.addRow("Owner Group:", self.group_combo)

        # 7) Approval Mode
        self.approval_mode_combo = QComboBox()
        self.approval_mode_combo.addItems(["Serial", "Parallel"])
        form_layout.addRow("Approval Mode:", self.approval_mode_combo)

        # 8) Global checkbox (only if user is Admin)
        if self.user_group == "Admin":
            self.global_cb = QCheckBox("Global Rule?")
            form_layout.addRow("Global:", self.global_cb)
        else:
            self.global_cb = None

        layout.addLayout(form_layout)

        # Buttons (Save / Cancel)
        btn_layout = QHBoxLayout()
        self.save_btn = QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        btn_layout.addWidget(self.save_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addStretch()

        layout.addLayout(btn_layout)
        self.setLayout(layout)

    # ----------------------------------------------------------------
    #  Load Owner Groups into combo (placeholder or real DB call)
    # ----------------------------------------------------------------
    def load_group_list(self):
        """
        In real usage, query from DB:
            SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID
        For now, we demonstrate a mock approach.
        """
        self.group_combo.clear()
        # Example mock data or real DB data
        # c = self.connection.cursor()
        # c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        # for gid, gname in c.fetchall():
        #     self.group_combo.addItem(gname, gid)

        # For demonstration:
        data = [
            (1, "Finance"),
            (2, "Operations"),
            (3, "IT"),
            (999, "Admin")
        ]
        for (gid, gname) in data:
            self.group_combo.addItem(f"{gname} (ID={gid})", gid)

    # ----------------------------------------------------------------
    #  Real-time SQL Validation
    # ----------------------------------------------------------------
    def live_validate_sql(self):
        sql_text = self.sql_edit.toPlainText().strip()
        op_type = detect_operation_type(sql_text)  # your existing function
        if not sql_text:
            # Pink for empty
            self.sql_edit.setStyleSheet("background-color: #FFC0CB;")
        elif op_type == "OTHER":
            # Yellow for unknown
            self.sql_edit.setStyleSheet("background-color: #FFFACD;")
        else:
            # Green for valid (SELECT/INSERT/UPDATE/DELETE)
            self.sql_edit.setStyleSheet("background-color: #CCFFCC;")

    # ----------------------------------------------------------------
    #  If updating, load fields from self.rule_data
    # ----------------------------------------------------------------
    def load_existing(self):
        rd = self.rule_data
        self.name_edit.setText(rd.get("RULE_NAME", ""))
        self.sql_edit.setPlainText(rd.get("RULE_SQL", ""))

        self.desc_edit.setPlainText(rd.get("DESCRIPTION", ""))
        self.just_edit.setPlainText(rd.get("BUSINESS_JUSTIFICATION", ""))

        status = rd.get("STATUS", "INACTIVE")
        idx_st = self.status_combo.findText(status)
        if idx_st >= 0:
            self.status_combo.setCurrentIndex(idx_st)

        # group
        owner_group = rd.get("OWNER_GROUP")  # e.g. "Finance" or numeric group ID
        if owner_group:
            # If your DB actually stores numeric group_id, we can find that in combo
            idx_g = self.group_combo.findData(owner_group)
            if idx_g >= 0:
                self.group_combo.setCurrentIndex(idx_g)
            else:
                # fallback if not found
                pass

        # global
        if self.user_group == "Admin" and self.global_cb:
            self.global_cb.setChecked(rd.get("IS_GLOBAL", 0) == 1)

        # approval mode
        app_mode = rd.get("APPROVAL_MODE", "Serial")
        idx_ap = self.approval_mode_combo.findText(app_mode)
        if idx_ap >= 0:
            self.approval_mode_combo.setCurrentIndex(idx_ap)

    # ----------------------------------------------------------------
    #  Final save logic
    # ----------------------------------------------------------------
    def save_rule(self):
        # 1) gather fields
        rule_name = self.name_edit.text().strip()
        sql_text = self.sql_edit.toPlainText().strip()
        description = self.desc_edit.toPlainText().strip()
        justification = self.just_edit.toPlainText().strip()
        status = self.status_combo.currentText()
        owner_group_id = self.group_combo.currentData()  # numeric group_id from .setItemData
        approval_mode = self.approval_mode_combo.currentText()
        is_global = 0
        if self.user_group == "Admin" and self.global_cb and self.global_cb.isChecked():
            is_global = 1

        # 2) basic validation
        if not rule_name:
            QMessageBox.warning(self, "Validation Error", "Rule name is required.")
            return
        if not sql_text:
            QMessageBox.warning(self, "Validation Error", "SQL is required.")
            return

        # 3) ACL check
        #  (make sure user can actually do 'EDIT_RULE' on this rule name)
        acl_mgr = ACLManager(self.connection)  # your existing ACL manager
        if not acl_mgr.advanced_check_user_permission(self.current_user_id, "EDIT_RULE", rule_name):
            QMessageBox.critical(self, "Permission Denied", "You are not allowed to edit this rule.")
            return

        c = self.connection.cursor()

        # 4) if new rule, check duplicates
        if not self.is_update:
            c.execute("SELECT RULE_ID FROM BRM_RULES WHERE LOWER(RULE_NAME)=LOWER(?)", (rule_name,))
            if c.fetchone():
                QMessageBox.warning(self, "Duplicate Rule", "A rule with this name already exists.")
                return

        # 5) parse operation type from the SQL (used for dependencies, etc.)
        op_type = detect_operation_type(sql_text)

        # Prepare a dict for auditing or re-check
        new_rule = {
            "RULE_NAME": rule_name,
            "RULE_SQL": sql_text,
            "DESCRIPTION": description,
            "BUSINESS_JUSTIFICATION": justification,
            "STATUS": status,
            "OWNER_GROUP": owner_group_id,
            "APPROVAL_MODE": approval_mode,
            "IS_GLOBAL": is_global,
            "OPERATION_TYPE": op_type
        }

        # 6) Insert or update
        try:
            if self.is_update and "RULE_ID" in self.rule_data:
                # update
                rid = self.rule_data["RULE_ID"]
                new_rule["RULE_ID"] = rid

                c.execute("""
                    UPDATE BRM_RULES
                    SET RULE_NAME=?,
                        RULE_SQL=?,
                        DESCRIPTION=?,
                        BUSINESS_JUSTIFICATION=?,
                        STATUS=?,
                        OWNER_GROUP=?,
                        APPROVAL_MODE=?,
                        IS_GLOBAL=?,
                        OPERATION_TYPE=?,
                        UPDATED_BY='RuleEditorDialog',
                        VERSION=VERSION+1,
                        APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
                    WHERE RULE_ID=?
                """, (
                    new_rule["RULE_NAME"],
                    new_rule["RULE_SQL"],
                    new_rule["DESCRIPTION"],
                    new_rule["BUSINESS_JUSTIFICATION"],
                    new_rule["STATUS"],
                    new_rule["OWNER_GROUP"],
                    new_rule["APPROVAL_MODE"],
                    new_rule["IS_GLOBAL"],
                    new_rule["OPERATION_TYPE"],
                    rid
                ))

            else:
                # insert
                c.execute("""
                    INSERT INTO BRM_RULES(
                        RULE_NAME, RULE_SQL, DESCRIPTION, BUSINESS_JUSTIFICATION,
                        STATUS, OWNER_GROUP, APPROVAL_MODE, IS_GLOBAL, OPERATION_TYPE,
                        CREATED_TIMESTAMP, UPDATED_BY, VERSION, APPROVAL_STATUS
                    )
                    OUTPUT inserted.RULE_ID
                    VALUES(?,?,?,?,?,?,?,?,?,?,?,1,'APPROVAL_IN_PROGRESS')
                """, (
                    new_rule["RULE_NAME"],
                    new_rule["RULE_SQL"],
                    new_rule["DESCRIPTION"],
                    new_rule["BUSINESS_JUSTIFICATION"],
                    new_rule["STATUS"],
                    new_rule["OWNER_GROUP"],
                    new_rule["APPROVAL_MODE"],
                    new_rule["IS_GLOBAL"],
                    new_rule["OPERATION_TYPE"],
                    datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "RuleEditorDialog"
                ))
                rid = c.fetchone()[0]
                new_rule["RULE_ID"] = rid

            # 7) commit changes
            self.connection.commit()

            # 8) Insert an audit log
            insert_audit_log(
                self.connection,
                "UPDATE" if self.is_update else "INSERT",
                "BRM_RULES",
                new_rule["RULE_ID"],
                "CurrentUser",  # or self.current_user_id
                None,
                new_rule
            )

            # 9) Initiate multi-step approvals
            create_multistep_approvals(self.connection, new_rule["RULE_ID"], "CurrentUser")

            QMessageBox.information(self, "Success", "Rule saved. Approval process started.")
            self.accept()

        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error Saving Rule", str(ex))

# ----------------------------------------------------------------------
#  BFS Execution & Conflict Resolution
# ----------------------------------------------------------------------
def load_rule_relationships_extended(conn):

    adjacency = defaultdict(list)
    conflicts = []
    composites = []
    global_links = []
    try:
        c = conn.cursor()
        # Parent-child from BRM_RULES
        c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
        for rid, pid in c.fetchall():
            if pid:
                adjacency[pid].append(rid)
        # Conflicts from RULE_CONFLICTS (two-way)
        c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
        for r1, r2 in c.fetchall():
            conflicts.append((r1, r2))
            adjacency[r1].append(r2)
            adjacency[r2].append(r1)
        # Global-critical links from BRM_GLOBAL_CRITICAL_LINKS
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        for p, cid in c.fetchall():
            global_links.append((p, cid))
            adjacency[p].append(cid)
        # Composite references from COMPOSITE_RULES (using regex to find 'Rule<number>')
        c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
        import re
        for comp_id, expr in c.fetchall():
            if expr:
                matches = re.findall(r'Rule(\d+)', expr)
                for m in matches:
                    try:
                        sub_rule = int(m)
                        composites.append((sub_rule, comp_id))
                        adjacency[sub_rule].append(comp_id)
                    except:
                        continue
        return adjacency, conflicts
    except Exception as ex:
        logger.error(f"Error loading extended relationships: {ex}")
        return {}, []


def extended_bfs_execute(conn, start_rule_id, handle_conflicts=True):
    """
    Perform a breadth-first execution starting from start_rule_id using the extended
    relationships. If a rule execution fails and the rule is critical or global, skip its descendants.

    Returns:
      List of executed rule IDs.
    """
    adjacency, conflicts = load_rule_relationships_extended(conn)
    visited = set()
    queue = [start_rule_id]
    executed = []
    c = conn.cursor()

    while queue:
        rid = queue.pop(0)
        if rid in visited:
            continue
        visited.add(rid)
        # Check conflicts: if any conflict exists with an already executed rule, skip this rule.
        if handle_conflicts:
            for (r1, r2) in conflicts:
                if (r1 == rid and r2 in executed) or (r2 == rid and r1 in executed):
                    logger.info(f"Skipping rule {rid} due to conflict with executed rule.")
                    continue
        # Execute the rule (using run_single_rule_in_transaction from Part 2)
        rule_info = {"RULE_ID": rid}
        # For simplicity, assume rule_info contains at least RULE_SQL and OPERATION_TYPE from BRM_RULES.
        c.execute(
            "SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID, CRITICAL_RULE, IS_GLOBAL FROM BRM_RULES WHERE RULE_ID=?",
            (rid,))
        row = c.fetchone()
        if not row:
            logger.warning(f"Rule {rid} not found.")
            continue
        rule_info["RULE_SQL"], rule_info["OPERATION_TYPE"], rule_info["DECISION_TABLE_ID"], rule_info["CRITICAL_RULE"], \
        rule_info["IS_GLOBAL"] = row
        ok, msg, rec_count = run_single_rule_in_transaction(conn, rule_info, is_dry_run=False)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)
        if ok:
            executed.append(rid)
            # Enqueue children
            for child in adjacency.get(rid, []):
                if child not in visited:
                    queue.append(child)
        else:
            # If rule is critical/global, skip descendants (placeholder logic)
            if rule_info.get("CRITICAL_RULE") or rule_info.get("IS_GLOBAL"):
                logger.info(f"Rule {rid} failed and is critical/global. Skipping its descendants.")
                # Mark all descendants as visited
                stack = [rid]
                while stack:
                    current = stack.pop()
                    visited.add(current)
                    stack.extend(adjacency.get(current, []))
    return executed


# ----------------------------------------------------------------------
# Advanced Search & Filtering
# ----------------------------------------------------------------------
def advanced_rule_search(conn, keywords=None, status_filter=None, date_from=None, date_to=None, critical_scope=None,
                         table_ref=None):
    """
    Perform an advanced multi-criteria search on BRM_RULES.

    Parameters:
      keywords      - Search terms for rule name or SQL.
      status_filter - Filter by rule status.
      date_from     - Start date for updated timestamp.
      date_to       - End date for updated timestamp.
      critical_scope- Filter by CRITICAL_SCOPE.
      table_ref     - Filter for rules referencing a specific table (via dependencies).

    Returns:
      List of matching rows.

    Future Enhancements:
      - Save search queries (e.g., store query parameters in a SAVED_SEARCHES table).
    """
    c = conn.cursor()
    clauses = []
    params = []
    if keywords:
        clauses.append("(LOWER(RULE_NAME) LIKE ? OR LOWER(RULE_SQL) LIKE ?)")
        params.extend([f"%{keywords.lower()}%", f"%{keywords.lower()}%"])
    if status_filter:
        clauses.append("STATUS = ?")
        params.append(status_filter)
    if date_from:
        clauses.append("UPDATED_TIMESTAMP >= ?")
        params.append(date_from)
    if date_to:
        clauses.append("UPDATED_TIMESTAMP <= ?")
        params.append(date_to)
    if critical_scope:
        clauses.append("CRITICAL_SCOPE = ?")
        params.append(critical_scope)

    query = "SELECT RULE_ID, RULE_NAME, STATUS, UPDATED_TIMESTAMP FROM BRM_RULES"
    if clauses:
        query += " WHERE " + " AND ".join(clauses)
    query += " ORDER BY RULE_ID DESC OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY"

    # If filtering by table reference, join with BRM_RULE_TABLE_DEPENDENCIES
    if table_ref:
        query = f"""
        SELECT R.RULE_ID, R.RULE_NAME, R.STATUS, R.UPDATED_TIMESTAMP
        FROM BRM_RULES R
        JOIN BRM_RULE_TABLE_DEPENDENCIES D ON R.RULE_ID = D.RULE_ID
        WHERE D.TABLE_NAME LIKE ?
        {"AND " + " AND ".join(clauses) if clauses else ""}
        ORDER BY R.RULE_ID DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """
        params.insert(0, f"%{table_ref}%")

    try:
        c.execute(query, params)
        return c.fetchall()
    except Exception as ex:
        logger.error(f"Advanced search error: {ex}")
        return []


# ----------------------------------------------------------------------
# Optional Extended ACL Manager (Placeholder Extension)
# ----------------------------------------------------------------------
class ExtendedACLManager:
    """
    An optional extended ACL manager that builds upon the basic ACLManager.
    This class can evaluate additional conditions (e.g., user clearance level, department)
    and resource-specific policies for fine-grained access.
    """

    def __init__(self, conn):
        self.conn = conn

    def check_permission(self, user_id, action, resource, extra_context=None):
        # For demonstration, call the basic ACL check and then extend with extra conditions.

        basic_acl = ACLManager(self.conn)
        allowed = basic_acl.advanced_check_user_permission(user_id, action, resource, extra_context)
        # Placeholder for extra checks – e.g., verify if user's clearance level meets a threshold.
        # For now, simply return the result of the basic check.
        return allowed


# ----------------------------------------------------------------------
# 4. Onboarding Wizard Integration
# ----------------------------------------------------------------------
class OnboardingWizard(QDialog):
    """
    A simple onboarding wizard that prompts the new user with introductory information.
    Once completed, it marks onboarding as complete in the database.
    """
    def __init__(self, conn, user_id, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.user_id = user_id
        self.setWindowTitle("Welcome to BRM – Onboarding")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        info_label = QLabel("Welcome to the Business Rules Manager (BRM) system!\n\n"
                            "Please review the following guidelines and complete the onboarding steps.")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        self.complete_btn = QPushButton("Complete Onboarding")
        self.complete_btn.clicked.connect(self.complete_onboarding)
        layout.addWidget(self.complete_btn)
        self.setLayout(layout)

    def complete_onboarding(self):
        try:
            c = self.conn.cursor()
            # Placeholder update – assume USERS table has an ONBOARDING_COMPLETED flag.
            c.execute("UPDATE USERS SET ONBOARDING_COMPLETED=1 WHERE USER_ID=?", (self.user_id,))  # Replace 1 with actual user ID.
            self.conn.commit()
            QMessageBox.information(self, "Onboarding Complete", "Thank you! Onboarding is now complete.")
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Failed to complete onboarding: {ex}")


def launch_onboarding_wizard(conn, user_id):
    """
    Check if the user has completed onboarding; if not, launch the onboarding wizard.
    """
    c = conn.cursor()
    try:
        c.execute("SELECT ONBOARDING_COMPLETED FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if not row or not row[0]:
            wizard = OnboardingWizard(conn)
            wizard.exec_()
    except Exception as ex:
        logger.error(f"Error checking onboarding: {ex}")


# ----------------------------------------------------------------------
# Snapshot Compare / Diff Wizard
# ----------------------------------------------------------------------
class SnapshotDiffWizard(QDialog):
    """
    A dialog that allows the user to compare two snapshots (or snapshot vs. current state)
    and view a unified diff.
    """

    def __init__(self, conn, parent=None):
        super().__init__(parent)
        self.conn = conn
        self.setWindowTitle("Snapshot Compare / Diff Wizard")
        self.resize(900, 600)
        layout = QVBoxLayout(self)
        h_layout = QHBoxLayout()
        self.snap_combo1 = QComboBox()
        self.snap_combo2 = QComboBox()
        h_layout.addWidget(QLabel("Snapshot A:"))
        h_layout.addWidget(self.snap_combo1)
        h_layout.addWidget(QLabel("Snapshot B:"))
        h_layout.addWidget(self.snap_combo2)
        layout.addLayout(h_layout)
        self.diff_edit = QPlainTextEdit()
        self.diff_edit.setReadOnly(True)
        layout.addWidget(self.diff_edit)
        btn_layout = QHBoxLayout()
        compare_btn = QPushButton("Compare")
        compare_btn.clicked.connect(self.compare_snapshots)
        btn_layout.addWidget(compare_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.populate_snapshots()

    def populate_snapshots(self):
        c = self.conn.cursor()
        try:
            c.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
            snapshots = c.fetchall()
            # Add a special option for current state
            self.snap_combo1.addItem("(Current)", -1)
            self.snap_combo2.addItem("(Current)", -1)
            for snap_id, snap_name in snapshots:
                display = f"{snap_id} - {snap_name}"
                self.snap_combo1.addItem(display, snap_id)
                self.snap_combo2.addItem(display, snap_id)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_snapshot_data(self, snap_id):
        c = self.conn.cursor()
        if snap_id < 0:
            # Get current state from BRM_RULES
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            return [dict(zip(colnames, row)) for row in rows]
        else:
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            row = c.fetchone()
            if row and row[0]:
                return json.loads(row[0])
            return []

    def compare_snapshots(self):
        id1 = self.snap_combo1.currentData()
        id2 = self.snap_combo2.currentData()
        try:
            data1 = self.get_snapshot_data(id1)
            data2 = self.get_snapshot_data(id2)
            text1 = json.dumps(data1, indent=2).splitlines()
            text2 = json.dumps(data2, indent=2).splitlines()
            diff = difflib.unified_diff(text1, text2, fromfile="SnapshotA", tofile="SnapshotB", lineterm="")
            diff_text = "\n".join(diff)
            if not diff_text.strip():
                diff_text = "No differences found."
            self.diff_edit.setPlainText(diff_text)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


# ----------------------------------------------------------------------
# Heatmap Generation for Advanced Metrics
# ----------------------------------------------------------------------
def generate_time_of_day_heatmap_data(conn):
    """
    Generate a 7x24 matrix representing, for each day of the week and each hour,
    the number of rule executions (or failure counts) for the last 30 days.

    Returns:
      A list of 7 lists (one per day), each with 24 integer counts.
    """
    matrix = [[0 for _ in range(24)] for _ in range(7)]
    c = conn.cursor()
    try:
        c.execute("""
            SELECT DATEPART(WEEKDAY, EXECUTION_TIMESTAMP) - 1 AS weekday,
                   DATEPART(HOUR, EXECUTION_TIMESTAMP) AS hour,
                   COUNT(*) AS count
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
            GROUP BY DATEPART(WEEKDAY, EXECUTION_TIMESTAMP), DATEPART(HOUR, EXECUTION_TIMESTAMP)
        """)
        for weekday, hour, count in c.fetchall():
            # Adjust weekday index as needed (here, 0–6)
            matrix[weekday % 7][hour] = count
        return matrix
    except Exception as ex:
        logger.error(f"Error generating heatmap data: {ex}")
        return matrix


# ----------------------------------------------------------------------
# Enhanced Collaboration Tab with Threaded Replies & @Mentions
# ----------------------------------------------------------------------
# (This builds on your previous CollaborationTab; here we add a simple threaded reply mechanism)
from PyQt5.QtWidgets import QListWidget, QListWidgetItem, QLineEdit


class EnhancedCollaborationTab(QWidget):
    """
    An enhanced collaboration tab that displays messages with threading support.
    It detects @username mentions and allows replying to individual messages.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.messages_list = QListWidget()
        layout.addWidget(self.messages_list)

        reply_layout = QHBoxLayout()
        self.reply_edit = QLineEdit()
        self.reply_edit.setPlaceholderText("Type a reply or new message (use @username for mentions)...")
        reply_layout.addWidget(self.reply_edit)
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        reply_layout.addWidget(send_btn)
        layout.addLayout(reply_layout)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_messages)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_messages()

        # Timer for periodic refresh (or use signals from a CollaborationManager)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.load_messages)
        self.timer.start(5000)

    def load_messages(self):
        self.messages_list.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT MESSAGE_ID, MESSAGE, SENDER, TIMESTAMP, THREAD_PARENT_ID
                FROM COLLABORATION_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            for msg_id, message, sender, ts, thread_parent in c.fetchall():
                prefix = ""
                if thread_parent:
                    prefix = "[Reply] "
                item_text = f"{prefix}[{ts}] {sender}: {message}"
                item = QListWidgetItem(item_text)
                # Store thread_parent_id for potential threading (None means top-level)
                item.setData(Qt.UserRole, thread_parent)
                self.messages_list.addItem(item)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def send_message(self):
        message = self.reply_edit.text().strip()
        if not message:
            return
        sender = "CurrentUser"  # Replace with current user's identifier
        # For threading, if an item is selected, use its MESSAGE_ID as thread_parent_id.
        selected = self.messages_list.currentItem()
        thread_parent = None
        if selected:
            thread_parent = selected.data(Qt.UserRole)
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COLLABORATION_LOGS(MESSAGE, SENDER, TIMESTAMP, THREAD_PARENT_ID)
                VALUES(?, ?, GETDATE(), ?)
            """, (message, sender, thread_parent))
            self.connection.commit()
            self.reply_edit.clear()
            self.load_messages()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))




# -------------------------------------------------------------
#  Visual Conflict Map Widget
# -------------------------------------------------------------
class VisualConflictMapWidget(QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene()
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.nodes = {}  # rule_id -> ConflictNodeItem
        self.edges = []  # list of ConflictEdgeItem
        self.load_conflict_data()
        self.setup_force_directed()
        self.setMinimumSize(600, 400)
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_layout)
        self.timer.start(30)

    def load_conflict_data(self):
        # Query RULE_CONFLICTS table to obtain conflict pairs and priority.
        self.conflicts = []
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
            for r1, r2, priority in c.fetchall():
                self.conflicts.append((r1, r2, priority))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading conflicts: {ex}")
        # Gather all rule IDs involved.
        rule_ids = set()
        for r1, r2, _ in self.conflicts:
            rule_ids.add(r1)
            rule_ids.add(r2)
        # Get rule info (name and status) from BRM_RULES.
        self.rule_info = {}
        try:
            if rule_ids:
                format_ids = ",".join(str(rid) for rid in rule_ids)
                query = f"SELECT RULE_ID, RULE_NAME, STATUS FROM BRM_RULES WHERE RULE_ID IN ({format_ids})"
                c.execute(query)
                for rid, name, status in c.fetchall():
                    self.rule_info[rid] = {"name": name, "status": status}
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading rule info: {ex}")

    def setup_force_directed(self):
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()
        # Create nodes for each rule
        for rid, info in self.rule_info.items():
            node = ConflictNodeItem(rid, info["name"], info["status"])
            # Start with random positions
            node.setPos(50 + (rid % 10) * 80, 50 + (rid // 10) * 80)
            self.scene.addItem(node)
            self.nodes[rid] = node
        # Create edges for each conflict pair
        for r1, r2, priority in self.conflicts:
            if r1 in self.nodes and r2 in self.nodes:
                edge = ConflictEdgeItem(self.nodes[r1], self.nodes[r2], priority)
                self.scene.addItem(edge)
                self.edges.append(edge)

    def update_layout(self):
        # Simple force-directed layout algorithm.
        repulsion = 5000.0
        spring_length = 150.0
        spring_strength = 0.1
        damping = 0.85
        for node in self.nodes.values():
            node.force = QPointF(0, 0)
        nodes = list(self.nodes.values())
        for i in range(len(nodes)):
            for j in range(i + 1, len(nodes)):
                a, b = nodes[i], nodes[j]
                delta = a.pos() - b.pos()
                dist = max(1.0, math.hypot(delta.x(), delta.y()))
                force = (repulsion / (dist * dist)) * (delta / dist)
                a.force += force
                b.force -= force
        for edge in self.edges:
            delta = edge.source.pos() - edge.dest.pos()
            dist = max(1.0, math.hypot(delta.x(), delta.y()))
            displacement = dist - spring_length
            force = (spring_strength * displacement) * (delta / dist)
            edge.source.force -= force
            edge.dest.force += force
        for node in self.nodes.values():
            velocity = node.velocity + node.force * 0.1
            velocity *= damping
            node.velocity = velocity
            node.setPos(node.pos() + velocity)
        for edge in self.edges:
            edge.updatePosition()


class ConflictNodeItem(QGraphicsEllipseItem):
    def __init__(self, rule_id, name, status, radius=25, parent=None):
        super().__init__(-radius, -radius, radius * 2, radius * 2, parent)
        self.rule_id = rule_id
        self.name = name
        self.status = status
        self.radius = radius
        self.setFlags(
            QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemSendsGeometryChanges)
        self.setBrush(self.get_brush())
        self.setPen(QPen(Qt.black))
        self.force = QPointF(0, 0)
        self.velocity = QPointF(0, 0)
        self.text_item = QGraphicsTextItem(str(rule_id), self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setFont(QFont("Arial", 8))
        self.text_item.setPos(-radius / 2, -radius / 2)

    def get_brush(self):
        if self.status.upper() == "ACTIVE":
            return QBrush(QColor(144, 238, 144))
        elif self.status.upper() == "INACTIVE":
            return QBrush(QColor(255, 182, 193))
        else:
            return QBrush(QColor(200, 200, 200))

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange:
            for item in self.scene().items():
                if isinstance(item, ConflictEdgeItem) and (item.source == self or item.dest == self):
                    item.updatePosition()
        return super().itemChange(change, value)


class ConflictEdgeItem(QGraphicsLineItem):
    def __init__(self, source, dest, priority, parent=None):
        super().__init__(parent)
        self.source = source
        self.dest = dest
        self.priority = priority
        self.arrow_size = 10
        # Color-code edge by priority.
        if self.priority >= 5:
            self.edge_color = QColor(255, 0, 0)  # High priority red
        else:
            self.edge_color = QColor(0, 200, 0)  # Lower priority green
        self.setPen(QPen(self.edge_color, 2))
        self.updatePosition()

    def updatePosition(self):
        line = QLineF(self.source.pos(), self.dest.pos())
        self.setLine(line)
        self.prepareGeometryChange()

    def paint(self, painter, option, widget):
        line = self.line()
        if line.length() == 0:
            return
        painter.setPen(self.pen())
        painter.drawLine(line)
        angle = math.atan2(-line.dy(), line.dx())
        arrow_p1 = line.p2() - QPointF(math.cos(angle + math.pi / 6) * self.arrow_size,
                                       -math.sin(angle + math.pi / 6) * self.arrow_size)
        arrow_p2 = line.p2() - QPointF(math.cos(angle - math.pi / 6) * self.arrow_size,
                                       -math.sin(angle - math.pi / 6) * self.arrow_size)
        arrow_head = QPolygonF([line.p2(), arrow_p1, arrow_p2])
        painter.setBrush(QBrush(self.edge_color))
        painter.drawPolygon(arrow_head)
# -------------------------------------------------------------
#  Conflict Triage Dialog (Voting UI)
# -------------------------------------------------------------
class ConflictTriageDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Conflict Triage")
        self.resize(600, 400)
        layout = QVBoxLayout(self)

        self.conflict_table = QTableWidget(0, 4)
        self.conflict_table.setHorizontalHeaderLabels(["Conflict ID", "Rule 1", "Rule 2", "Your Vote"])
        self.conflict_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.conflict_table)

        vote_btn = QPushButton("Submit Votes")
        vote_btn.clicked.connect(self.submit_votes)
        layout.addWidget(vote_btn)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.conflict_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            for row in c.fetchall():
                r_idx = self.conflict_table.rowCount()
                self.conflict_table.insertRow(r_idx)
                conflict_id, rule1, rule2, priority = row
                self.conflict_table.setItem(r_idx, 0, QTableWidgetItem(str(conflict_id)))
                self.conflict_table.setItem(r_idx, 1, QTableWidgetItem(str(rule1)))
                self.conflict_table.setItem(r_idx, 2, QTableWidgetItem(str(rule2)))
                # Voting combo box: 0=Undecided, 1=Prefer Rule1, 2=Prefer Rule2
                vote_combo = QComboBox()
                vote_combo.addItem("Undecided", 0)
                vote_combo.addItem("Prefer Rule 1", 1)
                vote_combo.addItem("Prefer Rule 2", 2)
                self.conflict_table.setCellWidget(r_idx, 3, vote_combo)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def submit_votes(self):
        c = self.connection.cursor()
        for row in range(self.conflict_table.rowCount()):
            conflict_id = int(self.conflict_table.item(row, 0).text())
            vote_combo = self.conflict_table.cellWidget(row, 3)
            vote = vote_combo.currentData()  # 0, 1, or 2
            try:
                c.execute("""
                    INSERT INTO CONFLICT_TRIAGE(CONFLICT_ID, DECISION, VOTE_COUNT, DECISION_TIMESTAMP)
                    VALUES(?, ?, 1, GETDATE())
                """, (conflict_id, vote))
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
        self.connection.commit()
        QMessageBox.information(self, "Submitted", "Your votes have been recorded.")
        self.load_conflicts()


# -------------------------------------------------------------
# Rollback Preview Dialog
# -------------------------------------------------------------
class RollbackPreviewDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Rollback Preview for Rule {rule_id}")
        self.resize(800, 600)
        layout = QVBoxLayout(self)

        self.diff_text = QPlainTextEdit()
        self.diff_text.setReadOnly(True)
        layout.addWidget(self.diff_text)

        btn_layout = QHBoxLayout()
        load_btn = QPushButton("Load Preview")
        load_btn.clicked.connect(self.load_preview)
        btn_layout.addWidget(load_btn)
        apply_btn = QPushButton("Apply Rollback")
        apply_btn.clicked.connect(self.apply_rollback)
        btn_layout.addWidget(apply_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def load_preview(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT OLD_DATA FROM BRM_AUDIT_LOG
                WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT','UPDATE')
                ORDER BY ACTION_TIMESTAMP DESC
            """, (self.rule_id,))
            row = c.fetchone()
            if row and row[0]:
                old_data = row[0]
                c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (self.rule_id,))
                current_row = c.fetchone()
                if current_row:
                    colnames = [desc[0] for desc in c.description]
                    current_data = dict(zip(colnames, current_row))
                    old_data_dict = json.loads(old_data)
                    diff = difflib.unified_diff(
                        json.dumps(old_data_dict, indent=2).splitlines(),
                        json.dumps(current_data, indent=2).splitlines(),
                        fromfile="Old Version", tofile="Current Version", lineterm=""
                    )
                    diff_text = "\n".join(list(diff))
                    self.diff_text.setPlainText(diff_text if diff_text.strip() else "No differences found.")
                else:
                    self.diff_text.setPlainText("Current rule not found.")
            else:
                self.diff_text.setPlainText("No rollback data available.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def apply_rollback(self):
        c = self.connection.cursor()
        try:
            c.execute(
                "SELECT OLD_DATA FROM BRM_AUDIT_LOG WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? ORDER BY ACTION_TIMESTAMP DESC",
                (self.rule_id,))
            row = c.fetchone()
            if not row or not row[0]:
                QMessageBox.warning(self, "Error", "No rollback data available.")
                return
            old_data = json.loads(row[0])
            self.apply_rollback_changes(old_data)
            QMessageBox.information(self, "Rolled Back", "Rollback applied successfully.")
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def apply_rollback_changes(self, old_data):
        rule_id = old_data.get("RULE_ID")
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        if not c.fetchone():
            raise ValueError("Rule not found; cannot rollback.")
        new_sql = old_data.get("RULE_SQL", "")
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("""
                UPDATE BRM_RULES
                SET RULE_NAME=?,
                    RULE_SQL=?,
                    OWNER_GROUP=?,
                    STATUS='INACTIVE',
                    VERSION=VERSION+1,
                    UPDATED_BY='Rollback',
                    APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
                WHERE RULE_ID=?
            """, (old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rule_id))
            c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
            parse_info = parse_sql_dependencies(new_sql)
            col_op = "WRITE" if detect_operation_type(new_sql).upper() in ("INSERT", "UPDATE", "DELETE") else "READ"
            for tb in parse_info["tables"]:
                c.execute("""
                    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP)
                    VALUES(?,?,?,?,?)
                """, (rule_id, "dbo", tb, "RolledBackCol", col_op))
            c.execute("COMMIT")
        except Exception as ex:
            c.execute("ROLLBACK")
            raise ex


# -------------------------------------------------------------
#  Fail/Pass Trend Widget
# -------------------------------------------------------------
class FailPassTrendWidget(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.plot_widget = pg.PlotWidget(title="Fail/Pass Trends")
        self.plot_widget.setBackground('w')
        layout.addWidget(self.plot_widget)
        refresh_btn = QPushButton("Refresh Trends")
        refresh_btn.clicked.connect(self.load_trends)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_trends()

    def load_trends(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(varchar(10), EXECUTION_TIMESTAMP, 120) AS exec_date,
                       SUM(CASE WHEN PASS_FLAG=1 THEN 1 ELSE 0 END) AS pass_count,
                       SUM(CASE WHEN PASS_FLAG=0 THEN 1 ELSE 0 END) AS fail_count
                FROM RULE_EXECUTION_LOGS
                GROUP BY CONVERT(varchar(10), EXECUTION_TIMESTAMP, 120)
                ORDER BY exec_date
            """)
            data = c.fetchall()
            dates = [row[0] for row in data]
            pass_counts = [row[1] for row in data]
            fail_counts = [row[2] for row in data]
            x_vals = list(range(len(dates)))
            self.plot_widget.clear()
            self.plot_widget.plot(x_vals, pass_counts, pen=pg.mkPen('g', width=2), name="Passes")
            self.plot_widget.plot(x_vals, fail_counts, pen=pg.mkPen('r', width=2), name="Fails")
            self.plot_widget.getAxis("bottom").setTicks([list(zip(x_vals, dates))])
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


# -------------------------------------------------------------
# Graphical Heatmap Widget
# -------------------------------------------------------------
class HeatmapWidget(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.image_view = pg.ImageView()
        layout.addWidget(self.image_view)
        refresh_btn = QPushButton("Refresh Heatmap")
        refresh_btn.clicked.connect(self.load_heatmap)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_heatmap()

    def load_heatmap(self):
        matrix = generate_time_of_day_heatmap_data(self.connection)
        data = np.array(matrix)
        self.image_view.setImage(data, autoLevels=True)
        self.image_view.ui.histogram.hide()
        self.image_view.ui.roiBtn.hide()
        self.image_view.ui.menuBtn.hide()

def generate_time_of_day_heatmap_data(conn):
    matrix = [[0 for _ in range(24)] for _ in range(7)]
    c = conn.cursor()
    try:
        c.execute("""
            SELECT DATEPART(WEEKDAY, EXECUTION_TIMESTAMP) - 1 AS weekday,
                   DATEPART(HOUR, EXECUTION_TIMESTAMP) AS hour,
                   COUNT(*) AS count
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
            GROUP BY DATEPART(WEEKDAY, EXECUTION_TIMESTAMP), DATEPART(HOUR, EXECUTION_TIMESTAMP)
        """)
        for weekday, hour, count in c.fetchall():
            matrix[weekday % 7][hour] = count
        return matrix
    except Exception as ex:
        print("Error generating heatmap data:", ex)
        return matrix

# ----------------------------------------------------------------------
# Advanced Search Widget
# ----------------------------------------------------------------------
class AdvancedSearchWidget(QWidget):


    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        form_layout = QHBoxLayout()
        self.keyword_edit = QtWidgets.QLineEdit()
        self.keyword_edit.setPlaceholderText("Enter keywords...")
        form_layout.addWidget(QtWidgets.QLabel("Keywords:"))
        form_layout.addWidget(self.keyword_edit)
        self.status_combo = QComboBox()
        self.status_combo.addItem("All", None)
        self.status_combo.addItem("ACTIVE", "ACTIVE")
        self.status_combo.addItem("INACTIVE", "INACTIVE")
        form_layout.addWidget(QtWidgets.QLabel("Status:"))
        form_layout.addWidget(self.status_combo)
        search_btn = QPushButton("Search")
        search_btn.clicked.connect(self.perform_search)
        form_layout.addWidget(search_btn)
        layout.addLayout(form_layout)

        self.results_table = QtWidgets.QTableWidget(0, 4)
        self.results_table.setHorizontalHeaderLabels(["RuleID", "Rule Name", "Status", "Updated"])
        layout.addWidget(self.results_table)
        self.setLayout(layout)

    def perform_search(self):
        keywords = self.keyword_edit.text().strip()
        status = self.status_combo.currentData()
        results = advanced_rule_search(self.connection, keywords=keywords, status_filter=status)
        self.results_table.setRowCount(0)
        for row in results:
            r_idx = self.results_table.rowCount()
            self.results_table.insertRow(r_idx)
            for i, val in enumerate(row):
                self.results_table.setItem(r_idx, i, QtWidgets.QTableWidgetItem(str(val)))

# ----------------------------------------------------------------------
# Visual Approval Pipeline Widget
# ----------------------------------------------------------------------
class ApprovalPipelineWidget(QWidget):
    """
    Displays the multi-step approval pipeline graphically.
    Each stage is represented as a node (displaying the stage number and the approvers),
    and arrowed connections link the stages.

     pipeline_data is a list of dictionaries, e.g.:
      [
          {"stage": 1, "approvers": ["UserA", "UserB"], "current": False},
          {"stage": 2, "approvers": ["UserC"], "current": True},
          {"stage": 3, "approvers": ["UserD", "UserE"], "current": False}
      ]
    """

    def __init__(self, pipeline_data, parent=None):
        super().__init__(parent)
        self.pipeline_data = pipeline_data
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        title = QLabel("Approval Pipeline")
        title.setFont(QFont("Arial", 14, QFont.Bold))
        layout.addWidget(title)
        self.view = QtWidgets.QGraphicsView()
        self.scene = QtWidgets.QGraphicsScene(self)
        self.view.setScene(self.scene)
        layout.addWidget(self.view)
        self.setLayout(layout)
        self.draw_pipeline()

    def draw_pipeline(self):
        self.scene.clear()
        node_items = []
        spacing = 150
        x = 20
        y = 20
        # Create a node for each stage
        for stage in self.pipeline_data:
            node = ApprovalStageNode(stage["stage"], stage["approvers"], stage.get("current", False))
            node.setPos(x, y)
            self.scene.addItem(node)
            node_items.append(node)
            x += spacing
        # Draw arrowed connections between consecutive nodes
        for i in range(len(node_items) - 1):
            arrow = PipelineArrow(node_items[i], node_items[i + 1])
            self.scene.addItem(arrow)


class ApprovalStageNode(QtWidgets.QGraphicsItem):


    def __init__(self, stage_number, approvers, current=False, width=120, height=60):
        super().__init__()
        self.stage_number = stage_number
        self.approvers = approvers
        self.current = current
        self.width = width
        self.height = height
        self.setFlags(QtWidgets.QGraphicsItem.ItemIsSelectable)

    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)

    def paint(self, painter, option, widget):
        fill_color = QColor(173, 216, 230) if self.current else QColor(211, 211, 211)
        painter.setBrush(QBrush(fill_color))
        painter.setPen(QPen(Qt.black, 2))
        painter.drawRoundedRect(0, 0, self.width, self.height, 10, 10)
        painter.setFont(QFont("Arial", 10, QFont.Bold))
        painter.drawText(self.boundingRect(), Qt.AlignTop | Qt.AlignHCenter, f"Stage {self.stage_number}")
        painter.setFont(QFont("Arial", 8))
        approvers_text = ", ".join(self.approvers)
        painter.drawText(self.boundingRect(), Qt.AlignCenter, approvers_text)


class PipelineArrow(QtWidgets.QGraphicsLineItem):
    """
    Custom graphics item to draw an arrow between two approval stage nodes.
    """

    def __init__(self, source_node, dest_node, parent=None):
        super().__init__(parent)
        self.source = source_node
        self.dest = dest_node
        self.arrow_size = 10
        self.setPen(QPen(Qt.black, 2))
        self.updatePosition()

    def updatePosition(self):
        src_center = self.source.pos() + self.source.boundingRect().center()
        dest_center = self.dest.pos() + self.dest.boundingRect().center()
        self.setLine(QLineF(src_center, dest_center))
        self.prepareGeometryChange()

    def paint(self, painter, option, widget):
        line = self.line()
        if line.length() == 0:
            return
        painter.setPen(self.pen())
        painter.drawLine(line)
        angle = math.atan2(-line.dy(), line.dx())
        arrow_p1 = line.p2() - QPointF(math.cos(angle + math.pi / 6) * self.arrow_size,
                                       -math.sin(angle + math.pi / 6) * self.arrow_size)
        arrow_p2 = line.p2() - QPointF(math.cos(angle - math.pi / 6) * self.arrow_size,
                                       -math.sin(angle - math.pi / 6) * self.arrow_size)
        arrow_head = QPolygonF([line.p2(), arrow_p1, arrow_p2])
        painter.setBrush(QBrush(Qt.black))
        painter.drawPolygon(arrow_head)

# ----------------------------------------------------------------------
# Main Window Integration
# ----------------------------------------------------------------------
import sys
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QWidget,
    QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QMessageBox,
    QDockWidget, QComboBox
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QIcon, QFont

# Assuming you have all these imports or from your own modules:
# from your_brm_code import (
#     # All the classes: DatabaseConnectionDialog, LoginDialog, ...
#     # BFS, LockManager, check_user_permissions, parse_sql_dependencies, ...
#     # All the tab classes:
#     GroupManagementTab,
#     UserManagementTab,
#     GlobalCriticalAdminTab,
#     ScheduleManagementTab,
#     DataValidationTab,
#     WhatIfTestTab,
#     DecisionTablesTab,
#     CompositeRulesTab,
#     ConflictPriorityManagerTab,
#     TagsManagerTab,
#     SnapshotManagerTab,
#     CollaborationTab,
#     CollaborationManager,
#     TaskNotificationCenterTab,
#     MetricsDashboardTab,
#     CtrlTablesTab,
#     MultiStepApprovalTab,
#     ChainSimulationDialog,
#     GroupSimulationDialog,
#     ConflictTriageDialog,
#     # etc...
# )

# Example placeholders if you need them:
# class LockManager: ...
# class BFSSubTab: ...
# etc.

logger = logging.getLogger("brm_master")


class MainWindow(QMainWindow):
    """
    A single integrated MainWindow that has every major feature:
      • Admin tab (Group Mgmt, User Mgmt, optional GlobalCriticalAdmin, Lock Mgmt)
      • Dashboard tab (Metrics, optional anomalies)
      • Rules tab with BFS sub-tab, DecisionTables, CompositeRules, Tags, Scheduling
      • Approvals tab (MultiStepApprovalTab)
      • Collaboration tab (EnhancedCollaborationTab)
      • Data tab (DataValidationTab, WhatIfTestTab)
      • Snapshots tab (SnapshotManagerTab, plus compare/diff)
      • Control tab (CtrlTablesTab)
      • Optional lineage tab (HierarchyViewTab, EnhancedLineageGraphWidget)
      • Dock for real-time TaskNotificationCenter
      • Real-time BFS “execute now” button or chain simulation
      • “Deactivate before Delete” rule constraints
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        self.setWindowTitle("BRM Tool – Ultimate Production Ready Edition")
        self.resize(2000, 1200)

        self.create_menu_bar()
        self.create_tool_bar()
        self.create_status_bar()

        # Main central widget layout
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)

        # If user is Admin, show “impersonation” row
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            imp_label = QLabel("Impersonate:")
            imp_label.setStyleSheet("font-weight: bold;")
            self.impersonation_combo = QComboBox()
            self.load_impersonation_options()
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.switch_user)
            imp_layout.addWidget(imp_label)
            imp_layout.addWidget(self.impersonation_combo)
            imp_layout.addWidget(imp_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)

        # Main TabWidget
        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)

        # 1) ADMIN TAB
        self.admin_tab = self.build_admin_tab()
        # Only show if user group is Admin
        if self.user_group == "Admin":
            self.tabs.addTab(self.admin_tab, QIcon(), "Admin")

        # 2) DASHBOARD TAB
        self.dashboard_tab = self.build_dashboard_tab()
        self.tabs.addTab(self.dashboard_tab, QIcon(), "Dashboard")

        # 3) RULES TAB
        self.rules_tab = self.build_rules_tab()
        self.tabs.addTab(self.rules_tab, QIcon(), "Rules")

        # 4) APPROVALS TAB
        self.approvals_tab = self.build_approvals_tab()
        self.tabs.addTab(self.approvals_tab, QIcon(), "Approvals")

        # 5) COLLABORATION TAB
        self.collab_tab = self.build_collaboration_tab()
        self.tabs.addTab(self.collab_tab, QIcon(), "Collaboration")

        # 6) DATA TAB (DataValidation + WhatIfTest)
        self.data_tab = self.build_data_tab()
        self.tabs.addTab(self.data_tab, QIcon(), "Data")

        # 7) SNAPSHOTS TAB
        self.snapshots_tab = self.build_snapshots_tab()
        self.tabs.addTab(self.snapshots_tab, QIcon(), "Snapshots")

        # 8) CONTROL TABLES TAB
        self.control_tab = self.build_control_tab()
        self.tabs.addTab(self.control_tab, QIcon(), "Control Tables")

        # 9) (Optional) LINEAGE TAB
        self.lineage_tab = self.build_lineage_tab()
        self.tabs.addTab(self.lineage_tab, QIcon(), "Lineage")

        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)

        # DOCK: Real-time tasks or alerts
        self.notifications_dock = QDockWidget("Real-Time Notifications", self)
        self.notifications_widget = TaskNotificationCenterTab(self.connection, self.user_id)
        self.notifications_dock.setWidget(self.notifications_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, self.notifications_dock)

        # Timer to auto-refresh
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_all)
        self.refresh_timer.start(30000)  # e.g. refresh every 30s

    # ------------------------------------------------------------------
    #  MENU, TOOLBAR, STATUS BAR
    # ------------------------------------------------------------------
    def create_menu_bar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)

        help_menu = menubar.addMenu("Help")
        doc_action = help_menu.addAction("Documentation")
        doc_action.triggered.connect(self.open_help)

    def create_tool_bar(self):
        toolbar = self.addToolBar("Main Toolbar")
        # Example: a “Refresh” action on the toolbar
        refresh_action = toolbar.addAction("Refresh")
        refresh_action.triggered.connect(self.refresh_all)
        # Example: an “Advanced Search” button to open a RuleSearchDialog
        adv_search_action = toolbar.addAction("Advanced Search")
        adv_search_action.triggered.connect(self.open_advanced_search)

    def create_status_bar(self):
        status = self.statusBar()
        status.showMessage(f"Connected | User: {self.get_username()} | Group: {self.user_group}")

    # ------------------------------------------------------------------
    #  BUILD ADMIN TAB
    # ------------------------------------------------------------------
    def build_admin_tab(self):
        """
        Returns a QWidget that has a QTabWidget for:
          - GroupManagementTab
          - UserManagementTab
          - Optional: GlobalCriticalAdminTab
          - Lock Manager sub-tab
        """
        admin_container = QWidget()
        admin_layout = QVBoxLayout(admin_container)

        self.admin_subtabs = QTabWidget()
        admin_layout.addWidget(self.admin_subtabs)

        # Group management
        self.group_mgmt = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.admin_subtabs.addTab(self.group_mgmt, "Group Management")

        # User management
        self.user_mgmt = UserManagementTab(self.connection)
        self.admin_subtabs.addTab(self.user_mgmt, "User Management")

        # Optional: Global Critical Admin (only if we want it)
        self.global_crit_admin = GlobalCriticalAdminTab(self.connection, self.user_group)
        if self.user_group == "Admin":
            self.admin_subtabs.addTab(self.global_crit_admin, "Global Critical Admin")

        # Lock Manager sub tab – show active locks, allow force unlock
        self.lock_manager_widget = self.build_lock_manager_widget()
        self.admin_subtabs.addTab(self.lock_manager_widget, "Lock Manager")

        admin_container.setLayout(admin_layout)
        return admin_container

    def build_lock_manager_widget(self):
        """
        A simple widget that shows all active locks & provides a 'Force Unlock' button.
        """
        w = QWidget()
        layout = QVBoxLayout(w)

        # E.g. a QTableWidget listing active locks
        from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QPushButton, QHBoxLayout

        self.lock_table = QTableWidget(0, 5)
        self.lock_table.setHorizontalHeaderLabels(["RuleID", "LockedBy", "LockTimestamp", "Expiry", "Force?"])
        layout.addWidget(self.lock_table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Locks")
        refresh_btn.clicked.connect(self.load_locks)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        return w

    def load_locks(self):
        """
        Pull from BRM_RULE_LOCKS, fill table with active locks. Provide Force Unlock per row.
        """
        self.lock_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1
                ORDER BY LOCK_TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.lock_table.rowCount()
                self.lock_table.insertRow(r_idx)
                rid_item = QTableWidgetItem(str(row[0]))
                lb_item = QTableWidgetItem(str(row[1]))
                lt_item = QTableWidgetItem(str(row[2]))
                ex_item = QTableWidgetItem(str(row[3]))
                self.lock_table.setItem(r_idx, 0, rid_item)
                self.lock_table.setItem(r_idx, 1, lb_item)
                self.lock_table.setItem(r_idx, 2, lt_item)
                self.lock_table.setItem(r_idx, 3, ex_item)

                # Force unlock button
                fw = QPushButton("Force Unlock")
                fw.clicked.connect(lambda _, rr=r_idx: self.force_unlock_row(rr))
                self.lock_table.setCellWidget(r_idx, 4, fw)
        except Exception as ex:
            QMessageBox.critical(self, "Lock Manager Error", str(ex))

    def force_unlock_row(self, row_index):
        rid_item = self.lock_table.item(row_index, 0)
        if not rid_item:
            return
        rule_id = int(rid_item.text())
          # or from your actual import location
        try:
            LockManager.unlock_rule_for_edit(self.connection, rule_id, self.user_id, force=True)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} forcibly unlocked.")
            self.load_locks()
        except Exception as ex:
            QMessageBox.critical(self, "Force Unlock Error", str(ex))

    # ------------------------------------------------------------------
    #  BUILD DASHBOARD TAB
    # ------------------------------------------------------------------
    def build_dashboard_tab(self):
        w = QWidget()
        layout = QVBoxLayout(w)

        # 1) Metrics

        self.metrics_tab = MetricsDashboardTab(self.connection)
        layout.addWidget(self.metrics_tab)

        # 2) (Optional) a mini anomaly detection check
        # Could add a button "Check Anomalies" that calls detect_rule_execution_anomalies_advanced
        # and displays them.
        check_ano_btn = QPushButton("Check Anomalies")
        check_ano_btn.clicked.connect(self.check_anomalies)
        layout.addWidget(check_ano_btn)

        w.setLayout(layout)
        return w

    def check_anomalies(self):

        anomalies = detect_rule_execution_anomalies_advanced(self.connection, days=7)
        if not anomalies:
            QMessageBox.information(self, "Anomalies", "No anomalies detected in last 7 days.")
        else:
            # Show them in a message or a small table
            msg = "Detected anomalies:\n"
            for (rid, reason) in anomalies:
                msg += f"Rule {rid} => {reason}\n"
            QMessageBox.warning(self, "Anomalies Found", msg)
            # Optionally auto-heal
            auto_heal_or_escalate_advanced(self.connection, anomalies)

    # ------------------------------------------------------------------
    #  BUILD RULES TAB (with BFS, DecisionTables, Composite, Tags, Scheduling)
    # ------------------------------------------------------------------
    def build_rules_tab(self):
        container = QWidget()
        layout = QVBoxLayout(container)

        self.rules_subtabs = QTabWidget()
        layout.addWidget(self.rules_subtabs)

        # BFS sub-tab
        self.bfs_subtab = self.build_bfs_subtab()
        self.rules_subtabs.addTab(self.bfs_subtab, "BFS & Execution")

        # Decision Tables

        dt_tab = DecisionTablesTab(self.connection)
        self.rules_subtabs.addTab(dt_tab, "Decision Tables")

        # Composite Rules

        comp_tab = CompositeRulesTab(self.connection)
        self.rules_subtabs.addTab(comp_tab, "Composite Rules")

        # Tags Manager

        tags_tab = TagsManagerTab(self.connection)
        self.rules_subtabs.addTab(tags_tab, "Tags")

        # Scheduling

        sched_tab = ScheduleManagementTab(self.connection)
        self.rules_subtabs.addTab(sched_tab, "Scheduling")

        container.setLayout(layout)
        return container

    def build_bfs_subtab(self):
        """
        BFS sub-tab containing chain simulation, group simulation, conflict priority, conflict triage, plus
        direct BFS execution with commit, as well as rule CRUD.
        """
        w = QWidget()
        layout = QVBoxLayout(w)

        # 1) A row of BFS / Conflict / Simulation buttons
        btn_layout = QHBoxLayout()

        chain_sim_btn = QPushButton("Chain Simulation")
        chain_sim_btn.clicked.connect(self.open_chain_simulation)
        btn_layout.addWidget(chain_sim_btn)

        group_sim_btn = QPushButton("Group Simulation")
        group_sim_btn.clicked.connect(self.open_group_simulation)
        btn_layout.addWidget(group_sim_btn)

        conflict_priority_btn = QPushButton("Conflict Priority Manager")
        conflict_priority_btn.clicked.connect(self.open_conflict_priority)
        btn_layout.addWidget(conflict_priority_btn)

        triage_btn = QPushButton("Conflict Triage")
        triage_btn.clicked.connect(self.open_conflict_triage)
        btn_layout.addWidget(triage_btn)

        # BFS commit run
        bfs_run_btn = QPushButton("Run BFS Execution (Commit)")
        bfs_run_btn.clicked.connect(self.run_bfs_execution)
        btn_layout.addWidget(bfs_run_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        # 2) A row of Rule CRUD (Add, Modify, Deactivate, Delete)
        #    Enforce "must be deactivated before delete"
        crud_layout = QHBoxLayout()
        add_rule_btn = QPushButton("Add Rule")
        add_rule_btn.clicked.connect(self.add_rule)
        crud_layout.addWidget(add_rule_btn)

        mod_rule_btn = QPushButton("Modify Rule")
        mod_rule_btn.clicked.connect(self.modify_rule)
        crud_layout.addWidget(mod_rule_btn)

        deact_rule_btn = QPushButton("Deactivate Rule")
        deact_rule_btn.clicked.connect(self.deactivate_rule)
        crud_layout.addWidget(deact_rule_btn)

        del_rule_btn = QPushButton("Delete Rule")
        del_rule_btn.clicked.connect(self.delete_rule)
        crud_layout.addWidget(del_rule_btn)

        crud_layout.addStretch()
        layout.addLayout(crud_layout)

        # Possibly a QTable or label to show BFS results or rule summary
        # (some placeholder)
        self.bfs_result_label = QLabel("BFS Results / Status will appear here...")
        layout.addWidget(self.bfs_result_label)

        return w

    def open_chain_simulation(self):

        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()

    def open_group_simulation(self):

        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()

    def open_conflict_priority(self):

        # Could open a separate dialog or just add the tab. Here we show as a dialog:
        diag = QDialog(self)
        diag.setWindowTitle("Conflict Priority")
        diag.resize(600, 400)
        layout = QVBoxLayout(diag)
        cpm = ConflictPriorityManagerTab(self.connection)
        layout.addWidget(cpm)
        diag.setLayout(layout)
        diag.exec_()

    def open_conflict_triage(self):

        dlg = ConflictTriageDialog(self.connection, self)
        dlg.exec_()

    def run_bfs_execution(self):
        # Possibly prompt user if they want “dry_run” or “commit”

        executed, skipped = execute_rules_unified_bfs(self.connection, dry_run=False, user_id=self.user_id)
        msg = f"BFS Execution done.\nExecuted: {executed}\nSkipped: {skipped}"
        self.bfs_result_label.setText(msg)
        QMessageBox.information(self, "BFS Execution", msg)

    def add_rule(self):

        editor = RuleEditorDialog(self.connection, self.user_group, self.user_id)
        if editor.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Added", "Rule added successfully.")

    def modify_rule(self):
        # Ask user for a RuleID to load
        rid, ok = QInputDialog.getInt(self, "Modify Rule", "Enter RuleID to modify:")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not found", f"Rule {rid} not found.")
                return
            colnames = [desc[0] for desc in c.description]
            rule_data = dict(zip(colnames, row))

            editor = RuleEditorDialog(self.connection, self.user_group, self.user_id, rule_data=rule_data)
            if editor.exec_() == QDialog.Accepted:
                QMessageBox.information(self, "Updated", "Rule updated successfully.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def deactivate_rule(self):
        # Mark rule as “INACTIVE”. Then user can delete
        rid, ok = QInputDialog.getInt(self, "Deactivate Rule", "Enter RuleID to deactivate:")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='INACTIVE', APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
                WHERE RULE_ID=?
            """, (rid,))
            self.connection.commit()
            QMessageBox.information(self, "Deactivated", f"Rule {rid} deactivated. You may now delete it.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_rule(self):
        # only if rule is inactive
        rid, ok = QInputDialog.getInt(self, "Delete Rule", "Enter RuleID to delete (must be inactive):")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            # Check if status=INACTIVE
            c.execute("SELECT STATUS FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", f"Rule {rid} not found.")
                return
            if row[0] != "INACTIVE":
                QMessageBox.warning(self, "Cannot Delete", f"Rule {rid} is not INACTIVE. Deactivate first.")
                return
            # proceed
            confirm = QMessageBox.question(self, "Confirm", f"Delete rule {rid} permanently?")
            if confirm != QMessageBox.Yes:
                return
            c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Rule {rid} deleted.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    # ------------------------------------------------------------------
    #  BUILD APPROVALS TAB
    # ------------------------------------------------------------------
    def build_approvals_tab(self):
        w = QWidget()
        layout = QVBoxLayout(w)

        self.approvals_widget = MultiStepApprovalTab(self.connection, self.get_username(), self.user_group)
        layout.addWidget(self.approvals_widget)
        w.setLayout(layout)
        return w

    # ------------------------------------------------------------------
    #  BUILD COLLABORATION TAB
    # ------------------------------------------------------------------
    def build_collaboration_tab(self):

        # or the EnhancedCollaborationTab if you want the advanced version
        collab_mgr = self.create_collaboration_manager()
        tab = EnhancedCollaborationTab(self.connection, collab_mgr)
        return tab

    def create_collaboration_manager(self):

        return CollaborationManager(self.connection, poll_ms=5000)

    # ------------------------------------------------------------------
    #  BUILD DATA TAB (DataValidation + WhatIfTest)
    # ------------------------------------------------------------------
    def build_data_tab(self):
        container = QWidget()
        layout = QVBoxLayout(container)

        self.data_subtabs = QTabWidget()
        layout.addWidget(self.data_subtabs)


        dv_tab = DataValidationTab(self.connection)
        self.data_subtabs.addTab(dv_tab, "Data Validation")


        whatif_tab = WhatIfTestTab(self.connection)
        self.data_subtabs.addTab(whatif_tab, "What-If Test")

        container.setLayout(layout)
        return container

    # ------------------------------------------------------------------
    #  BUILD SNAPSHOTS TAB
    # ------------------------------------------------------------------
    def build_snapshots_tab(self):
        container = QWidget()
        layout = QVBoxLayout(container)


        self.snap_tab = SnapshotManagerTab(self.connection)
        layout.addWidget(self.snap_tab)

        # Button to open SnapshotDiffWizard
        diff_btn = QPushButton("Compare Snapshots")
        diff_btn.clicked.connect(self.open_snapshot_diff)
        layout.addWidget(diff_btn)

        container.setLayout(layout)
        return container

    def open_snapshot_diff(self):

        diag = SnapshotDiffWizard(self.connection, self)
        diag.exec_()

    # ------------------------------------------------------------------
    #  BUILD CONTROL TAB
    # ------------------------------------------------------------------
    def build_control_tab(self):

        w = CtrlTablesTab(self.connection, user_group=self.user_group)
        return w

    # ------------------------------------------------------------------
    #  BUILD LINEAGE TAB
    # ------------------------------------------------------------------
    def build_lineage_tab(self):
        container = QWidget()
        layout = QVBoxLayout(container)

        # For hierarchy view

        self.hierarchy_view = HierarchyViewTab(self.connection)
        layout.addWidget(self.hierarchy_view)

        # For advanced lineage graph
        # from your_brm_code import EnhancedLineageGraphWidget
        # self.lineage_graph = EnhancedLineageGraphWidget(self.connection)
        # layout.addWidget(self.lineage_graph)

        container.setLayout(layout)
        return container

    # ------------------------------------------------------------------
    #  MENU & TOOLBAR ACTIONS
    # ------------------------------------------------------------------
    def logout(self):
        self.close()

    def open_help(self):
        QMessageBox.information(self, "Help", "Open Documentation... (Not implemented)")

    def open_advanced_search(self):
        # Launch a RuleSearchDialog for advanced searching

        dlg = RuleSearchDialog(self.connection, self.user_group, self)
        dlg.exec_()

    # ------------------------------------------------------------------
    #  IMPERSONATION (ADMIN ONLY)
    # ------------------------------------------------------------------
    def load_impersonation_options(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for uid, uname, ugroup in c.fetchall():
                self.impersonation_combo.addItem(f"{uname} ({ugroup})", (uid, ugroup))
        except Exception as ex:
            QMessageBox.critical(self, "Impersonation Error", str(ex))

    def switch_user(self):
        data = self.impersonation_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        QMessageBox.information(self, "Switched",
                                f"Now impersonating {self.get_username()} ({self.user_group}).")
        # E.g. reload relevant tabs
        self.approvals_tab.layout().itemAt(0).widget().logged_in_username = self.get_username()
        self.approvals_tab.layout().itemAt(0).widget().user_group = self.user_group
        self.approvals_tab.layout().itemAt(0).widget().load_approvals()

        # Reload BFS sub-tab or rules sub-tab if needed...
        # and so on. For brevity, not showing all reassignments.

        self.create_status_bar()

    # ------------------------------------------------------------------
    #  UTILITY
    # ------------------------------------------------------------------
    def get_username(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except:
            return "Unknown"

    def refresh_all(self):
        """
        Called periodically to refresh data in tabs.
        """
        try:
            # Refresh notifications
            self.notifications_widget.load_tasks()
            # Refresh BFS sub-tab label if needed, or scheduling tab, etc.
            # For example, reload the BFS sub tab’s data or conflict data
            self.statusBar().showMessage(f"Refreshed at {datetime.now().strftime('%H:%M:%S')}")
        except Exception as ex:
            logger.error(f"Error refreshing: {ex}")
def main():
    app = QApplication(sys.argv)

    # Show the Database Connection Dialog.
    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    conn = db_dialog.connection
    if not conn:
        sys.exit(1)

    # Show the Login Dialog.
    login_dialog = LoginDialog(conn)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dialog.user_id
    user_group = login_dialog.user_group

    window = MainWindow(conn, user_id, user_group)
    window.show()

    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
