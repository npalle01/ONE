#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8 (FINAL, NO ENCRYPTION, FULL LOCK/UNLOCK)
-------------------------------------------------------------------
This part contains:
  - All imports (PyQt5, logging, smtplib, etc.)
  - Logging config
  - Email sending function
  - Database connection dialog
  - Database helper functions (fetch, audit)
  - Login dialog
  - SQL parse helpers (detect_operation_type, parse_sql_dependencies)
  - Rule lifecycle constants
  - OnboardingWizard (optional user setup flow, commented out by default)
  - Production-ready lock/unlock logic for rule editing
No references to old encryption fields or “secure tab.” 
All future parts rely on these definitions.
"""

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re
import csv

from datetime import datetime, date, time, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 for GUI usage
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QDateTime, QTimer, QDate, QMimeData, QPoint
)
from PyQt5.QtGui import (
    QColor, QPainter, QBrush, QPen, QDrag
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog
)

# (Optional) pyqtgraph usage in later parts
import pyqtgraph as pg

# from sqlparse, for advanced SQL parsing
from sqlparse.sql import (
    Identifier, IdentifierList, Parenthesis, Token
)
from sqlparse.tokens import Keyword, DML


# ---------------------------------------------------------------------------
# LOGGING SETUP
# ---------------------------------------------------------------------------
logging.basicConfig(
    filename='brm_tool_production.log',  # log file name
    level=logging.DEBUG,                 # log level
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# EMAIL CONFIGURATION + SENDER
# ---------------------------------------------------------------------------
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "YOUR_SMTP_USERNAME",
    "smtp_password": "YOUR_SMTP_PASSWORD",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Send an email using the above SMTP config.
    `recipients` is a list of email addresses.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()

        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email to {recipients}: {ex}")


# ---------------------------------------------------------------------------
# DATABASE CONNECTION DIALOG
# ---------------------------------------------------------------------------
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    A simple dialog to let the user pick an ODBC DSN or enter a custom
    ODBC connection string, used to connect to SQL Server.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None

        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)

        prompt_label = QLabel(
            "Select an ODBC DSN (SQL Server) or provide a custom connection string:"
        )
        main_layout.addWidget(prompt_label)

        self.conn_type_combo = QComboBox()
        # Attempt to find all ODBC DSNs that have "SQL SERVER" in driver
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(
                        f"ODBC DSN: {dsn_name}",
                        dsn_name
                    )
        except Exception as e:
            logger.error(f"Error listing DSNs: {e}")

        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText(
            "Or custom ODBC connection string (optional)."
        )
        main_layout.addWidget(self.conn_str_edit)

        btn_layout = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

    def get_connection(self):
        """
        After the dialog is accepted, call this to retrieve the pyodbc connection.
        """
        override_str = self.conn_str_edit.text().strip()
        if override_str:
            conn_str = override_str
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self,
                    "Error",
                    "No DSN or custom connection string was provided."
                )
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None


# ---------------------------------------------------------------------------
# DATABASE HELPER FUNCTIONS
# ---------------------------------------------------------------------------
def fetch_all_dict(cursor):
    """
    For a given pyodbc cursor, fetch all rows into a list of dictionaries.
    If there's no description (no columns), return the raw rows.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        out = []
        for r_ in rows:
            out.append(dict(zip(colnames, r_)))
        return out
    else:
        return rows

def fetch_one_dict(cursor):
    """
    Fetch the next row from the cursor as a dictionary if description present.
    Return None if no row or no description.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    """
    Insert a record into BRM_AUDIT_LOG, storing old_data/new_data as JSON.
    record_id can be int or string; we store it as string if needed.
    """
    c = conn.cursor()
    c.execute("""
        INSERT INTO BRM_AUDIT_LOG(
            ACTION,
            TABLE_NAME,
            RECORD_ID,
            ACTION_BY,
            OLD_DATA,
            NEW_DATA,
            ACTION_TIMESTAMP
        )
        VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (
        action,
        table_name,
        str(record_id) if record_id else None,
        actor,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()


# ---------------------------------------------------------------------------
# LOGIN DIALOG
# ---------------------------------------------------------------------------
class LoginDialog(QtWidgets.QDialog):
    """
    Minimal username/password => checks USERS table => sets user_id, user_group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – Part 1")
        self.resize(300, 150)

        main_layout = QVBoxLayout(self)

        # Username
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        # Password
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        # Button
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)

        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Please enter both username and password.")
            return
        cur = self.connection.cursor()
        cur.execute(
            "SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",
            (un, pw)
        )
        row = fetch_one_dict(cur)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")


# ---------------------------------------------------------------------------
# DETECT OPERATION TYPE
# ---------------------------------------------------------------------------
def detect_operation_type(rule_sql: str) -> str:
    """
    Returns one of:
      - "INSERT"
      - "UPDATE"
      - "DELETE"
      - "SELECT"
      - "OTHER"
    based on the first keyword in `rule_sql`.
    """
    stripped = rule_sql.strip().upper()
    if stripped.startswith("INSERT"):
        return "INSERT"
    elif stripped.startswith("UPDATE"):
        return "UPDATE"
    elif stripped.startswith("DELETE"):
        return "DELETE"
    elif stripped.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"


# ---------------------------------------------------------------------------
# ADVANCED SQL PARSER for Dependencies
# ---------------------------------------------------------------------------
def parse_sql_dependencies(sql_text: str):
    """
    Use sqlparse to identify table references, columns, etc.
    Returns a dict with:
      {
        "tables": [ (schema, table, alias, is_subselect) ... ],
        "cte_tables": [ (CTEName, [list_of_refs])... ],
        "alias_map": { alias: (schema,table) ... },
        "columns": [ (colName, isWrite, isRead) ... ]
      }
    This helps in building lineage and advanced referencing.
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []

    for stmt in statements:
        # Extract any CTE usage
        ctes = _extract_with_clauses(stmt)
        for cName, cRefs in ctes.items():
            cte_info.append((cName, cRefs))

        # Main FROM references
        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        # Columns
        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)

    # De-duplicate tables
    unique_tables = list({x for x in all_tables})

    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }


def _extract_with_clauses(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        val = tk.value.upper() if tk.ttype else ""
        if val == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2 = _extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, set())
                    st = (st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st = _parse_identifier(tk, set())
                st = (st[0], st[1], st[2], True)
                results.append(st)
        i += 1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper() == "SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2 = _extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, known_cte_names)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]] = (st[0], st[1])
            elif isinstance(tk, Identifier):
                st = _parse_identifier(tk, known_cte_names)
                results.append(st)
                if st[2]:
                    alias_map[st[2]] = (st[0], st[1])
        i += 1
    return (results, alias_map)

def _parse_identifier(ident, known_cte_names):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema_name = ident.get_parent_name()
    # if real_name in known_cte_names => referencing a cte
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    """
    Return a list of (colName, isWrite, isRead).
    Insert => write
    Update => write
    Delete => write
    Select => read
    """
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is DML:
            dml_word = tk.value.upper()
            if dml_word == "SELECT":
                col_refs = _parse_select_list(tokens, i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif dml_word in ("INSERT","UPDATE"):
                col_refs2 = _parse_dml_columns(tokens, i, dml_word)
                for c_ in col_refs2:
                    results.append((c_, True, False))
        i += 1
    return results

def _parse_select_list(tokens, start_idx):
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                colnm = ident.get_name()
                if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(colnm)
        elif isinstance(tk, Identifier):
            colnm = tk.get_name()
            if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(colnm)
        i += 1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                for sub in tk.tokens:
                    if isinstance(sub, IdentifierList):
                        for ident in sub.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(sub, Identifier):
                        columns.append(sub.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return columns

def _parse_update_set_list(tokens, start_i):
    columns = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, Identifier):
            columns.append(tk.get_name())
        i += 1
    return columns


# ---------------------------------------------------------------------------
# RULE LIFECYCLE STATES
# ---------------------------------------------------------------------------
RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]


# ---------------------------------------------------------------------------
# ONBOARDING WIZARD (OPTIONAL)
# ---------------------------------------------------------------------------
class OnboardingWizard(QDialog):
    """
    Optional wizard for brand-new users. Steps:
      1) Add a group
      2) Add a rule
      3) Add a schedule
      Then done.
    This is commented out by default if you don’t want it.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Welcome Wizard (Part 1)")
        self.resize(400, 300)

        main_layout = QVBoxLayout(self)

        self.label = QLabel("Welcome to the BRM Onboarding Wizard!")
        main_layout.addWidget(self.label)

        self.current_step = 0

        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.go_next)
        main_layout.addWidget(self.next_btn)

        self.setLayout(main_layout)

    def go_next(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Go to 'Group Management' => add a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Go to 'Business Rules' => add a new rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Go to 'Scheduling' => add a schedule.")
        else:
            self.label.setText("All done. Enjoy the BRM Tool.")
            self.accept()


# ---------------------------------------------------------------------------
# RULE LOCK/UNLOCK FUNCTIONS (FULLY IMPLEMENTED)
# ---------------------------------------------------------------------------

def rule_current_lock_owner(conn, rule_id):
    """
    Return (locked_by_user_id, lock_timestamp, lock_expiration, forcibly_locked_flag)
    or None if not locked or lock expired.

    We assume a table BRM_RULE_LOCKS:
      - RULE_ID (int)
      - LOCKED_BY (int)
      - LOCK_TIMESTAMP (datetime)
      - EXPIRY_TIMESTAMP (datetime)
      - FORCE_LOCK (bit)
      - ACTIVE_LOCK (bit)
    If lock is expired => treat as not locked.
    """
    c = conn.cursor()
    c.execute("""
    SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
    FROM BRM_RULE_LOCKS
    WHERE RULE_ID=? AND ACTIVE_LOCK=1
    """, (rule_id,))
    row = c.fetchone()
    if not row:
        return None
    (locked_by, lock_ts, expiry_ts, force_lock, active_lock) = row
    if not active_lock:
        return None
    if expiry_ts is not None:
        now = datetime.now()
        if now > expiry_ts:
            # lock expired => mark inactive
            c2 = conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """,(rule_id,))
            conn.commit()
            return None
    return (locked_by, lock_ts, expiry_ts, force_lock)


def lock_rule_for_edit(conn, rule_id, user_id, force=False):
    """
    Attempt to lock rule for editing:
      - If already locked by someone else => error (unless force=True and user is Admin)
      - If locked by same user => refresh expiry
      - Else => insert new lock row
    We'll do e.g. 30-min expiry.

    *You must handle admin checks outside if you want 'force' allowed only to admin.
    """
    info = rule_current_lock_owner(conn, rule_id)
    now = datetime.now()
    expiry = now + timedelta(minutes=30)
    c = conn.cursor()

    if info is not None:
        (locked_by, _, _, force_lock_flag) = info
        if locked_by == user_id:
            # refresh expiry
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET EXPIRY_TIMESTAMP=?, LOCK_TIMESTAMP=?, FORCE_LOCK=?
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """,(expiry, now, 1 if force else 0, rule_id))
            conn.commit()
            logger.debug(f"Lock refreshed for user {user_id} on rule {rule_id}.")
            return (True, f"Lock refreshed (user {user_id} on rule {rule_id})")

        else:
            # locked by someone else
            if not force:
                return (False, f"Rule {rule_id} is locked by user {locked_by}.")
            else:
                # force => override
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """,(rule_id,))
                c.execute("""
                    INSERT INTO BRM_RULE_LOCKS(
                      RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                      FORCE_LOCK, ACTIVE_LOCK
                    )
                    VALUES(?,?,?,?,?,1)
                """,(rule_id, user_id, now, expiry, 1 if force else 0))
                conn.commit()
                logger.debug(f"Rule {rule_id} forcibly locked by user {user_id}.")
                return (True, f"Rule {rule_id} forcibly locked by user {user_id}.")
    else:
        # no existing active lock => create
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS(
                RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                FORCE_LOCK, ACTIVE_LOCK
            )
            VALUES(?,?,?,?,?,1)
        """,(rule_id, user_id, now, expiry, 1 if force else 0))
        conn.commit()
        logger.debug(f"Rule {rule_id} locked by user {user_id}. Force={force}")
        return (True, f"Rule {rule_id} locked by user {user_id}.")


def unlock_rule_for_edit(conn, rule_id, user_id=None, force=False):
    """
    Unlock the rule:
      - If force => any user can unlock
      - else => only the user who locked it can unlock
    Deactivate ACTIVE_LOCK=1 => set it to 0.
    """
    info = rule_current_lock_owner(conn, rule_id)
    if not info:
        return
    (locked_by, _, _, _) = info
    if not force:
        if user_id and locked_by != user_id:
            raise ValueError("Cannot unlock => locked by another user, no override given.")
    c = conn.cursor()
    c.execute("""
        UPDATE BRM_RULE_LOCKS
        SET ACTIVE_LOCK=0
        WHERE RULE_ID=? AND ACTIVE_LOCK=1
    """,(rule_id,))
    conn.commit()
    logger.debug(f"Rule {rule_id} unlocked. Admin/force={force}, by user {user_id}")


def auto_unlock_expired_locks(conn):
    """
    Periodic check to free locks that are expired. 
    If user was idle beyond 30 min => we do an expiry.
    """
    now = datetime.now()
    c = conn.cursor()
    c.execute("""
        UPDATE BRM_RULE_LOCKS
        SET ACTIVE_LOCK=0
        WHERE ACTIVE_LOCK=1
          AND EXPIRY_TIMESTAMP<?
    """,(now,))
    rowcount = c.rowcount
    conn.commit()
    if rowcount>0:
        logger.debug(f"Auto-unlocked {rowcount} expired rule locks.")
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 2 of 8 (ADVANCED BFS, CRUD, VALIDATIONS, LOCKS, PERMISSIONS)
---------------------------------------------------------------------------
Builds on Part 1’s classes & functions:
  - Logging, DatabaseConnectionDialog, parse_sql_dependencies, detect_operation_type
  - rule_current_lock_owner, lock_rule_for_edit, unlock_rule_for_edit, auto_unlock_expired_locks
  - fetch_one_dict, fetch_all_dict, insert_audit_log, RULE_LIFECYCLE_STATES
  - Possibly OnboardingWizard if used

This part includes:
  - BFS logic for rules (child, GCR, conflict, composite) => `execute_rules_with_conflicts_composites_bfs`
  - Data validations execution during BFS if needed
  - Multi-level approvals creation & checking
  - Advanced CRUD (add_rule, update_rule, deactivate_rule, delete_rule, force_activate_rule, force_deactivate_rule)
  - Permission checks on table usage
  - Performance metrics logging for rule execution
  - Automatic lock checks in CRUD to ensure the rule is locked by the editor (unless admin force)
No references to encryption or secure fields.
"""

import json
import time
from datetime import datetime, timedelta
from collections import deque

# We rely on Part 1’s everything (logger, parse_sql_dependencies, detect_operation_type, locks, etc.).
# We'll just assume they are in the same file or namespace.

# ---------------------------------------------------------------------------
# PERMISSION CHECK
# ---------------------------------------------------------------------------
def user_has_table_permission(conn, user_group, table_name):
    """
    Check if `user_group` has permission to access `table_name` (schema.table)
    by looking at GROUP_PERMISSIONS or a similar table. Return True/False.
    """
    c = conn.cursor()
    normalized = table_name.lower()
    c.execute("""
        SELECT 1
        FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME=? AND LOWER(TARGET_TABLE)=?
    """,(user_group, normalized))
    row = c.fetchone()
    return bool(row)

def enforce_table_permissions_for_rule(conn, user_group, rule_sql):
    """
    Parse rule_sql => find all tables => ensure user_group has permission.
    If missing, raise ValueError.
    """
    deps = parse_sql_dependencies(rule_sql)
    for (schema, tbl, alias, is_sub) in deps["tables"]:
        if tbl and not tbl.startswith("(CTE)"):
            dbn = schema if schema else "dbo"
            full_tn = f"{dbn}.{tbl}".lower()
            if not user_has_table_permission(conn, user_group, full_tn):
                raise ValueError(f"Group {user_group} has no permission for table '{full_tn}'. Rule not allowed.")


# ---------------------------------------------------------------------------
# DATA VALIDATIONS
# ---------------------------------------------------------------------------
def load_data_validations_for_table(conn, table_name):
    """
    Return all validation rules for the given `table_name` from DATA_VALIDATIONS.
    Returns list of dict => {VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS}.
    """
    c = conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
        WHERE LOWER(TABLE_NAME)=LOWER(?)
    """,(table_name,))
    return fetch_all_dict(c)

def run_single_data_validation(validation_rule, conn):
    """
    Execute the data validation logic. Return True if pass, False otherwise.
    For example:
      - NOT NULL => check that the column has no NULL
      - RANGE => check min/max from PARAMS
      - REGEX => (not fully implemented, could do T-SQL or Python)
    """
    vtype = (validation_rule["VALIDATION_TYPE"] or "").upper()
    table_ = validation_rule["TABLE_NAME"]
    column_ = validation_rule["COLUMN_NAME"]
    params_ = validation_rule["PARAMS"] or ""

    c = conn.cursor()
    try:
        if vtype == "NOT NULL":
            q = f"SELECT COUNT(*) FROM {table_} WHERE {column_} IS NULL"
            c.execute(q)
            row = c.fetchone()
            null_count = row[0]
            return (null_count == 0)

        elif vtype == "RANGE":
            parts = params_.split(",")
            if len(parts)==2:
                try:
                    min_val = float(parts[0])
                    max_val = float(parts[1])
                    q = f"""
                      SELECT COUNT(*) 
                      FROM {table_}
                      WHERE {column_} < {min_val} OR {column_} > {max_val}
                    """
                    c.execute(q)
                    row = c.fetchone()
                    out_of_range = row[0]
                    return (out_of_range == 0)
                except:
                    return False
            else:
                return False

        elif vtype == "REGEX":
            # Stub => pass for now
            return True

        else:
            # Unknown => fail
            return False
    except:
        return False

def run_data_validations_for_table(conn, table_name):
    """
    Load all validations for `table_name`, run them, return True if all pass.
    """
    vlist = load_data_validations_for_table(conn, table_name)
    for v_ in vlist:
        ok = run_single_data_validation(v_, conn)
        if not ok:
            return False
    return True


# ---------------------------------------------------------------------------
# MULTI-STEP APPROVALS
# ---------------------------------------------------------------------------
def create_multistep_approvals(conn, rule_id):
    """
    Insert approvals pipeline for a rule. For demonstration:
      - Possibly BG1 => BG2 => BG3 => FINAL
      - Also BFS impacted groups => add if needed
      - If references to finance => require BG2, if references to sensitive => BG3
    """
    impacted = _find_impacted_groups_bfs(conn, rule_id)

    c2 = conn.cursor()
    c2.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
    trows = c2.fetchall()
    require_bg2 = False
    require_bg3 = False
    for (tname,) in trows:
        lo = (tname or "").lower()
        if "finance" in lo or "credit" in lo:
            require_bg2 = True
        if "sensitive" in lo or "personal_info" in lo:
            require_bg3 = True

    pipeline = []
    pipeline.append("BG1")
    if require_bg2 or ("BG2" in impacted):
        pipeline.append("BG2")
    if require_bg3 or ("BG3" in impacted):
        pipeline.append("BG3")
    pipeline.append("FINAL")

    c = conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_id,))

    stage = 1
    for grp in pipeline:
        if grp=="FINAL":
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME,
                  APPROVED_FLAG, APPROVED_TIMESTAMP,
                  APPROVAL_STAGE
                )
                VALUES(?,?,?,0,NULL,?)
            """,(rule_id,"FINAL","final_approver",stage))
            stage+=1
        else:
            # insert for each approver in that group
            c3 = conn.cursor()
            c3.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
            arows = c3.fetchall()
            for (uname,) in arows:
                c.execute("""
                    INSERT INTO BRM_RULE_APPROVALS(
                      RULE_ID, GROUP_NAME, USERNAME,
                      APPROVED_FLAG, APPROVED_TIMESTAMP,
                      APPROVAL_STAGE
                    )
                    VALUES(?,?,?,0,NULL,?)
                """,(rule_id, grp, uname, stage))
            stage+=1
    conn.commit()

def _find_impacted_groups_bfs(conn, start_rule_id):
    """
    BFS from start_rule => gather all related => return set of OWNER_GROUP
    """
    visited = set()
    queue = [start_rule_id]
    adjacency, roots, parent_map = _load_rule_relationships(conn)

    c = conn.cursor()

    out_groups = set()
    while queue:
        rid = queue.pop(0)
        if rid in visited:
            continue
        visited.add(rid)

        c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if row:
            out_groups.add(row[0])

        if rid in adjacency:
            for ch_ in adjacency[rid]:
                if ch_ not in visited:
                    queue.append(ch_)
    return out_groups


# ---------------------------------------------------------------------------
# BFS LOGIC (CHILD, GCR, CONFLICT, COMPOSITE)
# ---------------------------------------------------------------------------
def _load_rule_relationships(conn):
    """
    Build adjacency for BFS:
      - child relationships => PARENT_RULE_ID
      - GCR links => BRM_GLOBAL_CRITICAL_LINKS
      - Conflicts => RULE_CONFLICTS
      - Composites => COMPOSITE_RULES
    Return adjacency dict => rule_id -> set(next_ids), plus root list, plus parent_map
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()

    for (rid,pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            parent_map[rid] = pid

    # GCR
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcr_rows = c.fetchall()
    for (gcr,child) in gcr_rows:
        adjacency.setdefault(gcr,set()).add(child)

    # Conflicts => symmetrical adjacency
    c.execute("SELECT RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    cf_rows = c.fetchall()
    for (r1,r2,pri) in cf_rows:
        adjacency.setdefault(r1,set()).add(r2)
        adjacency.setdefault(r2,set()).add(r1)

    # Composites => parse LOGIC_EXPR for "RuleX"
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp_rows = c.fetchall()
    pat = re.compile(r"Rule(\d+)")
    for (cid,expr) in comp_rows:
        if expr:
            matches = pat.findall(expr)
            for m_ in matches:
                try:
                    sub = int(m_)
                    adjacency.setdefault(sub,set()).add(cid)
                except:
                    pass

    # roots => those not in parent_map
    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]
    return adjacency, roots, parent_map

def gather_all_related_rule_ids(conn, start_rule_id):
    """
    BFS => gather all reachable from `start_rule_id`
    """
    adjacency, roots, pmap = _load_rule_relationships(conn)
    visited = set()
    queue = [start_rule_id]
    while queue:
        cur = queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in adjacency:
            for nxt in adjacency[cur]:
                if nxt not in visited:
                    queue.append(nxt)
    return visited

def execute_rules_with_conflicts_composites_bfs(
    conn, 
    selected_rule_ids=None, 
    skip_data_validation=False,
    measure_perf=False
):
    """
    Full BFS => child + GCR + conflict + composite adjacency
    If `selected_rule_ids` => start BFS from those, else from root rules.
    If `skip_data_validation=False`, we run table-level validations first.
    If measure_perf=True => we time the BFS overall, but also each rule call 
        can store execution logs with elapsed time.

    Return (executed_list, skipped_set).
    """
    adjacency, roots, parent_map = _load_rule_relationships(conn)
    rule_map = _get_all_rules_map(conn)

    if not selected_rule_ids:
        queue = list(roots)
    else:
        queue = list(selected_rule_ids)

    executed = []
    skipped = set()

    start_time = time.time() if measure_perf else None

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue

        rinfo = rule_map[rid]

        # run data validations if not skipping
        if not skip_data_validation:
            # gather tables from dependencies
            c2 = conn.cursor()
            c2.execute("""
                SELECT DATABASE_NAME, TABLE_NAME
                FROM BRM_RULE_TABLE_DEPENDENCIES
                WHERE RULE_ID=?
            """,(rid,))
            tdeps = c2.fetchall()
            val_failed = False
            for (dbn,tb) in tdeps:
                if not tb:
                    continue
                fulln = (dbn + "." + tb).lower()
                pass_ok = run_data_validations_for_table(conn, fulln)
                if not pass_ok:
                    val_failed = True
                    break
            if val_failed:
                skipped.add(rid)
                if rid in adjacency:
                    for ch_ in adjacency[rid]:
                        _skip_descendants(ch_, adjacency, skipped)
                continue

        # run the rule
        (ok,msg,rec_count,elapsed) = _run_single_rule(conn, rinfo, is_dry_run=False)
        _insert_performance_log(conn, rid, ok, msg, rec_count, elapsed)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # if the rule is critical => skip children
            is_crit = (rinfo["CRITICAL_RULE"]==1 or rinfo["IS_GLOBAL"]==1)
            scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and scope!="NONE":
                if rid in adjacency:
                    for child_ in adjacency[rid]:
                        _skip_descendants(child_, adjacency, skipped)
            skipped.add(rid)

    if measure_perf and start_time is not None:
        total_elapsed = time.time() - start_time
        logger.debug(f"BFS measure_perf => total {total_elapsed:.4f} s")

    return (executed, skipped)


def _skip_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch_ in adjacency[cur]:
                if ch_ not in skipped:
                    stack.append(ch_)

def _get_all_rules_map(conn):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows=c.fetchall()
    colnames=[desc[0] for desc in c.description]
    out={}
    for row in rows:
        d_=dict(zip(colnames,row))
        out[d_["RULE_ID"]]=d_
    return out

def _run_single_rule(conn, rule_info, is_dry_run=False):
    """
    Execute rule => interpret rows[0][0]==1 => pass, else fail => rollback if fail or is_dry_run.
    Return (ok_flag, message, record_count, elapsed_seconds).
    """
    import time
    sql_ = (rule_info.get("RULE_SQL","") or "").strip()
    start_t = time.time()
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        rows = c.fetchall()
        if rows:
            rec_count = len(rows)
            val = rows[0][0]
            success = (val==1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg="No rows => PASS"

        if not success or is_dry_run:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")

    except Exception as ex:
        c.execute("ROLLBACK")
        success = False
        msg=str(ex)
    end_t = time.time()
    elapsed = round(end_t - start_t, 4)
    return (success, msg, rec_count, elapsed)

def _insert_performance_log(conn, rule_id, pass_flag, message, record_count, elapsed):
    """
    Insert a line in RULE_EXECUTION_LOGS capturing performance info, if desired.
    """
    c=conn.cursor()
    c.execute("""
        INSERT INTO RULE_EXECUTION_LOGS(
          RULE_ID,
          EXECUTION_TIMESTAMP,
          PASS_FLAG,
          MESSAGE,
          RECORD_COUNT,
          EXECUTION_TIME_MS
        )
        VALUES(?,GETDATE(),?,?,?,?)
    """,(rule_id, 1 if pass_flag else 0, message, record_count, int(elapsed*1000)))
    conn.commit()


# ---------------------------------------------------------------------------
# ADVANCED CRUD with LIFECYCLE + LOCK CHECKS
# ---------------------------------------------------------------------------
def add_rule(conn, rule_data, created_by_user_id, created_by_group):
    """
    Insert a new rule => parse dependencies => set lifecycle to DRAFT => create_multistep_approvals => 
    enforce DB table permissions => no lock needed for brand-new rule.
    
    rule_data must have keys like:
      "GROUP_ID", "RULE_TYPE_ID", "RULE_NAME", "RULE_SQL", 
      "EFFECTIVE_START_DATE", "OWNER_GROUP", possibly "IS_GLOBAL", "CRITICAL_RULE", etc.
    """
    # table permission
    rule_sql = rule_data.get("RULE_SQL","").strip()
    if rule_sql:
        enforce_table_permissions_for_rule(conn, created_by_group, rule_sql)

    # detect op
    op_type = detect_operation_type(rule_sql)
    # parse
    deps = parse_sql_dependencies(rule_sql)

    # Insert
    c=conn.cursor()

    # check duplicates by name
    c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE OWNER_GROUP=? AND RULE_NAME=?
    """,(rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    # check duplicates by exact SQL if you want
    if rule_sql:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(rule_sql,))
        row2 = c.fetchone()
        if row2:
            raise ValueError("Another rule with the exact same SQL already exists.")

    if rule_data.get("IS_GLOBAL",0)==1 and created_by_group!="Admin":
        raise ValueError("Only Admin can create a global rule.")

    # Set lifecycle
    rule_data["LIFECYCLE_STATE"] = "DRAFT"

    # Insert
    nowstr = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    row = c.execute("""
        INSERT INTO BRM_RULES(
          GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,
          RULE_NAME,RULE_SQL,
          EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,
          STATUS,VERSION,CREATED_BY,
          DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
          CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,
          APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,
          CRITICAL_SCOPE,CDC_TYPE,LIFECYCLE_STATE
        )
        OUTPUT inserted.RULE_ID
        VALUES(?,?,?,?,?,
               ?,?,
               ?,?,
               ?,
               ?,?,?,?,
               ?,?,?,?,
               ?,?,?)
    """,(
       rule_data.get("GROUP_ID"),
       rule_data.get("PARENT_RULE_ID"),
       rule_data["RULE_TYPE_ID"],
       rule_data["RULE_NAME"].strip(),
       rule_sql,

       rule_data["EFFECTIVE_START_DATE"],
       rule_data.get("EFFECTIVE_END_DATE"),
       rule_data.get("STATUS","INACTIVE"),
       1,
       str(created_by_user_id),

       rule_data.get("DESCRIPTION",""),
       op_type,
       rule_data.get("BUSINESS_JUSTIFICATION",""),
       nowstr,
       None,
       rule_data["OWNER_GROUP"],

       "APPROVAL_IN_PROGRESS",
       rule_data.get("IS_GLOBAL",0),
       rule_data.get("CRITICAL_RULE",0),
       rule_data.get("CRITICAL_SCOPE","NONE"),
       rule_data.get("CDC_TYPE","NONE"),
       rule_data["LIFECYCLE_STATE"]
    )).fetchone()
    if not row:
        raise ValueError("Insert failed => no RULE_ID returned.")
    new_rule_id = row[0]

    # Insert dependencies
    col_op = "READ"
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    for (sch,tb,alias,is_sub) in deps["tables"]:
        if tb and not tb.startswith("(CTE)"):
            dbn = sch if sch else "dbo"
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
            """,(new_rule_id, dbn, tb, "AutoCol", col_op))

    # audit
    insert_audit_log(conn,"INSERT","BRM_RULES", new_rule_id, str(created_by_user_id), None, rule_data)
    conn.commit()

    # create approvals if not skipping
    create_multistep_approvals(conn, new_rule_id)

    return new_rule_id


def update_rule(conn, rule_data, updated_by_user_id, updated_by_group):
    """
    Update existing rule => check lock => parse => re-approval => refresh table deps => 
    set status=INACTIVE => LIFECYCLE_STATE=UNDER_APPROVAL => version++
    """
    rid = rule_data["RULE_ID"]
    # check lock unless admin
    lock_info = rule_current_lock_owner(conn, rid)
    if lock_info:
        (locked_by, _, _, _) = lock_info
        if locked_by != updated_by_user_id and updated_by_group!="Admin":
            raise ValueError(f"Rule {rid} is locked by user {locked_by}, you cannot update.")
    else:
        if updated_by_group!="Admin":
            raise ValueError(f"Rule {rid} not locked => cannot update (unless admin).")

    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old_row = c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    colnames=[desc[0] for desc in c.description]
    old_data = dict(zip(colnames,old_row))

    if old_data["IS_GLOBAL"]==1 and updated_by_group!="Admin":
        raise ValueError("Only Admin can update a global rule.")

    # new sql
    new_sql = rule_data.get("RULE_SQL","").strip()
    if new_sql and new_sql!=old_data["RULE_SQL"]:
        # check permission
        enforce_table_permissions_for_rule(conn, updated_by_group, new_sql)
        # check duplicates by SQL
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        row2=c.fetchone()
        if row2 and row2[0]!=rid:
            raise ValueError("Another rule with identical SQL exists => not allowed.")
    op_type = detect_operation_type(new_sql)
    deps = parse_sql_dependencies(new_sql)

    # do update
    c.execute("""
    UPDATE BRM_RULES
    SET GROUP_ID=?,
        PARENT_RULE_ID=?,
        RULE_TYPE_ID=?,
        RULE_NAME=?,
        RULE_SQL=?,
        EFFECTIVE_START_DATE=?,
        EFFECTIVE_END_DATE=?,
        STATUS='INACTIVE',
        VERSION=VERSION+1,
        UPDATED_BY=?,
        DESCRIPTION=?,
        OPERATION_TYPE=?,
        BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?,
        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?,
        CRITICAL_RULE=?,
        CRITICAL_SCOPE=?,
        CDC_TYPE=?,
        LIFECYCLE_STATE='UNDER_APPROVAL'
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data.get("EFFECTIVE_START_DATE"),
        rule_data.get("EFFECTIVE_END_DATE"),
        str(updated_by_user_id),
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rid
    ))
    conn.commit()

    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    col_op="READ"
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    for (sch,tb,alias,is_sub) in deps["tables"]:
        if tb and not tb.startswith("(CTE)"):
            dbn=sch if sch else "dbo"
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
            """,(rid, dbn, tb, "AutoCol", col_op))
    conn.commit()

    # build new data
    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["STATUS"]="INACTIVE"
    new_data["LIFECYCLE_STATE"]="UNDER_APPROVAL"
    insert_audit_log(conn,"UPDATE","BRM_RULES",rid,str(updated_by_user_id),old_data,new_data)

    # re-create approvals
    create_multistep_approvals(conn, rid)


def force_activate_rule(conn, rule_id, user_id, user_group):
    """
    Force-activate => skip normal approval => must be admin or rule lock owner => 
    set STATUS=ACTIVE, LIFECYCLE_STATE=ACTIVE, APPROVAL_STATUS='FORCED'
    """
    if user_group!="Admin":
        # must check lock
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info:
            raise ValueError(f"Rule {rule_id} is not locked => cannot force activate unless admin.")
        (locked_by, _, _, _) = lock_info
        if locked_by != user_id:
            raise ValueError(f"Rule {rule_id} locked by {locked_by}, you cannot force activate.")

    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data = dict(zip(cols,old_row))

    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='ACTIVE',
            LIFECYCLE_STATE='ACTIVE',
            APPROVAL_STATUS='FORCE_ACTIVATED'
        WHERE RULE_ID=?
    """,(rule_id,))

    new_data=dict(old_data)
    new_data["STATUS"]="ACTIVE"
    new_data["LIFECYCLE_STATE"]="ACTIVE"
    new_data["APPROVAL_STATUS"]="FORCE_ACTIVATED"
    insert_audit_log(conn,"FORCE_ACTIVATE","BRM_RULES",rule_id,str(user_id),old_data,new_data)
    conn.commit()

def force_deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Force-deactivate => must be admin or lock owner => 
    set STATUS=INACTIVE => skip approvals => set LIFECYCLE_STATE=INACTIVE => APPROVAL_STATUS='FORCE_DEACTIVATED'
    """
    if user_group!="Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info:
            raise ValueError(f"Rule {rule_id} not locked => cannot force deactivate unless admin.")
        (locked_by, _, _, _) = lock_info
        if locked_by!=user_id:
            raise ValueError(f"Rule {rule_id} locked by {locked_by}, cannot force deactivate.")
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old_row))

    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE',
            LIFECYCLE_STATE='INACTIVE',
            APPROVAL_STATUS='FORCE_DEACTIVATED'
        WHERE RULE_ID=?
    """,(rule_id,))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["LIFECYCLE_STATE"]="INACTIVE"
    new_data["APPROVAL_STATUS"]="FORCE_DEACTIVATED"
    insert_audit_log(conn,"FORCE_DEACTIVATE","BRM_RULES",rule_id,str(user_id),old_data,new_data)
    conn.commit()


def deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Normal (non-force) => must be fully approved => no active children => global => admin only => must own lock
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old_row))

    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate => not fully APPROVED.")
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate a global rule.")

    if user_group!="Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info:
            raise ValueError("Rule not locked => cannot deactivate.")
        (locked_by, _, _, _) = lock_info
        if locked_by!=user_id:
            raise ValueError(f"Locked by {locked_by}, you can't deactivate.")

    # check children active
    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    if c.fetchone():
        raise ValueError("Deactivate child rules first => some are ACTIVE.")

    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE',
            UPDATED_BY=?,
            VERSION=VERSION+1,
            LIFECYCLE_STATE='INACTIVE'
        WHERE RULE_ID=?
    """,(str(user_id), rule_id))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["LIFECYCLE_STATE"]="INACTIVE"
    insert_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,str(user_id),old_data,new_data)
    conn.commit()


def delete_rule(conn, rule_id, action_by, user_group):
    """
    Normal (non-force) => must be fully approved => must be inactive => global => admin only => no children => no references => must own lock
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old_row))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete => not fully APPROVED.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Must be INACTIVE first.")

    if user_group!="Admin":
        lock_info = rule_current_lock_owner(conn, rule_id)
        if not lock_info:
            raise ValueError("Rule not locked => cannot delete.")
        (locked_by, _, _, _) = lock_info
        if locked_by!=action_by:
            raise ValueError(f"Rule locked by {locked_by}, you can't delete.")

    # no children
    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    if c.fetchone():
        raise ValueError("Child rules exist => remove them first.")

    # references
    c.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    if c.fetchone():
        raise ValueError("Remove references from BRM_COLUMN_MAPPING first.")

    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    insert_audit_log(conn,"DELETE","BRM_RULES",rule_id,str(action_by),old_data,None)
    conn.commit()


# ---------------------------------------------------------------------------
# END OF PART 2
# ---------------------------------------------------------------------------
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 3 of 8 (SCHEDULING, SYNC METADATA, SIMULATIONS, ADVANCED TABS)
-----------------------------------------------------------------------------
Builds on:
  - Part 1 (imports/logging/connectors/locks)
  - Part 2 (BFS logic => execute_rules_with_conflicts_composites_bfs, 
            data validations, advanced CRUD)

Includes:
  - Enhanced Scheduling (UI + DB integration)
  - sync_metadata_improved (mark missing tables, capture data types)
  - Single/Chain/Group simulations (dry-run BFS)
  - DecisionTablesTab
  - ConflictPriorityManagerTab
  - CompositeRulesTab
  - SnapshotManagerTab
  - TagsManagerTab
  - DataValidationTab
  - WhatIfTestTab
No references to encryption or secure fields.
"""

import sys
import os
import json
import math
import csv
import logging
import time
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QPushButton, QPlainTextEdit, QLineEdit, QCalendarWidget,
    QTableWidget, QTableWidgetItem, QListWidget, QListWidgetItem,
    QMessageBox, QInputDialog, QTextEdit, QFileDialog, QCheckBox
)
from PyQt5.QtCore import Qt, QDate, QTime
import pyqtgraph as pg


# Assume from Part 2 we have:
#   execute_rules_with_conflicts_composites_bfs(conn, selected_rule_ids=None, skip_data_validation=False, measure_perf=False)
#   run_data_validations_for_table, advanced CRUD, etc.
# from Part 1 we have fetch_one_dict, fetch_all_dict, logger, parse_sql_dependencies, etc.


# ---------------------------------------------------------------------------
# SYNC METADATA (IMPROVED, CAPTURE DATA TYPES)
# ---------------------------------------------------------------------------
def sync_metadata_improved(conn):
    """
    Scan sys.tables + sys.columns => compare with BRM_RULE_TABLE_DEPENDENCIES => if not found => mark MISSING_,
    also attempt to store data type in a new column if your schema has it 
    (like a column "DATA_TYPE" in BRM_RULE_TABLE_DEPENDENCIES).
    
    Example approach:
      1) Gather real (schema.table, column, data_type) from sys.objects + sys.columns.
      2) Compare with BRM_RULE_TABLE_DEPENDENCIES => if mismatch => mark 'MISSING_...' 
         or update DATA_TYPE if you want.
    """
    c = conn.cursor()
    # gather actual tables + columns
    c.execute("""
    SELECT 
        s.name AS schema_name,
        t.name AS table_name,
        c.name AS column_name,
        typ.name AS data_type
    FROM sys.columns c
    JOIN sys.tables t ON c.object_id = t.object_id
    JOIN sys.schemas s ON t.schema_id = s.schema_id
    JOIN sys.types typ ON c.user_type_id = typ.user_type_id
    ORDER BY s.name, t.name, c.column_id
    """)
    actual = []
    for row in c.fetchall():
        sc,tn,col,dt = row
        fulln = f"{sc}.{tn}".lower()
        actual.append((fulln, col.lower(), dt.lower()))

    # build a dict => (schema.table)-> {col->data_type}
    table_map = {}
    for (fulln, col, dt) in actual:
        table_map.setdefault(fulln, {})[col] = dt

    c.execute("SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps = c.fetchall()
    missing_count = 0
    updated_data_type_count = 0

    # We'll assume we've added a column "DATA_TYPE" to BRM_RULE_TABLE_DEPENDENCIES
    # If not, you can remove the data_type update logic.
    for (dep_id, dbn, tbn, coln) in deps:
        # unify
        full_tbl = f"{dbn}.{tbn}".lower().strip(".")
        if full_tbl not in table_map:
            # mark as MISSING_ if not already
            if not tbn.startswith("MISSING_"):
                c.execute("""
                    UPDATE BRM_RULE_TABLE_DEPENDENCIES
                    SET TABLE_NAME='MISSING_' + TABLE_NAME
                    WHERE DEPENDENCY_ID=?
                """,(dep_id,))
                missing_count += 1
        else:
            # check column
            if coln:
                col_low = coln.lower()
                dt_map = table_map[full_tbl]
                if col_low in dt_map:
                    # update data_type if we have that column
                    data_type = dt_map[col_low]
                    try:
                        c.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET DATA_TYPE=? WHERE DEPENDENCY_ID=?",(data_type,dep_id))
                        updated_data_type_count += 1
                    except:
                        pass
                else:
                    # the column might not exist => do nothing or rename
                    pass

    conn.commit()

    msg = (f"Metadata sync complete.\n"
           f"Found {len(table_map)} real tables in sys.tables.\n"
           f"Scanned {len(deps)} dependencies.\n"
           f"Marked {missing_count} references as MISSING_.\n"
           f"Updated data_type for {updated_data_type_count} references.")
    QMessageBox.information(None, "Sync Metadata", msg)


# ---------------------------------------------------------------------------
# SCHEDULING
# ---------------------------------------------------------------------------
class EnhancedScheduleDialog(QDialog):
    """
    Pick rule => pick date/time => store in RULE_SCHEDULES => optional data validation flag.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling (Part 3)")
        self.resize(420, 320)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rr = c.fetchall()
        for (rid, rn) in rr:
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setGridVisible(True)
        self.calendar.setSelectedDate(QDate.currentDate())
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QLineEdit()
        self.time_edit.setPlaceholderText("HH:mm:ss (24-hour format)")
        form.addRow("Select Time:", self.time_edit)

        self.val_cb = QCheckBox("Run Data Validations?")
        form.addRow("Options:", self.val_cb)

        layout.addLayout(form)

        bh = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        dt_ = self.calendar.selectedDate()
        time_str = self.time_edit.text().strip()
        if not time_str:
            time_str="00:00:00"
        # check parse
        qtime = QTime.fromString(time_str, "HH:mm:ss")
        if not qtime.isValid():
            QMessageBox.warning(self,"Invalid Time","Please enter HH:mm:ss in 24h format.")
            return
        dt_str = f"{dt_.toString('yyyy-MM-dd')} {qtime.toString('HH:mm:ss')}"

        c = self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(
          RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP,VALIDATION_FLAG
        )
        VALUES(?,?, 'Scheduled', GETDATE(), ?)
        """,(rid,dt_str, 1 if self.val_cb.isChecked() else 0))
        self.connection.commit()

        QMessageBox.information(self,"Scheduled",f"Rule {rid} at {dt_str} scheduled.")
        self.close()


class ScheduleManagementTab(QWidget):
    """
    Show RULE_SCHEDULES => top 1000 => user can add, update, delete => see if validation_flag is on
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["ScheduleID","RuleID","ScheduleTime","Status","Validate?","Actions"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT TOP 1000
           SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, VALIDATION_FLAG
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            # row => schedule_id, rule_id, schedule_time, status, validation_flag
            self.table.setItem(r_i,0, QTableWidgetItem(str(row[0])))
            self.table.setItem(r_i,1, QTableWidgetItem(str(row[1])))
            self.table.setItem(r_i,2, QTableWidgetItem(str(row[2])))
            self.table.setItem(r_i,3, QTableWidgetItem(str(row[3])))
            self.table.setItem(r_i,4, QTableWidgetItem("Yes" if row[4]==1 else "No"))

            act_w = QWidget()
            hh = QHBoxLayout(act_w)
            hh.setContentsMargins(0,0,0,0)

            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rowix=r_i: self.update_schedule(rowix))
            hh.addWidget(upd_btn)

            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rowix=r_i: self.delete_schedule(rowix))
            hh.addWidget(del_btn)

            hh.addStretch()
            self.table.setCellWidget(r_i,5,act_w)

        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_idx):
        it = self.table.item(row_idx,0)
        if not it:
            return
        sch_id=int(it.text())
        new_dt,ok=QInputDialog.getText(self,"Update","Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated => {new_dt}")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, row_idx):
        it = self.table.item(row_idx,0)
        if not it:
            return
        sch_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()


# ---------------------------------------------------------------------------
# SIMULATIONS (SINGLE, CHAIN, GROUP)
# ---------------------------------------------------------------------------
def do_simulate_single_rule_bfs(conn, rule_id, skip_data_validation=False):
    """
    BFS from a single root => call execute_rules_with_conflicts_composites_bfs
    """
    return execute_rules_with_conflicts_composites_bfs(
        conn, 
        selected_rule_ids=[rule_id], 
        skip_data_validation=skip_data_validation,
        measure_perf=False
    )

def do_simulate_chain_bfs(conn, parent_rule_id, skip_data_validation=False):
    """
    BFS from the given parent => same call
    """
    return execute_rules_with_conflicts_composites_bfs(
        conn, 
        selected_rule_ids=[parent_rule_id],
        skip_data_validation=skip_data_validation,
        measure_perf=False
    )

def do_simulate_custom_group_bfs(conn, custom_group_id, skip_data_validation=False):
    """
    Gather all rules in that custom group => BFS them as multi-root
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
    rows=c.fetchall()
    if not rows:
        return ([], set())  # no rules => nothing
    group_rules = [r[0] for r in rows]
    return execute_rules_with_conflicts_composites_bfs(
        conn,
        selected_rule_ids=group_rules,
        skip_data_validation=skip_data_validation,
        measure_perf=False
    )


class SingleRuleSimulationDialog(QDialog):
    """
    Let user pick 1 rule => BFS => optional skip data validations => show pass/fail.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        self.setWindowTitle("Single Rule Simulation (Part 3)")
        self.resize(500,400)

        layout = QVBoxLayout(self)

        form = QFormLayout()

        self.rule_combo = QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rr=c.fetchall()
        for (rid,rn) in rr:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.skip_val_cb = QCheckBox("Skip Data Validations?")
        form.addRow(self.skip_val_cb)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        run_btn = QPushButton("Run BFS Simulation")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        rid=self.rule_combo.currentData()
        skip_val=self.skip_val_cb.isChecked()
        (executed, skipped)=do_simulate_single_rule_bfs(self.connection, rid, skip_val)
        txt=(f"Executed => {executed}\n"
             f"Skipped => {list(skipped)}")
        self.result_text.setPlainText(txt)


class ChainSimulationDialog(QDialog):
    """
    BFS => pick a parent rule => chain BFS => pass/fail => skip validations?
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Chain Simulation (Part 3)")
        self.resize(500,400)

        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.parent_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rr=c.fetchall()
        for (rid,rn) in rr:
            disp=f"{rid} - {rn}"
            self.parent_combo.addItem(disp, rid)
        form.addRow("Parent Rule:", self.parent_combo)

        self.skip_val_cb=QCheckBox("Skip Data Validations?")
        form.addRow(self.skip_val_cb)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate BFS Chain")
        sim_btn.clicked.connect(self.do_sim)
        bh.addWidget(sim_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        pid=self.parent_combo.currentData()
        skip_val=self.skip_val_cb.isChecked()
        (exed,skp)=do_simulate_chain_bfs(self.connection, pid, skip_val)
        txt=(f"Chain BFS => start={pid}\n"
             f"Executed => {exed}\n"
             f"Skipped => {list(skp)}")
        self.result_text.setPlainText(txt)


class GroupSimulationDialog(QDialog):
    """
    BFS => all rules in a custom group => optionally skip validations.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Custom Group Simulation (Part 3)")
        self.resize(500,400)

        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.grp_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        cg=c.fetchall()
        for (cid,cname) in cg:
            disp=f"{cid} - {cname}"
            self.grp_combo.addItem(disp, cid)
        form.addRow("Custom Group:", self.grp_combo)

        self.skip_val_cb=QCheckBox("Skip Data Validations?")
        form.addRow(self.skip_val_cb)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate BFS Group")
        sim_btn.clicked.connect(self.do_sim)
        bh.addWidget(sim_btn)

        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        cg_id=self.grp_combo.currentData()
        skip_val=self.skip_val_cb.isChecked()
        (exed,skp)=do_simulate_custom_group_bfs(self.connection, cg_id, skip_val)
        txt=(f"Group BFS => group_id={cg_id}\n"
             f"Executed => {exed}\n"
             f"Skipped => {list(skp)}")
        self.result_text.setPlainText(txt)


# ---------------------------------------------------------------------------
# ADVANCED FEATURE TABS
# ---------------------------------------------------------------------------
class DecisionTablesTab(QWidget):
    """
    Manage DECISION_TABLES => plus a Run button that does a BFS or stub pass.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.dt_table=QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels(["DecTableID","TableName","Description"])
        layout.addWidget(self.dt_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete DT")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        run_btn=QPushButton("Run DT")
        run_btn.clicked.connect(self.run_dt)
        bh.addWidget(run_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.dt_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_dt(self):
        nm,ok=QInputDialog.getText(self,"Add DecisionTable","TableName:")
        if not ok or not nm.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION)
            VALUES(?,?)
        """,(nm.strip(),desc.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Decision table created.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No decision table selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Decision table removed.")
        self.load_dt()

    def run_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No decision table selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        # stub
        QMessageBox.information(self,"Run DecisionTable",f"DecisionTable {dt_id} => stub pass.")


class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS => BFS references them. 
    """
    def __init__(self,connection,parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        setp_btn=QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY
            FROM RULE_CONFLICTS
            ORDER BY CONFLICT_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.cf_table.setItem(r_i,col_i,QTableWidgetItem(str(val)))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","RuleID1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","RuleID2:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Enter integer priority:")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY)
            VALUES(?,?,?)
        """,(r1,r2,pri))
        self.connection.commit()
        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            return
        cfid_item=self.cf_table.item(row,0)
        if not cfid_item:
            return
        cf_id=int(cfid_item.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cf_id))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Conflict priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            return
        it=self.cf_table.item(row,0)
        if not it:
            return
        cf_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()


class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES => BFS references them as adjacency from sub-rule => composite
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CompositeRuleID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Composite Rule")
        addb.clicked.connect(self.add_composite)
        bh.addWidget(addb)

        delb=QPushButton("Delete Composite")
        delb.clicked.connect(self.del_composite)
        bh.addWidget(delb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_composites)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.cr_table.rowCount()
            self.cr_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.cr_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_composite(self):
        nm,ok=QInputDialog.getText(self,"Add Composite","Composite Name:")
        if not ok or not nm.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expr","(e.g. 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","(Optional) e.g. 'SendEmail'")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(
          CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
        )
        VALUES(?,?,?)
        """,(nm.strip(), expr.strip(), act.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Composite rule created.")
        self.load_composites()

    def del_composite(self):
        row=self.cr_table.currentRow()
        if row<0:
            return
        it=self.cr_table.item(row,0)
        if not it:
            return
        cid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_composites()


class SnapshotManagerTab(QWidget):
    """
    Snapshots => store entire BRM_RULES as JSON => restore reference
    """
    def __init__(self,connection,parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["SnapshotID","SNAPSHOT_NAME","CREATED_BY","CREATED_TIMESTAMP","SNAPSHOT_JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snapshot)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
            FROM RULE_SNAPSHOTS
            ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.ss_table.rowCount()
            self.ss_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.ss_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def take_snapshot(self):
        nm,ok=QInputDialog.getText(self,"Snapshot","Snapshot name:")
        if not ok or not nm.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        cols=[desc[0] for desc in c.description]
        data_list=[]
        for rr in rows:
            data_list.append(dict(zip(cols,rr)))
        snap_json=json.dumps(data_list, indent=2)

        c.execute("""
            INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
            VALUES(?,?,?)
        """,(nm.strip(),"SnapshotUser",snap_json))
        self.connection.commit()
        QMessageBox.information(self,"Snapshot","Snapshot created.")
        self.load_snapshots()

    def del_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            return
        it=self.ss_table.item(row,0)
        if not it:
            return
        sid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Snapshot removed.")
        self.load_snapshots()


class TagsManagerTab(QWidget):
    """
    Manage RULE_TAGS => textual tags => BFS or search can use them in advanced approaches
    """
    def __init__(self,connection,parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows=c.fetchall()
        for row in rows:
            r_i=self.tags_table.rowCount()
            self.tags_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.tags_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            return
        it=self.tags_table.item(row,0)
        if not it:
            return
        tid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()


class DataValidationTab(QWidget):
    """
    Manage DATA_VALIDATIONS => user can run them manually => show pass/fail
    """
    def __init__(self,connection,parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Validation")
        addb.clicked.connect(self.add_val)
        bh.addWidget(addb)

        delb=QPushButton("Remove Validation")
        delb.clicked.connect(self.remove_val)
        bh.addWidget(delb)

        runb=QPushButton("Run All Validations")
        runb.clicked.connect(self.run_all_validations)
        bh.addWidget(runb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_vals)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
        ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.dv_table.rowCount()
            self.dv_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.dv_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name (e.g. 'dbo.Customers'):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'NOT NULL','RANGE','REGEX'):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional) param string (e.g. '0,100'):")
        if not ok4:
            pars=""

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(
          TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
        )
        VALUES(?,?,?,?)
        """,(tbl.strip(),col.strip(),vtype.strip(),pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Data validation rule added.")
        self.load_vals()

    def remove_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

    def run_all_validations(self):
        # gather distinct tables
        c=self.connection.cursor()
        c.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        trows=c.fetchall()

        fails=[]
        for (tn,) in trows:
            if tn:
                pass_ok = run_data_validations_for_table(self.connection, tn.lower())
                if not pass_ok:
                    fails.append(tn)
        if fails:
            QMessageBox.warning(self,"Validation Results",f"Some validations failed => {fails}")
        else:
            QMessageBox.information(self,"Validation Results","All validations passed.")


# ---------------------------------------------------------------------------
# WHAT-IF TESTING TAB
# ---------------------------------------------------------------------------
class WhatIfTestTab(QWidget):
    """
    Let user pick a rule => BFS or single-run => optionally skip validations => upload CSV => show pass/fail
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.csv_path=None

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        self.bfs_cb=QCheckBox("Use BFS Execution?")
        top_h.addWidget(self.bfs_cb)

        self.skip_val_cb=QCheckBox("Skip Validations?")
        top_h.addWidget(self.skip_val_cb)
        top_h.addStretch()
        layout.addLayout(top_h)

        mid_h=QHBoxLayout()
        up_btn=QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        mid_h.addWidget(up_btn)

        run_btn=QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        mid_h.addWidget(run_btn)
        mid_h.addStretch()
        layout.addLayout(mid_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if not path:
            return
        self.csv_path=path
        QMessageBox.information(self,"Uploaded",f"CSV {path} chosen. (Stub: no auto loading)")

    def run_test(self):
        rid=self.rule_combo.currentData()
        use_bfs=self.bfs_cb.isChecked()
        skip_val=self.skip_val_cb.isChecked()

        if use_bfs:
            (exed,skp) = execute_rules_with_conflicts_composites_bfs(
                self.connection,
                selected_rule_ids=[rid],
                skip_data_validation=skip_val,
                measure_perf=False
            )
            msg=(f"BFS => executed={exed}\n"
                 f"skipped={list(skp)}\n"
                 f"CSV={self.csv_path if self.csv_path else 'None'}")
        else:
            # single-run => run dry => interpret pass/fail
            from time import perf_counter
            c=self.connection.cursor()
            c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            row=c.fetchone()
            if not row:
                self.result_text.setPlainText(f"Rule {rid} not found.")
                return
            sql_=row[0]
            # do validations if skip_val==False
            if not skip_val:
                c2=self.connection.cursor()
                c2.execute("SELECT DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
                trows=c2.fetchall()
                for (dbn,tb) in trows:
                    if tb:
                        fulln=(dbn+"."+tb).lower()
                        passok=run_data_validations_for_table(self.connection,fulln)
                        if not passok:
                            self.result_text.setPlainText(f"Data validation failed for {fulln} => skip rule.")
                            return

            start=perf_counter()
            success=False
            msg_=""
            rec_count=0
            c.execute("BEGIN TRANSACTION")
            try:
                c.execute(sql_)
                rows_=c.fetchall()
                if rows_:
                    rec_count=len(rows_)
                    val=rows_[0][0]
                    success=(val==1)
                    msg_=f"Returned: {val}"
                else:
                    success=True
                    msg_="No rows => PASS"
                c.execute("ROLLBACK")
            except Exception as ex:
                c.execute("ROLLBACK")
                success=False
                msg_=str(ex)
            elapsed_ms=int((perf_counter()-start)*1000)
            msg=(f"Single => pass={success}, message={msg_}, rec_count={rec_count}, time={elapsed_ms} ms\n"
                 f"CSV={self.csv_path if self.csv_path else 'None'}")

        self.result_text.setPlainText(msg)
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 4 of 8 (AUDIT LOG VIEWER, RULE SEARCH, VERSION HISTORY, RULE DASHBOARD, RULE EDITOR)
--------------------------------------------------------------------------------------------------
Builds on:
  - Part 1 (core imports, DB connection, locks)
  - Part 2 (BFS logic, advanced CRUD, data validations)
  - Part 3 (scheduling, sync metadata, advanced tabs)
  
Includes:
  - Extended AuditLogViewer
  - Extended RuleSearchDialog
  - VersionHistoryDialog (with line-by-line diffs + optional rollback)
  - RuleDashboard (with lock status, performance stats column, pagination)
  - RuleEditorDialog (with lock/unlock logic, table-permission checks, multi-step approvals)
"""

import sys
import json
import csv
import math
import difflib
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QLineEdit, QMessageBox, QFileDialog, QPlainTextEdit,
    QInputDialog, QComboBox, QTextEdit, QDateTimeEdit, QFormLayout,
    QGroupBox, QWidget, QVBoxLayout, QHBoxLayout, QCheckBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

# Assume from prior parts:
#   fetch_one_dict, fetch_all_dict, insert_audit_log, parse_sql_dependencies, detect_operation_type
#   rule_current_lock_owner, lock_rule_for_edit, unlock_rule_for_edit
#   add_rule, update_rule, deactivate_rule, delete_rule, force_activate_rule, force_deactivate_rule
#   create_multistep_approvals, ...
#   RULE_LIFECYCLE_STATES
#   user_has_table_permission => from Part 2
#   multi-level approvals => from Part 2
#   Possibly no encryption references
#   BFS is in Part 2 => not used here

# ---------------------------------------------------------------------------
# AUDIT LOG VIEWER
# ---------------------------------------------------------------------------
class AuditLogViewer(QDialog):
    """
    Displays BRM_AUDIT_LOG => extended search => CSV export => optional color highlighting 
    for actions like DELETE or REJECT.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs (Part 4)")
        self.resize(900,600)

        main_layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search in action, table, actor, or old/new data..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.log_table = QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.log_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        csv_btn=QPushButton("Export CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)

        bh.addStretch()
        main_layout.addLayout(bh)
        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT TOP 1000
              AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
              OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                # parse JSON if old/new
                if col_i in (5,6) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                it=QTableWidgetItem(str(val) if val else "")
                # color highlight if action is e.g. DELETE or REJECT
                if col_i==1:
                    action_val=(val or "").upper()
                    if action_val in ("DELETE","REJECT","FORCE_DEACTIVATE"):
                        it.setBackground(QColor(255,215,0))
                self.log_table.setItem(r_i,col_i,it)

        self.log_table.resizeColumnsToContents()

    def perform_search(self, text):
        txt=text.lower()
        for row_i in range(self.log_table.rowCount()):
            row_visible=False
            for col_i in range(self.log_table.columnCount()):
                it=self.log_table.item(row_i,col_i)
                if it and txt in it.text().lower():
                    row_visible=True
                    break
            self.log_table.setRowHidden(row_i, not row_visible)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export Audit Logs CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row_i in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row_i):
                    continue
                row_data=[]
                for col_i in range(self.log_table.columnCount()):
                    it=self.log_table.item(row_i,col_i)
                    row_data.append(it.text() if it else "")
                writer.writerow(row_data)
        QMessageBox.information(self,"Exported",f"Audit logs exported to {path}.")


# ---------------------------------------------------------------------------
# RULE SEARCH DIALOG
# ---------------------------------------------------------------------------
class RuleSearchDialog(QDialog):
    """
    Search rules by name, SQL snippet, or tags => up to 1000
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules (Part 4)")
        self.resize(900,600)

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Name, SQL snippet, or tag..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.res_table=QTableWidget(0,8)
        self.res_table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","OwnerGroup","Tags","CreatedBy"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.res_table)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        main_layout.addWidget(ref_btn)

        self.setLayout(main_layout)
        self.load_results()

    def load_results(self):
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
                SELECT DISTINCT TOP 1000
                  R.RULE_ID, R.RULE_NAME, R.RULE_SQL, R.STATUS,
                  R.VERSION, R.OWNER_GROUP,
                  (SELECT STRING_AGG(T.TAG_NAME, ',')
                   FROM RULE_TAGS T
                   WHERE T.RULE_ID=R.RULE_ID) as TAGS,
                  R.CREATED_BY
                FROM BRM_RULES R
                LEFT JOIN RULE_TAGS TT ON TT.RULE_ID=R.RULE_ID
                WHERE (R.RULE_NAME LIKE ? OR R.RULE_SQL LIKE ?
                       OR TT.TAG_NAME LIKE ?)
                ORDER BY R.RULE_ID DESC
            """,(f"%{txt}%", f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
                SELECT TOP 1000
                  R.RULE_ID, R.RULE_NAME, R.RULE_SQL, R.STATUS,
                  R.VERSION, R.OWNER_GROUP,
                  (SELECT STRING_AGG(T.TAG_NAME, ',')
                   FROM RULE_TAGS T
                   WHERE T.RULE_ID=R.RULE_ID) as TAGS,
                  R.CREATED_BY
                FROM BRM_RULES R
                ORDER BY R.RULE_ID DESC
            """)
        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_i=self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.res_table.setItem(r_i,col_i,it)

        self.res_table.resizeColumnsToContents()


# ---------------------------------------------------------------------------
# VERSION HISTORY DIALOG (line-by-line diffs + optional rollback)
# ---------------------------------------------------------------------------
class VersionHistoryDialog(QDialog):
    """
    Show audit trail for a single rule => let user do line-by-line compare.
    Also optionally do a forced rollback if the user has permission (i.e. admin).
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(900,500)

        main_layout=QVBoxLayout(self)

        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData","Compare"])
        self.table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb_btn=QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.do_rollback)
        bh.addWidget(rb_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        # We filter by TABLE_NAME='BRM_RULES', RECORD_ID=rule_id, ACTION in (INSERT,UPDATE) for a version chain
        c.execute("""
            SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
            FROM BRM_AUDIT_LOG
            WHERE TABLE_NAME='BRM_RULES'
              AND RECORD_ID=?
              AND ACTION IN ('INSERT','UPDATE')
            ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            # row => (audit_id, action, action_ts, old_data, new_data)
            for col_i,val in enumerate(row):
                if col_i in (3,4) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)

            # "Compare" button
            cmp_btn=QPushButton("Diff")
            cmp_btn.clicked.connect(lambda _,ridx=r_i: self.do_compare(ridx))
            self.table.setCellWidget(r_i,5,cmp_btn)

    def do_compare(self, row_idx):
        old_item=self.table.item(row_idx,3)
        new_item=self.table.item(row_idx,4)
        old_str=old_item.text() if old_item else ""
        new_str=new_item.text() if new_item else ""

        old_lines=old_str.splitlines()
        new_lines=new_str.splitlines()
        diff=difflib.unified_diff(
            old_lines, new_lines,
            fromfile="old_data", tofile="new_data", lineterm=''
        )
        diff_str="\n".join(diff)

        dlg=QDialog(self)
        dlg.setWindowTitle("Line-by-Line Diff")
        dlg.resize(800,600)
        lay=QVBoxLayout(dlg)
        txt=QPlainTextEdit()
        txt.setReadOnly(True)
        txt.setPlainText(diff_str)
        lay.addWidget(txt)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        lay.addWidget(cb)
        dlg.setLayout(lay)
        dlg.exec_()

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected to rollback.")
            return
        row_i=sel[0].row()
        old_data_item=self.table.item(row_i,3)
        if not old_data_item:
            QMessageBox.warning(self,"Empty","No old_data found => cannot rollback.")
            return
        old_data_str=old_data_item.text().strip()
        if not old_data_str:
            QMessageBox.warning(self,"No OldData","No old_data => cannot rollback.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to this version?")
        if confirm!=QMessageBox.Yes:
            return
        # parse old_data
        try:
            old_json=json.loads(old_data_str)
        except Exception as ex:
            QMessageBox.critical(self,"JSON Error",str(ex))
            return
        ok=self.do_force_rollback_rule(old_json)
        if ok:
            QMessageBox.information(self,"Rolled Back","Rule successfully rolled back.")
            self.load_history()
        else:
            QMessageBox.warning(self,"Failed","Rollback failed or not allowed.")

    def do_force_rollback_rule(self, old_data):
        """
        Minimal approach => forcibly sets the rule fields => sets status=INACTIVE => re-approval => re-parse deps.
        We call update logic from Part 2 or do direct approach. We'll do a direct approach for demonstration.
        """
        rid=old_data.get("RULE_ID")
        if not rid:
            return False

        # check if user is admin or lock
        # We'll do a simplified approach => only admin can do force rollback
        # Real approach might require you to lock the rule or be admin
        # We'll assume we are admin in this example
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            return False

        old_sql=old_data.get("RULE_SQL","")
        from .part1_core import parse_sql_dependencies, detect_operation_type  # if single-file, direct

        op_type=detect_operation_type(old_sql)
        deps=parse_sql_dependencies(old_sql)

        c.execute("BEGIN TRANSACTION")
        try:
            c.execute("""
                UPDATE BRM_RULES
                SET RULE_NAME=?,
                    RULE_SQL=?,
                    OWNER_GROUP=?,
                    STATUS='INACTIVE',
                    VERSION=VERSION+1,
                    UPDATED_BY='Rollback',
                    APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                    LIFECYCLE_STATE='UNDER_APPROVAL'
                WHERE RULE_ID=?
            """,(
                old_data.get("RULE_NAME","RolledBack"),
                old_sql,
                old_data.get("OWNER_GROUP","BG1"),
                rid
            ))
            c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
            col_op="READ" if op_type=="SELECT" else "WRITE"
            for (sch,tb,alias,is_sub) in deps["tables"]:
                if tb and not tb.startswith("(CTE)"):
                    dbn=sch if sch else "dbo"
                    c.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                          RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                        )
                        VALUES(?,?,?,?,?)
                    """,(rid,dbn,tb,"RolledBackCol", col_op))

            c.execute("COMMIT")
            return True
        except:
            c.execute("ROLLBACK")
            return False


# ---------------------------------------------------------------------------
# RULE DASHBOARD
# ---------------------------------------------------------------------------
class RuleDashboard(QGroupBox):
    """
    Paginated & filterable table => columns for lock status, performance stats, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL..")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)

        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,10)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","OwnerGroup",
            "LockStatus","Perf(ms avg)","CreatedTS","ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_clause(self):
        filters=[]
        pars=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            pars.extend([f"%{txt}%",f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            pars.append(st)
        if filters:
            clause=" AND ".join(filters)
        else:
            clause="1=1"
        return (clause,pars)

    def load_rules(self):
        c=self.connection.cursor()
        clause,pars=self.build_filter_clause()
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, pars)
        rowc=c.fetchone()
        total=rowc[0] if rowc else 0
        self.total_pages=max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page
        data_q=f"""
        SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
               LOCK_STATUS, PERF_MS_AVG, CREATED_TIMESTAMP, APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*pars, offset, self.records_per_page))
        rows=c.fetchall()

        self.rule_table.setRowCount(0)
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val is not None else "")
                # color highlight for status or lock
                if col_i==6 and val and str(val).upper()=="LOCKED":
                    it.setBackground(QColor(255,160,160))
                self.rule_table.setItem(r_i,col_i,it)

        self.rule_table.resizeColumnsToContents()

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

    def get_selected_rule_ids(self):
        """
        Return list of rule_ids based on selected rows in the table (column 0).
        """
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out


# ---------------------------------------------------------------------------
# RULE EDITOR DIALOG
# ---------------------------------------------------------------------------
class RuleEditorDialog(QDialog):
    """
    Add or Update a rule => includes lock/unlock logic for update, multi-step approvals triggered, 
    table-level permission checks, no encryption references.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)
        self.rule_locked=False

        title="Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title+" (Part 4)")
        self.resize(850,650)

        main_layout=QVBoxLayout(self)
        form_layout=QFormLayout()

        # group combo
        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grows=c.fetchall()
        for (gid,gname) in grows:
            disp=f"{gname} (ID={gid})"
            self.group_combo.addItem(disp,gid)
        form_layout.addRow("Rule Group:", self.group_combo)

        # parent combo
        self.parent_combo=QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        prow=c.fetchall()
        for (rid,rn) in prow:
            disp2=f"{rn} (ID={rid})"
            self.parent_combo.addItem(disp2,rid)
        form_layout.addRow("Parent Rule:", self.parent_combo)

        # name
        self.name_edit=QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        # rule_type
        self.rule_type_combo=QComboBox()
        c.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        rtrows=c.fetchall()
        for (rt_id,rt_name) in rtrows:
            self.rule_type_combo.addItem(rt_name, rt_id)
        form_layout.addRow("Rule Type:", self.rule_type_combo)

        # status
        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        # date/time
        self.start_dt=QDateTimeEdit()
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_layout.addRow("Effective Start:", self.start_dt)

        self.end_dt=QDateTimeEdit()
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_layout.addRow("Effective End:", self.end_dt)

        # cdc
        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_layout.addRow("CDC Type:", self.cdc_combo)

        # sql
        self.sql_edit=QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => pass, else 0 => fail.")
        form_layout.addRow("Rule SQL:", self.sql_edit)

        # desc
        self.desc_edit=QTextEdit()
        form_layout.addRow("Description:", self.desc_edit)

        # justification
        self.just_edit=QTextEdit()
        form_layout.addRow("Business Justification:", self.just_edit)

        # global
        self.global_cb=QCheckBox("Global?")
        form_layout.addRow("Global:", self.global_cb)

        # critical
        self.critical_cb=QCheckBox("Critical Rule?")
        form_layout.addRow("Critical:", self.critical_cb)

        # scope
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_layout.addRow("Critical Scope:", self.scope_combo)

        main_layout.addLayout(form_layout)

        bh=QHBoxLayout()
        self.save_btn=QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)

        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(cancel_btn)

        if self.is_update:
            self.lock_btn=QPushButton("Lock for Edit")
            self.lock_btn.clicked.connect(self.lock_rule)
            bh.addWidget(self.lock_btn)

            self.unlock_btn=QPushButton("Unlock")
            self.unlock_btn.setEnabled(False)
            self.unlock_btn.clicked.connect(self.unlock_rule)
            bh.addWidget(self.unlock_btn)

        bh.addStretch()
        main_layout.addLayout(bh)
        self.setLayout(main_layout)

        if self.is_update and self.rule_data:
            self.load_existing()

    def load_existing(self):
        rd=self.rule_data
        # group
        gid=rd.get("GROUP_ID")
        if gid:
            ix=self.group_combo.findData(gid)
            if ix>=0:
                self.group_combo.setCurrentIndex(ix)

        # parent
        pid=rd.get("PARENT_RULE_ID")
        if pid:
            ix2=self.parent_combo.findData(pid)
            if ix2>=0:
                self.parent_combo.setCurrentIndex(ix2)

        self.name_edit.setText(rd.get("RULE_NAME",""))
        # rule_type
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3=self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)

        st=rd.get("STATUS","INACTIVE")
        i_st=self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        fmt="%Y-%m-%d %H:%M:%S"
        sd=rd.get("EFFECTIVE_START_DATE","")
        ed=rd.get("EFFECTIVE_END_DATE","")
        if sd:
            try:
                dt_s=datetime.strptime(sd,fmt)
                self.start_dt.setDateTime(dt_s)
            except:
                pass
        if ed:
            try:
                dt_e=datetime.strptime(ed,fmt)
                self.end_dt.setDateTime(dt_e)
            except:
                pass

        cdcv=rd.get("CDC_TYPE","NONE").upper()
        ic=self.cdc_combo.findText(cdcv)
        if ic>=0:
            self.cdc_combo.setCurrentIndex(ic)

        if rd.get("RULE_SQL"):
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        self.global_cb.setChecked(bool(rd.get("IS_GLOBAL",0)))
        self.critical_cb.setChecked(bool(rd.get("CRITICAL_RULE",0)))

        scp=rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp=self.scope_combo.findText(scp)
        if i_scp>=0:
            self.scope_combo.setCurrentIndex(i_scp)

    def save_rule(self):
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","Rule name required.")
            return

        rule_sql=self.sql_edit.toPlainText().strip()
        group_id=self.group_combo.currentData()
        parent_id=self.parent_combo.currentData()
        rtid=self.rule_type_combo.currentData()
        st=self.status_combo.currentText()
        sd_str=self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        ed_str=self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_=self.cdc_combo.currentText().upper()
        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()

        isg=1 if self.global_cb.isChecked() else 0
        isc=1 if self.critical_cb.isChecked() else 0
        scp_=self.scope_combo.currentText().upper()

        # gather group name
        grp_name=None
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?",(group_id,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing","Group ID not found in BRM_RULE_GROUPS.")
            return
        grp_name=row[0]

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rtid,
            "RULE_NAME": nm,
            "RULE_SQL": rule_sql,
            "EFFECTIVE_START_DATE": sd_str,
            "EFFECTIVE_END_DATE": ed_str,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdc_,
            "OWNER_GROUP": grp_name
        }

        # If update
        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            confirm=QMessageBox.question(self,"Confirm","Update rule now?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, "CurrentUserID", self.user_group)
                QMessageBox.information(self,"Updated","Rule updated => re-approval triggered.")
                # unlock automatically
                if self.rule_locked:
                    self.unlock_rule()
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule now?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id=add_rule(self.connection, rule_dict, "CurrentUserID", self.user_group)
                QMessageBox.information(self,"Created",f"New rule ID={new_id} => approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))

    def lock_rule(self):
        if not self.is_update or not self.rule_data:
            QMessageBox.warning(self,"No update","Lock only for existing rule in update mode.")
            return
        rid=self.rule_data["RULE_ID"]
        # must call lock_rule_for_edit => unless admin force
        try:
            lock_rule_for_edit(self.connection, rid, "CurrentUserID", force=False, user_group=self.user_group)
            QMessageBox.information(self,"Locked",f"Rule {rid} locked by you.")
            self.rule_locked=True
            self.lock_btn.setEnabled(False)
            self.unlock_btn.setEnabled(True)
        except Exception as ex:
            QMessageBox.critical(self,"Lock Error",str(ex))

    def unlock_rule(self):
        if not self.is_update or not self.rule_data:
            return
        rid=self.rule_data["RULE_ID"]
        try:
            unlock_rule_for_edit(self.connection, rid, "CurrentUserID", admin_override=False, user_group=self.user_group)
            QMessageBox.information(self,"Unlocked",f"Rule {rid} unlocked.")
            self.rule_locked=False
            self.lock_btn.setEnabled(True)
            self.unlock_btn.setEnabled(False)
        except Exception as ex:
            QMessageBox.critical(self,"Unlock Error",str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 5 of 8 (APPROVALS, GLOBAL/CRITICAL ADMIN, HIERARCHY, ENHANCED LINEAGE)
-----------------------------------------------------------------------------
Builds on:
  - Part 1 (core imports/logging/connectors/locks)
  - Part 2 (BFS logic, advanced CRUD + validations)
  - Part 3 (scheduling, sync metadata, advanced tabs)
  - Part 4 (audit logs, rule search, version history, dashboard, editor)

Includes:
  - MultiStepApprovalTab (enhanced multi-level approvals, color-coded pipeline)
  - GlobalCriticalAdminTab (admin => set global/critical + link/unlink child rules)
  - HierarchyViewTab (drag & drop group->rule => DB updates, re-approval if needed)
  - EnhancedLineageGraphWidget (ER-style boxes with advanced search & optional data validation triggers)
"""

import sys
import json
import math
import logging
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QCheckBox, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu, QInputDialog,
    QFileDialog, QGraphicsView, QGraphicsScene, QGraphicsItem, QPlainTextEdit
)
from PyQt5.QtCore import Qt, QPoint, QRectF
from PyQt5.QtGui import QBrush, QColor, QPen, QPainter, QPainterPath

# We assume from prior parts:
#   - multi-step approval logic: create_multistep_approvals, minimal stage check, lock checks
#   - lock_rule_for_edit, unlock_rule_for_edit, rule_current_lock_owner
#   - BFS logic for GCR (global-critical links), conflict, composite from Part 2
#   - logging, fetch_all_dict, fetch_one_dict, insert_audit_log, parse_sql_dependencies, run_data_validations_for_table, etc.


# ---------------------------------------------------------------------------
# MULTI-STEP APPROVAL TAB
# ---------------------------------------------------------------------------
class MultiStepApprovalTab(QWidget):
    """
    Display pending approvals for current user, color-coded pipeline:
    - Also show a color-coded chain “BG1->BG2->FINAL” if your domain uses that approach
    - Let user Approve/Reject
    - If admin => Force Unlock button
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.approval_table = QTableWidget(0,9)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","GroupName","RuleName","Stage","Approved?","ColorPipeline","Approve","Reject","ForceUnlock"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        self.approval_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.approval_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c=self.connection.cursor()
        # get all unapproved for user
        c.execute("""
          SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, 
                 A.APPROVAL_STAGE, R.RULE_NAME
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
          ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()

        # find minimal stage per rule
        minimal_stage={}
        rid_map={}
        for r_ in rows:
            rid_map.setdefault(r_[0],[]).append(r_)
        for rid in rid_map.keys():
            c2=self.connection.cursor()
            c2.execute("""
              SELECT MIN(APPROVAL_STAGE)
              FROM BRM_RULE_APPROVALS
              WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid,))
            rowx=c2.fetchone()
            if rowx and rowx[0]:
                minimal_stage[rid]=rowx[0]
            else:
                minimal_stage[rid]=None  # fully approved?

        # filter => only show rows where stage== minimal
        display_rows=[]
        for row in rows:
            rid,grpname,usr,ap_flag,ap_stage,rnm = row
            if minimal_stage[rid]==ap_stage:
                display_rows.append((rid,grpname,rnm,ap_stage,ap_flag,usr))

        for row_data in display_rows:
            rid=row_data[0]
            grpname=row_data[1]
            rnm=row_data[2]
            stage=row_data[3]
            apf=row_data[4]
            usern=row_data[5]

            r_i=self.approval_table.rowCount()
            self.approval_table.insertRow(r_i)
            self.approval_table.setItem(r_i,0, QTableWidgetItem(str(rid)))
            self.approval_table.setItem(r_i,1, QTableWidgetItem(str(grpname)))
            self.approval_table.setItem(r_i,2, QTableWidgetItem(str(rnm)))
            self.approval_table.setItem(r_i,3, QTableWidgetItem(str(stage)))
            self.approval_table.setItem(r_i,4, QTableWidgetItem(str(apf)))

            # color pipeline => e.g. BG1 -> BG2 -> FINAL. We can do a small text or color-coded rect.
            pipe_item=QTableWidgetItem(self.get_pipeline_colors(rid))
            self.approval_table.setItem(r_i,5, pipe_item)

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _,rowix=r_i: self.do_approve(rowix))
            self.approval_table.setCellWidget(r_i,6,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _,rowix=r_i: self.do_reject(rowix))
            self.approval_table.setCellWidget(r_i,7,reject_btn)

            fu_btn=QPushButton("ForceUnlock")
            if self.user_group!="Admin":
                fu_btn.setEnabled(False)
            else:
                fu_btn.clicked.connect(lambda _,rowix=r_i: self.do_force_unlock(rowix))
            self.approval_table.setCellWidget(r_i,8,fu_btn)

        self.approval_table.resizeColumnsToContents()

    def get_pipeline_colors(self, rule_id):
        """
        Optional method => retrieve entire pipeline => color-code who approved vs pending
        E.g. "BG1(approved)->BG2(pending)->FINAL(not assigned)"
        """
        c=self.connection.cursor()
        c.execute("""
          SELECT GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE
          FROM BRM_RULE_APPROVALS
          WHERE RULE_ID=?
          ORDER BY APPROVAL_STAGE, USERNAME
        """,(rule_id,))
        rows=c.fetchall()
        # we can group by stage
        stage_map={}
        for (grp,usr,af,st) in rows:
            stage_map.setdefault(st,[]).append((grp,usr,af))

        pipeline=[]
        stages=sorted(stage_map.keys())
        for st in stages:
            chunk=stage_map[st]
            # if any in chunk => if one is approved => or all pending => depends on domain
            # we'll just build a small textual chunk
            chunk_txt=[]
            for (g,u,a) in chunk:
                if a==1:
                    chunk_txt.append(f"{g}:{u}(OK)")
                elif a==2:
                    chunk_txt.append(f"{g}:{u}(REJECT)")
                else:
                    chunk_txt.append(f"{g}:{u}(PEND)")
            stage_str=" / ".join(chunk_txt)
            pipeline.append(f"[{st}] {stage_str}")
        return " -> ".join(pipeline)

    def do_approve(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=grp_item.text()

        c=self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
          WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))

        # check if more needed
        nxt=self.get_minimal_stage_unapproved(rid)
        if nxt is None:
            # all approved
            c.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS='APPROVED',
                  STATUS='ACTIVE',
                  LIFECYCLE_STATE='ACTIVE'
              WHERE RULE_ID=?
            """,(rid,))
        else:
            c.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                  STATUS='INACTIVE'
              WHERE RULE_ID=?
            """,(rid,))

        insert_audit_log(self.connection,"APPROVE","BRM_RULE_APPROVALS",rid,self.logged_in_username,{"approved_flag":0},{"approved_flag":1})
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} => Approved.")
        self.load_approvals()

    def get_minimal_stage_unapproved(self, rule_id):
        c=self.connection.cursor()
        c.execute("""
          SELECT MIN(APPROVAL_STAGE)
          FROM BRM_RULE_APPROVALS
          WHERE RULE_ID=?
            AND APPROVED_FLAG=0
        """,(rule_id,))
        row=c.fetchone()
        if row and row[0]:
            return row[0]
        return None

    def do_reject(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=grp_item.text()
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
          WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))

        c.execute("""
          UPDATE BRM_RULES
          SET APPROVAL_STATUS='REJECTED',
              STATUS='INACTIVE',
              LIFECYCLE_STATE='INACTIVE'
          WHERE RULE_ID=?
        """,(rid,))

        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"rejected":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} => Rejected.")
        self.load_approvals()

    def do_force_unlock(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        if not rid_item:
            return
        rid=int(rid_item.text())
        confirm=QMessageBox.question(self,"Force Unlock",f"Force unlock rule {rid}? (Admin only)")
        if confirm!=QMessageBox.Yes:
            return
        try:
            unlock_rule_for_edit(self.connection, rid, "AdminOverride", admin_override=True, user_group=self.user_group)
            QMessageBox.information(self,"Unlocked",f"Rule {rid} forcibly unlocked by admin.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


# ---------------------------------------------------------------------------
# GLOBAL/CRITICAL ADMIN TAB
# ---------------------------------------------------------------------------
class GlobalCriticalAdminTab(QWidget):
    """
    Admin => set a rule as global or critical => manage scope => link/unlink child in BRM_GLOBAL_CRITICAL_LINKS
    """
    def __init__(self, main_window, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_window=main_window
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)

        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_h=QHBoxLayout()
        self.show_only_gcr=QCheckBox("Show only GCR rules")
        self.show_only_gcr.setChecked(True)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(self.show_only_gcr)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IS_GLOBAL","CRITICAL_RULE",
            "CRITICAL_SCOPE","STATUS","LOCK_STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        flags_h=QHBoxLayout()
        self.global_cb=QCheckBox("Set Global?")
        flags_h.addWidget(self.global_cb)
        self.critical_cb=QCheckBox("Set Critical?")
        flags_h.addWidget(self.critical_cb)

        flags_h.addWidget(QLabel("Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        flags_h.addWidget(self.scope_combo)

        apply_btn=QPushButton("Apply to Selected")
        apply_btn.clicked.connect(self.apply_flags)
        flags_h.addWidget(apply_btn)
        flags_h.addStretch()
        layout.addLayout(flags_h)

        link_h=QHBoxLayout()
        self.gcr_parent_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_parent_combo)

        self.gcr_child_combo=QComboBox()
        link_h.addWidget(QLabel("Child:"))
        link_h.addWidget(self.gcr_child_combo)

        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(link_btn)
        link_h.addWidget(unlink_btn)
        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["ParentGCR","ChildRule"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref2_btn=QPushButton("Refresh All")
        ref2_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref2_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_parent_combo()
        self.populate_child_combo()
        self.load_links()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,LOCK_STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,LOCK_STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.rule_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def populate_parent_combo(self):
        self.gcr_parent_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.gcr_parent_combo.addItem(disp, rid)

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.gcr_child_combo.addItem(disp, rid)

    def load_links(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def get_selected_rules(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def apply_flags(self):
        sel=self.get_selected_rules()
        if not sel:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        is_global=1 if self.global_cb.isChecked() else 0
        is_crit=1 if self.critical_cb.isChecked() else 0
        scope_val=self.scope_combo.currentText().upper()

        confirm=QMessageBox.question(
            self,"Confirm",
            f"Set is_global={is_global}, critical={is_crit}, scope={scope_val} for {len(sel)} rule(s)?"
        )
        if confirm!=QMessageBox.Yes:
            return

        c=self.connection.cursor()
        for rid in sel:
            # forcibly unlock if locked
            unlock_rule_for_edit(self.connection, rid, "AdminOverride", admin_override=True, user_group=self.user_group)
            c.execute("""
                UPDATE BRM_RULES
                SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
                WHERE RULE_ID=?
            """,(is_global, is_crit, scope_val, rid))
        c.commit()
        QMessageBox.information(self,"Updated",f"Flags updated for {len(sel)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            QMessageBox.warning(self,"Missing","Pick both parent and child.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID)
            VALUES(?,?)
        """,(pid,cid))
        insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"p":pid,"c":cid})
        c.commit()
        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_links()

    def unlink_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            QMessageBox.warning(self,"Missing","Pick both parent and child.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
            WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
        """,(pid,cid))
        insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",{"p":pid,"c":cid},None)
        c.commit()
        QMessageBox.information(self,"Unlinked",f"Child {cid} from {pid}.")
        self.load_links()


# ---------------------------------------------------------------------------
# HIERARCHY VIEW TAB
# ---------------------------------------------------------------------------
class HierarchyViewTab(QTreeWidget):
    """
    Show group->rules in a tree => user can drag a rule under new parent => DB update => sets PARENT_RULE_ID + re-approval
    We'll forcibly unlock if needed. Admin can do that, or we can require the same user lock.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule (Part 5)"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)

        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        groups=c.fetchall()
        self.gid_map={}
        for (gid,gname) in groups:
            top=QTreeWidgetItem([f"{gname} (ID={gid})"])
            top.setData(0,Qt.UserRole,("group",gid))
            self.addTopLevelItem(top)
            self.gid_map[gid]=top

        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rrows=c.fetchall()
        self.rule_map={}
        for (rid,rnm,gid,pid) in rrows:
            self.rule_map[rid]=(rnm,gid,pid)

        # top-level => no parent
        for rid,(rn,gid,pid) in self.rule_map.items():
            if not pid:
                if gid in self.gid_map:
                    parent_item=self.gid_map[gid]
                    child=QTreeWidgetItem([f"Rule {rid}: {rn}"])
                    child.setData(0,Qt.UserRole,("rule",rid))
                    parent_item.addChild(child)

        self.expandAll()

    def dropEvent(self, event):
        source_item=self.currentItem()
        if not source_item:
            super().dropEvent(event)
            return
        data_role=source_item.data(0,Qt.UserRole)
        if not data_role or data_role[0]!="rule":
            super().dropEvent(event)
            return

        super().dropEvent(event)  # let Qt reorder

        new_parent=source_item.parent()
        if not new_parent:
            # means top-level => revert
            QMessageBox.information(self,"Invalid","Cannot put rule at top-level with no group. Reverting.")
            self.load_hierarchy()
            return

        parent_role=new_parent.data(0,Qt.UserRole)
        rule_id=data_role[1]

        if parent_role[0]=="group":
            new_gid=parent_role[1]
            # forcibly unlock
            unlock_rule_for_edit(self.connection, rule_id, "HierarchyDrag", admin_override=True, user_group="Admin")
            c=self.connection.cursor()
            old=self.get_rule_dict(rule_id)
            c.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID=?, PARENT_RULE_ID=NULL,
                    STATUS='INACTIVE', APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                    VERSION=VERSION+1, UPDATED_BY='HierarchyView'
                WHERE RULE_ID=?
            """,(new_gid,rule_id))
            new_data=dict(old)
            new_data["GROUP_ID"]=new_gid
            new_data["PARENT_RULE_ID"]=None
            new_data["STATUS"]="INACTIVE"
            new_data["APPROVAL_STATUS"]="APPROVAL_IN_PROGRESS"
            insert_audit_log(self.connection,"HIERARCHY_MOVE","BRM_RULES",rule_id,"HierarchyDrag",old,new_data)
            self.connection.commit()
        elif parent_role[0]=="rule":
            parent_rid=parent_role[1]
            # forcibly unlock
            unlock_rule_for_edit(self.connection, rule_id, "HierarchyDrag", admin_override=True, user_group="Admin")
            # adopt parent's group
            pinfo=self.get_rule_dict(parent_rid)
            if not pinfo:
                self.load_hierarchy()
                return
            new_gid=pinfo["GROUP_ID"]
            old=self.get_rule_dict(rule_id)
            c=self.connection.cursor()
            c.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID=?, PARENT_RULE_ID=?,
                    STATUS='INACTIVE', APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                    VERSION=VERSION+1, UPDATED_BY='HierarchyView'
                WHERE RULE_ID=?
            """,(new_gid,parent_rid,rule_id))
            new_data=dict(old)
            new_data["GROUP_ID"]=new_gid
            new_data["PARENT_RULE_ID"]=parent_rid
            new_data["STATUS"]="INACTIVE"
            new_data["APPROVAL_STATUS"]="APPROVAL_IN_PROGRESS"
            insert_audit_log(self.connection,"HIERARCHY_MOVE","BRM_RULES",rule_id,"HierarchyDrag",old,new_data)
            self.connection.commit()
        else:
            QMessageBox.warning(self,"Invalid","Cannot move under unknown item. Reverting.")
            self.load_hierarchy()

    def get_rule_dict(self, rule_id):
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
        row=c.fetchone()
        if not row:
            return None
        cols=[d[0] for d in c.description]
        return dict(zip(cols,row))


# ---------------------------------------------------------------------------
# ENHANCED LINEAGE GRAPH (ER-like box style)
# ---------------------------------------------------------------------------
class EnhancedLineageGraphWidget(QGraphicsView):
    """
    A QGraphicsView that draws an ER-style diagram of rules (as boxes) + table dependencies (boxes),
    color-coded by status, with lines for relationships (child, GCR, conflict, composite).
    Also includes optional search highlighting, and a "Run Validation" right-click if the item is a table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()

        # load rules => we do BFS layering or direct
        c=self.connection.cursor()
        c.execute("""
            SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,
                   CRITICAL_RULE,IS_GLOBAL,CRITICAL_SCOPE,LOCK_STATUS
            FROM BRM_RULES
            ORDER BY RULE_ID
        """)
        rules=c.fetchall()

        # build adjacency from parent->child
        children_map={}
        parent_map={}
        all_ids=set()
        for row in rules:
            rid=row[0]
            pid=row[2]
            all_ids.add(rid)
            if pid:
                children_map.setdefault(pid,[]).append(rid)
                parent_map[rid]=pid

        # find roots
        child_ids=set(parent_map.keys())
        roots=[r for r in all_ids if r not in child_ids]

        # BFS layering
        from collections import deque
        queue=deque()
        for rt in roots:
            queue.append((rt,0))

        level_count={}
        rule_data_map={}
        for row in rules:
            rd={
                "RULE_ID":row[0],
                "RULE_NAME":row[1],
                "PARENT_RULE_ID":row[2],
                "STATUS":row[3],
                "CRITICAL_RULE":row[4],
                "IS_GLOBAL":row[5],
                "CRITICAL_SCOPE":row[6],
                "LOCK_STATUS":row[7]
            }
            rule_data_map[row[0]]=rd

        visited=set()
        while queue:
            (rid, depth)=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            level_count[depth]=level_count.get(depth,0)+1
            x=depth*220
            y=(level_count[depth]-1)*160

            node=RuleNodeItem(rule_data_map[rid])
            node.setPos(x,y)
            self.scene.addItem(node)
            self.node_map[rid]=node

            if rid in children_map:
                for ch_ in children_map[rid]:
                    queue.append((ch_,depth+1))

        # draw edges for parent->child
        for rid in all_ids:
            pid=rule_data_map[rid]["PARENT_RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid], color=QColor("darkGray"))

        # handle GCR => adjacency from Part 2
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        gcr_rows=c.fetchall()
        for (prid,chid) in gcr_rows:
            if prid in self.node_map and chid in self.node_map:
                self.draw_edge(self.node_map[prid], self.node_map[chid], color=QColor("blue"))

        # handle conflicts => we'll do a dotted line
        c.execute("SELECT RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
        cf_rows=c.fetchall()
        for (r1,r2,pri) in cf_rows:
            if r1 in self.node_map and r2 in self.node_map:
                self.draw_edge(self.node_map[r1], self.node_map[r2], color=QColor("magenta"), dashed=True)

        # handle composite => parse logic => adjacency
        c.execute("SELECT COMPOSITE_RULE_ID,LOGIC_EXPR FROM COMPOSITE_RULES")
        comp_rows=c.fetchall()
        pat=re.compile(r"Rule(\d+)", re.IGNORECASE)
        for (cid,expr) in comp_rows:
            if not expr:
                continue
            matches=pat.findall(expr)
            for m_ in matches:
                try:
                    sub_id=int(m_)
                    if sub_id in self.node_map and cid in self.node_map:
                        self.draw_edge(self.node_map[sub_id], self.node_map[cid], color=QColor("green"))
                except:
                    pass

        # table dependencies => also show them as boxes
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps=c.fetchall()
        # place table boxes off to the side or do an incremental approach
        table_map={}
        t_x=1000
        t_y=0
        for (drid,dbn,tb,op) in deps:
            if not tb:
                continue
            key=(f"{dbn}.{tb}").lower()
            if key not in table_map:
                tbox=TableNodeItem(key)
                tbox.setPos(t_x,t_y)
                t_y+=120
                self.scene.addItem(tbox)
                table_map[key]=tbox
            if drid in self.node_map:
                color=QColor("red") if op=="WRITE" else QColor("blue")
                self.draw_edge(self.node_map[drid], table_map[key], color=color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.reset_view()

    def draw_edge(self, item1, item2, color=QColor("black"), dashed=False):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        edge=LineageEdgeItem(p1,p2,color,dashed)
        self.scene.addItem(edge)

    def reset_view(self):
        br=self.scene.itemsBoundingRect()
        if br.isValid():
            self.fitInView(br, Qt.KeepAspectRatio)

    def mouseDoubleClickEvent(self, event):
        """
        Double-click => if rule => show details,
        if table => maybe run validation?
        """
        item=self.itemAt(event.pos())
        if isinstance(item, RuleNodeItem):
            rinfo=item.rule_data
            rid=rinfo["RULE_ID"]
            detail=(f"Rule {rid}:\n"
                    f"Name={rinfo['RULE_NAME']}\n"
                    f"Status={rinfo['STATUS']}\n"
                    f"Lock={rinfo['LOCK_STATUS']}\n"
                    f"Global={rinfo['IS_GLOBAL']}, Critical={rinfo['CRITICAL_RULE']}\n"
                    f"Scope={rinfo['CRITICAL_SCOPE']}")
            QMessageBox.information(self,"Rule Details",detail)
        elif isinstance(item, TableNodeItem):
            tablename=item.table_key
            # optional => run validation or just show
            dlg=QMessageBox(self)
            dlg.setWindowTitle("Table Node")
            dlg.setText(f"Table: {tablename}\nClick 'Run Validation' to test data validations.")
            run_btn=dlg.addButton("Run Validation",QMessageBox.AcceptRole)
            dlg.addButton("Close",QMessageBox.RejectRole)
            dlg.exec_()
            if dlg.clickedButton()==run_btn:
                passok=run_data_validations_for_table(self.connection,tablename.lower())
                if passok:
                    QMessageBox.information(self,"Validation","All validations passed.")
                else:
                    QMessageBox.warning(self,"Validation","Validation failed.")
        super().mouseDoubleClickEvent(event)

    def search_and_highlight(self, text):
        txt=text.lower()
        # dim all
        for item in self.scene.items():
            item.setOpacity(0.3)
        # highlight matches
        for item in self.scene.items():
            if isinstance(item, RuleNodeItem):
                if txt in item.rule_data["RULE_NAME"].lower():
                    item.setOpacity(1.0)
                elif txt in (item.rule_data["STATUS"] or "").lower():
                    item.setOpacity(1.0)
            elif isinstance(item, TableNodeItem):
                if txt in item.table_key.lower():
                    item.setOpacity(1.0)

# ---------------------------------------------------------------------------
# GFX Items
# ---------------------------------------------------------------------------
class RuleNodeItem(QGraphicsItem):
    """
    A rectangular box to represent a rule => color-coded by status => highlight if locked or critical/global
    """
    def __init__(self, rule_data, width=150, height=80):
        super().__init__()
        self.rule_data=rule_data
        self.w=width
        self.h=height
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)

    def boundingRect(self):
        return QRectF(0,0,self.w,self.h)

    def paint(self, painter, option, widget=None):
        status=(self.rule_data["STATUS"] or "").upper()
        if status=="ACTIVE":
            fillcol=QColor("palegreen")
        elif status=="INACTIVE":
            fillcol=QColor("lightpink")
        else:
            fillcol=QColor("lightgray")

        pen=QPen(Qt.black,2)
        if (self.rule_data["LOCK_STATUS"] or "").upper()=="LOCKED":
            pen.setColor(QColor("red"))
            pen.setWidth(3)
        # if critical or global => dashed
        if self.rule_data["CRITICAL_RULE"]==1 or self.rule_data["IS_GLOBAL"]==1:
            pen.setStyle(Qt.DashLine)

        painter.setPen(pen)
        painter.setBrush(QBrush(fillcol))
        painter.drawRect(0,0,self.w,self.h)

        txt=f"R{self.rule_data['RULE_ID']}:{self.rule_data['RULE_NAME']}"
        painter.drawText(0,0,self.w,self.h,Qt.AlignCenter, txt)


class TableNodeItem(QGraphicsItem):
    """
    A rectangular box for table => might add field for some details or color-coded
    """
    def __init__(self, table_key, width=180, height=60):
        super().__init__()
        self.table_key=table_key
        self.w=width
        self.h=height
        self.setFlag(QGraphicsItem.ItemIsSelectable,True)

    def boundingRect(self):
        return QRectF(0,0,self.w,self.h)

    def paint(self,painter,option,widget=None):
        pen=QPen(Qt.darkBlue,2)
        painter.setPen(pen)
        painter.setBrush(QBrush(QColor("lightblue")))
        painter.drawRect(0,0,self.w,self.h)
        painter.drawText(0,0,self.w,self.h,Qt.AlignCenter,self.table_key)


class LineageEdgeItem(QGraphicsItem):
    """
    A line from p1 to p2 => optional dashed => used to connect nodes in the scene
    """
    def __init__(self, p1, p2, color=QColor("black"), dashed=False):
        super().__init__()
        self.p1=p1
        self.p2=p2
        self.color=color
        self.dashed=dashed

    def boundingRect(self):
        minx=min(self.p1.x(), self.p2.x())
        miny=min(self.p1.y(), self.p2.y())
        w=abs(self.p2.x()-self.p1.x())
        h=abs(self.p2.y()-self.p1.y())
        return QRectF(minx,miny,w,h)

    def paint(self, painter, option, widget=None):
        pen=QPen(self.color,2)
        if self.dashed:
            pen.setStyle(Qt.DashLine)
        painter.setPen(pen)
        painter.drawLine(self.p1,self.p2)
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 6 of 8 (METRICS, CONTROL TABLES, GROUPS, USERS)
----------------------------------------------------------------
Builds on:
  - Part 1 (imports, DB connection, locks)
  - Part 2 (BFS logic, advanced CRUD)
  - Part 3 (scheduling, sync metadata)
  - Part 4 (audit logs, rule search, version history, dashboard, editor)
  - Part 5 (approvals, GCR admin, hierarchy, enhanced lineage)

Includes:
  - MetricsDashboardTab (performance/usage stats, bar/line charts)
  - CtrlTablesTab (user can pick from known admin tables => load data => if admin => can edit)
  - GroupManagementTab (manage business groups, membership, group permissions, group approvers)
  - UserManagementTab (manage user accounts, storing plain-text password => demonstration only)
"""

import sys
import math
import csv
import logging
import json
from datetime import datetime, timedelta
from collections import defaultdict

import pyodbc

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget, QFileDialog
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor

# We assume PyQtGraph is available for charting. 
import pyqtgraph as pg

# ---------------------------------------------------------------------------
# METRICS DASHBOARD TAB
# ---------------------------------------------------------------------------
class MetricsDashboardTab(QWidget):
    """
    Displays:
      - Bar chart of rule counts by status
      - Line chart of daily execution counts (RULE_EXECUTION_LOGS)
      - Optional data validation pass/fail ratio if we track in a table like DATA_VALIDATION_LOGS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        # 1) bar => rule counts by status
        self.status_chart=pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        layout.addWidget(self.status_chart)

        # 2) line => daily execution counts
        self.exec_chart=pg.PlotWidget(title="Executions/Day (Last 7d)")
        self.exec_chart.setBackground('w')
        layout.addWidget(self.exec_chart)

        # 3) data validation ratio
        self.val_chart=pg.PlotWidget(title="Data Validation Pass/Fail (Last 30d)")
        self.val_chart.setBackground('w')
        layout.addWidget(self.val_chart)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        bh.addWidget(ref_btn)

        export_btn=QPushButton("Export Metrics CSV")
        export_btn.clicked.connect(self.export_metrics_csv)
        bh.addWidget(export_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_metrics()

    def load_metrics(self):
        self.load_status_bar()
        self.load_execution_line()
        self.load_validation_ratio()

    def load_status_bar(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()
        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]

        self.status_chart.clear()
        if statuses:
            xvals=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(xvals), height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(xvals, statuses))])
            self.status_chart.setLabel("left","Count")
            self.status_chart.setLabel("bottom","Status")
            self.status_chart.showGrid(x=True, y=True)

    def load_execution_line(self):
        """
        Show daily execution counts in RULE_EXECUTION_LOGS for last 7 days
        """
        self.exec_chart.clear()
        c=self.connection.cursor()
        c.execute("""
            SELECT CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120) as dt,
                   COUNT(*) as c
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP>=DATEADD(day,-7,GETDATE())
            GROUP BY CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120)
            ORDER BY dt
        """)
        rows=c.fetchall()
        if not rows:
            return
        x_labels=[r[0] for r in rows]  # date string
        y_counts=[r[1] for r in rows]
        xvals=range(len(x_labels))

        self.exec_chart.plot(list(xvals), y_counts, pen='b', symbol='o')
        self.exec_chart.getAxis('bottom').setTicks([list(zip(xvals, x_labels))])
        self.exec_chart.setLabel('left',"Executions")
        self.exec_chart.setLabel('bottom',"Date")
        self.exec_chart.showGrid(x=True, y=True)

    def load_validation_ratio(self):
        """
        If we store pass/fail in e.g. DATA_VALIDATION_LOGS => show ratio for last 30 days
        """
        self.val_chart.clear()
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT RESULT_FLAG, COUNT(*)
                FROM DATA_VALIDATION_LOGS
                WHERE VALIDATION_TIMESTAMP>=DATEADD(day,-30,GETDATE())
                GROUP BY RESULT_FLAG
            """)
            rows=c.fetchall()
            pass_count=0
            fail_count=0
            for (rf,ct) in rows:
                if str(rf).upper()=="PASS":
                    pass_count+=ct
                else:
                    fail_count+=ct
            if pass_count+fail_count>0:
                xvals=[0,1]
                yvals=[pass_count, fail_count]
                colors=["green","red"]
                bar_item=pg.BarGraphItem(x=xvals, height=yvals, width=0.6, brushes=colors)
                self.val_chart.addItem(bar_item)
                label_map=[(0,"Pass"),(1,"Fail")]
                self.val_chart.getAxis("bottom").setTicks([label_map])
                self.val_chart.setLabel("left","Count")
                self.val_chart.showGrid(x=True, y=True)
        except:
            pass  # if table not present, skip

    def export_metrics_csv(self):
        """
        Export some aggregated metrics into a CSV
        """
        path,_=QFileDialog.getSaveFileName(self,"Export Metrics","","CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path,"w",newline="",encoding="utf-8") as f:
                writer=csv.writer(f)
                writer.writerow(["Metric","Value"])

                # 1) rule statuses
                c=self.connection.cursor()
                c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
                rrows=c.fetchall()
                for rr in rrows:
                    writer.writerow([f"RuleStatus_{rr[0]}", rr[1]])

                # 2) daily executions last 7
                c.execute("""
                    SELECT CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120), COUNT(*)
                    FROM RULE_EXECUTION_LOGS
                    WHERE EXECUTION_TIMESTAMP>=DATEADD(day,-7,GETDATE())
                    GROUP BY CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120)
                    ORDER BY 1
                """)
                exrows=c.fetchall()
                for ex_ in exrows:
                    writer.writerow([f"Exec_{ex_[0]}", ex_[1]])

                # 3) data validation logs
                try:
                    c.execute("""
                        SELECT RESULT_FLAG, COUNT(*)
                        FROM DATA_VALIDATION_LOGS
                        WHERE VALIDATION_TIMESTAMP>=DATEADD(day,-30,GETDATE())
                        GROUP BY RESULT_FLAG
                    """)
                    valrows=c.fetchall()
                    for v_ in valrows:
                        writer.writerow([f"DataVal_{v_[0]}",v_[1]])
                except:
                    pass

            QMessageBox.information(self,"Exported",f"Metrics exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


# ---------------------------------------------------------------------------
# CONTROL TABLES TAB
# ---------------------------------------------------------------------------
class CtrlTablesTab(QWidget):
    """
    Let user pick from a known list of admin tables => load data => if Admin => can edit (double-click).
    We do naive "UPDATE" for changed cells (some logic might do advanced PK detection).
    """
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)

        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS",
            "DATA_VALIDATION_LOGS"
        ]

        top_h=QHBoxLayout()
        self.tbl_combo=QComboBox()
        for t_ in self.table_list:
            self.tbl_combo.addItem(t_)
        top_h.addWidget(QLabel("Select Admin Table:"))
        top_h.addWidget(self.tbl_combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.load_table_data)
        top_h.addWidget(load_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.data_table=QTableWidget(0,0)
        if self.user_group=="Admin":
            # let admin edit
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)

        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.data_table)

        self.setLayout(layout)
        self.columns=[]
        self.current_table=None

    def load_table_data(self):
        tbl=self.tbl_combo.currentText()
        self.current_table=tbl
        self.data_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            self.columns=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error retrieving columns",str(ex))
            return

        try:
            c.execute(f"SELECT TOP 500 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error retrieving data",str(ex))
            return

        self.data_table.setColumnCount(len(self.columns))
        self.data_table.setHorizontalHeaderLabels(self.columns)
        for row in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val is not None else "")
                self.data_table.setItem(r_i,col_i,it)
        self.data_table.resizeColumnsToContents()

    def setData(self, row, col, value):
        it=QTableWidgetItem(str(value))
        self.data_table.setItem(row,col,it)

    def update_cell_in_db(self, row, col, new_val):
        if self.user_group!="Admin":
            return
        if not self.current_table or col>=len(self.columns):
            return
        # naive approach => we do not know PK => not safe in real scenario
        # here we just do no-op or we do a re-insert approach
        pass

    # optional approach => if you want immediate updates on double-click
    # you'd override cellChanged signal, etc. Real scenario would require PK handling.


# ---------------------------------------------------------------------------
# GROUP MANAGEMENT TAB
# ---------------------------------------------------------------------------
class GroupManagementTab(QWidget):
    """
    Admin => manage BUSINESS_GROUPS, membership in USERS, group-level table permissions, and group approvers
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        if user_group.lower()!="admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # 1) groups & membership
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Groups")
        grp_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        grp_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp=QPushButton("Add Group")
        add_grp.clicked.connect(self.add_group)
        grp_btns.addWidget(add_grp)

        rename_grp=QPushButton("Rename Group")
        rename_grp.clicked.connect(self.rename_group)
        grp_btns.addWidget(rename_grp)

        del_grp=QPushButton("Delete Group")
        del_grp.clicked.connect(self.delete_group)
        grp_btns.addWidget(del_grp)

        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        memb_box=QGroupBox("Membership")
        memb_layout=QVBoxLayout(memb_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        memb_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr=QPushButton("Add User to Group")
        add_usr.clicked.connect(self.add_user_to_group)
        memb_btns.addWidget(add_usr)

        rm_usr=QPushButton("Remove User from Group")
        rm_usr.clicked.connect(self.remove_user_from_group)
        memb_btns.addWidget(rm_usr)
        memb_btns.addStretch()
        memb_layout.addLayout(memb_btns)
        gm_layout.addWidget(memb_box)

        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # 2) permissions
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)

        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)
        top_h=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(QLabel("Select Group:"))
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["TargetTable"])
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.add_permission)
        ph.addWidget(addp_btn)

        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.remove_permission)
        ph.addWidget(remp_btn)

        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # 3) Approvers
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(QLabel("Group:"))
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr=QPushButton("Add Approver")
        add_appr.clicked.connect(self.add_approver)
        appr_btns.addWidget(add_appr)

        del_appr=QPushButton("Remove Approver")
        del_appr.clicked.connect(self.remove_approver)
        appr_btns.addWidget(del_appr)

        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_all=QPushButton("Refresh All")
        ref_all.clicked.connect(self.load_data)
        layout.addWidget(ref_all)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_group_combo()
        self.load_appr_group_combo()

    # -------------------------
    # Groups
    # -------------------------
    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT GROUP_NAME, DESCRIPTION, EMAIL
          FROM BUSINESS_GROUPS
          ORDER BY GROUP_NAME
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.groups_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            return None
        it=self.groups_table.item(row,0)
        if not it:
            return None
        return it.text().strip()

    def add_group(self):
        gname,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not gname.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("""
          INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
          VALUES(?,?,?)
        """,(gname.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for '{grp}':")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        # check duplicate
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Another group with that name already exists.")
            return
        try:
            oldd={"GROUP_NAME":grp}
            newd={"GROUP_NAME":new_name.strip()}
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RENAME_GROUP","BUSINESS_GROUPS",grp,self.user_id,oldd,newd)
            QMessageBox.information(self,"Renamed",f"Group '{grp}' => '{new_name}'.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            oldd={"GROUP_NAME":grp}
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
            c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            insert_audit_log(self.connection,"DELETE_GROUP","BUSINESS_GROUPS",grp,self.user_id,oldd,None)
            QMessageBox.information(self,"Deleted",f"Group '{grp}' removed.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    # -------------------------
    # Membership
    # -------------------------
    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.users_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_user_id(self):
        row=self.users_table.currentRow()
        if row<0:
            return None
        it=self.users_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user_to_group(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Assign Group","Group name (existing):")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"User {uid} => group {grp}")
        self.load_data()

    def remove_user_from_group(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Remove user {uid} => move to BG1?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"User {uid} => BG1")
        self.load_data()

    # -------------------------
    # Permissions
    # -------------------------
    def load_perm_group_combo(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for (gn,) in rows:
            self.perm_group_combo.addItem(gn, gn)

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        self.perm_table.setRowCount(0)
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT TARGET_TABLE
          FROM GROUP_PERMISSIONS
          WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))

    def add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        tbl,ok=QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.Customers'):")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE)
          VALUES(?,?)
        """,(grp.strip(),tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"{grp} => {tbl}")
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentData()
        row=self.perm_table.currentRow()
        if row<0 or not grp:
            return
        it=self.perm_table.item(row,0)
        tbl=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission => {grp}:{tbl}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
          DELETE FROM GROUP_PERMISSIONS
          WHERE GROUP_NAME=? AND TARGET_TABLE=?
        """,(grp,tbl))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"Permission removed => {tbl}")
        self.load_permissions()

    # -------------------------
    # Approvers
    # -------------------------
    def load_appr_group_combo(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for (gn,) in rows:
            self.appr_group_combo.addItem(gn, gn)

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        self.appr_table.setRowCount(0)
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT APPROVER_ID,USERNAME
          FROM BUSINESS_GROUP_APPROVERS
          WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        usern,ok=QInputDialog.getText(self,"Add Approver",f"Username for group {grp}:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME)
          VALUES(?,?)
        """,(grp.strip(),usern.strip()))
        self.connection.commit()
        insert_audit_log(self.connection,"ADD_APPROVER","BUSINESS_GROUP_APPROVERS",grp,self.user_id,None,{"approver":usern})
        QMessageBox.information(self,"Added",f"Approver {usern} => {grp}")
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentData()
        row=self.appr_table.currentRow()
        if row<0:
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        app_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver {app_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(app_id,))
        self.connection.commit()
        insert_audit_log(self.connection,"REMOVE_APPROVER","BUSINESS_GROUP_APPROVERS",app_id,self.user_id,{"app_id":app_id},None)
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()


# ---------------------------------------------------------------------------
# USER MANAGEMENT TAB
# ---------------------------------------------------------------------------
class UserManagementTab(QWidget):
    """
    Admin => manage USERS => store plain-text passwords => not recommended for real production.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        # We'll not block non-admin usage, but typical scenario => you'd do an admin check
        # We'll do a quick check
        # If you want to block => check user group from outside.

        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password(PlainText)","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        bh.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.user_table.setItem(r_i,col_i,it)

    def get_selected_userid(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Plain text password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        # check duplicates
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("""
          INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP)
          VALUES(?,?,?)
        """,(uname.strip(), pwd.strip(), grp.strip()))
        self.connection.commit()
        insert_audit_log(self.connection,"ADD_USER","USERS",uname,"AdminUser",None,{"usr":uname})
        QMessageBox.information(self,"Added","User created with plain-text password.")
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        # optional check => references
        c.execute("SELECT USERNAME,PASSWORD,USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldrow=c.fetchone()
        if not oldrow:
            QMessageBox.warning(self,"Missing","User not found.")
            return
        oldd={"USERNAME":oldrow[0],"PASSWORD":oldrow[1],"GROUP":oldrow[2]}
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        c.commit()
        insert_audit_log(self.connection,"DELETE_USER","USERS",uid,"AdminUser",oldd,None)
        QMessageBox.information(self,"Deleted",f"User {uid} removed.")
        self.load_users()

    def change_password(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        new_pw,ok=QInputDialog.getText(self,"Change Password","New plain-text password:")
        if not ok or not new_pw.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USERNAME,PASSWORD,USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldrow=c.fetchone()
        if not oldrow:
            QMessageBox.warning(self,"Missing","User not found.")
            return
        oldd={"PASSWORD":oldrow[1]}
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(new_pw.strip(),uid))
        c.commit()
        insert_audit_log(self.connection,"CHANGE_PASSWORD","USERS",uid,"AdminUser",oldd,{"PASSWORD":new_pw.strip()})
        QMessageBox.information(self,"Updated","Password changed.")
        self.load_users()
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 7 of 8 (CUSTOM GROUPS + ALERTS)
----------------------------------------------
Builds on previous parts (1–6) to provide:
 - CustomRuleGroupEnhancedTab: manage custom groups, BFS references, backups
 - AlertsAndDashboardsTab: see old approvals, stale locks, upcoming schedules, performance outliers
"""

import sys
import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox,
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QMenu, QSplitter
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor

# We rely on prior parts for BFS logic, lock checks, scheduling, etc.
# e.g. skip if locked, or do forced unlock for admin, etc.


# ---------------------------------------------------------------------------
# CUSTOM RULE GROUP ENHANCED TAB
# ---------------------------------------------------------------------------
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manages custom rule groups:
      - Create, rename, delete
      - BFS membership references if needed
      - Backup & restore each group
      - Assign or remove rules from groups
      - Searching among available unassigned rules
      - Skip rule assignment if rule is locked by another user
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        # top row => new group name => create/rename/delete => backup/restore
        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name...")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        # main splitter => left tree (group+rules), right list (available rules)
        splitter=QSplitter(Qt.Horizontal)

        # left => QTreeWidget for group => child rules
        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        # right => search + list
        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)

        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules (by name/SQL)...")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected => Group")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        rw_layout.addStretch()
        right_widget.setLayout(rw_layout)
        splitter.addWidget(right_widget)

        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    # -------------------------------------------
    # Group tree
    # -------------------------------------------
    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
          SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
          FROM BRM_CUSTOM_RULE_GROUPS
          ORDER BY CUSTOM_GROUP_ID DESC
        """)
        grps=c.fetchall()
        for (cg_id,cg_name,owner_bg) in grps:
            disp=f"{cg_name} (Owner={owner_bg})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0,Qt.UserRole,cg_id)
            g_item.setBackground(0,QBrush(QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            # assigned rules
            c2=self.connection.cursor()
            c2.execute("""
              SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE,
                     L.LOCKED_BY
              FROM BRM_CUSTOM_GROUP_MEMBERS M
              JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
              LEFT JOIN BRM_RULE_LOCKS L ON R.RULE_ID=L.RULE_ID AND L.ACTIVE_LOCK=1
              WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for (rid,rn,isg,isc,locked_by) in assigned:
                txt=f"Rule {rid}: {rn}"
                if locked_by:
                    txt+=f" [LOCKED by {locked_by}]"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0,Qt.UserRole,rid)
                if isg==1:
                    rr_item.setBackground(0,QBrush(QColor("lightblue")))
                if isc==1:
                    rr_item.setBackground(0,QBrush(QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    # -------------------------------------------
    # Available rules
    # -------------------------------------------
    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()

        # find assigned
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned_set=set([r[0] for r in c.fetchall()])

        if txt:
            c.execute("""
              SELECT RULE_ID, RULE_NAME, OWNER_GROUP
              FROM BRM_RULES
              WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID, RULE_NAME, OWNER_GROUP
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)

        rows=c.fetchall()
        for (rid,rn,og) in rows:
            if rid in assigned_set:
                continue
            disp=f"Rule {rid}: {rn} (Owner={og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,rid)
            self.rule_list.addItem(it)

    # -------------------------------------------
    # Create, rename, delete
    # -------------------------------------------
    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No custom group name.")
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BRM_CUSTOM_RULE_GROUPS(
            CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP
          )
          VALUES(?,?,?,GETDATE())
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        pr=it.parent()
        if pr:
            it=pr
        g_id=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (g_id,disp)

    def rename_group(self):
        (cg_id, disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No custom group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename","New name for group ID={}:".format(cg_id))
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            oldd={"cg_id":cg_id}
            newd={"cg_name":new_name}
            c.execute("BEGIN TRANSACTION")
            c.execute("""
              UPDATE BRM_CUSTOM_RULE_GROUPS
              SET CUSTOM_GROUP_NAME=?
              WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(), cg_id))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RENAME_CUSTOM_GROUP","BRM_CUSTOM_RULE_GROUPS",cg_id,str(self.user_id),oldd,newd)
            QMessageBox.information(self,"Renamed",f"Group {cg_id} => '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        (cg_id, disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group {cg_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            oldd={"cg_id":cg_id}
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"DELETE_CUSTOM_GROUP","BRM_CUSTOM_RULE_GROUPS",cg_id,str(self.user_id),oldd,None)
            QMessageBox.information(self,"Deleted",f"Custom group {cg_id} removed.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    # -------------------------------------------
    # Backup & restore
    # -------------------------------------------
    def backup_group(self):
        (cg_id, disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        # gather name + members
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing","Group not found.")
            return
        grp_name=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        assigned=[r[0] for r in c.fetchall()]
        backup_data={
            "group_name":grp_name,
            "members":assigned,
            "backup_user":self.user_id,
            "backup_timestamp":datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        c.execute("""
          SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
        """,(cg_id,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1

        c.execute("""
          INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
            CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
          )
          VALUES(?,GETDATE(),?,?)
        """,(cg_id,new_ver,json.dumps(backup_data)))
        c.commit()
        insert_audit_log(self.connection,"BACKUP_CUSTOM_GROUP","BRM_CUSTOM_GROUP_BACKUPS",cg_id,str(self.user_id),None,{"version":new_ver})
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {cg_id} saved.")
        self.refresh_all()

    def restore_group(self):
        (cg_id,disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
          ORDER BY BACKUP_VERSION DESC
        """,(cg_id,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups for that group.")
            return
        items=[f"Version {r[0]} (ts={r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore Backup","Pick version:", items, 0,False)
        if not ok or not sel:
            return
        m=re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver=int(m.group(1))

        confirm=QMessageBox.question(self,"Confirm",f"Restore group {cg_id} => version {ver}? Overwrites membership.")
        if confirm!=QMessageBox.Yes:
            return

        backup_json=None
        for row in rows:
            if row[0]==ver:
                backup_json=row[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Missing","Backup not found for that version.")
            return
        try:
            data=json.loads(backup_json)
            new_gname=data["group_name"]
            members=data["members"]
            c.execute("BEGIN TRANSACTION")
            c.execute("""
              UPDATE BRM_CUSTOM_RULE_GROUPS
              SET CUSTOM_GROUP_NAME=?
              WHERE CUSTOM_GROUP_ID=?
            """,(new_gname,cg_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
            for mid in members:
                # check if locked
                if self.is_rule_locked(mid):
                    # skip or ignore
                    continue
                c.execute("""
                  INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(cg_id,mid))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RESTORE_CUSTOM_GROUP","BRM_CUSTOM_GROUP_BACKUPS",cg_id,str(self.user_id),{"version":ver},data)
            QMessageBox.information(self,"Restored",f"Group {cg_id} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    # -------------------------------------------
    # Remove from group => tree context menu
    # -------------------------------------------
    def on_tree_context(self,pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # means this is a rule => "Remove"
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                self.remove_rule_from_group(group_id,rule_id)

    def remove_rule_from_group(self, group_id, rule_id):
        if self.is_rule_locked(rule_id):
            QMessageBox.warning(self,"Locked",f"Rule {rule_id} is locked; cannot remove.")
            return
        c=self.connection.cursor()
        c.execute("""
          DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
          WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
        """,(group_id,rule_id))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group {group_id}.")
        self.refresh_all()

    # -------------------------------------------
    # Assign rules
    # -------------------------------------------
    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected on the left.")
            return
        top_item=sel[0]
        if top_item.parent():
            top_item=top_item.parent()
        group_id=top_item.data(0,Qt.UserRole)
        if not group_id:
            QMessageBox.warning(self,"Error","Selected item has no group ID.")
            return

        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected on the right.")
            return
        c=self.connection.cursor()
        assigned_count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            if self.is_rule_locked(rid):
                # skip
                continue
            try:
                c.execute("""
                  INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(group_id,rid))
                assigned_count+=1
            except:
                pass
        c.commit()
        QMessageBox.information(self,"Assigned",f"{assigned_count} rule(s) assigned to group {group_id}.")
        self.refresh_all()

    def is_rule_locked(self,rule_id):
        """
        Return True if rule is locked by someone else.
        We'll check BRM_RULE_LOCKS if active_lock=1.
        """
        c=self.connection.cursor()
        c.execute("""
          SELECT LOCKED_BY
          FROM BRM_RULE_LOCKS
          WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        row=c.fetchone()
        if row and row[0]:
            return True
        return False


# ---------------------------------------------------------------------------
# ALERTS & DASHBOARDS TAB
# ---------------------------------------------------------------------------
class AlertsAndDashboardsTab(QWidget):
    """
    Summarizes:
      - Old approvals (>3 days)
      - Stale locks (>6 hours)
      - Upcoming schedules (24h)
      - Performance outliers (rule execution >5s last 7 days)
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        main_layout=QVBoxLayout(self)

        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        main_layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        main_layout.addWidget(check_btn)

        self.setLayout(main_layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # 1) Old approvals => older than 3 days
        c.execute("""
          SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                 DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP), GETDATE()) as age
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.APPROVED_FLAG=0
            AND A.APPROVAL_STAGE=(SELECT MIN(APPROVAL_STAGE)
                                  FROM BRM_RULE_APPROVALS
                                  WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0)
            AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP), GETDATE())>3
        """)
        old_ap=c.fetchall()
        if old_ap:
            lines.append("** Old Approvals (>3 days) **")
            for (rid,stg,rn,age) in old_ap:
                lines.append(f"   - Rule {rid} '{rn}', stage={stg}, age={age} days")
        else:
            lines.append("No old approvals >3 days found.")

        lines.append("")

        # 2) stale locks => locked >6 hours
        c.execute("""
          SELECT L.RULE_ID, L.LOCKED_BY, R.RULE_NAME,
                 DATEDIFF(HOUR,L.LOCK_TIMESTAMP,GETDATE()) as locked_hrs
          FROM BRM_RULE_LOCKS L
          JOIN BRM_RULES R ON L.RULE_ID=R.RULE_ID
          WHERE L.ACTIVE_LOCK=1
            AND DATEDIFF(HOUR,L.LOCK_TIMESTAMP,GETDATE())>6
        """)
        stale=c.fetchall()
        if stale:
            lines.append("** Stale Locks (>6 hrs) **")
            for (rid,ub,rn,hrs) in stale:
                lines.append(f"   - Rule {rid} '{rn}' locked by {ub} for {hrs} hours")
        else:
            lines.append("No stale locks >6h found.")
        lines.append("")

        # 3) upcoming schedules next 24h
        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
          FROM RULE_SCHEDULES
          WHERE STATUS='Scheduled'
            AND SCHEDULE_TIME>=GETDATE()
            AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
          ORDER BY SCHEDULE_TIME
        """)
        upc=c.fetchall()
        if upc:
            lines.append("** Upcoming Schedules (next 24h) **")
            for (sid,rid,ts) in upc:
                lines.append(f"   - Schedule {sid}, Rule {rid}, time={ts}")
        else:
            lines.append("No upcoming schedules in next 24 hours.")
        lines.append("")

        # 4) performance outliers => >5s last 7 days
        c.execute("""
          SELECT LOG_ID,RULE_ID,EXECUTION_TIME_MS,EXECUTION_TIMESTAMP
          FROM RULE_EXECUTION_LOGS
          WHERE EXECUTION_TIME_MS>5000
            AND EXECUTION_TIMESTAMP>=DATEADD(day,-7,GETDATE())
          ORDER BY EXECUTION_TIMESTAMP DESC
        """)
        perf=c.fetchall()
        if perf:
            lines.append("** Performance Outliers (>5s in last 7 days) **")
            for (lid,rid,ms,ts) in perf:
                lines.append(f"   - ExecLog {lid}, Rule {rid}, {ms} ms @ {ts}")
        else:
            lines.append("No performance outliers >5s in last 7 days.")

        self.alert_text.setPlainText("\n".join(lines))
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 8 of 8 (MAIN WINDOW, FULL INTEGRATION)
------------------------------------------------------
Brings together all parts (1–7) in a single QMainWindow:
 - Database connection & user login (Part 1)
 - BFS, advanced CRUD, locks, multi-step approvals (Part 2)
 - Scheduling, metadata sync, simulations, advanced feature tabs (Part 3)
 - Audit logs, rule search, version history, rule dashboard/editor (Part 4)
 - Approvals tab, global/critical admin, hierarchy, advanced lineage (Part 5)
 - Metrics, control tables, group/user management (Part 6)
 - Custom groups & alerts/dashboards (Part 7)
No references to encryption remain. All functionalities are integrated.
"""

import sys
import logging
import json
from datetime import datetime

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QComboBox,
    QPushButton, QLabel, QMessageBox, QDialog, QLineEdit, QAction
)
from PyQt5.QtCore import QTimer, Qt

# We assume the following classes/functions come from the final single-file code of Parts 1–7:
#   - DatabaseConnectionDialog
#   - LoginDialog
#   - OnboardingWizard (optional)
#   - auto_unlock_expired_locks
#   - sync_metadata_improved
#   - detect_operation_type, parse_sql_dependencies
#   - add_rule, update_rule, deactivate_rule, delete_rule, force_activate_rule, force_deactivate_rule
#   - lock_rule_for_edit, unlock_rule_for_edit
#   - create_multistep_approvals, user_has_table_permission
#   - BFS logic => e.g. execute_rules_bfs or specialized “execute_rules_with_conflicts_composites_bfs”
#   - SingleRuleSimulationDialog, ChainSimulationDialog, GroupSimulationDialog, EnhancedScheduleDialog
#   - AuditLogViewer, RuleSearchDialog, VersionHistoryDialog, RuleDashboard, RuleEditorDialog
#   - MultiStepApprovalTab, GlobalCriticalAdminTab, HierarchyViewTab, EnhancedLineageGraphWidget
#   - MetricsDashboardTab, CtrlTablesTab, GroupManagementTab, UserManagementTab
#   - CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab
#   - DataValidationTab, DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab,
#       SnapshotManagerTab, TagsManagerTab, WhatIfTestTab, ScheduleManagementTab
#

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Final Production Build")
        self.resize(1350,900)

        self.connection=None
        self.user_id=None
        self.user_group=None
        self.logged_in_username=None

        # 1) DB connect
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            conn_obj=dbdlg.get_connection()
            if not conn_obj:
                sys.exit(1)
            self.connection=conn_obj
        else:
            sys.exit(0)

        # 2) Login
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if not row:
            QMessageBox.critical(self,"Error","User not found in DB after login.")
            sys.exit(1)
        self.logged_in_username=row[0]

        # optional OnboardingWizard
        # wiz=OnboardingWizard(self.connection)
        # wiz.exec_()

        self.init_ui()

    def init_ui(self):
        # build menubar
        menubar=self.menuBar()

        # File menu
        fileMenu=menubar.addMenu("File")

        syncAction=QAction("Sync Metadata", self)
        syncAction.triggered.connect(self.handle_sync_metadata)
        fileMenu.addAction(syncAction)

        metricsAction=QAction("View Metrics Dashboard", self)
        metricsAction.triggered.connect(self.launch_metrics_dialog)
        fileMenu.addAction(metricsAction)

        schedAction=QAction("New Schedule Dialog", self)
        schedAction.triggered.connect(self.launch_schedule_dialog)
        fileMenu.addAction(schedAction)

        chainAction=QAction("Simulate Parent Chain BFS", self)
        chainAction.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAction)

        groupAction=QAction("Simulate Custom Group BFS", self)
        groupAction.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(groupAction)

        # Help menu
        helpMenu=menubar.addMenu("Help")
        aboutAct=QAction("Help/About",self)
        aboutAct.triggered.connect(self.show_help_about)
        helpMenu.addAction(aboutAct)

        # Tools menu
        toolsMenu=menubar.addMenu("Tools")

        alAct=QAction("View Audit Logs", self)
        alAct.triggered.connect(self.launch_audit_viewer)
        toolsMenu.addAction(alAct)

        srAct=QAction("Search Rules", self)
        srAct.triggered.connect(self.launch_rule_search)
        toolsMenu.addAction(srAct)

        vhAct=QAction("Version History (Prompt for ID)", self)
        vhAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(vhAct)

        dvAct=QAction("Run All Data Validations", self)
        dvAct.triggered.connect(self.run_all_data_validations)
        toolsMenu.addAction(dvAct)

        # advanced menu
        advMenu=menubar.addMenu("Advanced")
        advMenu.addAction("Decision Tables", lambda: self.open_tab(DecisionTablesTab(self.connection), "Decision Tables"))
        advMenu.addAction("Conflict Priority", lambda: self.open_tab(ConflictPriorityManagerTab(self.connection), "Conflict Priority"))
        advMenu.addAction("Composite Rules", lambda: self.open_tab(CompositeRulesTab(self.connection), "Composite Rules"))
        advMenu.addAction("Snapshot Manager", lambda: self.open_tab(SnapshotManagerTab(self.connection), "Snapshots"))
        advMenu.addAction("Tags Manager", lambda: self.open_tab(TagsManagerTab(self.connection), "Tags"))
        advMenu.addAction("Data Validation Tab", lambda: self.open_tab(DataValidationTab(self.connection), "DataValidation"))
        advMenu.addAction("WhatIf Tests", lambda: self.open_tab(WhatIfTestTab(self.connection), "WhatIf Tests"))

        # central widget
        cw=QWidget()
        main_layout=QVBoxLayout(cw)

        # impersonation if Admin
        if self.user_group.lower()=="admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.handle_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            main_layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs=QTabWidget()
        main_layout.addWidget(self.tabs)

        # 1) Business Rules => BFS references => dashboard
        brw=QWidget()
        br_layout=QVBoxLayout(brw)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule)
        btn_h.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.update_rule)
        btn_h.addWidget(upd_btn)

        force_act_btn=QPushButton("Force Activate")
        force_act_btn.clicked.connect(self.force_activate)
        btn_h.addWidget(force_act_btn)

        force_deact_btn=QPushButton("Force Deactivate")
        force_deact_btn.clicked.connect(self.force_deactivate)
        btn_h.addWidget(force_deact_btn)

        del_btn=QPushButton("Delete Rule")
        del_btn.clicked.connect(self.delete_rule)
        btn_h.addWidget(del_btn)

        run_bfs_btn=QPushButton("Run ETL BFS")
        run_bfs_btn.clicked.connect(self.run_etl_bfs)
        btn_h.addWidget(run_bfs_btn)

        sim_single_btn=QPushButton("Simulate Single Rule")
        sim_single_btn.clicked.connect(self.simulate_single_rule)
        btn_h.addWidget(sim_single_btn)

        btn_h.addStretch()
        br_layout.addLayout(btn_h)

        self.brm_dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_layout.addWidget(self.brm_dashboard)
        brw.setLayout(br_layout)
        self.tabs.addTab(brw,"Business Rules")

        # 2) approvals
        self.approvals_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approvals_tab,"Approvals")

        # 3) global/critical admin
        if self.user_group.lower()=="admin":
            self.gcr_tab=GlobalCriticalAdminTab(self,self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # 4) hierarchy
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # 5) advanced lineage
        lineage_widget=QWidget()
        lw_layout=QVBoxLayout(lineage_widget)

        label_top=QLabel("Enhanced Lineage Graph (Production)")
        label_top.setStyleSheet("font-weight: bold; font-size: 14px;")
        lw_layout.addWidget(label_top)

        self.lineage_view=EnhancedLineageGraphWidget(self.connection)
        lw_layout.addWidget(self.lineage_view)

        bottom_h=QHBoxLayout()
        self.lineage_search_edit=QLineEdit()
        self.lineage_search_edit.setPlaceholderText("Search rule/table/column..")
        bottom_h.addWidget(self.lineage_search_edit)
        sb=QPushButton("Search")
        sb.clicked.connect(self.lineage_search)
        bottom_h.addWidget(sb)

        reset_btn=QPushButton("Reset View")
        reset_btn.clicked.connect(self.lineage_view.resetView)
        bottom_h.addWidget(reset_btn)

        ref_lineage_btn=QPushButton("Refresh Graph")
        ref_lineage_btn.clicked.connect(self.lineage_view.populate_graph)
        bottom_h.addWidget(ref_lineage_btn)

        bottom_h.addStretch()
        lw_layout.addLayout(bottom_h)
        lineage_widget.setLayout(lw_layout)
        self.tabs.addTab(lineage_widget,"Lineage")

        # 6) custom groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # 7) scheduling
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # 8) control tables
        self.ctrl_tab=CtrlTablesTab(self.connection,self.user_group)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # 9) metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # 10) alerts
        self.alerts_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alerts_tab,"Alerts & Dashboard")

        # 11) group mgmt
        self.grp_mgmt_tab=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # 12) user mgmt if admin
        if self.user_group.lower()=="admin":
            self.user_mgmt_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        cw.setLayout(main_layout)
        self.setCentralWidget(cw)

        # Timers => approvals, schedule due, stale locks, etc.
        self.approval_timer=QTimer(self)
        self.approval_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approval_timer.start(4000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules_due)
        self.schedule_timer.start(60000)

        self.alerts_timer=QTimer(self)
        self.alerts_timer.timeout.connect(self.alerts_tab.check_alerts)
        self.alerts_timer.start(120000)

        # optionally auto unlock expired locks
        self.unlock_timer=QTimer(self)
        self.unlock_timer.timeout.connect(lambda: auto_unlock_expired_locks(self.connection))
        self.unlock_timer.start(300000)  # every 5 min

        self.show()

    # ----------------------------------------------------------------------
    # Menubar handlers
    # ----------------------------------------------------------------------
    def handle_sync_metadata(self):
        try:
            sync_metadata_improved(self.connection)
        except Exception as ex:
            QMessageBox.critical(self,"Sync Error",str(ex))

    def launch_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard (Popup)")
        dlg.resize(800,600)
        from PyQt5.QtWidgets import QVBoxLayout,QPushButton
        layout=QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection,dlg)
        layout.addWidget(chart)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        layout.addWidget(cb)
        dlg.exec_()

    def launch_schedule_dialog(self):
        d_=EnhancedScheduleDialog(self.connection,self)
        d_.exec_()

    def launch_chain_sim(self):
        d_=ChainSimulationDialog(self.connection,self)
        d_.exec_()

    def launch_group_sim(self):
        d_=GroupSimulationDialog(self.connection,self)
        d_.exec_()

    def show_help_about(self):
        info=(
            "BRM Tool – final integrated.\n"
            "Includes BFS, advanced CRUD, data validations, multi-step approvals, etc.\n"
            "No encryption references remain. Enjoy!"
        )
        QMessageBox.information(self,"About",info)

    def launch_audit_viewer(self):
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_rule_search(self):
        dlg=RuleSearchDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Version History","Enter Rule ID to view history:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection,rid,self)
        dlg.exec_()

    def run_all_data_validations(self):
        """
        Example => just run a quick approach or show a message that they've passed/failed.
        If you track logs in e.g. DATA_VALIDATION_LOGS, store results.
        """
        c=self.connection.cursor()
        c.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        trows=c.fetchall()
        fails=[]
        for (tn,) in trows:
            ok=self.run_validations_for_table(tn)
            if not ok:
                fails.append(tn)
        if fails:
            QMessageBox.warning(self,"Validation","Some validations failed => "+", ".join(fails))
        else:
            QMessageBox.information(self,"Validation","All table validations passed.")

    def run_validations_for_table(self, table_name):
        """
        Minimal approach => check validations for the given table_name => if fail => return False
        Repeats logic from Part 2 or 3. 
        """
        c=self.connection.cursor()
        c.execute("""
          SELECT VALIDATION_ID, VALIDATION_TYPE, COLUMN_NAME, PARAMS
          FROM DATA_VALIDATIONS
          WHERE TABLE_NAME=?
        """,(table_name,))
        rows=c.fetchall()
        for (vid,vtype,col,pars) in rows:
            if not self.do_single_validation(table_name,vtype,col,pars):
                return False
        return True

    def do_single_validation(self, table_name, vtype, col, pars):
        """
        Very naive. e.g. "NOT NULL" => check no null in col. 
        Return True if pass, False if fail.
        """
        c=self.connection.cursor()
        if vtype.upper()=="NOT NULL":
            q=f"SELECT COUNT(*) FROM {table_name} WHERE {col} IS NULL"
            c.execute(q)
            cnt=c.fetchone()[0]
            return (cnt==0)
        elif vtype.upper()=="RANGE":
            # e.g. param = "0,100"
            sp=pars.split(",")
            if len(sp)==2:
                minv=float(sp[0])
                maxv=float(sp[1])
                q=f"SELECT COUNT(*) FROM {table_name} WHERE {col}<{minv} OR {col}>{maxv}"
                c.execute(q)
                cc=c.fetchone()[0]
                return (cc==0)
            else:
                return True
        else:
            return True

    # ----------------------------------------------------------------------
    # Impersonation if admin
    # ----------------------------------------------------------------------
    def populate_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for (uid,uname,ugrp) in rows:
            disp=f"{uname}({ugrp})"
            self.switch_combo.addItem(disp,(uid,ugrp))

    def handle_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        (new_uid,new_grp)=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="Unknown"

        QMessageBox.information(self,"Switched",f"Now impersonating user {new_uid}, group {new_grp}")

        # refresh approvals
        self.approvals_tab.logged_in_username=self.logged_in_username
        self.approvals_tab.user_group=self.user_group
        self.approvals_tab.load_approvals()

        # refresh dashboard
        self.brm_dashboard.user_id=self.user_id
        self.brm_dashboard.user_group=self.user_group
        self.brm_dashboard.load_rules()

        # refresh group mgmt
        self.grp_mgmt_tab.user_id=self.user_id
        self.grp_mgmt_tab.user_group=self.user_group
        self.grp_mgmt_tab.load_data()

        # refresh alerts
        self.alerts_tab.user_id=self.user_id
        self.alerts_tab.user_group=self.user_group
        self.alerts_tab.check_alerts()

    # ----------------------------------------------------------------------
    # Business Rules => BFS, CRUD
    # ----------------------------------------------------------------------
    def add_rule(self):
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def update_rule(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if len(sel)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid=sel[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing",f"No rule {rid}.")
            return
        colnames=[desc[0] for desc in c.description]
        data=dict(zip(colnames,row))
        dlg=RuleEditorDialog(self.connection,self.user_group,data,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def force_activate(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force-activate {len(sel)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                force_activate_rule(self.connection,rid,self.user_id,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"ForceActivate => success={success}, fails={len(fails)} => {fails}"
        QMessageBox.information(self,"ForceActivate",msg)
        self.brm_dashboard.load_rules()

    def force_deactivate(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force-deactivate {len(sel)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                force_deactivate_rule(self.connection,rid,self.user_id,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"ForceDeactivate => success={success}, fails={len(fails)} => {fails}"
        QMessageBox.information(self,"ForceDeactivate",msg)
        self.brm_dashboard.load_rules()

    def delete_rule(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(sel)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                delete_rule(self.connection,rid,self.user_id,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Delete => success={success}, fails={len(fails)} => {fails}"
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_etl_bfs(self):
        """
        Perform BFS (with conflict/composite logic if your function does so).
        """
        from time import perf_counter
        start=perf_counter()
        (executed,skipped)=execute_rules_with_conflicts_composites_bfs(self.connection, measure_perf=True)
        elapsed=(perf_counter()-start)*1000
        msg=f"BFS => executed={executed}, skipped={list(skipped)}, totalTime={elapsed:.2f}ms"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def simulate_single_rule(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if len(sel)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule for single simulation.")
            return
        rid=sel[0]
        # fetch rule
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"NotFound",f"No rule {rid} found.")
            return
        from PyQt5.QtWidgets import QDialog
        dlg=SingleRuleSimulationDialog(self.connection, self)
        # set the selected rule in that dialog
        # or we can alter the constructor if needed
        # For now, let's do a quick approach => or just create a minimal BFS
        dlg.rule_combo.setCurrentIndex(dlg.rule_combo.findData(rid))
        dlg.exec_()

    # ----------------------------------------------------------------------
    # Timer => schedules
    # ----------------------------------------------------------------------
    def check_schedules_due(self):
        """
        Called every minute => if any RULE_SCHEDULES is due => run it => store pass/fail
        """
        now_str=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,VALIDATION_FLAG
          FROM RULE_SCHEDULES
          WHERE STATUS='Scheduled'
            AND SCHEDULE_TIME<=?
        """,(now_str,))
        due=c.fetchall()
        for row in due:
            sch_id=row[0]
            rid=row[1]
            val_flag=(row[3]==1)
            # mark in-progress
            c2=self.connection.cursor()
            c2.execute("UPDATE RULE_SCHEDULES SET STATUS='InProgress' WHERE SCHEDULE_ID=?",(sch_id,))
            self.connection.commit()

            c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            rw=c2.fetchone()
            if not rw:
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                self.connection.commit()
                continue

            rule_sql=rw[0]
            from time import perf_counter
            start=perf_counter()
            pass_flag=False
            msg=""
            rec_count=0
            c2.execute("BEGIN TRANSACTION")
            try:
                # optional data validations if val_flag
                if val_flag:
                    # run validation on that rule's tables
                    c3=self.connection.cursor()
                    c3.execute("""
                      SELECT DATABASE_NAME,TABLE_NAME
                      FROM BRM_RULE_TABLE_DEPENDENCIES
                      WHERE RULE_ID=?
                    """,(rid,))
                    dt_rows=c3.fetchall()
                    validation_failed=False
                    for (dbn,tbn) in dt_rows:
                        if not tbn:
                            continue
                        full_tn=(dbn+"."+tbn)
                        # reuse do_single_validation or similar approach
                        if not self.run_validations_for_table(full_tn):
                            validation_failed=True
                            break
                    if validation_failed:
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                        self.connection.commit()
                        continue

                c2.execute(rule_sql)
                rows_=c2.fetchall()
                if rows_:
                    rec_count=len(rows_)
                    if rows_[0][0]==1:
                        pass_flag=True
                    msg=f"Returned {rows_[0][0]}"
                else:
                    pass_flag=True
                    msg="No rows => PASS"

                if pass_flag:
                    c2.execute("COMMIT")
                else:
                    c2.execute("ROLLBACK")
            except Exception as ex:
                pass_flag=False
                msg=str(ex)
                c2.execute("ROLLBACK")

            endt=perf_counter()
            exec_ms=int((endt-start)*1000)
            # update schedule
            if pass_flag:
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
            else:
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
            # log
            c2.execute("""
              INSERT INTO RULE_EXECUTION_LOGS(
                RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
                MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS
              )
              VALUES(?,GETDATE(),?,?,?,?)
            """,(rid,1 if pass_flag else 0,msg,rec_count,exec_ms))
            self.connection.commit()

        self.sch_tab.load_schedules()

    # ----------------------------------------------------------------------
    # lineage search
    # ----------------------------------------------------------------------
    def lineage_search(self):
        pat=self.lineage_search_edit.text().strip()
        self.lineage_view.search_and_highlight(pat)

    # ----------------------------------------------------------------------
    # open advanced tabs
    # ----------------------------------------------------------------------
    def open_tab(self, widget, title):
        # if a tab with 'title' not found => add
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i)==title:
                self.tabs.setCurrentIndex(i)
                return
        self.tabs.addTab(widget,title)
        self.tabs.setCurrentIndex(self.tabs.count()-1)

    # ----------------------------------------------------------------------
    # close event => close db
    # ----------------------------------------------------------------------
    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()
        