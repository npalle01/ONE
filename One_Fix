import sys
import math
import logging
import pyodbc

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox,
    QPlainTextEdit, QMessageBox
)

def run_rule_sql_dry_run(connection, rule_sql):
    """
    Minimal example: Start a transaction, run rule_sql,
    interpret row[0][0]==1 => PASS else FAIL => rollback always.
    Return (success, message).
    """
    c = connection.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
        c.execute(rule_sql)
        rows = c.fetchall()
        if rows:
            val = rows[0][0]
            success = (val == 1)
            message = f"Returned: {val}"
        else:
            success = True
            message = "No rows => PASS"
        c.execute("ROLLBACK")
        return (success, message)
    except Exception as ex:
        c.execute("ROLLBACK")
        return (False, str(ex))


class SingleRuleSimulationDialog(QDialog):
    """
    Lets user pick a single rule => run a dry-run => show pass/fail message.
    """
    def __init__(self, connection, rule_id, rule_sql, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.rule_sql = rule_sql

        self.setWindowTitle(f"Single Rule Simulation â€“ Rule {rule_id}")
        self.resize(500, 300)

        main_layout = QVBoxLayout(self)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        main_layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Dry-Run")
        sim_btn.clicked.connect(self.do_sim)
        bh.addWidget(sim_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        main_layout.addLayout(bh)
        self.setLayout(main_layout)

    def do_sim(self):
        ok, msg = run_rule_sql_dry_run(self.connection, self.rule_sql)
        result_str = f"Rule {self.rule_id} => {'PASS' if ok else 'FAIL'} => {msg}"
        self.result_text.setPlainText(result_str)


class ChainSimulationDialog(QDialog):
    """
    Lets the user pick a 'parent rule' => do a BFS from parent->child
    (if child is indicated by BRM_RULES.PARENT_RULE_ID).
    Then runs a dry-run for each rule in that chain, skipping children if parent fails.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        self.setWindowTitle("Simulate Parent Rule Chain")
        self.resize(600, 400)

        main_layout = QVBoxLayout(self)

        # pick rule
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            rid, rname = row
            display = f"{rid} - {rname}"
            self.rule_combo.addItem(display, rid)

        main_layout.addWidget(QLabel("Select Parent Rule:"))
        main_layout.addWidget(self.rule_combo)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        main_layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Simulate BFS")
        run_btn.clicked.connect(self.do_chain_sim)
        bh.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        main_layout.addLayout(bh)
        self.setLayout(main_layout)

    def do_chain_sim(self):
        start_rid = self.rule_combo.currentData()
        executed, failed = self.execute_chain_bfs_dry_run(start_rid)
        txt = (f"BFS from rule {start_rid}\n"
               f"Executed => {executed}\n"
               f"Failed => {failed}")
        self.result_text.setPlainText(txt)

    def execute_chain_bfs_dry_run(self, start_rule_id):
        """
        Minimal BFS => parent->child => run dry-run for each => skip children if parent fails.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rows = c.fetchall()
        rule_sql_map = {}
        children_map = {}
        for (rid, pid, rsql) in rows:
            rule_sql_map[rid] = rsql
            if pid:
                children_map.setdefault(pid, []).append(rid)

        executed = []
        fails = []
        queue = [start_rule_id]
        while queue:
            rid = queue.pop(0)
            if rid not in rule_sql_map:
                fails.append(rid)
                continue
            sql_ = rule_sql_map[rid] or ""
            ok, msg = run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch in children_map[rid]:
                        queue.append(ch)
            else:
                fails.append(rid)
        return (executed, fails)


class GroupSimulationDialog(QDialog):
    """
    Let user pick a custom rule group => run all its rules in a simple dry-run approach.
    We skip BFS chaining here; we just run each rule individually.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        self.setWindowTitle("Simulate Custom Group")
        self.resize(600, 400)
        main_layout = QVBoxLayout(self)

        self.group_combo = QComboBox()
        c = self.connection.cursor()
        # We assume custom groups are in BRM_CUSTOM_RULE_GROUPS
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for row in c.fetchall():
            cg_id, cg_name = row
            display = f"{cg_id} - {cg_name}"
            self.group_combo.addItem(display, cg_id)

        main_layout.addWidget(QLabel("Custom Group:"))
        main_layout.addWidget(self.group_combo)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        main_layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Group Rules")
        sim_btn.clicked.connect(self.do_group_sim)
        bh.addWidget(sim_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)

    def do_group_sim(self):
        group_id = self.group_combo.currentData()
        executed, fails = self.run_group_rules_dry_run(group_id)
        txt = f"Group {group_id} => executed={executed}, fails={fails}"
        self.result_text.setPlainText(txt)

    def run_group_rules_dry_run(self, custom_group_id):
        c = self.connection.cursor()
        # find rules in that custom group
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
        rule_ids = [row[0] for row in c.fetchall()]

        # build a map: rid -> sql
        c2 = self.connection.cursor()
        c2.execute("SELECT RULE_ID,RULE_SQL FROM BRM_RULES")
        allrows = c2.fetchall()
        rule_sql_map = {}
        for (rid, rsql) in allrows:
            rule_sql_map[rid] = rsql

        executed = []
        fails = []
        for rid in rule_ids:
            if rid not in rule_sql_map:
                fails.append(rid)
                continue
            sql_ = rule_sql_map[rid] or ""
            ok, msg = run_rule_sql_dry_run(self.connection, sql_)
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return (executed, fails)