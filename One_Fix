from PyQt5.QtWidgets import (
    QPlainTextEdit, QWidget, QVBoxLayout, QLabel,
    QLineEdit, QPushButton, QHBoxLayout
)
from PyQt5.QtCore import Qt
import logging

class EnhancedLineageGraphWidget(QPlainTextEdit):
    """
    A textual placeholder for an 'advanced' lineage or 'brain-map' display.
    Provides:
      - populate_graph() to gather BFS adjacency
      - resetView() to restore original text
      - dim_non_matches_and_highlight() for searching lines
      - optional advanced flag in constructor
    """

    def __init__(self, connection, advanced=False, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.advanced = advanced  # if you want to toggle advanced mode
        self.setReadOnly(True)
        self.setPlaceholderText(
            "Enhanced lineage 'brain map' (textual fallback).\n"
            "Use 'populate_graph()' to load adjacency. Use 'search_lineage()' or "
            "'dim_non_matches_and_highlight()' to highlight lines."
        )

        self.current_lineage_data = []
        # Optionally auto-populate the text on creation
        self.populate_graph()

    def populate_graph(self):
        """
        Build a textual lineage representation using BFS.
        We'll read from BRM_RULES, plus any adjacency like PARENT_RULE_ID,
        global-critical links, child links, table dependencies, etc.
        Then we'll produce lines of text in self.current_lineage_data.
        """
        self.clear()
        self.current_lineage_data = []

        # 1) Gather basic rule info
        c = self.connection.cursor()
        c.execute("""
            SELECT RULE_ID, RULE_NAME, STATUS, CRITICAL_RULE, IS_GLOBAL
            FROM BRM_RULES
            ORDER BY RULE_ID
        """)
        all_rules = c.fetchall()
        rule_map = {}
        for (rid, name, st, crit, glob) in all_rules:
            rule_map[rid] = {
                "RULE_NAME": name,
                "STATUS": st,
                "CRITICAL": crit,
                "GLOBAL": glob
            }

        # 2) Build adjacency from parent->child
        adjacency = {}
        # gather parent->child from PARENT_RULE_ID
        c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES WHERE PARENT_RULE_ID IS NOT NULL")
        for (child_id, parent_id) in c.fetchall():
            adjacency.setdefault(parent_id, []).append(child_id)

        # 3) (Optional) gather global-critical links if needed:
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        gcr_links = c.fetchall()
        # We'll store them separately for textual display
        gcr_map = {}
        for (gcr, tgt) in gcr_links:
            gcr_map.setdefault(gcr, []).append(tgt)

        # 4) Identify "root" rules (no parent). BFS from each root.
        # We'll gather all RULE_ID => see which ones are children
        all_rule_ids = set(rule_map.keys())
        children_ids = set()
        for prnt, childs in adjacency.items():
            for c_ in childs:
                children_ids.add(c_)
        # root = those not in children_ids
        roots = [r for r in all_rule_ids if r not in children_ids]

        out_lines = []
        out_lines.append("=== LINEAGE MAP (Text-based BFS) ===")

        from collections import deque
        queue = deque(roots)
        depth_map = {}
        for r_ in roots:
            depth_map[r_] = 0

        visited = set()
        while queue:
            cur = queue.popleft()
            if cur in visited:
                continue
            visited.add(cur)
            d_ = depth_map.get(cur, 0)

            # info about the rule
            info = rule_map.get(cur, {})
            nm = info.get("RULE_NAME", f"Rule{cur}")
            st = info.get("STATUS", "UNKNOWN")
            cval = info.get("CRITICAL", 0)
            gval = info.get("GLOBAL", 0)
            prefix = "  " * d_

            # Build a descriptive line
            line = f"{prefix}- Rule {cur}: {nm} [status={st}, crit={cval}, global={gval}]"
            out_lines.append(line)

            # If current rule has a GCR link in gcr_map => show them
            if cur in gcr_map:
                for child_gcr in gcr_map[cur]:
                    out_lines.append(f"{prefix}   -> GCR link => Rule {child_gcr}")

            # Enqueue children from adjacency
            if cur in adjacency:
                for ch in adjacency[cur]:
                    if ch not in visited:
                        depth_map[ch] = d_ + 1
                        queue.append(ch)

        self.current_lineage_data = out_lines
        self.appendPlainText("\n".join(out_lines))

    def resetView(self):
        """
        Restore the original 'current_lineage_data' lines.
        """
        self.clear()
        if self.current_lineage_data:
            self.appendPlainText("\n".join(self.current_lineage_data))

    def dim_non_matches_and_highlight(self, text):
        """
        Simple text-based approach to highlight lines that contain `text`
        and 'dim' lines that do not.
        """
        text_lower = text.lower()
        output_lines = []
        for line in self.current_lineage_data:
            if text_lower in line.lower():
                # highlight
                output_lines.append(f">>> {line} <<<")
            else:
                # dim
                output_lines.append(f"(dim) {line}")

        self.clear()
        self.appendPlainText("\n".join(output_lines))

    def search_lineage(self, text):
        """
        Optional approach if you want a single method to do searching.
        Could just call dim_non_matches_and_highlight(text).
        """
        self.dim_non_matches_and_highlight(text)