#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8 (ENHANCED + LOCKS)
Core foundation: 
 - Consolidated imports for entire 8-part solution
 - Logging
 - Email Config + Sender
 - Database Connection Dialog
 - Basic DB helpers (fetch, audit)
 - Login Dialog
 - detect_operation_type
 - parse_sql_dependencies (advanced)
 - Lifecycle states
 - OnboardingWizard (optional new-user flow)
 - Lock/unlock logic stubs (RULE_LOCKS) + auto-unlock

No external/old code references outside these 8 parts.
"""

# =========================
#         IMPORTS
# =========================
import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re
import csv

from datetime import datetime, date, time, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 for GUI
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QDateTime, QTimer, QDate, QMimeData, 
)
from PyQt5.QtGui import (
    QColor, QPainter, QBrush, QPen, QDrag
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog,
    QCalendarWidget, QAbstractItemView
)
import pyqtgraph as pg
from sqlparse.sql import (
    Identifier, IdentifierList, Parenthesis, Token
)
from sqlparse.tokens import Keyword, DML

# =========================
#         LOGGING
# =========================
logging.basicConfig(
    filename='brm_tool_advanced.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

# =========================
#     EMAIL CONFIG
# =========================
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_user",
    "smtp_password": "your_smtp_pass",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    SMTP-based email sending using the above config.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email to {recipients}: {ex}")


# =========================
#   DATABASE CONNECTION
# =========================
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    ODBC DSN or custom string for connecting to SQL Server.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection=None
        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400,200)

        main_layout=QVBoxLayout(self)
        lbl=QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.conn_type_combo=QComboBox()
        try:
            dsn_dict=pyodbc.dataSources()
            for dsn_name,driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error(f"Error listing DSNs: {e}")
        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit=QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        bh=QHBoxLayout()
        ok_btn=QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

    def get_connection(self):
        override=self.conn_str_edit.text().strip()
        if override:
            conn_str=override
        else:
            choice=self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self,"Error","No DSN or conn string chosen.")
                return None
            conn_str=f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self,"Connection Error",str(ex))
            return None

# =========================
#       DB HELPERS
# =========================
def fetch_all_dict(cursor):
    """
    Return fetchall as a list of dicts if description present.
    """
    rows=cursor.fetchall()
    if cursor.description:
        cols=[d[0] for d in cursor.description]
        return [dict(zip(cols,r)) for r in rows]
    return rows

def fetch_one_dict(cursor):
    """
    Return single row as dict if description present.
    """
    row=cursor.fetchone()
    if row and cursor.description:
        cols=[d[0] for d in cursor.description]
        return dict(zip(cols,row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    """
    Insert a record into BRM_AUDIT_LOG => storing old/new data as JSON.
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
      OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """,(
        action,
        table_name,
        str(record_id) if record_id else None,
        actor,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()


# =========================
#        LOGIN
# =========================
class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password => query USERS table => store user_id, user_group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=None
        self.user_group=None
        self.setWindowTitle("Login – Part 1")
        self.resize(300,150)

        main_layout=QVBoxLayout(self)

        self.user_edit=QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit=QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        btn=QPushButton("Login")
        btn.clicked.connect(self.do_login)
        main_layout.addWidget(btn)

        self.setLayout(main_layout)

    def do_login(self):
        un=self.user_edit.text().strip()
        pw=self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self,"Error","Enter username and password.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT USER_ID,USER_GROUP
        FROM USERS
        WHERE USERNAME=? AND PASSWORD=?
        """,(un,pw))
        row=fetch_one_dict(c)
        if row:
            self.user_id=row["USER_ID"]
            self.user_group=row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")


# =========================
#  DETECT OPERATION TYPE
# =========================
def detect_operation_type(rule_sql: str, decision_table_id=None)->str:
    """
    Return one of INSERT/UPDATE/DELETE/SELECT/DECISION_TABLE/OTHER.
    If rule_sql is empty but there's a decision_table_id => DECISION_TABLE.
    """
    if (not rule_sql.strip()) and decision_table_id:
        return "DECISION_TABLE"
    txt=rule_sql.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"


# =========================
#  ADVANCED SQL PARSER
# =========================
def parse_sql_dependencies(sql_text:str):
    """
    Parse using sqlparse => find table references (including subselect & cte).
    Return dict with { 'tables': [...], 'cte_tables': [...], 'alias_map':..., 'columns':... }.
    """
    statements=sqlparse.parse(sql_text)
    all_tables=[]
    cte_info=[]
    alias_map={}
    columns=[]

    for stmt in statements:
        ctes=_extract_with_clauses(stmt)
        for cName, cRefs in ctes.items():
            cte_info.append((cName,cRefs))

        main_refs, main_alias=_extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs=_extract_columns(stmt)
        columns.extend(col_refs)

    unique_tables=list({x for x in all_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }

from sqlparse.sql import Identifier, IdentifierList, Parenthesis
from sqlparse.tokens import Keyword, DML

def _extract_with_clauses(statement):
    cte_map={}
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper()=="WITH":
            i+=1
            i=_parse_cte_block(tokens,i,cte_map)
            continue
        i+=1
    return cte_map

def _parse_cte_block(tokens,i,cte_map):
    while i<len(tokens):
        tk=tokens[i]
        if isinstance(tk,Identifier):
            cte_name=tk.get_real_name()
            i+=1
            i=_parse_cte_as_clause(tokens,i,cte_name,cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i+=1
    return i

def _parse_cte_as_clause(tokens,i,cte_name,cte_map):
    while i<len(tokens):
        tk=tokens[i]
        val=tk.value.upper() if tk.ttype else ""
        if val=="AS":
            i+=1
            if i<len(tokens):
                sub=tokens[i]
                if isinstance(sub,Parenthesis):
                    sub_refs=_extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name]=sub_refs
                    i+=1
                    return i
        else:
            i+=1
    return i

def _extract_subselect_tokens(tokens):
    results=[]
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk,IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident,set())
                    st=(st[0],st[1],st[2],True)
                    results.append(st)
            elif isinstance(tk,Identifier):
                st=_parse_identifier(tk,set())
                st=(st[0],st[1],st[2],True)
                results.append(st)
        i+=1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper()=="SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    results=[]
    alias_map={}
    tokens=list(tokenlist)
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk,IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, known_cte_names)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]]=(st[0],st[1])
            elif isinstance(tk,Identifier):
                st=_parse_identifier(tk, known_cte_names)
                results.append(st)
                if st[2]:
                    alias_map[st[2]]=(st[0],st[1])
        i+=1
    return (results,alias_map)

def _parse_identifier(ident, known_cte_names):
    alias=ident.get_alias()
    real_name=ident.get_real_name()
    schema_name=ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    results=[]
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is DML:
            word=tk.value.upper()
            if word=="SELECT":
                col_refs=_parse_select_list(tokens,i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif word in ("INSERT","UPDATE"):
                colRefs=_parse_dml_columns(tokens,i,word)
                for c_ in colRefs:
                    results.append((c_, True, False))
        i+=1
    return results

def _parse_select_list(tokens, start_idx):
    columns=[]
    i=start_idx
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk,IdentifierList):
            for ident in tk.get_identifiers():
                nm=ident.get_name()
                if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(nm)
        elif isinstance(tk,Identifier):
            nm=tk.get_name()
            if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(nm)
        i+=1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    columns=[]
    if dml_word=="INSERT":
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and isinstance(tk,Parenthesis):
                for st in tk.tokens:
                    if isinstance(st,IdentifierList):
                        for ident in st.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(st,Identifier):
                        columns.append(st.get_name())
                return columns
            i+=1
    elif dml_word=="UPDATE":
        found_set=False
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.ttype is Keyword and tk.value.upper()=="SET":
                found_set=True
                i+=1
                columns.extend(_parse_update_set_list(tokens,i))
                break
            i+=1
    return columns

def _parse_update_set_list(tokens, start_i):
    columns=[]
    i=start_i
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk,Identifier):
            columns.append(tk.get_name())
        i+=1
    return columns


# =========================
# LIFECYCLE STATES
# =========================
RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]

# =========================
#  ONBOARDING WIZARD
# =========================
class OnboardingWizard(QDialog):
    """
    Optional wizard => new users => create group, create rule, schedule rule => done.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Welcome Wizard (Part 1)")
        self.resize(400,300)

        main_layout=QVBoxLayout(self)
        self.steps_label=QLabel("Welcome to the advanced BRM Tool!\nThis wizard helps new users do basic setup.")
        main_layout.addWidget(self.steps_label)

        self.current_step=0
        next_btn=QPushButton("Next")
        next_btn.clicked.connect(self.advance_step)
        main_layout.addWidget(next_btn)
        self.setLayout(main_layout)

    def advance_step(self):
        self.current_step+=1
        if self.current_step==1:
            self.steps_label.setText("Step 1: Go to 'Group Management' => 'Add Group'.")
        elif self.current_step==2:
            self.steps_label.setText("Step 2: Go to 'Business Rules' => 'Add Rule'.")
        elif self.current_step==3:
            self.steps_label.setText("Step 3: Go to 'Scheduling' => 'Add New Schedule'.")
        else:
            self.steps_label.setText("All done. Enjoy the BRM Tool.")
            self.accept()


# ====================================================
#     LOCKING FUNCTIONALITY (RULE_LOCKS)
# ====================================================
def lock_rule_for_editing(conn, rule_id, user_id):
    """
    Attempt to lock RULE_ID for editing by user_id.
    - If rule is unlocked => insert new row into RULE_LOCKS => success => return True
    - If locked by same user => refresh timestamp => return True
    - If locked by different user => check if expired (30 min). If expired => forcibly unlock => re-lock => return True
      else => return False
    """
    try:
        c=conn.cursor()
        c.execute("BEGIN TRANSACTION")

        # check if already locked
        c.execute("""
        SELECT LOCKED_BY, LOCK_TIMESTAMP
        FROM RULE_LOCKS
        WHERE RULE_ID=?
        """,(rule_id,))
        row=c.fetchone()
        now_dt=datetime.now()
        expiry=now_dt - timedelta(minutes=30)

        if row:
            locked_by=row[0]
            lock_ts=row[1]  # datetime
            if locked_by==user_id:
                # same user => refresh timestamp
                c.execute("""
                UPDATE RULE_LOCKS
                SET LOCK_TIMESTAMP=GETDATE()
                WHERE RULE_ID=?
                """,(rule_id,))
                c.execute("COMMIT")
                return True, "Already locked by you. Timestamp refreshed."
            else:
                # locked by someone else => check expiry
                if lock_ts<expiry:
                    # forcibly unlock
                    c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?",(rule_id,))
                    c.execute("""
                    INSERT INTO RULE_LOCKS(RULE_ID,LOCKED_BY,LOCK_TIMESTAMP)
                    VALUES(?,?,GETDATE())
                    """,(rule_id,user_id))
                    c.execute("COMMIT")
                    return True,"Lock was expired => forcibly taken."
                else:
                    c.execute("ROLLBACK")
                    return False,f"Locked by user {locked_by}, not expired."
        else:
            # no lock => create
            c.execute("""
            INSERT INTO RULE_LOCKS(RULE_ID,LOCKED_BY,LOCK_TIMESTAMP)
            VALUES(?,?,GETDATE())
            """,(rule_id,user_id))
            c.execute("COMMIT")
            return True,"Lock acquired."
    except Exception as ex:
        c.execute("ROLLBACK")
        return False,str(ex)


def unlock_rule(conn, rule_id, user_id):
    """
    If rule is locked by that user => remove row => success => return True
    If locked by another => return False
    """
    try:
        c=conn.cursor()
        c.execute("BEGIN TRANSACTION")
        c.execute("""
        SELECT LOCKED_BY
        FROM RULE_LOCKS
        WHERE RULE_ID=?
        """,(rule_id,))
        row=c.fetchone()
        if not row:
            c.execute("ROLLBACK")
            return False,"Not locked."

        locked_by=row[0]
        if locked_by==user_id:
            c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?",(rule_id,))
            c.execute("COMMIT")
            return True,"Unlocked."
        else:
            c.execute("ROLLBACK")
            return False,f"Locked by another user {locked_by}."
    except Exception as ex:
        c.execute("ROLLBACK")
        return False,str(ex)


def force_unlock_rule(conn, rule_id, admin_user):
    """
    Admin => forcibly unlock the rule => no matter who locked it.
    """
    try:
        c=conn.cursor()
        c.execute("BEGIN TRANSACTION")
        c.execute("DELETE FROM RULE_LOCKS WHERE RULE_ID=?",(rule_id,))
        c.execute("COMMIT")
        return True,"Force-unlocked."
    except Exception as ex:
        c.execute("ROLLBACK")
        return False,str(ex)


def auto_unlock_expired_locks(conn):
    """
    Periodically called => remove any lock older than 30 minutes.
    """
    try:
        c=conn.cursor()
        expiry=datetime.now() - timedelta(minutes=30)
        c.execute("""
        DELETE FROM RULE_LOCKS
        WHERE LOCK_TIMESTAMP < ?
        """,(expiry,))
        count=c.rowcount
        conn.commit()
        if count>0:
            logger.info(f"Auto-unlocked {count} expired locks.")
    except Exception as ex:
        logger.error(f"Error in auto_unlock_expired_locks: {ex}")
"""
BRM TOOL – PART 2 of 8 (ENHANCED + LOCKS)
Unified BFS (child, GCR, conflict, composite), multi-step approvals, 
advanced CRUD (lifecycle), advanced impact analysis,
plus LOCK checks on update or delete.

Builds on Part 1’s imports, logging, DB helpers, plus lock/unlock functions.
No references to external old code.
"""

import json
from datetime import datetime, timedelta
from collections import deque

# from Part 1 in same file => we have:
#    fetch_one_dict, insert_audit_log, detect_operation_type, parse_sql_dependencies
#    lock_rule_for_editing, unlock_rule, force_unlock_rule, etc.


# =========================
#   BUILD ADJACENCY
# =========================

def load_rule_relationships(conn):
    """
    Construct adjacency for:
      - child rules (PARENT_RULE_ID)
      - global-critical links (BRM_GLOBAL_CRITICAL_LINKS)
      - conflict adjacency (RULE_CONFLICTS)
      - composite adjacency (COMPOSITE_RULES)
    Return a dict => rule_id -> set of connected rule_ids
    plus a list of root rules (no parent).
    Also store each rule’s parent in parent_map for quick root identification.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()

    # child BFS
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            parent_map[rid]=pid

    # find GCR links
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcr_rows = c.fetchall()
    for (gcr, tgt) in gcr_rows:
        adjacency.setdefault(gcr,set()).add(tgt)

    # find conflicts => skip the lower priority if the higher fails
    conf_map = build_conflict_adjacency(conn)
    for r1, linkedset in conf_map.items():
        adjacency.setdefault(r1,set()).update(linkedset)

    # find composite references => treat each sub-rule as an adjacency to the composite
    comp_map = build_composite_adjacency(conn)
    for r1, compset in comp_map.items():
        adjacency.setdefault(r1,set()).update(compset)

    # identify root rules => those with no parent
    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]

    return adjacency, roots, parent_map

def build_conflict_adjacency(conn):
    """
    Return dict => rule_id -> set of conflicting rule_ids
    referencing RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY).
    We'll store adjacency for BFS; actual skip logic uses priority map in BFS logic if needed.
    """
    c=conn.cursor()
    c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    rows=c.fetchall()
    adjacency={}
    # For demonstration, we won't fill adjacency here unless you wanted symmetrical adjacency:
    # e.g. adjacency.setdefault(r1,set()).add(r2) and adjacency.setdefault(r2,set()).add(r1)
    # We'll keep it minimal for BFS skipping demonstration. This can be expanded if needed.
    return adjacency

def build_priority_map(conn):
    """
    Return map => frozenset({r1,r2}) -> priority (just an int).
    BFS skip logic can interpret these as needed.
    """
    c=conn.cursor()
    c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    rows=c.fetchall()
    pmap={}
    for (cfid,r1,r2,pri) in rows:
        key=frozenset({r1,r2})
        pmap[key]=pri
    return pmap

def build_composite_adjacency(conn):
    """
    Return dict => subRuleID -> set of compositeRuleIDs
    to unify BFS adjacency. If subRule fails => skip composite.
    We'll parse LOGIC_EXPR for 'RuleX' references.
    """
    c=conn.cursor()
    c.execute("SELECT COMPOSITE_RULE_ID,LOGIC_EXPR FROM COMPOSITE_RULES")
    rows=c.fetchall()
    adj={}
    pat = r"Rule(\d+)"
    import re
    for (crid, expr) in rows:
        if not expr:
            continue
        matches=re.findall(pat, expr)
        for m_ in matches:
            try:
                rid=int(m_)
                adj.setdefault(rid,set()).add(crid)
            except:
                pass
    return adj

def skip_all_descendants(start_id, adjacency, skipped):
    """
    BFS to skip everything reachable from start_id.
    """
    queue=[start_id]
    while queue:
        cur=queue.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch_ in adjacency[cur]:
                if ch_ not in skipped:
                    queue.append(ch_)


# =========================
#   ENHANCED BFS
# =========================

def execute_rules_with_conflicts_composites_bfs(conn):
    """
    Unified BFS => handle child, GCR, conflicts, composites.
      - If a rule fails AND is critical => skip children.
      - Conflicts or composites => skip them if the “parent” fails, etc.
    Return (executed, skipped).
    This BFS does not check or skip locked rules => (by default, BFS is read-only).
    If you want BFS to skip locked rules, see note below.
    """
    adjacency, roots, parent_map = load_rule_relationships(conn)
    pmap = build_priority_map(conn)  # for conflicts
    rule_lookup = get_all_rules_map(conn)

    executed=[]
    skipped=set()
    queue=list(roots)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info=rule_lookup[rid]
        (ok,msg,rec_count)=run_single_rule_in_transaction(conn, info)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # if fails => skip adjacency if rule is critical
            is_crit = (info["CRITICAL_RULE"]==1 or info["IS_GLOBAL"]==1)
            scope = (info["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and scope!="NONE":
                if rid in adjacency:
                    for ch_ in adjacency[rid]:
                        skip_all_descendants(ch_, adjacency, skipped)
            # also skip conflicts or composites referencing rid => BFS might unify the adjacency in future expansions
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    skip_all_descendants(ch_, adjacency, skipped)
            skipped.add(rid)

    return (executed, skipped)

def get_all_rules_map(conn):
    """
    Return rule_id -> full row.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows=c.fetchall()
    colnames=[desc[0] for desc in c.description]
    out={}
    for row in rows:
        d=dict(zip(colnames,row))
        out[d["RULE_ID"]]=d
    return out


def run_single_rule_in_transaction(conn, rule_info):
    """
    For BFS => transaction-based => if OPERATION_TYPE='DECISION_TABLE' => stub pass,
    else run rule_sql => if row[0][0]==1 => pass => commit else fail => rollback.
    Return (ok, msg, record_count).
    """
    if rule_info["OPERATION_TYPE"]=="DECISION_TABLE":
        dt_id=rule_info.get("DECISION_TABLE_ID")
        return (True, f"DT {dt_id} => PASS (stub)",1)

    sql_=rule_info["RULE_SQL"] or ""
    c=conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    rec_count=0
    try:
        c.execute(sql_)
        rows=c.fetchall()
        if rows:
            rec_count=len(rows)
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
        if success:
            c.execute("COMMIT")
        else:
            c.execute("ROLLBACK")
    except Exception as ex:
        c.execute("ROLLBACK")
        success=False
        msg=str(ex)
    return (success,msg,rec_count)

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert row in RULE_EXECUTION_LOGS => BFS or scheduled runs.
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID, EXECUTION_TIMESTAMP,
      PASS_FLAG, MESSAGE, RECORD_COUNT
    )
    VALUES(?,GETDATE(),?,?,?)
    """,(rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()


# =========================
# MULTI-STEP APPROVALS
# =========================
def create_multistep_approvals(conn, rule_id):
    """
    Insert approvals in BRM_RULE_APPROVALS => pipeline BG1->BG2->BG3->FINAL 
    with optional checks for finance => BG2, sensitive => BG3, BFS impacted groups, etc.
    """
    impacted=find_impacted_groups_advanced(conn, rule_id)

    # check table references
    c2=conn.cursor()
    c2.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rule_id,))
    trows=c2.fetchall()
    require_bg2=False
    require_bg3=False
    for (tname,) in trows:
        lo=(tname or "").lower()
        if "finance" in lo or "credit" in lo:
            require_bg2=True
        if "sensitive_data" in lo or "personal_info" in lo:
            require_bg3=True

    pipeline=[]
    pipeline.append("BG1")
    if require_bg2 or "BG2" in impacted:
        pipeline.append("BG2")
    if require_bg3 or "BG3" in impacted:
        pipeline.append("BG3")
    pipeline.append("FINAL")

    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    stage=1
    for grp in pipeline:
        if grp=="FINAL":
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID,GROUP_NAME,USERNAME,
              APPROVED_FLAG,APPROVED_TIMESTAMP,APPROVAL_STAGE
            )
            VALUES(?,?,?,?,NULL,?)
            """,(rule_id,"FINAL","final_approver",0,stage))
            stage+=1
        else:
            c3=conn.cursor()
            c3.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
            arows=c3.fetchall()
            for (apuser,) in arows:
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID,GROUP_NAME,USERNAME,
                  APPROVED_FLAG,APPROVED_TIMESTAMP,APPROVAL_STAGE
                )
                VALUES(?,?,?,?,NULL,?)
                """,(rule_id,grp,apuser,0,stage))
            stage+=1
    conn.commit()


# =========================
#  ADVANCED IMPACT ANALYSIS
# =========================
def find_impacted_groups_advanced(conn, rule_id):
    """
    BFS => gather child rules, GCR, conflicts => unify => read their OWNER_GROUP => return set of groups.
    """
    impacted=set()
    c=conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if row:
        impacted.add(row[0])

    all_related=unified_get_related_rules(conn, rule_id)
    for rid in all_related:
        c2=conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        r2=c2.fetchone()
        if r2:
            impacted.add(r2[0])
    return impacted

def unified_get_related_rules(conn, start_rule_id):
    """
    BFS => child rules, GCR links, conflict adjacency, composite adjacency => returns set of rule IDs.
    """
    adjacency, roots, parent_map=load_rule_relationships(conn)
    visited=set()
    queue=[start_rule_id]
    while queue:
        cur=queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in adjacency:
            for ch_ in adjacency[cur]:
                if ch_ not in visited:
                    queue.append(ch_)
    return visited


# =========================
# RULE CRUD (with Lock checks)
# =========================
def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert => parse => set lifecycle => create approvals => handle duplicates
    Lock not needed for 'add', as there's no existing rule to lock.
    """
    c=conn.cursor()

    # check duplicates
    c.execute("""
    SELECT RULE_ID FROM BRM_RULES
    WHERE OWNER_GROUP=? AND RULE_NAME=?
    """,(rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    # same SQL?
    new_sql=rule_data.get("RULE_SQL","").strip()
    if new_sql:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        row2=c.fetchone()
        if row2:
            raise ValueError("Another rule with that exact SQL already exists.")

    rule_data["LIFECYCLE_STATE"]="DRAFT"
    if rule_data.get("IS_GLOBAL",0)==1 and user_group!="Admin":
        raise ValueError("Only Admin can create a global rule.")

    from .part1_foundation import detect_operation_type, parse_sql_dependencies  # if multi-file
    final_op=detect_operation_type(new_sql, rule_data.get("DECISION_TABLE_ID"))
    rule_data["OPERATION_TYPE"]=final_op

    parse_info={}
    col_op="READ"
    if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
        parse_info=parse_sql_dependencies(new_sql)
        if final_op in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"

    nowstr=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    row=c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
      EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,
      STATUS,VERSION,
      CREATED_BY,DESCRIPTION,OPERATION_TYPE,
      BUSINESS_JUSTIFICATION,CREATED_TIMESTAMP,
      UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,
      APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,
      CRITICAL_SCOPE,CDC_TYPE,LIFECYCLE_STATE,
      DECISION_TABLE_ID
    )
    OUTPUT inserted.RULE_ID
    VALUES(?,?,?,?,?,
           ?,?,
           ?,?,
           ?,?,?,?,?,?,
           ?,?,?,?,
           ?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,

        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),

        rule_data.get("STATUS","INACTIVE"),
        1,

        created_by,
        rule_data.get("DESCRIPTION",""),
        final_op,

        rule_data.get("BUSINESS_JUSTIFICATION",""),
        nowstr,

        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),

        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),

        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE"),
        rule_data["LIFECYCLE_STATE"],

        rule_data.get("DECISION_TABLE_ID", None)
    )).fetchone()

    if not row:
        raise ValueError("Insert failed => no RULE_ID.")
    new_id=row[0]

    if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
        for (sch,tb,alias,issub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(new_id, sch if sch else "N/A",tb,"AutoCol", col_op))

    insert_audit_log(conn, "INSERT","BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # create approvals if not global or user is admin
    if rule_data.get("IS_GLOBAL",0)==0 or user_group=="Admin":
        create_multistep_approvals(conn, new_id)

    return new_id


def update_rule(conn, rule_data, updated_by, user_group):
    """
    Update => check lock => set status=INACTIVE => re-approval => parse new SQL => advanced references.
    If locked by another user => if admin => can forcibly unlock, else raise error.
    """
    c=conn.cursor()
    rid=rule_data["RULE_ID"]

    # lock check
    from .part1_foundation import lock_rule_for_editing, force_unlock_rule
    ok,msg=lock_rule_for_editing(conn, rid, updated_by)
    if not ok:
        # means locked by diff user & not expired
        # if user_group=="Admin", we can force
        if user_group=="Admin":
            # forcibly unlock
            ok2,msg2=force_unlock_rule(conn, rid, updated_by)
            if not ok2:
                raise ValueError(f"Cannot force-unlock: {msg2}")
            # now attempt lock again
            ok3,msg3=lock_rule_for_editing(conn, rid, updated_by)
            if not ok3:
                raise ValueError(f"After force-unlock, still cannot lock: {msg3}")
        else:
            raise ValueError(f"Rule is locked => {msg}")

    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    colnames=[desc[0] for desc in c.description]
    old_data=dict(zip(colnames,old))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update global rule.")

    new_sql=rule_data.get("RULE_SQL","").strip()
    if new_sql and new_sql!=old_data["RULE_SQL"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        row2=c.fetchone()
        if row2 and row2[0]!=rid:
            raise ValueError("Another rule with that SQL already exists.")

    from .part1_foundation import detect_operation_type, parse_sql_dependencies
    final_op=detect_operation_type(new_sql, rule_data.get("DECISION_TABLE_ID"))
    rule_data["OPERATION_TYPE"]=final_op

    parse_info={}
    col_op="READ"
    if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
        parse_info=parse_sql_dependencies(new_sql)
        if final_op in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"

    c.execute("""
    UPDATE BRM_RULES
    SET GROUP_ID=?,
        PARENT_RULE_ID=?,
        RULE_TYPE_ID=?,
        RULE_NAME=?,
        RULE_SQL=?,
        EFFECTIVE_START_DATE=?,
        EFFECTIVE_END_DATE=?,
        STATUS='INACTIVE',
        VERSION=VERSION+1,
        UPDATED_BY=?,
        DESCRIPTION=?,
        OPERATION_TYPE=?,
        BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?,
        CLUSTER_NAME=?,
        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?,
        CRITICAL_RULE=?,
        CRITICAL_SCOPE=?,
        CDC_TYPE=?,
        LIFECYCLE_STATE='UNDER_APPROVAL',
        DECISION_TABLE_ID=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        final_op,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
        rule_data.get("CLUSTER_NAME", old_data["CLUSTER_NAME"]),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rule_data.get("DECISION_TABLE_ID", old_data["DECISION_TABLE_ID"]),
        rid
    ))
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))

    if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
        for (sch,tb,alias,issub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid, sch if sch else "N/A", tb,"AutoCol", col_op))

    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"]=old_data["VERSION"]+1

    insert_audit_log(conn,"UPDATE","BRM_RULES",rid,updated_by,old_data,new_data)
    conn.commit()

    # re-create approvals
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"])==0 or user_group=="Admin":
        create_multistep_approvals(conn, rid)


def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivate => must be APPROVED => no ACTIVE children => if global => admin only
    Lock check => user must lock it first or forcibly unlock if admin.
    """
    # lock check
    from .part1_foundation import lock_rule_for_editing, force_unlock_rule
    ok,msg=lock_rule_for_editing(conn, rule_id, updated_by)
    if not ok:
        # attempt force if admin
        if user_group=="Admin":
            ok2,msg2=force_unlock_rule(conn, rule_id, updated_by)
            if not ok2:
                raise ValueError(f"Cannot force-unlock: {msg2}")
            ok3,msg3=lock_rule_for_editing(conn, rule_id, updated_by)
            if not ok3:
                raise ValueError(f"After force-unlock => {msg3}")
        else:
            raise ValueError(f"Rule is locked => {msg}")

    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old))

    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate => not fully APPROVED.")
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")

    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    if c.fetchone():
        raise ValueError("Deactivate child rules first (some are ACTIVE).")

    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',
        UPDATED_BY=?,
        VERSION=VERSION+1,
        LIFECYCLE_STATE='INACTIVE'
    WHERE RULE_ID=?
    """,(updated_by, rule_id))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["LIFECYCLE_STATE"]="INACTIVE"

    insert_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()


def delete_rule(conn, rule_id, action_by, user_group):
    """
    Fully-approved, inactive => no children => no references => if global => admin only => remove from BRM_RULES
    Also check lock => if locked by another => block or force unlock if admin.
    """
    from .part1_foundation import lock_rule_for_editing, force_unlock_rule
    ok,msg=lock_rule_for_editing(conn, rule_id, action_by)
    if not ok:
        if user_group=="Admin":
            ok2,msg2=force_unlock_rule(conn, rule_id, action_by)
            if not ok2:
                raise ValueError(f"Cannot force-unlock: {msg2}")
            ok3,msg3=lock_rule_for_editing(conn, rule_id, action_by)
            if not ok3:
                raise ValueError(f"After force-unlock => {msg3}")
        else:
            raise ValueError(f"Rule is locked => {msg}")

    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Must be INACTIVE first.")

    c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    if c.fetchone():
        raise ValueError("Child rules exist; cannot delete.")

    c.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    if c.fetchone():
        raise ValueError("Remove references from BRM_COLUMN_MAPPING first.")

    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    insert_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)
    conn.commit()
"""
BRM TOOL – PART 3 of 8 (ENHANCED + LOCKS)
Single/chain/group simulations (unified BFS), improved metadata sync,
scheduling, advanced feature tabs (decision tables, conflicts, composites, snapshots, tags, validations),
plus an updated WhatIfTestTab with CSV loading.

Builds on the advanced BFS logic from Part 2 and the foundation/locking from Part 1.
No references to old code outside these 8 parts.
"""

import json
import math
import logging
import csv
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget, QFileDialog, QAbstractItemView
)
from PyQt5.QtCore import Qt, QDate, QDateTime
import pyqtgraph as pg

# from Part 1 => parse_sql_dependencies, sync_metadata_improved, lock/unlock if needed
# from Part 2 => BFS logic => execute_rules_with_conflicts_composites_bfs, run_single_rule_in_transaction, etc.


# =========================
#  DRY-RUN UTILITY + SIMS (UNIFIED BFS)
# =========================

def dry_run_advanced_bfs(conn, selected_rule_ids=None):
    """
    Single BFS routine that can handle:
     - If selected_rule_ids => BFS from those rule IDs (chain or group).
     - Otherwise => BFS from all root rules in the system.

    Uses the logic from Part 2 => 'execute_rules_with_conflicts_composites_bfs'
    but does it in 'dry-run' mode => always ROLLBACK each rule.
    """
    if not selected_rule_ids:
        # BFS from entire set => using the real function but forced to rollback
        (executed, skipped) = _dry_run_bfs_overall(conn)
        return (executed, skipped)
    else:
        (executed, skipped)=_dry_run_bfs_subset(conn, selected_rule_ids)
        return (executed, skipped)

def _dry_run_bfs_overall(conn):
    """
    Load adjacency => BFS from roots => for each rule => run_single_rule_in_transaction => ROLLBACK => gather pass/fail => skip if needed.
    """
    from .part2_crud import load_rule_relationships, get_all_rules_map, skip_all_descendants
    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_map = get_all_rules_map(conn)

    executed=[]
    skipped=set()
    queue=list(roots)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue

        info=rule_map[rid]
        (ok,msg,rec_count)=_dry_run_single(conn, info)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip adjacency if critical
            is_crit=(info["CRITICAL_RULE"]==1 or info["IS_GLOBAL"]==1)
            scope=(info["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and scope!="NONE":
                if rid in adjacency:
                    for c_ in adjacency[rid]:
                        skip_all_descendants(c_, adjacency, skipped)
            if rid in adjacency:
                for c_ in adjacency[rid]:
                    skip_all_descendants(c_, adjacency, skipped)
            skipped.add(rid)

    return (executed, skipped)

def _dry_run_bfs_subset(conn, start_ids):
    """
    BFS from a subset => same approach => always rollback each rule’s SQL.
    """
    from .part2_crud import load_rule_relationships, get_all_rules_map, skip_all_descendants
    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_map = get_all_rules_map(conn)

    executed=[]
    skipped=set()
    queue=list(start_ids)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        info=rule_map[rid]
        (ok,msg,rc)=_dry_run_single(conn, info)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            is_crit=(info["CRITICAL_RULE"]==1 or info["IS_GLOBAL"]==1)
            scope=(info["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and scope!="NONE":
                if rid in adjacency:
                    for c_ in adjacency[rid]:
                        skip_all_descendants(c_, adjacency, skipped)
            if rid in adjacency:
                for c_ in adjacency[rid]:
                    skip_all_descendants(c_, adjacency, skipped)
            skipped.add(rid)

    return (executed, skipped)

def _dry_run_single(conn, rule_info):
    """
    BFS => begin tran => run => rollback => see pass/fail => return (ok, msg, row_count).
    """
    op=rule_info["OPERATION_TYPE"]
    if op=="DECISION_TABLE":
        dt_id=rule_info.get("DECISION_TABLE_ID")
        return (True, f"[DryRun] DT {dt_id} => PASS",1)

    sql_=rule_info["RULE_SQL"] or ""
    c=conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    row_count=0
    try:
        c.execute(sql_)
        rows=c.fetchall()
        if rows:
            row_count=len(rows)
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
        # always rollback in dry-run
        c.execute("ROLLBACK")
    except Exception as ex:
        c.execute("ROLLBACK")
        success=False
        msg=str(ex)
    return (success,msg,row_count)


class SingleRuleSimulationDialog(QDialog):
    """
    Let user pick 1 rule => BFS Dry-run for that single rule => show results.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Simulate Single Rule {rule_id} (Part 3)")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        run_btn=QPushButton("Dry-Run BFS")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_sim(self):
        ex,sk = dry_run_advanced_bfs(self.connection, [self.rule_id])
        txt=f"Executed => {ex}\nSkipped => {sk}"
        self.result_text.setPlainText(txt)


class ChainOrGroupSimulationDialog(QDialog):
    """
    Let user pick a 'parent rule' or 'custom group' => BFS dry-run from those rule IDs => show pass/fail.
    Replaces old chain vs group simulation with a single BFS approach.
    """
    def __init__(self, connection, is_group=False, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.is_group=is_group
        title="Simulate Custom Group" if is_group else "Simulate Parent Rule Chain"
        self.setWindowTitle(title+" (Part 3)")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.combo=QComboBox()
        c=connection.cursor()
        if is_group:
            c.execute("SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            rows=c.fetchall()
            for (cg_id,cg_name) in rows:
                disp=f"{cg_id} - {cg_name}"
                self.combo.addItem(disp,cg_id)
            form.addRow("Custom Group:", self.combo)
        else:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            rows=c.fetchall()
            for (rid,rn) in rows:
                disp=f"{rid} - {rn}"
                self.combo.addItem(disp,rid)
            form.addRow("Parent Rule:", self.combo)
        layout.addLayout(form)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate BFS Dry-Run")
        sim_btn.clicked.connect(self.do_sim)
        bh.addWidget(sim_btn)

        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        choice=self.combo.currentData()
        if self.is_group:
            c=self.connection.cursor()
            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(choice,))
            members=c.fetchall()
            start_ids=[m[0] for m in members]
            ex,sk=dry_run_advanced_bfs(self.connection, start_ids)
            txt=f"Group {choice} BFS:\nExecuted => {ex}\nSkipped => {sk}"
        else:
            ex,sk=dry_run_advanced_bfs(self.connection, [choice])
            txt=f"Chain BFS from rule {choice}:\nExecuted => {ex}\nSkipped => {sk}"
        self.result_text.setPlainText(txt)


# =========================
# SYNC METADATA (IMPROVED)
# =========================
def sync_metadata_improved(conn):
    """
    Mark missing table references in BRM_RULE_TABLE_DEPENDENCIES as 'MISSING_' prefix.
    """
    c=conn.cursor()
    c.execute("""
    SELECT s.name as schema_name, t.name as table_name
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id=s.schema_id
    ORDER BY s.name, t.name
    """)
    actual_tables=set()
    for row in c.fetchall():
        fulln=(f"{row[0]}.{row[1]}").lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID,DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps=c.fetchall()
    missing_count=0
    for (dep_id,dbn,tn) in deps:
        cand=tn.lower().strip()
        if "." not in cand:
            cand=(f"dbo.{cand}").lower()
        if cand not in actual_tables:
            c.execute("""
            UPDATE BRM_RULE_TABLE_DEPENDENCIES
            SET TABLE_NAME='MISSING_' + TABLE_NAME
            WHERE DEPENDENCY_ID=?
            """,(dep_id,))
            missing_count+=1

    conn.commit()
    msg=(f"Metadata sync complete.\nFound {len(actual_tables)} real DB tables.\n"
         f"Scanned {len(deps)} dependencies.\n"
         f"Marked {missing_count} references as 'MISSING_'.")
    QMessageBox.information(None,"Sync Metadata",msg)


# =========================
# SCHEDULING
# =========================
class EnhancedScheduleDialog(QDialog):
    """
    Pick a rule => datetime => store in RULE_SCHEDULES => 'Scheduled' status.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Enhanced Scheduling UI (Part 3)")
        self.resize(400,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        cl_btn=QPushButton("Close")
        cl_btn.clicked.connect(self.close)
        bh.addWidget(cl_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        date_=self.calendar.selectedDate()
        time_=self.time_edit.time()
        dt_str=f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP)
        VALUES(?,?,'Scheduled',GETDATE())
        """,(rid, dt_str))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} scheduled at {dt_str}.")
        self.close()


class ScheduleManagementTab(QWidget):
    """
    Show RULE_SCHEDULES => add/update/delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID","RuleID","ScheduleTime","Status","Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn=QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            self.table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.table.setItem(r_i,2,QTableWidgetItem(str(row[2])))
            self.table.setItem(r_i,3,QTableWidgetItem(str(row[3])))

            act_widget=QWidget()
            hh=QHBoxLayout(act_widget)
            hh.setContentsMargins(0,0,0,0)

            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rr=r_i: self.update_schedule(rr))
            hh.addWidget(upd_btn)

            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rr=r_i: self.delete_schedule(rr))
            hh.addWidget(del_btn)

            hh.addStretch()
            self.table.setCellWidget(r_i,4,act_widget)

        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self,row_idx):
        it=self.table.item(row_idx,0)
        if not it:
            return
        sch_id=int(it.text())
        new_dt,ok=QInputDialog.getText(self,"Update Schedule","New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self,row_idx):
        it=self.table.item(row_idx,0)
        if not it:
            return
        sch_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()


# =========================
# ADVANCED FEATURE TABS
# =========================
class DecisionTablesTab(QWidget):
    """
    Manage DECISION_TABLES => BFS logic is in Part 2 => if OPERATION_TYPE=DECISION_TABLE => stub pass.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dt_table=QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","TableName","Description"])
        layout.addWidget(self.dt_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add DecisionTable")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete DecisionTable")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        run_btn=QPushButton("Stub: Run DecisionTable")
        run_btn.clicked.connect(self.run_dt)
        bh.addWidget(run_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.dt_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_dt(self):
        nm,ok=QInputDialog.getText(self,"Add DecisionTable","TableName:")
        if not ok or not nm.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional desc:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(nm.strip(),desc.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","DT created.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No DT selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete DT {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","DT removed.")
        self.load_dt()

    def run_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No DT selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        QMessageBox.information(self,"Stub","DT run => PASS (not implemented).")


class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS => BFS in Part 2 uses them. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        setp_btn=QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.cf_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","RuleID1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","RuleID2:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Enter int priority:")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pri))
        self.connection.commit()
        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        cf_id=int(cfid_item.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cf_id))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Conflict priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        cf_id=int(cfid_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()


class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES => BFS in Part 2 references them for adjacency skipping if sub-rule fails.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CRuleID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_cr)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_cr)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_cr)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_cr()

    def load_cr(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.cr_table.rowCount()
            self.cr_table.insertRow(rr)
            for i_,val in enumerate(row):
                self.cr_table.setItem(rr,i_,QTableWidgetItem(str(val) if val else ""))

    def add_cr(self):
        nm,ok=QInputDialog.getText(self,"New Composite","Name:")
        if not ok or not nm.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expression","(e.g. 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","(Optional) e.g. 'SendEmail'")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
        VALUES(?,?,?)
        """,(nm.strip(), expr.strip(), act.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","Composite rule created.")
        self.load_cr()

    def del_cr(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        cr_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_cr()


class SnapshotManagerTab(QWidget):
    """
    Snapshots => store entire BRM_RULES as JSON => can be used for rollbacks or archiving.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["SnapshotID","Name","CreatedBy","CreatedTS","SnapshotJSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snap)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snaps)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_snaps()

    def load_snaps(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.ss_table.rowCount()
            self.ss_table.insertRow(r_i)
            for idx,val in enumerate(row):
                self.ss_table.setItem(r_i,idx,QTableWidgetItem(str(val) if val else ""))

    def take_snapshot(self):
        nm,ok=QInputDialog.getText(self,"Snapshot","Snapshot name:")
        if not ok or not nm.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        arr=[]
        for row in rows:
            arr.append(dict(zip(colnames,row)))
        snap_json=json.dumps(arr,indent=2)

        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(nm.strip(),"SnapshotUser",snap_json))
        self.connection.commit()
        QMessageBox.information(self,"Snapshot","Snapshot created.")
        self.load_snaps()

    def del_snap(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        it=self.ss_table.item(row,0)
        sid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Snapshot deleted.")
        self.load_snaps()


class TagsManagerTab(QWidget):
    """
    Manage RULE_TAGS => add or remove textual tags to rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows=c.fetchall()
        for r_ in rows:
            rr=self.tags_table.rowCount()
            self.tags_table.insertRow(rr)
            for col_i,val in enumerate(r_):
                self.tags_table.setItem(rr,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        tag_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tag_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()


class DataValidationTab(QWidget):
    """
    Manage DATA_VALIDATIONS => e.g. 'NOT NULL', 'RANGE', etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Validation")
        addb.clicked.connect(self.add_validation)
        bh.addWidget(addb)

        delb=QPushButton("Remove Validation")
        delb.clicked.connect(self.remove_validation)
        bh.addWidget(delb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_validations)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
        FROM DATA_VALIDATIONS
        ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for row in rows:
            rr=self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            for col_i,val in enumerate(row):
                self.dv_table.setItem(rr,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_validation(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name (e.g. 'dbo.Customers'):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'NOT NULL','RANGE'):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional) param string:")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(
          TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
        )
        VALUES(?,?,?,?)
        """,(tbl.strip(), col.strip(), vtype.strip(), pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Data validation added.")
        self.load_validations()

    def remove_validation(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation ID={vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_validations()


# =========================
# UPDATED WHAT-IF TEST TAB
# =========================
def load_csv_into_staging(path, conn):
    """
    Example => parse CSV => store in a list (or a real staging table if desired).
    """
    data_list=[]
    try:
        with open(path,"r",encoding="utf-8") as f:
            reader=csv.reader(f)
            headers=next(reader,None)
            if headers is None:
                return data_list
            for row in reader:
                data_list.append(row)
    except Exception as ex:
        logger.error(f"Error loading CSV {path}: {ex}")
    return data_list


class WhatIfTestTab(QWidget):
    """
    Let user pick a rule => optionally upload CSV => BFS (dry-run) that rule => show pass/fail or partial results.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        self.csv_path=None
        up_btn=QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(up_btn)

        run_btn=QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if not path:
            return
        self.csv_path=path
        QMessageBox.information(self,"Uploaded",f"CSV {path} chosen.\nWe will parse on test run if needed.")

    def run_test(self):
        rid=self.rule_combo.currentData()
        data_list=[]
        if self.csv_path:
            data_list=load_csv_into_staging(self.csv_path,self.connection)
        # BFS => dry-run for the chosen rule
        ex,sk=dry_run_advanced_bfs(self.connection, [rid])
        msg=f"BFS => executed={ex}\nskipped={sk}\nCSV rows loaded={len(data_list)}"
        self.result_text.setPlainText(msg)
"""
BRM TOOL – PART 4 of 8 (ENHANCED + LOCKS)
AuditLogViewer, RuleSearchDialog, VersionHistoryDialog,
RuleDashboard (pagination + filters), RuleEditorDialog with lock/unlock usage.

Builds on Parts 1–3 code: BFS logic, advanced CRUD with locks, scheduling, etc.
No references to external old code.
"""

import sys
import json
import csv
import math
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox,
    QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox
)
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtGui import QColor

# from Part 1 => fetch_one_dict, insert_audit_log, lock_rule_for_editing, unlock_rule, force_unlock_rule
# from Part 2 => add_rule, update_rule, deactivate_rule, delete_rule, detect_operation_type, parse_sql_dependencies
# from Part 3 => no direct references unless using BFS sims


# =========================
#   AUDIT LOG VIEWER
# =========================

class AuditLogViewer(QDialog):
    """
    Display BRM_AUDIT_LOG => search => CSV export.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs (Part 4)")
        self.resize(800,600)

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.log_table=QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.log_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        csv_btn=QPushButton("Export to CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)
        bh.addStretch()
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                if col_i in (5,6) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.log_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def perform_search(self, text):
        txt=text.lower()
        for row in range(self.log_table.rowCount()):
            show=False
            for col_i in (1,2,4): # Action, TableName, ActionBy
                it=self.log_table.item(row,col_i)
                if it and txt in it.text().lower():
                    show=True
                    break
            self.log_table.setRowHidden(row, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row):
                    continue
                rowdata=[]
                for col in range(self.log_table.columnCount()):
                    it=self.log_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported",f"Audit logs exported to {path}.")


# =========================
#   RULE SEARCH DIALOG
# =========================

class RuleSearchDialog(QDialog):
    """
    Search BRM_RULES => top 1000 => by name or SQL snippet.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules (Part 4)")
        self.resize(800,600)

        main_layout=QVBoxLayout(self)
        top_h=QHBoxLayout()

        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","CreatedBy"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.res_table)

        rb=QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        main_layout.addWidget(rb)

        self.setLayout(main_layout)
        self.load_results()

    def load_results(self):
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_=self.res_table.rowCount()
            self.res_table.insertRow(r_)
            for i_ in range(6):
                self.res_table.setItem(r_,i_,QTableWidgetItem(str(row[i_]) if row[i_] else ""))


# =========================
#   VERSION HISTORY
# =========================
class VersionHistoryDialog(QDialog):
    """
    Show audit log for a single rule => can rollback if old_data is present.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(800,400)

        main_layout=QVBoxLayout(self)
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData"])
        self.table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb_btn=QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.do_rollback)
        bh.addWidget(rb_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,ACTION_TIMESTAMP,OLD_DATA,NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES'
          AND RECORD_ID=?
          AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_=self.table.rowCount()
            self.table.insertRow(r_)
            for col_i,val in enumerate(row):
                if col_i in (3,4) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected.")
            return
        row_i=sel[0].row()
        old_data_item=self.table.item(row_i,3)
        if not old_data_item:
            QMessageBox.warning(self,"None","No old_data found.")
            return
        old_data_str=old_data_item.text().strip()
        if not old_data_str:
            QMessageBox.warning(self,"Empty","Empty old_data => cannot rollback.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to this version?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            old_data=json.loads(old_data_str)
        except Exception as ex:
            QMessageBox.critical(self,"JSON Error",str(ex))
            return
        self.apply_rollback(old_data)
        QMessageBox.information(self,"Rolled Back","Version rollback done.")
        self.load_history()

    def apply_rollback(self, old_data):
        """
        Minimal approach => forcibly sets name, sql, owner => sets status=INACTIVE => re-approval
        plus parse new deps if needed. 
        Uses lock forcibly if needed or admin. 
        """
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")
        new_sql=old_data.get("RULE_SQL","")

        # We'll forcibly lock -> update -> parse => unlock 
        from .part1_foundation import lock_rule_for_editing, force_unlock_rule, parse_sql_dependencies, detect_operation_type
        user_="Rollback"
        ok,msg=lock_rule_for_editing(conn=self.connection, rule_id=rid, user_id=user_)
        if not ok:
            # try force
            ok2,msg2=force_unlock_rule(self.connection, rid, user_)
            if not ok2:
                raise ValueError(f"Cannot force unlock: {msg2}")
            ok3,msg3=lock_rule_for_editing(self.connection, rid, user_)
            if not ok3:
                raise ValueError(f"Still cannot lock after force unlock: {msg3}")

        c.execute("BEGIN TRANSACTION")
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rid))

        op=detect_operation_type(new_sql, old_data.get("DECISION_TABLE_ID"))
        deps=parse_sql_dependencies(new_sql)
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        if op not in ("DECISION_TABLE","OTHER") and new_sql.strip():
            col_op="READ" if op=="SELECT" else "WRITE"
            for (sch,tb,alias,issub) in deps["tables"]:
                if tb and not tb.startswith("(CTE)"):
                    c.execute("""
                    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                      RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                    )
                    VALUES(?,?,?,?,?)
                    """,(rid,sch if sch else "N/A",tb,"RolledBackCol",col_op))

        c.execute("COMMIT")

        # unlock
        from .part1_foundation import unlock_rule
        ok4,msg4=unlock_rule(self.connection, rid, user_)
        # if not ok => it's not critical => we do nothing

# =========================
#   RULE DASHBOARD
# =========================

class RuleDashboard(QGroupBox):
    """
    Paginated, filterable table of rules => user can select multiple => advanced CRUD in main window.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        self.selected_rule_id=None
        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL..")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","OwnerGroup","CreatedTS","ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_clause(self):
        filters=[]
        params=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause=" AND ".join(filters) if filters else "1=1"
        return (clause, params)

    def load_rules(self):
        c=self.connection.cursor()
        clause,pars=self.build_filter_clause()
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, pars)
        rowc=c.fetchone()
        total=rowc[0] if rowc else 0
        self.total_pages=max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page
        data_q=f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*pars, offset, self.records_per_page))
        rows=c.fetchall()

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_ = self.rule_table.rowCount()
            self.rule_table.insertRow(r_)
            for col_i in range(8):
                it=QTableWidgetItem(str(rd[col_i]) if rd[col_i] else "")
                if col_i==3: # status
                    if rd[col_i] and str(rd[col_i]).upper()=="ACTIVE":
                        it.setBackground(QColor(144,238,144))
                    else:
                        it.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_, col_i, it)

    def update_selected_rule_id(self):
        sel=self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.rule_table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()


# =========================
#  RULE EDITOR DIALOG
# =========================

class RuleEditorDialog(QDialog):
    """
    Add or Update a rule => calls add_rule or update_rule from Part 2 directly.
    Includes lock attempt on open, forced unlock if needed, and optional unlock on close.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)

        title="Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title+" (Part 4)")
        self.resize(800,600)

        self.main_layout=QVBoxLayout(self)
        form_l=QFormLayout()

        # Group combobox
        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        g_rows=c.fetchall()
        for (gid,gname) in g_rows:
            disp=f"{gname} (ID={gid})"
            self.group_combo.addItem(disp,gid)
        form_l.addRow("Rule Group:", self.group_combo)

        # Parent rule
        self.parent_combo=QComboBox()
        self.parent_combo.addItem("(No Parent)",None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        pr_rows=c.fetchall()
        for (rid,rn) in pr_rows:
            disp2=f"{rn} (ID={rid})"
            self.parent_combo.addItem(disp2, rid)
        form_l.addRow("Parent Rule:", self.parent_combo)

        # Basic fields
        self.name_edit=QLineEdit()
        form_l.addRow("Rule Name:", self.name_edit)

        self.rule_type_combo=QComboBox()
        c.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        trows=c.fetchall()
        for (tid,tn) in trows:
            self.rule_type_combo.addItem(tn, tid)
        form_l.addRow("Rule Type:", self.rule_type_combo)

        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_l.addRow("Status:", self.status_combo)

        self.start_dt=QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_l.addRow("Effective Start:", self.start_dt)

        self.end_dt=QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_l.addRow("Effective End:", self.end_dt)

        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_l.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit=QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, 0 => FAIL.\nIf blank => use DECISION_TABLE_ID.")
        form_l.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit=QTextEdit()
        form_l.addRow("Description:", self.desc_edit)

        self.just_edit=QTextEdit()
        form_l.addRow("Justification:", self.just_edit)

        # Admin can set global
        self.global_cb=None
        if self.user_group=="Admin":
            self.global_cb=QCheckBox("Global (Admin only)")
            form_l.addRow("Global:", self.global_cb)

        self.critical_cb=QCheckBox()
        form_l.addRow("Critical Rule:", self.critical_cb)

        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_l.addRow("Critical Scope:", self.scope_combo)

        self.dt_id_edit=QLineEdit()
        form_l.addRow("Decision Table ID:", self.dt_id_edit)

        self.main_layout.addLayout(form_l)

        # Buttons
        bh=QHBoxLayout()
        self.save_btn=QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)

        self.cancel_btn=QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        bh.addWidget(self.cancel_btn)
        self.main_layout.addLayout(bh)
        self.setLayout(self.main_layout)

        # Attempt lock if updating
        if self.is_update and self.rule_data:
            self.attempt_lock_rule()

        if self.is_update and self.rule_data:
            self.load_existing_data()

    def load_existing_data(self):
        rd=self.rule_data

        # group
        gid=rd["GROUP_ID"]
        ix=self.group_combo.findData(gid)
        if ix>=0:
            self.group_combo.setCurrentIndex(ix)

        # parent
        pid=rd.get("PARENT_RULE_ID")
        if pid:
            ix2=self.parent_combo.findData(pid)
            if ix2>=0:
                self.parent_combo.setCurrentIndex(ix2)
        else:
            self.parent_combo.setCurrentIndex(0)

        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3=self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)

        st=rd.get("STATUS","INACTIVE")
        ix_st=self.status_combo.findText(st)
        if ix_st>=0:
            self.status_combo.setCurrentIndex(ix_st)

        fmt="%Y-%m-%d %H:%M:%S"
        sd=rd.get("EFFECTIVE_START_DATE","")
        if sd:
            try:
                dt_=datetime.strptime(sd,fmt)
                self.start_dt.setDateTime(dt_)
            except:
                pass
        ed=rd.get("EFFECTIVE_END_DATE","")
        if ed:
            try:
                dt2_=datetime.strptime(ed,fmt)
                self.end_dt.setDateTime(dt2_)
            except:
                pass

        cdcv=rd.get("CDC_TYPE","NONE").upper()
        i_cdc=self.cdc_combo.findText(cdcv)
        if i_cdc>=0:
            self.cdc_combo.setCurrentIndex(i_cdc)

        if rd.get("RULE_SQL"):
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.user_group=="Admin" and rd.get("IS_GLOBAL")==1 and self.global_cb:
            self.global_cb.setChecked(True)

        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_cb.setChecked(True)

        sc=rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp=self.scope_combo.findText(sc)
        if i_scp>=0:
            self.scope_combo.setCurrentIndex(i_scp)

        if rd.get("DECISION_TABLE_ID"):
            self.dt_id_edit.setText(str(rd["DECISION_TABLE_ID"]))

    def attempt_lock_rule(self):
        """
        If is_update => try to lock the rule. If locked by another => if admin => forcibly unlock, else error & close.
        """
        from .part1_foundation import lock_rule_for_editing, force_unlock_rule
        rid=self.rule_data["RULE_ID"]
        user_="EditorDialogUser"
        ok,msg=lock_rule_for_editing(self.connection, rid, user_)
        if not ok:
            if self.user_group=="Admin":
                # force
                ok2,msg2=force_unlock_rule(self.connection, rid, user_)
                if not ok2:
                    QMessageBox.critical(self,"Error",f"Cannot force unlock => {msg2}")
                    self.reject()
                    return
                ok3,msg3=lock_rule_for_editing(self.connection, rid, user_)
                if not ok3:
                    QMessageBox.critical(self,"Error",f"After force unlock => {msg3}")
                    self.reject()
                    return
                else:
                    QMessageBox.information(self,"Forced","Lock forcibly taken.")
            else:
                QMessageBox.critical(self,"Locked",f"Rule is locked => {msg}")
                self.reject()
                return
        else:
            # we have the lock
            pass

    def save_rule(self):
        from .part2_crud import add_rule, update_rule
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","Rule name is required.")
            return
        sql_=self.sql_edit.toPlainText().strip()

        group_id=self.group_combo.currentData()
        parent_id=self.parent_combo.currentData()
        rt_id=self.rule_type_combo.currentData()
        st=self.status_combo.currentText()
        sd_str=self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        ed_str=self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_type=self.cdc_combo.currentText().upper()

        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()

        isg=0
        if self.user_group=="Admin" and self.global_cb:
            if self.global_cb.isChecked():
                isg=1
        isc=1 if self.critical_cb.isChecked() else 0
        scp=self.scope_combo.currentText().upper()

        dt_id=None
        if self.dt_id_edit.text().strip():
            try:
                dt_id=int(self.dt_id_edit.text().strip())
            except:
                dt_id=None

        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?",(group_id,))
        rowg=c.fetchone()
        if rowg:
            gname=rowg[0]
        else:
            gname="BG1"

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id if parent_id else None,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sd_str,
            "EFFECTIVE_END_DATE": ed_str,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp,
            "CDC_TYPE": cdc_type,
            "OWNER_GROUP": gname,
            "DECISION_TABLE_ID": dt_id
        }

        if self.is_update and self.rule_data:
            confirm=QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            try:
                update_rule(self.connection, rule_dict, "EditorDialogUser", self.user_group)
                QMessageBox.information(self,"Success","Rule updated => re-approval started.")
                # optionally unlock
                self.unlock_before_close()
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id=add_rule(self.connection, rule_dict, "EditorDialogUser", self.user_group)
                QMessageBox.information(self,"Created",f"Rule '{nm}' created (ID={new_id}).")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))

    def unlock_before_close(self):
        """
        On success or explicit close => if we had locked the rule => unlock if we want. 
        In real usage, you might keep it locked until user closes entire form. 
        """
        if self.is_update and self.rule_data:
            from .part1_foundation import unlock_rule
            rid=self.rule_data["RULE_ID"]
            user_="EditorDialogUser"
            ok,msg=unlock_rule(self.connection, rid, user_)
            # if fails => not critical => ignoring

    def reject(self):
        """
        If we are in update mode => unlock the rule if locked by us.
        """
        if self.is_update and self.rule_data:
            self.unlock_before_close()
        super().reject()
"""
BRM TOOL – PART 5 of 8 (ENHANCED + LOCKS)
MultiStepApprovalTab, GlobalCriticalAdminTab,
Hierarchy with real DB updates on drag,
EnhancedLineageGraphWidget (table + rule nodes).

Builds on Parts 1–4. No references to external old code.
"""

import sys
import json
import math
import logging
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QCheckBox, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu, QFileDialog,
    QInputDialog, QGraphicsView, QGraphicsScene, QGraphicsLineItem,
    QGraphicsRectItem, QGraphicsEllipseItem
)
from PyQt5.QtCore import Qt, QPoint
from PyQt5.QtGui import QColor, QPen, QBrush

# from Part 1 => lock/unlock if needed
# from Part 2 => advanced BFS, advanced CRUD (including add_rule, update_rule, etc.)
# from Part 3 => no direct references unless for BFS sims
# from Part 4 => no direct references


# =========================
# APPROVALS TAB
# =========================
class MultiStepApprovalTab(QWidget):
    """
    Shows pending approvals for current user => can Approve/Reject if minimal stage.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.approval_table=QTableWidget(0,7)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","GroupName","RuleName","Stage","Approved?","Approve","Reject"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        self.approval_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.approval_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.approval_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, 
               A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()

        def get_current_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            return ro[0] if ro and ro[0] else None

        minimal=[]
        for rd in rows:
            rule_id=rd[0]
            stage=rd[4]
            cur_stage=get_current_stage(rule_id)
            if stage==cur_stage:
                minimal.append(rd)

        self.approval_table.setRowCount(0)
        for row_data in minimal:
            r_i=self.approval_table.rowCount()
            self.approval_table.insertRow(r_i)
            # row_data => (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, RULE_NAME, RULE_APPROVAL_STATUS)
            self.approval_table.setItem(r_i,0,QTableWidgetItem(str(row_data[0])))
            self.approval_table.setItem(r_i,1,QTableWidgetItem(str(row_data[1])))
            self.approval_table.setItem(r_i,2,QTableWidgetItem(str(row_data[5])))
            self.approval_table.setItem(r_i,3,QTableWidgetItem(str(row_data[4])))
            self.approval_table.setItem(r_i,4,QTableWidgetItem(str(row_data[3])))

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rowidx=r_i: self.do_approve(rowidx))
            self.approval_table.setCellWidget(r_i,5,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rowidx=r_i: self.do_reject(rowidx))
            self.approval_table.setCellWidget(r_i,6,reject_btn)

    def do_approve(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=str(grp_item.text())

        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))

        def get_current_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            return ro[0] if ro and ro[0] else None

        nxt_stage=get_current_stage(rid)
        if nxt_stage is None:
            # means all approved
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE' WHERE RULE_ID=?",(rid,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?",(rid,))

        from .part1_foundation import insert_audit_log
        old_data={"APPROVED_FLAG":0}
        new_data={"APPROVED_FLAG":1}
        insert_audit_log(self.connection,"UPDATE","BRM_RULE_APPROVALS",rid,self.logged_in_username,old_data,new_data)
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} approved.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=str(grp_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))
        c.execute("""
        UPDATE BRM_RULES 
        SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
        WHERE RULE_ID=?
        """,(rid,))
        from .part1_foundation import insert_audit_log
        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"REJECTED":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} rejected.")
        self.load_approvals()


# =========================
# GLOBAL/CRITICAL ADMIN
# =========================
class GlobalCriticalAdminTab(QWidget):
    """
    Admin-only => set rules global/critical => manage scope => link child in GCR links
    """
    def __init__(self, main_window, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_window=main_window
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_h=QHBoxLayout()
        self.show_only_gcr=QCheckBox("Show only GCR (global/critical) rules")
        self.show_only_gcr.setChecked(True)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(self.show_only_gcr)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IS_GLOBAL","CRITICAL_RULE",
            "CRITICAL_SCOPE","STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        scope_h=QHBoxLayout()
        self.global_cb=QCheckBox("Set Global?")
        scope_h.addWidget(self.global_cb)

        self.critical_cb=QCheckBox("Set Critical?")
        scope_h.addWidget(self.critical_cb)

        scope_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        scope_h.addWidget(self.scope_combo)

        apply_btn=QPushButton("Apply to Selected")
        apply_btn.clicked.connect(self.apply_gcs)
        scope_h.addWidget(apply_btn)
        scope_h.addStretch()
        layout.addLayout(scope_h)

        # link mgmt
        link_h=QHBoxLayout()
        self.gcr_parent_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_parent_combo)

        self.gcr_child_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.gcr_child_combo)

        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(link_btn)
        link_h.addWidget(unlink_btn)

        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all_btn=QPushButton("Refresh All")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.rule_table.setItem(r_i,col_i,QTableWidgetItem(str(val)))

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.gcr_parent_combo.addItem(disp, rid)

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.gcr_child_combo.addItem(disp,rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT GCR_RULE_ID,TARGET_RULE_ID
        FROM BRM_GLOBAL_CRITICAL_LINKS
        ORDER BY GCR_RULE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def get_selected_rules(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def apply_gcs(self):
        rids=self.get_selected_rules()
        if not rids:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        is_global=1 if self.global_cb.isChecked() else 0
        is_crit=1 if self.critical_cb.isChecked() else 0
        scope_val=self.scope_combo.currentText().upper()
        confirm=QMessageBox.question(self,"Confirm",
            f"Set IS_GLOBAL={is_global},CRITICAL_RULE={is_crit},SCOPE={scope_val} for {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        for rid in rids:
            c.execute("""
            UPDATE BRM_RULES
            SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
            WHERE RULE_ID=?
            """,(is_global,is_crit,scope_val,rid))
        self.connection.commit()
        QMessageBox.information(self,"Done",f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No Parent","Select a parent GCR rule.")
            return
        if not cid:
            QMessageBox.warning(self,"No Child","Select a child rule.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        from .part1_foundation import insert_audit_log
        c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(pid,cid))
        insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}",
                         "Admin",None,{"parent":pid,"child":cid})
        self.connection.commit()
        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        from .part1_foundation import insert_audit_log
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
        insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}",
                         "Admin",{"parent":pid,"child":cid},None)
        self.connection.commit()
        QMessageBox.information(self,"Unlinked",f"Child {cid} from {pid}")
        self.load_link_view()


# =========================
# HIERARCHY VIEW
# =========================
class HierarchyViewTab(QTreeWidget):
    """
    Show group -> rule in a tree => user can drag rule to another group => we actually update BRM_RULES (re-parent).
    If locked by another => can either skip or force if admin, similar to the Editor approach.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule (Part 5)"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        groups=c.fetchall()
        self.gid_map={}
        for (gid,gname) in groups:
            top=QTreeWidgetItem([f"{gname} (ID={gid})"])
            top.setData(0,Qt.UserRole,("group",gid))
            self.addTopLevelItem(top)
            self.gid_map[gid]=top

        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rws=c.fetchall()
        self.rule_map={}
        for (rid,rn,gid,pid) in rws:
            self.rule_map[rid]=(rn,gid,pid)

        # place top-level => no parent => under group
        for rid,(rname, g_id, p_id) in self.rule_map.items():
            if not p_id:
                if g_id in self.gid_map:
                    parent_it=self.gid_map[g_id]
                    child=QTreeWidgetItem([f"Rule {rid}: {rname}"])
                    child.setData(0,Qt.UserRole,("rule",rid))
                    parent_it.addChild(child)
        self.expandAll()

        # if you want multi-level nesting => you can do a second pass for child-of-child. 
        # or a BFS approach. For demonstration, we only nest one level.

    def dropEvent(self, event):
        """
        Actually update DB for re-parent or re-group upon drop.
        For a real system, you'd check locks or forcibly lock if admin. 
        """
        source_item=self.currentItem()
        if not source_item:
            super().dropEvent(event)
            return
        data_role=source_item.data(0,Qt.UserRole)
        if not data_role or data_role[0]!="rule":
            super().dropEvent(event)
            return

        # let Qt do the default rearrange
        super().dropEvent(event)

        new_parent=source_item.parent()
        if not new_parent:
            # means top-level => ambiguous group => skip or revert
            QMessageBox.information(self,"No Group?","Cannot place rule top-level with no group node. Reverting.")
            self.load_hierarchy()
            return
        parent_role=new_parent.data(0,Qt.UserRole)
        if not parent_role:
            QMessageBox.information(self,"Error","Parent has no data => revert.")
            self.load_hierarchy()
            return

        rule_id=data_role[1]
        if parent_role[0]=="group":
            group_id=parent_role[1]
            parent_rule_id=None
            self.update_rule_parent_and_group(rule_id, parent_rule_id, group_id)
        elif parent_role[0]=="rule":
            parent_rid=parent_role[1]
            # find parent's group
            if parent_rid in self.rule_map:
                rn,pgid,ppid=self.rule_map[parent_rid]
                group_id=pgid
                parent_rule_id=parent_rid
                self.update_rule_parent_and_group(rule_id, parent_rule_id, group_id)
            else:
                QMessageBox.warning(self,"Invalid","Cannot find parent's group => revert.")
                self.load_hierarchy()
                return
        else:
            QMessageBox.warning(self,"Invalid parent type","Reverting.")
            self.load_hierarchy()
            return

        self.load_hierarchy()

    def update_rule_parent_and_group(self, rule_id, parent_rule_id, group_id):
        """
        Actually do DB update => set PARENT_RULE_ID=? GROUP_ID=? => bump version => set status=INACTIVE => re-approval
        Potentially check lock or forcibly lock if admin. Minimal example here.
        """
        from .part1_foundation import lock_rule_for_editing, force_unlock_rule, insert_audit_log

        user_="HierarchyView"
        ok,msg=lock_rule_for_editing(self.connection, rule_id, user_)
        if not ok:
            # if your user is admin => force
            # for demonstration, we skip forcibly. Real usage => you might do it automatically.
            QMessageBox.warning(self,"Locked",f"Rule is locked => {msg}. Skipping re-parent.")
            return

        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
        old=c.fetchone()
        if not old:
            QMessageBox.warning(self,"Not found",f"Rule {rule_id} not found => skipping.")
            return
        colnames=[desc[0] for desc in c.description]
        old_data=dict(zip(colnames,old))

        c.execute("BEGIN TRANSACTION")
        c.execute("""
        UPDATE BRM_RULES
        SET PARENT_RULE_ID=?,
            GROUP_ID=?,
            STATUS='INACTIVE',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
            UPDATED_BY='HierarchyView',
            VERSION=VERSION+1
        WHERE RULE_ID=?
        """,(parent_rule_id, group_id, rule_id))

        new_data=dict(old_data)
        new_data["PARENT_RULE_ID"]=parent_rule_id
        new_data["GROUP_ID"]=group_id
        new_data["STATUS"]="INACTIVE"
        new_data["APPROVAL_STATUS"]="APPROVAL_IN_PROGRESS"
        new_data["VERSION"]=old_data["VERSION"]+1

        insert_audit_log(self.connection,"RE_PARENT","BRM_RULES",rule_id,"HierarchyView",old_data,new_data)
        c.execute("COMMIT")

        # optionally unlock
        from .part1_foundation import unlock_rule
        unlock_rule(self.connection, rule_id, user_)

        QMessageBox.information(self,"Re-parented",f"Rule {rule_id} => parent={parent_rule_id} group={group_id}")


# =========================
# ENHANCED LINEAGE GRAPH
# =========================
class EnhancedLineageGraphWidget(QGraphicsView):
    """
    Visual graph => BFS of parent->child + table dependencies => color-coded for critical or global.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()

        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        if not rows:
            self.scene.addText("No rules found.")
            return

        # build adjacency
        children_map={}
        all_ids=set()
        parent_map={}
        for row in rows:
            rid=row[0]
            pid=row[2]
            all_ids.add(rid)
            if pid:
                children_map.setdefault(pid,[]).append(rid)
                parent_map[rid]=pid

        # BFS layering
        from collections import deque
        child_ids=set(parent_map.keys())
        roots=[r for r in all_ids if r not in child_ids]

        # store entire row => make node
        rule_lookup={}
        for row in rows:
            d={
                "RULE_ID":row[0],
                "RULE_NAME":row[1],
                "PARENT_RULE_ID":row[2],
                "STATUS":row[3],
                "RULE_TYPE_ID":row[4],
                "CLUSTER_NAME":row[5],
                "IS_GLOBAL":row[6],
                "CRITICAL_RULE":row[7]
            }
            rule_lookup[row[0]]=d

        queue=deque()
        level_counts={}
        visited=set()

        for rt in roots:
            queue.append((rt,0))

        while queue:
            (rid, depth)=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info=rule_lookup[rid]
            level_counts[depth]=level_counts.get(depth,0)+1
            x=depth*220
            y=(level_counts[depth]-1)*100

            node=self.make_rule_node(info)
            node.setPos(x,y)
            self.scene.addItem(node)
            self.node_map[rid]=node

            if rid in children_map:
                for ch_ in children_map[rid]:
                    queue.append((ch_, depth+1))

        # edges for parent->child
        for row in rows:
            rid=row[0]
            pid=row[2]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # add table dependencies
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps=c.fetchall()
        tbl_map={}
        idx=0
        for (drid,dbn,tbn,coln,op) in deps:
            key=(dbn+"."+tbn).lower().strip(".")
            if key not in tbl_map:
                t_ellipse=TableEllipseItem(key)
                t_ellipse.setPos(800, idx*60)
                idx+=1
                self.scene.addItem(t_ellipse)
                tbl_map[key]=t_ellipse
            if drid in self.node_map:
                color=QColor("blue") if op=="READ" else QColor("red")
                self.draw_edge(self.node_map[drid], tbl_map[key], color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def make_rule_node(self, info):
        rt_id=info["RULE_TYPE_ID"]
        if rt_id==1:
            node=QGraphicsRectItem(0,0,120,50)
        else:
            node=QGraphicsEllipseItem(0,0,120,50)

        stat=info["STATUS"]
        if stat.lower()=="active":
            basecol=QColor("lightgreen")
        else:
            basecol=QColor("tomato")

        cluster=info["CLUSTER_NAME"] or ""
        if cluster:
            hv=abs(hash(cluster))%360
            basecol=QColor.fromHsv(hv,128,255)

        node.setBrush(QBrush(basecol))
        pen=QPen(Qt.black,2)
        if info["CRITICAL_RULE"]==1:
            pen=QPen(QColor("red"),3)
        node.setPen(pen)

        disp=info["RULE_NAME"]
        if info["IS_GLOBAL"]==1:
            disp=f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self, item1, item2, color=QColor("darkblue")):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=QGraphicsLineItem(p1.x(),p1.y(),p2.x(),p2.y())
        line.setPen(QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene:
            br=self.scene.itemsBoundingRect()
            if br.isValid():
                self.fitInView(br, Qt.KeepAspectRatio)


class TableEllipseItem(QGraphicsEllipseItem):
    """
    A small ellipse representing a DB table in the lineage graph.
    """
    def __init__(self, table_name):
        super().__init__(0,0,100,40)
        self.table_name=table_name
        self.setBrush(QBrush(QColor("lightblue")))
        self.setToolTip(f"Table: {table_name}")
"""
BRM TOOL – PART 6 of 8 (ENHANCED + LOCKS)
MetricsDashboardTab, CtrlTablesTab, GroupManagementTab, UserManagementTab.

Builds on BFS logic, advanced CRUD, plus locking from Parts 1–5.
No references to old code outside these 8 parts.
"""

import math
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget
)
from PyQt5.QtCore import Qt
import pyqtgraph as pg

# from Part 1 => DB connection, etc.
# from Part 2 => advanced BFS, advanced CRUD
# from Part 3 => no direct references except scheduling
# from Part 4 => no direct references
# from Part 5 => no direct references


# =========================
#   METRICS DASHBOARD
# =========================
class MetricsDashboardTab(QWidget):
    """
    Show a bar chart => rule counts by status from BRM_RULES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.chart=pg.PlotWidget(title="Rule Counts by Status (Part 6)")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        ref_btn=QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS,COUNT(*) as ct FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()
        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]

        self.chart.clear()
        if statuses:
            xvals=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(xvals), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(xvals, statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True, y=True)


# =========================
#   CONTROL TABLES TAB
# =========================
class CtrlTablesTab(QWidget):
    """
    A control-table viewer => pick from known admin tables => show up to 1000 rows.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS"
        ]
        self.tbl_combo=QComboBox()
        for t_ in self.table_list:
            self.tbl_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def on_load_data(self):
        tbl=self.tbl_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[d[0] for d in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error fetching columns from {tbl}: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving data from {tbl}: {ex}")
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)

        for row in rows:
            r_=self.data_table.rowCount()
            self.data_table.insertRow(r_)
            for j,val in enumerate(row):
                self.data_table.setItem(r_,j,QTableWidgetItem(str(val) if val is not None else ""))


# =========================
#  GROUP MANAGEMENT TAB
# =========================
class GroupManagementTab(QWidget):
    """
    Manage business groups => membership => group permissions => approvers.
    Admin-only.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # groups + membership
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.delete_group)
        grp_btns.addWidget(del_grp_btn)

        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        memb_box=QGroupBox("Membership")
        memb_layout=QVBoxLayout(memb_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        memb_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.add_user_to_group)
        memb_btns.addWidget(add_usr_btn)

        rm_usr_btn=QPushButton("Remove User from Group")
        rm_usr_btn.clicked.connect(self.remove_user_from_group)
        memb_btns.addWidget(rm_usr_btn)

        memb_btns.addStretch()
        memb_layout.addLayout(memb_btns)
        gm_layout.addWidget(memb_box)

        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # permissions
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)

        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)

        top_h=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(QLabel("Select Group:"))
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["TargetTable"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.add_permission)
        ph.addWidget(addp_btn)

        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.remove_permission)
        ph.addWidget(remp_btn)

        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # approvers
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(QLabel("Group:"))
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.add_approver)
        appr_btns.addWidget(add_appr_btn)

        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.remove_approver)
        appr_btns.addWidget(del_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)

        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_all_btn=QPushButton("Refresh All")
        ref_all_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_groups()
        self.load_appr_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.groups_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            return None
        it=self.groups_table.item(row,0)
        if not it:
            return None
        return it.text().strip()

    def add_group(self):
        gname,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not gname.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",
                  (gname.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for '{grp}':")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New group name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group '{grp}' removed.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.users_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_user(self):
        row=self.users_table.currentRow()
        if row<0:
            return None
        it=self.users_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Enter group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        row=c.fetchone()
        if row and row[0]==grp.strip():
            QMessageBox.warning(self,"Error","User is already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user => move them to BG1?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def load_perm_groups(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for (gn,) in rows:
            self.perm_group_combo.addItem(gn, gn)

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))

    def add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Pick a group first.")
            return
        tbl,ok=QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.MyTable'):")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        row=self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it=self.perm_table.item(row,0)
        tbl=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{tbl}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(),tbl))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    def load_appr_groups(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for (gn,) in rows:
            self.appr_group_combo.addItem(gn, gn)

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        self.appr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(row[1]))

    def add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        usern,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(), usern.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver '{usern}' added to {grp}.")
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it=self.appr_table.item(row,0)
        appr_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver ID={appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()


# =========================
#  USER MANAGEMENT TAB
# =========================
class UserManagementTab(QWidget):
    """
    Admin => manage USERS => add, delete, change password.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        bh.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.user_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_userid(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",
                  (uname.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","User created.")
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"User ID={uid} removed.")
        self.load_users()

    def change_password(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"New Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Changed","Password updated.")
        self.load_users()
"""
BRM TOOL – PART 7 of 8 (ENHANCED + LOCKS)
CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab.

Builds on BFS logic, advanced CRUD, scheduling, etc. from Parts 1–6.
No placeholders or references to external code outside these 8 parts.
"""

import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem, 
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox, 
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QMenu
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor

# from Part 1 => lock/unlock if needed
# from Part 2 => BFS adjacency if we want to unify child rules
# from Part 3 => scheduling references
# from Part 4 => no direct references
# from Part 5 => no direct references
# from Part 6 => no direct references


# =========================
# CUSTOM RULE GROUP (Enhanced)
# =========================
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manage custom rule groups => create/rename/delete => backup/restore => assign rules.
    BFS references if you want to unify child or conflict logic for assigned rules.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_grp_edit=QLineEdit()
        self.new_grp_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_grp_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search rules to assign..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for (cg_id,cg_name,owner) in groups:
            disp=f"{cg_name} (Owner={owner})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0,Qt.UserRole,cg_id)
            g_item.setBackground(0,QBrush(QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for (rid,rn,isg,isc) in assigned:
                txt=f"Rule {rid}: {rn}"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0,Qt.UserRole,rid)
                if isg==1:
                    rr_item.setBackground(0,QBrush(QColor("lightblue")))
                if isc==1:
                    rr_item.setBackground(0,QBrush(QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)

        rows=c.fetchall()
        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set([x[0] for x in c2.fetchall()])

        for (rid,rn,og) in rows:
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rn} (Owner={og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole, rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # child => rule => can remove from group
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id,rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group.")
                self.refresh_all()

    def create_group(self):
        name=self.new_grp_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name specified.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(
          CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP
        )
        VALUES(?,?,?,GETDATE())
        """,(name, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_grp_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        parent=it.parent()
        if parent:
            # if selected a rule => parent is group
            it=parent
        cg_id=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (cg_id,disp)

    def rename_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[r[0] for r in c.fetchall()]
        backup_data={"group_name":grpname,"members":assigned}

        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1

        import json
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {r[0]} (ts={r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:", items, 0,False)
        if not ok or not sel:
            return
        m=re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver=int(m.group(1))

        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return

        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found.")
            return
        import json
        try:
            data=json.loads(backup_json)
            new_gname=data["group_name"]
            members=data["members"]
            c.execute("BEGIN TRANSACTION")
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_gname,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected in the tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        if not gid:
            QMessageBox.warning(self,"Error","No group ID found.")
            return

        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return
        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()


# =========================
# ALERTS & DASHBOARDS
# =========================
class AlertsAndDashboardsTab(QWidget):
    """
    Show old approvals (>3 days) + upcoming schedules (24h).
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # old approvals
        c.execute("""
        SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
               DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
          )
          AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        old_approvals=c.fetchall()
        if old_approvals:
            lines.append("Approvals older than 3 days:")
            for (rid,stg,rn,age) in old_approvals:
                lines.append(f" - Rule {rid}, stage={stg}, age={age} => {rn}")
        else:
            lines.append("No old approvals > 3 days.")

        lines.append("")

        # upcoming schedules
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upc=c.fetchall()
        if upc:
            lines.append("Upcoming schedules in next 24h:")
            for (sid,rid,ts) in upc:
                lines.append(f" - ID={sid}, rule={rid}, time={ts}")
        else:
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))
"""
BRM TOOL – PART 8 of 8 (ENHANCED + LOCKS)
Final QMainWindow (BRMTool) unifying all parts, with:
 - BFS logic, advanced CRUD with locking
 - Scheduling, approvals, advanced tabs, group mgmt, user mgmt
 - Impersonation for Admin
 - Timers for approvals & schedules
 - Enhanced lineage graph color-coded by last execution status
No references to external old code beyond these 8 parts.
"""

import sys
import json
import logging
from datetime import datetime, timedelta

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QComboBox,
    QPushButton, QLabel, QMessageBox, QDialog, QLineEdit
)
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QColor

# from Part 1 => DatabaseConnectionDialog, LoginDialog, OnboardingWizard, etc.
# from Part 2 => BFS logic, advanced CRUD (add_rule, update_rule, etc.)
# from Part 3 => scheduling dialogs, advanced feature tabs, sync_metadata_improved
# from Part 4 => AuditLogViewer, RuleSearchDialog, VersionHistoryDialog, RuleDashboard, RuleEditorDialog
# from Part 5 => MultiStepApprovalTab, GlobalCriticalAdminTab, HierarchyViewTab
# from Part 6 => MetricsDashboardTab, CtrlTablesTab, GroupManagementTab, UserManagementTab
# from Part 7 => CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Integration (Part 8)")
        self.resize(1300,850)

        self.connection=None
        self.user_id=None
        self.logged_in_username=None
        self.user_group=None

        # Step 1: DB connection
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection=dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Step 2: Login
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group
        # get username
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="UnknownUser"

        # optional onboarding
        # wiz=OnboardingWizard(self.connection)
        # wiz.exec_()

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        # Sync metadata
        syncAct=QtWidgets.QAction("Sync Metadata",self)
        syncAct.triggered.connect(self.sync_metadata_action)
        fileMenu.addAction(syncAct)

        # metrics
        metricsAct=QtWidgets.QAction("View Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        # schedule
        schedAct=QtWidgets.QAction("New Schedule (Dialog)",self)
        schedAct.triggered.connect(self.launch_schedule_dialog)
        fileMenu.addAction(schedAct)

        # chain sim
        chainAct=QtWidgets.QAction("Simulate Parent Chain",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        # group sim
        grpAct=QtWidgets.QAction("Simulate Custom Group",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        # help
        helpMenu=menubar.addMenu("Help")
        usageAct=QtWidgets.QAction("Show Tips",self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        # Tools
        toolsMenu=menubar.addMenu("Tools")
        alAct=QtWidgets.QAction("View Audit Logs",self)
        alAct.triggered.connect(self.launch_audit_logs)
        toolsMenu.addAction(alAct)

        srAct=QtWidgets.QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_rule_search)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (Enter Rule ID)",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        # advanced
        advMenu=menubar.addMenu("Advanced")
        self.decision_tab=DecisionTablesTab(self.connection)
        self.conflict_tab=ConflictPriorityManagerTab(self.connection)
        self.composite_tab=CompositeRulesTab(self.connection)
        self.snap_tab=SnapshotManagerTab(self.connection)
        self.tags_tab=TagsManagerTab(self.connection)
        self.dv_tab=DataValidationTab(self.connection)
        self.whatif_tab=WhatIfTestTab(self.connection)

        advMenu.addAction("Open Decision Tables", lambda: self.tabs.addTab(self.decision_tab,"Decision Tables"))
        advMenu.addAction("Open Conflict Priority", lambda: self.tabs.addTab(self.conflict_tab,"Conflict Priority"))
        advMenu.addAction("Open Composite Rules", lambda: self.tabs.addTab(self.composite_tab,"Composite Rules"))
        advMenu.addAction("Open Snapshot Manager", lambda: self.tabs.addTab(self.snap_tab,"Snapshots"))
        advMenu.addAction("Open Tags Manager", lambda: self.tabs.addTab(self.tags_tab,"Tags Manager"))
        advMenu.addAction("Open Data Validation", lambda: self.tabs.addTab(self.dv_tab,"Data Validation"))
        advMenu.addAction("Open What-If Testing", lambda: self.tabs.addTab(self.whatif_tab,"WhatIf Testing"))

        cw=QWidget()
        layout=QVBoxLayout(cw)

        # impersonation if admin
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.load_user_switch_combo()

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # business rules => BFS references
        brw=QWidget()
        br_layout=QVBoxLayout(brw)
        top_btns=QHBoxLayout()

        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        top_btns.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        top_btns.addWidget(upd_btn)

        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.on_deactivate_rule)
        top_btns.addWidget(deact_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.on_delete_rule)
        top_btns.addWidget(del_btn)

        etl_btn=QPushButton("Run ETL BFS")
        etl_btn.clicked.connect(self.run_etl_bfs)
        top_btns.addWidget(etl_btn)

        sim_btn=QPushButton("Simulate Single Rule")
        sim_btn.clicked.connect(self.sim_single_rule)
        top_btns.addWidget(sim_btn)

        top_btns.addStretch()
        br_layout.addLayout(top_btns)

        self.brm_dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_layout.addWidget(self.brm_dashboard)
        brw.setLayout(br_layout)
        self.tabs.addTab(brw,"Business Rules")

        # approvals
        self.approv_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # GCR admin if admin
        if self.user_group=="Admin":
            self.gcr_tab=GlobalCriticalAdminTab(self,self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # Hierarchy
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # Enhanced lineage
        lw=QWidget()
        lw_l=QVBoxLayout(lw)
        lb=QLabel("Lineage Visualization (With Execution Status)")
        lb.setStyleSheet("font-weight:bold;")
        lw_l.addWidget(lb)

        self.lineage_view=CustomEnhancedLineageGraphWidget(self.connection)
        lw_l.addWidget(self.lineage_view)

        bot_h=QHBoxLayout()
        ref_graph=QPushButton("Refresh Graph")
        ref_graph.clicked.connect(self.lineage_view.populate_graph)
        bot_h.addWidget(ref_graph)
        reset_btn=QPushButton("Reset View")
        reset_btn.clicked.connect(self.lineage_view.resetView)
        bot_h.addWidget(reset_btn)
        bot_h.addStretch()
        lw_l.addLayout(bot_h)
        lw.setLayout(lw_l)
        self.tabs.addTab(lw,"Lineage")

        # custom groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # scheduling
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # control tables
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # alerts
        self.alert_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Dashboards")

        # group mgmt
        self.grp_mgmt_tab=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # user mgmt => if admin
        if self.user_group=="Admin":
            self.user_mgmt_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # timers
        self.appr_timer=QTimer(self)
        self.appr_timer.timeout.connect(self.approv_tab.load_approvals)
        self.appr_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

        # also auto-unlock expired locks every 5 minutes
        self.lock_timer=QTimer(self)
        self.lock_timer.timeout.connect(self.auto_unlock_expired)
        self.lock_timer.start(5*60*1000)  # 5 minutes in ms

        self.show()

    def sync_metadata_action(self):
        sync_metadata_improved(self.connection)

    def show_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800,600)
        lay=QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection)
        lay.addWidget(chart)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        lay.addWidget(cb)
        dlg.exec_()

    def launch_schedule_dialog(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()

    def launch_chain_sim(self):
        dlg=ChainOrGroupSimulationDialog(self.connection,is_group=False,parent=self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=ChainOrGroupSimulationDialog(self.connection,is_group=True,parent=self)
        dlg.exec_()

    def show_help(self):
        QMessageBox.information(self,"Help/Tips",
            "BRM Tool – fully advanced version. Use the tabs to manage rules, approvals, scheduling, etc.")

    def launch_audit_logs(self):
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_rule_search(self):
        dlg=RuleSearchDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection,rid,self)
        dlg.exec_()

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        (new_uid,new_grp)=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="UnknownUser"

        QMessageBox.information(self,"Switched",f"Impersonating user {new_uid} => group {new_grp}.")

        # refresh key tabs
        self.approv_tab.logged_in_username=self.logged_in_username
        self.approv_tab.user_group=self.user_group
        self.approv_tab.load_approvals()

        self.brm_dashboard.user_id=self.user_id
        self.brm_dashboard.user_group=self.user_group
        self.brm_dashboard.load_rules()

        if hasattr(self,"gcr_tab"):
            self.gcr_tab.load_rule_list()
            self.gcr_tab.load_link_view()

        if hasattr(self,"hier_tab"):
            self.hier_tab.load_hierarchy()

        if hasattr(self,"alert_tab"):
            self.alert_tab.check_alerts()

        if hasattr(self,"grp_mgmt_tab"):
            self.grp_mgmt_tab.user_id=new_uid
            self.grp_mgmt_tab.user_group=new_grp
            self.grp_mgmt_tab.load_data()

        if hasattr(self,"user_mgmt_tab"):
            self.user_mgmt_tab.load_users()

    def load_user_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for (uid,uname,ugrp) in rows:
            disp=f"{uname} ({ugrp})"
            self.switch_combo.addItem(disp,(uid,ugrp))

    def on_add_rule(self):
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def on_update_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule to update.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No rule with ID={rid}")
            return
        colnames=[desc[0] for desc in c.description]
        rule_data=dict(zip(colnames,row))
        dlg=RuleEditorDialog(self.connection,self.user_group,rule_data,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def on_deactivate_rule(self):
        from .part2_crud import deactivate_rule
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                deactivate_rule(self.connection, rid, "MainWindowUser", self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivation => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def on_delete_rule(self):
        from .part2_crud import delete_rule
        rids=self.brm_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                delete_rule(self.connection, rid, "MainWindowUser", self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deletion => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_etl_bfs(self):
        # from .part2_crud => execute_rules_with_conflicts_composites_bfs
        (executed,skipped)=execute_rules_with_conflicts_composites_bfs(self.connection)
        msg=f"ETL BFS => executed={executed}, skipped={list(skipped)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def sim_single_rule(self):
        rids=self.brm_dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=rids[0]
        dlg=SingleRuleSimulationDialog(self.connection,rid,self)
        dlg.exec_()

    def check_due_schedules(self):
        """
        Called every minute => check RULE_SCHEDULES => run rule => update status to Executed or Failed.
        """
        now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
        """,(now,))
        due=c.fetchall()
        for row in due:
            sch_id=row[0]
            rid=row[1]
            c2=self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL,OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                r_=c2.fetchone()
                if r_:
                    (sql_,op_)=r_
                    success=False
                    msg=""
                    record_count=0
                    try:
                        if op_=="DECISION_TABLE":
                            success=True
                            msg="DECISION_TABLE => pass"
                            record_count=1
                        else:
                            c2.execute(sql_)
                            rows2=c2.fetchall()
                            if rows2:
                                record_count=len(rows2)
                                val=rows2[0][0]
                                success=(val==1)
                                msg=f"Returned: {val}"
                            else:
                                success=True
                                msg="No rows => PASS"
                    except Exception as ex:
                        msg=str(ex)
                        success=False

                    if success:
                        c2.execute("COMMIT")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
                    else:
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                    # also log to RULE_EXECUTION_LOGS
                    c2.execute("""
                    INSERT INTO RULE_EXECUTION_LOGS(
                      RULE_ID,EXECUTION_TIMESTAMP,PASS_FLAG,MESSAGE,RECORD_COUNT
                    )
                    VALUES(?,GETDATE(),?,?,?)
                    """,(rid,1 if success else 0,msg,record_count))
                self.connection.commit()
            except Exception as ex:
                logging.error(f"Scheduled exec error => {ex}")
                c2.execute("ROLLBACK")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                self.connection.commit()
        self.sch_tab.load_schedules()

    def auto_unlock_expired(self):
        """
        Called every 5 minutes => remove locks older than 30 minutes.
        """
        from .part1_foundation import auto_unlock_expired_locks
        auto_unlock_expired_locks(self.connection)

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()


class CustomEnhancedLineageGraphWidget(EnhancedLineageGraphWidget):
    """
    Subclass of EnhancedLineageGraphWidget => override make_rule_node() to incorporate
    last execution pass/fail color overlay for 'live execution status'.
    """
    def make_rule_node(self, info):
        # call base version
        node=super().make_rule_node(info)

        # check last pass/fail
        rid=info["RULE_ID"]
        c2=self.connection.cursor()
        c2.execute("""
        SELECT TOP 1 PASS_FLAG
        FROM RULE_EXECUTION_LOGS
        WHERE RULE_ID=?
        ORDER BY EXECUTION_TIMESTAMP DESC
        """,(rid,))
        row=c2.fetchone()
        if row:
            pass_flag=row[0]
            if pass_flag==1:
                # overlay a slightly greener color border or overlay
                pen=node.pen()
                pen.setColor(QColor("darkgreen"))
                pen.setWidth(3)
                node.setPen(pen)
            else:
                # failed => red border
                pen=node.pen()
                pen.setColor(QColor("darkred"))
                pen.setWidth(3)
                node.setPen(pen)

        return node


def main():
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())