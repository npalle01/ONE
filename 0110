#!/usr/bin/env python
"""
BRM TOOL – PART 1
Core imports, logging, email config, DB connection dialog, login,
and advanced SQL parsing (including table/column extraction).
Fully self-contained; no references to other parts.
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
from datetime import datetime
from collections import deque
from email.mime.text import MIMEText

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtWidgets import (
    QApplication, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QComboBox, QMessageBox, QLineEdit
)
from sqlparse.sql import Identifier, IdentifierList, Parenthesis
from sqlparse.tokens import Keyword, DML

###############################################################################
# LOGGING
###############################################################################
logging.basicConfig(
    filename='brm_tool_part1.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# EMAIL CONFIG
###############################################################################
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Sends an email via SMTP to 'recipients' using EMAIL_CONFIG.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()

        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Lets user pick an ODBC DSN (SQL Server) or enter a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection - Part 1")
        self.resize(400, 200)

        layout = QVBoxLayout(self)

        lbl = QLabel("Select a SQL Server ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        layout.addWidget(self.conn_str_edit)

        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cb = QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cb)
        layout.addLayout(bh)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"

        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

###############################################################################
# DB HELPERS
###############################################################################
def get_cursor_rows_part1(cursor):
    """
    Safely fetches all rows from a cursor, returns list of dicts if column info present.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    return rows

def get_cursor_one_part1(cursor):
    """
    Fetches one row from a cursor, returns dict if column info present.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return None

def add_audit_log_part1(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert an audit record into BRM_AUDIT_LOG table.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """, (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# LOGIN
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Simple username/password prompt, verifying from USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login - Part 1")
        self.resize(300, 150)

        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return

        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one_part1(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Failed", "Invalid credentials.")

###############################################################################
# DETECT OPERATION TYPE
###############################################################################
def detect_operation_type_part1(sql_text:str)->str:
    """
    Determines the operation type (INSERT, UPDATE, DELETE, SELECT, or OTHER)
    based on the first keyword in 'sql_text'.
    """
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

###############################################################################
# ADVANCED SQL PARSER
###############################################################################
def enhanced_advanced_extract_tables_part1(sql_text:str):
    """
    Returns a dict with:
      "tables": list of (schema, table, alias, is_subselect)
      "cte_tables": list of (cte_name, list_of_references)
      "alias_map": mapping alias -> (schema, table)
      "columns": list of (col_name, is_dml_target, in_select)
    We do a fairly advanced parse with CTE handling and subselect detection.
    """
    statements = sqlparse.parse(sql_text)
    final_tables = []
    cte_info = []
    alias_map = {}
    column_list = []

    for stmt in statements:
        # Identify WITH cte references
        cte_dict = _extract_with_clauses_part1(stmt)
        for cName, refs in cte_dict.items():
            cte_info.append((cName, refs))

        # Identify main FROM references
        main_refs, main_alias = _extract_main_from_part1(stmt.tokens, set(cte_dict.keys()))
        final_tables.extend(main_refs)
        alias_map.update(main_alias)

        # Identify columns in SELECT or DML
        col_refs = _extract_columns_part1(stmt)
        column_list.extend(col_refs)

    # Deduplicate final_tables
    final_tables = list({x for x in final_tables})
    return {
        "tables": final_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": column_list
    }

def _extract_with_clauses_part1(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block_part1(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def _parse_cte_block_part1(tokens, i, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause_part1(tokens, i, cte_name, cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause_part1(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        val = tk.value.upper() if tk.ttype else ""
        if val == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs = _extract_subselect_tokens_part1(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens_part1(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect_part1(tk):
            sub2 = _extract_subselect_tokens_part1(tk.tokens)
            results.extend(sub2)

        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False

        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier_part1(ident, set())
                    st = (st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st = _parse_identifier_part1(tk, set())
                st = (st[0], st[1], st[2], True)
                results.append(st)
        i += 1
    return results

def _is_subselect_part1(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper() == "SELECT":
            return True
    return False

def _extract_main_from_part1(tokenlist, known_cte_names):
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect_part1(tk):
            sub2 = _extract_subselect_tokens_part1(tk.tokens)
            results.extend(sub2)

        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False

        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier_part1(ident, known_cte_names)
                    results.append(st)
                    al = st[2]
                    if al:
                        alias_map[al] = (st[0], st[1])
            elif isinstance(tk, Identifier):
                st = _parse_identifier_part1(tk, known_cte_names)
                results.append(st)
                al = st[2]
                if al:
                    alias_map[al] = (st[0], st[1])
        i += 1
    return (results, alias_map)

def _parse_identifier_part1(ident, known_cte_names):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema_name = ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns_part1(statement):
    """
    Parse columns from SELECT list or DML target columns.
    Returns list of (column_name, is_dml_target, in_select_list).
    """
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is DML:
            dml_word = tk.value.upper()
            if dml_word == "SELECT":
                col_refs = _parse_select_list_part1(tokens, i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif dml_word in ("INSERT","UPDATE"):
                col_refs2 = _parse_dml_columns_part1(tokens, i, dml_word)
                for c_ in col_refs2:
                    results.append((c_, True, False))
        i += 1
    return results

def _parse_select_list_part1(tokens, start_idx):
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                colnm = ident.get_name()
                if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(colnm)
        elif isinstance(tk, Identifier):
            colnm = tk.get_name()
            if colnm and colnm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(colnm)
        i += 1
    return columns

def _parse_dml_columns_part1(tokens, start_idx, dml_word):
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                for subiden in tk.tokens:
                    if isinstance(subiden, IdentifierList):
                        for ident in subiden.get_identifiers():
                            colnm = ident.get_name()
                            columns.append(colnm)
                    elif isinstance(subiden, Identifier):
                        columns.append(subiden.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list_part1(tokens, i))
                break
            i += 1
    return columns

def _parse_update_set_list_part1(tokens, start_i):
    columns = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, Identifier):
            columns.append(tk.get_name())
        i += 1
    return columns

# End of PART 1
#!/usr/bin/env python
"""
BRM TOOL – PART 2
BFS rule exec, multi-step approvals, advanced update logic (re-approvals),
and CRUD operations for rules. Fully self-contained; no references to other parts.
"""

import sys
import json
import math
import logging
import pyodbc
from datetime import datetime
from collections import deque

logging.basicConfig(
    filename='brm_tool_part2.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger=logging.getLogger(__name__)

###############################################################################
# HELPER DB + AUDIT
###############################################################################
def get_cursor_rows_part2(cursor):
    """
    Fetch all rows from a cursor safely; returns a list of dicts if column info present.
    """
    try:
        rows=cursor.fetchall()
    except:
        rows=[]
    if cursor.description:
        cols=[desc[0] for desc in cursor.description]
        return [dict(zip(cols,r)) for r in rows]
    return rows

def get_cursor_one_part2(cursor):
    """
    Fetch one row from the cursor; returns a dict if column info present.
    """
    row=cursor.fetchone()
    if row and cursor.description:
        cols=[desc[0] for desc in cursor.description]
        return dict(zip(cols,row))
    return None

def add_audit_log_part2(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert an audit record into BRM_AUDIT_LOG (includes JSON of old/new states).
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """,(
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# DETECT OPERATION TYPE
###############################################################################
def detect_operation_type_part2(sql_text:str)->str:
    """
    Determine whether the given SQL text begins with INSERT, UPDATE, DELETE, SELECT, or OTHER.
    """
    txt=sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

###############################################################################
# BFS RULE EXEC + STATS
###############################################################################
def build_rule_adjacency_part2(conn):
    """
    Return (children_map, roots), where children_map is a dict { parent_id: [child_ids...] }
    and roots is a list of top-level rule IDs with no parent.
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows=c.fetchall()
    children_map={}
    all_ids=set()
    parent_ids=set()
    for r_ in rows:
        rid=r_[0]
        pid=r_[1]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid,[]).append(rid)
    roots=[x for x in all_ids if x not in parent_ids]
    return children_map, roots

def load_global_critical_links_part2(conn):
    """
    Return a dict mapping GCR_RULE_ID -> set of child rule IDs from BRM_GLOBAL_CRITICAL_LINKS.
    """
    c=conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows=c.fetchall()
    link_map={}
    for r_ in rows:
        gcr=r_[0]
        tgt=r_[1]
        link_map.setdefault(gcr,set()).add(tgt)
    return link_map

def get_all_rules_as_dict_part2(conn):
    """
    Load all rules from BRM_RULES into a dict { rule_id: row_as_dict } for quick lookups.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rr=c.fetchall()
    cols=[desc[0] for desc in c.description]
    res={}
    for row in rr:
        d=dict(zip(cols,row))
        res[d["RULE_ID"]]=d
    return res

def skip_descendants_part2(child_id, children_map, skipped):
    """
    BFS to skip entire subtree of 'child_id' (and any further descendants).
    """
    stack=[child_id]
    while stack:
        curr=stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def insert_rule_execution_log_part2(conn, rule_id, pass_flag, message, record_count):
    """
    Insert a row into RULE_EXECUTION_LOGS capturing the result of a rule's BFS execution.
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
    )
    VALUES(?,GETDATE(),?,?,?)
    """,(rule_id,1 if pass_flag else 0,message,record_count))
    conn.commit()

def execute_rules_in_order_part2(conn):
    """
    BFS-based rule execution from root rules => children.
    If a critical/global rule fails => skip its subtree (and GCR links).
    Returns (executed_list, skipped_set).
    """
    children_map, roots = build_rule_adjacency_part2(conn)
    gcr_links = load_global_critical_links_part2(conn)
    rule_lookup = get_all_rules_as_dict_part2(conn)

    executed=[]
    skipped=set()
    c=conn.cursor()
    queue=list(roots)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            continue

        rinfo=rule_lookup[rid]
        sql_=rinfo["RULE_SQL"]
        is_crit=(rinfo["CRITICAL_RULE"]==1 or rinfo["IS_GLOBAL"]==1)
        crit_scope=(rinfo["CRITICAL_SCOPE"] or "NONE").upper()

        c.execute("BEGIN TRANSACTION")
        success=False
        msg=""
        record_count=0
        try:
            c.execute(sql_)
            rows=c.fetchall()
            if rows:
                record_count=len(rows)
                val=rows[0][0]
                success=(val==1)
                msg=f"Returned: {val}"
            else:
                success=True
                msg="No rows => PASS"
            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success=False
            msg=str(ex)

        insert_rule_execution_log_part2(conn, rid, success, msg, record_count)

        if success:
            executed.append(rid)
            if rid in children_map:
                for ch_ in children_map[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip children if critical
            if is_crit and crit_scope!="NONE":
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants_part2(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants_part2(child_rid, children_map, skipped)

    return (executed, skipped)

###############################################################################
# BFS FOR CHILD RULES
###############################################################################
def get_child_rules_bfs_part2(conn, start_rule_id):
    """
    Return all descendant rules of 'start_rule_id' via BFS, including GCR links.
    """
    c=conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    allrows=c.fetchall()

    children_map={}
    for row in allrows:
        rid=row[0]
        pid=row[1]
        if pid:
            children_map.setdefault(pid,[]).append(rid)

    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    glinks=c.fetchall()
    gl_map={}
    for row in glinks:
        g_parent=row[0]
        g_child=row[1]
        gl_map.setdefault(g_parent,[]).append(g_child)

    visited=set()
    queue=[start_rule_id]
    results=set()
    while queue:
        cur=queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in children_map:
            for ch_ in children_map[cur]:
                results.add(ch_)
                queue.append(ch_)
        if cur in gl_map:
            for ch_ in gl_map[cur]:
                results.add(ch_)
                queue.append(ch_)
    return results

###############################################################################
# MULTI-STEP APPROVAL CREATION
###############################################################################
def find_impacted_business_groups_part2(conn, rule_id):
    """
    Return a set of business groups impacted by 'rule_id' => the rule's own group plus BFS child owners.
    """
    impacted=set()
    c=conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if row:
        impacted.add(row[0])

    child_ids=get_child_rules_bfs_part2(conn, rule_id)
    for cid in child_ids:
        c2=conn.cursor()
        c2.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(cid,))
        r2=c2.fetchone()
        if r2:
            impacted.add(r2[0])
    return impacted

def create_multistep_approvals_part2(conn, rule_id):
    """
    Create a multi-step approval pipeline for 'rule_id':
      1) BG1, BG2, BG3 in order IF they are impacted
      2) Then FINAL
    """
    base_order=["BG1","BG2","BG3","FINAL"]
    impacted=find_impacted_business_groups_part2(conn, rule_id)

    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    stage_ctr=1
    pipeline=[]

    for stg in base_order:
        if stg=="FINAL":
            pipeline.append(stg)
        else:
            if stg in impacted:
                pipeline.append(stg)

    for st_ in pipeline:
        if st_=="FINAL":
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE
            )
            VALUES(?,?,?,?,NULL,?)
            """,(rule_id,"FINAL","final_approver",0,stage_ctr))
            stage_ctr+=1
        else:
            c2=conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(st_,))
            ap_rows=c2.fetchall()
            for apx in ap_rows:
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE
                )
                VALUES(?,?,?,?,NULL,?)
                """,(rule_id, st_, apx[0], 0, stage_ctr))
            stage_ctr+=1

    conn.commit()

###############################################################################
# RULE CRUD
###############################################################################
def add_rule_part2(conn, rule_data, created_by, user_group):
    """
    Create a new rule in BRM_RULES, plus table deps, triggers re-approval if not global.
    """
    c=conn.cursor()

    # check duplicates in same owner group
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    # check if same SQL
    new_sql=rule_data["RULE_SQL"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
    if c.fetchone():
        raise ValueError("Another rule with the same SQL exists. Not allowed.")

    # global check
    if rule_data.get("IS_GLOBAL",0)==1 and user_group!="Admin":
        raise ValueError("Only Admin can create global rule.")

    # detect op
    op_type=detect_operation_type_part2(new_sql)
    rule_data["OPERATION_TYPE"]=op_type

    row=c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
      EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
      CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
      CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,
      APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
    )
    OUTPUT inserted.RULE_ID
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """,(
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS","INACTIVE"),
        1,
        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION",""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),
        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),
        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE")
    )).fetchone()

    if not row:
        raise ValueError("Insert failed, no RULE_ID returned.")
    new_id=row[0]

    # insert table deps
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    else:
        col_op="READ"
    c.execute("""
    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
      RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
    )
    VALUES(?,?,?,?,?)
    """,(new_id,"dbo","SampleTable","DerivedCol",col_op))

    add_audit_log_part2(conn,"INSERT","BRM_RULES",new_id,created_by,None,rule_data)
    conn.commit()

    # create approvals if not global
    if rule_data.get("IS_GLOBAL",0)==0:
        create_multistep_approvals_part2(conn,new_id)

    return new_id

def update_rule_part2(conn, rule_data, updated_by, user_group):
    """
    Update an existing rule, set it to re-approval. Also handle table dependencies re-population.
    """
    c=conn.cursor()
    rid=rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=get_cursor_one_part2(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data=dict(old)

    new_owner=rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_name=rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()

    # check duplicates
    if (new_owner!=old["OWNER_GROUP"] or new_name!=old["RULE_NAME"]):
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",(new_owner,new_name))
        du=c.fetchone()
        if du and du[0]!=rid:
            raise ValueError(f"Duplicate rule '{new_name}' in group '{new_owner}'")

    new_sql=rule_data["RULE_SQL"].strip()
    if new_sql!=old["RULE_SQL"].strip():
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?",(new_sql,))
        rowx=c.fetchone()
        if rowx and rowx[0]!=rid:
            raise ValueError("Another rule with that SQL exists. Not allowed.")

    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"])==1 and user_group!="Admin":
        raise ValueError("Only Admin can set is_global=1.")

    op_type=detect_operation_type_part2(new_sql)
    rule_data["OPERATION_TYPE"]=op_type

    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID=?,
      PARENT_RULE_ID=?,
      RULE_TYPE_ID=?,
      RULE_NAME=?,
      RULE_SQL=?,
      EFFECTIVE_START_DATE=?,
      EFFECTIVE_END_DATE=?,
      STATUS='INACTIVE',
      VERSION=VERSION+1,
      UPDATED_BY=?,
      DESCRIPTION=?,
      OPERATION_TYPE=?,
      BUSINESS_JUSTIFICATION=?,
      OWNER_GROUP=?,
      CLUSTER_NAME=?,
      APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
      IS_GLOBAL=?,
      CRITICAL_RULE=?,
      CRITICAL_SCOPE=?,
      CDC_TYPE=?
    WHERE RULE_ID=?
    """,(
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_name,
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old["BUSINESS_JUSTIFICATION"]),
        new_owner,
        rule_data.get("CLUSTER_NAME", old.get("CLUSTER_NAME","")),
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rid
    ))

    # re-insert dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    else:
        col_op="READ"
    c.execute("""
    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
      RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
    )VALUES(?,?,?,?,?)
    """,(rid,"dbo","UpdatedTable","DerivedCol",col_op))

    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["VERSION"]=old_data["VERSION"]+1

    add_audit_log_part2(conn,"UPDATE","BRM_RULES",rid,updated_by,old_data,new_data)
    conn.commit()

    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"])==0:
        create_multistep_approvals_part2(conn, rid)

def deactivate_rule_part2(conn, rule_id, updated_by, user_group):
    """
    Deactivate a rule => set STATUS='INACTIVE' if it's fully approved and not global (or user is Admin).
    Ensures no active children before deactivating.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=get_cursor_one_part2(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids=c.fetchall()
    if kids:
        raise ValueError("Deactivate child rules first.")
    old_data=dict(old)

    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',UPDATED_BY=?,VERSION=VERSION+1
    WHERE RULE_ID=?
    """,(updated_by,rule_id))

    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1

    add_audit_log_part2(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()

def delete_rule_part2(conn, rule_id, action_by, user_group):
    """
    Delete a rule if it's fully approved, inactive, no children, and not referencing columns in BRM_COLUMN_MAPPING.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=get_cursor_one_part2(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids=c.fetchall()
    if kids:
        raise ValueError("Child rules exist, cannot delete.")
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    leftover=c.fetchall()
    if leftover:
        raise ValueError("Re-map or remove column references first.")

    old_data=dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log_part2(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)
    conn.commit()

# End of PART 2
#!/usr/bin/env python
"""
BRM TOOL – PART 3
Single rule/chain/group simulation, improved sync_metadata,
scheduling (add/update/delete), and advanced feature tabs:
  - Decision tables
  - Conflict priority
  - Composite rules
  - Snapshots
  - Tags
  - Data validations
Fully self-contained; no references to other parts.
"""

import sys
import json
import math
import logging
import pyodbc
from datetime import datetime
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QDate
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget, QAbstractItemView
)
import pyqtgraph as pg

logging.basicConfig(
    filename='brm_tool_part3.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger=logging.getLogger(__name__)

###############################################################################
# DB HELPERS
###############################################################################
def get_cursor_rows_part3(cursor):
    """
    Safely fetch all rows from a cursor; returns a list of dicts if column info present.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    return rows

def get_cursor_one_part3(cursor):
    """
    Fetch a single row from the cursor; returns a dict if column info present.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return None

###############################################################################
# DRY-RUN
###############################################################################
def run_rule_sql_dry_run_part3(conn, rule_sql):
    """
    Attempt to run 'rule_sql' within a transaction; returns (success_flag, message).
    success_flag=True if the returned first row's first col is 1 or if no rows => PASS.
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    try:
        c.execute(rule_sql)
        rows = c.fetchall()
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
    except Exception as ex:
        success = False
        msg = str(ex)
    c.execute("ROLLBACK")
    return success, msg

###############################################################################
# SINGLE RULE SIM
###############################################################################
class SingleRuleSimulationDialogPart3(QDialog):
    """
    A dialog to show dry-run results of a single rule's SQL.
    """
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.sql_text = sql_text

        self.setWindowTitle(f"Simulate Rule {rule_id} - Part 3")
        self.resize(500, 300)

        layout = QVBoxLayout(self)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def do_sim(self):
        success, msg = run_rule_sql_dry_run_part3(self.connection, self.sql_text)
        self.result_text.setPlainText(f"{'PASS' if success else 'FAIL'} => {msg}")

###############################################################################
# CHAIN SIM
###############################################################################
class ChainSimulationDialogPart3(QDialog):
    """
    A dialog to pick a parent rule and simulate BFS chain execution (dry-run).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        self.setWindowTitle("Simulate Rule Chain - Part 3")
        self.resize(500,300)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.parent_rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for r_ in rows:
            rid = r_[0]
            rname = r_[1]
            disp = f"{rid} - {rname}"
            self.parent_rule_combo.addItem(disp, rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        bh.addWidget(sim_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def sim_chain(self):
        pid = self.parent_rule_combo.currentData()
        ex, sk = self.do_chain_sim(pid)
        txt = f"Chain from rule {pid}\nExecuted => {ex}\nSkipped => {sk}"
        self.result_text.setPlainText(txt)

    def do_chain_sim(self, start_rule):
        """
        BFS chain sim from the selected start_rule, using run_rule_sql_dry_run_part3
        to see if each rule passes => if pass, enqueue children; else skip.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rows = c.fetchall()

        rule_map = {}
        children_map = {}
        for row in rows:
            rid = row[0]
            pid = row[1]
            sql_ = row[2]
            rule_map[rid] = sql_
            if pid:
                children_map.setdefault(pid, []).append(rid)

        executed = []
        skipped = set()
        queue = [start_rule]

        while queue:
            rid = queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_map:
                skipped.add(rid)
                continue
            sql_ = rule_map[rid]
            ok, msg = run_rule_sql_dry_run_part3(self.connection, sql_)
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch_ in children_map[rid]:
                        if ch_ not in skipped:
                            queue.append(ch_)
            else:
                skipped.add(rid)
        return (executed, skipped)

###############################################################################
# GROUP SIM
###############################################################################
class GroupSimulationDialogPart3(QDialog):
    """
    A dialog to pick a custom group and dry-run each rule in that group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        self.setWindowTitle("Simulate Custom Group - Part 3")
        self.resize(500,300)

        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.group_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        rows = c.fetchall()
        for row in rows:
            cg_id = row[0]
            cg_name = row[1]
            disp = f"{cg_id} - {cg_name}"
            self.group_combo.addItem(disp, cg_id)
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        sim_btn = QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        bh.addWidget(sim_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)

    def sim_group(self):
        cg_id = self.group_combo.currentData()
        ex, fails = self.do_sim(cg_id)
        msg = f"Group {cg_id}\nExecuted => {ex}\nFails => {fails}"
        self.result_text.setPlainText(msg)

    def do_sim(self, custom_group_id):
        """
        For each rule in the custom group, run dry_run => if pass => executed, else fails.
        """
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
        rows = c.fetchall()
        group_rules = [x[0] for x in rows]

        c.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES")
        all_ = c.fetchall()
        rule_map = {}
        for row in all_:
            rule_map[row[0]] = row[1]

        executed = []
        fails = []
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            sql_ = rule_map[rid]
            ok, msg = run_rule_sql_dry_run_part3(self.connection, sql_)
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return executed, fails

###############################################################################
# SYNC METADATA (IMPROVED)
###############################################################################
def sync_metadata_improved_part3(conn):
    """
    Compare BRM_RULE_TABLE_DEPENDENCIES to actual sys.tables. Mark missing with 'MISSING_' prefix.
    """
    c = conn.cursor()
    c.execute("""
    SELECT s.name AS schema_name, t.name AS table_name
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id=s.schema_id
    ORDER BY s.name, t.name
    """)
    actual_tables = set()
    for row in c.fetchall():
        fulln = f"{row[0]}.{row[1]}".lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID, RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps = c.fetchall()
    missing = []
    updated = 0
    for d_ in deps:
        dep_id = d_[0]
        tbl = (d_[3] or "").strip()
        if "." not in tbl:
            candidate = f"dbo.{tbl}".lower()
        else:
            candidate = tbl.lower()
        if candidate not in actual_tables:
            missing.append(dep_id)

    for dep_id in missing:
        c.execute("""
        UPDATE BRM_RULE_TABLE_DEPENDENCIES
        SET TABLE_NAME='MISSING_' + TABLE_NAME
        WHERE DEPENDENCY_ID=?
        """, (dep_id,))
        updated += 1

    conn.commit()
    msg = (f"Metadata Sync completed.\n"
           f"Found {len(actual_tables)} real tables.\n"
           f"Scanned {len(deps)} dependencies.\n"
           f"Marked {updated} references as MISSING.\n")
    QMessageBox.information(None, "Sync Metadata", msg)

###############################################################################
# SCHEDULING (ADD/UPDATE/DELETE)
###############################################################################
class EnhancedScheduleDialogPart3(QDialog):
    """
    Dialog to pick a rule and schedule date/time => inserts into RULE_SCHEDULES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Scheduling UI - Part 3")
        self.resize(400,300)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for row in rows:
            rid = row[0]
            rname = row[1]
            disp = f"{rid} - {rname}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_ = self.calendar.selectedDate()
        time_ = self.time_edit.time()
        dt_str = f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        c = self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP)
        VALUES(?,?,'Scheduled',GETDATE())
        """, (rid, dt_str))
        self.connection.commit()

        QMessageBox.information(self, "Scheduled", f"Rule {rid} scheduled at {dt_str}.")
        self.close()

class ScheduleManagementTabPart3(QWidget):
    """
    A tab to show the top 1000 schedules and allow update/delete, plus 'Add New Schedule'.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0,5)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID","Rule ID","Schedule Time","Status","Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()

        for row in rows:
            r_i = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            self.schedule_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(r_i, 2, QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(r_i, 3, QTableWidgetItem(str(row[3])))

            act_widget = QWidget()
            h = QHBoxLayout(act_widget)
            h.setContentsMargins(0,0,0,0)
            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rowidx=r_i: self.update_schedule(rowidx))
            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rowidx=r_i: self.delete_schedule(rowidx))
            h.addWidget(upd_btn)
            h.addWidget(del_btn)
            h.addStretch()
            self.schedule_table.setCellWidget(r_i, 4, act_widget)

        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg = EnhancedScheduleDialogPart3(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, rowidx):
        sch_id_item = self.schedule_table.item(rowidx, 0)
        if not sch_id_item:
            return
        sch_id = int(sch_id_item.text())

        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return

        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?", (new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, rowidx):
        sch_id_item = self.schedule_table.item(rowidx, 0)
        if not sch_id_item:
            return
        sch_id = int(sch_id_item.text())

        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {sch_id}?")
        if confirm != QMessageBox.Yes:
            return

        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sch_id,))
        self.connection.commit()

        QMessageBox.information(self, "Deleted", f"Schedule {sch_id} removed.")
        self.load_schedules()

###############################################################################
# ADVANCED FEATURE TABS
###############################################################################
class DecisionTablesTabPart3(QWidget):
    """
    A tab to manage DECISION_TABLES: add, delete, refresh. 
    Demonstration only; adapt as needed.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels(["Decision Table ID","Table Name","Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn = QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows = c.fetchall()
        for r_ in rows:
            rr = self.dt_table.rowCount()
            self.dt_table.insertRow(rr)
            self.dt_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.dt_table.setItem(rr,1,QTableWidgetItem(r_[1]))
            self.dt_table.setItem(rr,2,QTableWidgetItem(r_[2] if r_[2] else ""))

    def add_dt(self):
        name,ok=QInputDialog.getText(self,"Add Decision Table","Table Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional desc:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(name.strip(),desc.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Decision table created.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No decision table selected.")
            return
        it=self.dt_table.item(row,0)
        if not it:
            return
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete decision table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Decision table removed.")
        self.load_dt()

class ConflictPriorityManagerTabPart3(QWidget):
    """
    A simple tab to manage RULE_CONFLICTS: add conflict, set priority, delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.cf_table = QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["Conflict ID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        setp_btn = QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.cf_table.rowCount()
            self.cf_table.insertRow(rr)
            self.cf_table.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.cf_table.setItem(rr,1,QTableWidgetItem(str(row[1])))
            self.cf_table.setItem(rr,2,QTableWidgetItem(str(row[2])))
            self.cf_table.setItem(rr,3,QTableWidgetItem(str(row[3])))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule ID1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule ID2:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Enter priority (int):")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pri))
        self.connection.commit()
        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        if not cfid_item:
            return
        cf_id=int(cfid_item.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cf_id))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Conflict priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cfid_item=self.cf_table.item(row,0)
        if not cfid_item:
            return
        cf_id=int(cfid_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()

class CompositeRulesTabPart3(QWidget):
    """
    A tab to manage COMPOSITE_RULES: add, delete, refresh. (Logic_expr, action_on_pass, etc.)
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["Composite Rule ID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_crule)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_crule)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_crules)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_crules()

    def load_crules(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        rows=c.fetchall()
        for r_ in rows:
            rr=self.cr_table.rowCount()
            self.cr_table.insertRow(rr)
            self.cr_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.cr_table.setItem(rr,1,QTableWidgetItem(r_[1]))
            self.cr_table.setItem(rr,2,QTableWidgetItem(r_[2] if r_[2] else ""))
            self.cr_table.setItem(rr,3,QTableWidgetItem(r_[3] if r_[3] else ""))

    def add_crule(self):
        name,ok=QInputDialog.getText(self,"New Composite Rule","Name:")
        if not ok or not name.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expr","(e.g. 'Rule1==PASS AND Rule2==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","(Optional) Action:")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
        VALUES(?,?,?)
        """,(name.strip(),expr.strip(),act.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","Composite rule created.")
        self.load_crules()

    def del_crule(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        if not it:
            return
        cid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_crules()

class SnapshotManagerTabPart3(QWidget):
    """
    A tab to handle RULE_SNAPSHOTS: list, create (take snapshot of BRM_RULES), delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout=QVBoxLayout(self)
        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["Snapshot ID","SNAPSHOT_NAME","CREATED_BY","CREATED_TIMESTAMP","SNAPSHOT_JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snapshot)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for r_ in rows:
            rr=self.ss_table.rowCount()
            self.ss_table.insertRow(rr)
            self.ss_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.ss_table.setItem(rr,1,QTableWidgetItem(r_[1]))
            self.ss_table.setItem(rr,2,QTableWidgetItem(r_[2]))
            self.ss_table.setItem(rr,3,QTableWidgetItem(str(r_[3])))
            self.ss_table.setItem(rr,4,QTableWidgetItem(r_[4] if r_[4] else ""))

    def take_snapshot(self):
        name,ok=QInputDialog.getText(self,"Snapshot","Snapshot name:")
        if not ok or not name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        import json
        colnames=[desc[0] for desc in c.description]
        rules_list=[]
        for row in rows:
            rules_list.append(dict(zip(colnames,row)))
        snapshot_json=json.dumps(rules_list)

        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(name.strip(),"SnapshotUser",snapshot_json))
        self.connection.commit()
        QMessageBox.information(self,"Snapshot","Snapshot created.")
        self.load_snapshots()

    def del_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        it=self.ss_table.item(row,0)
        if not it:
            return
        ssid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {ssid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(ssid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Snapshot removed.")
        self.load_snapshots()

class TagsManagerTabPart3(QWidget):
    """
    A tab to manage RULE_TAGS: add tags, remove tags, refresh.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)
        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        rows=c.fetchall()
        for r_ in rows:
            rr=self.tags_table.rowCount()
            self.tags_table.insertRow(rr)
            self.tags_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.tags_table.setItem(rr,1,QTableWidgetItem(str(r_[1])))
            self.tags_table.setItem(rr,2,QTableWidgetItem(r_[2]))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        if not it:
            return
        tag_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tag_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()

class DataValidationTabPart3(QWidget):
    """
    A tab to manage DATA_VALIDATIONS: table_name, column_name, validation_type, params.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_val)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        rows=c.fetchall()
        for r_ in rows:
            rr=self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            self.dv_table.setItem(rr,0,QTableWidgetItem(str(r_[0])))
            self.dv_table.setItem(rr,1,QTableWidgetItem(r_[1]))
            self.dv_table.setItem(rr,2,QTableWidgetItem(r_[2]))
            self.dv_table.setItem(rr,3,QTableWidgetItem(r_[3]))
            self.dv_table.setItem(rr,4,QTableWidgetItem(r_[4] if r_[4] else ""))

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name:")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'RANGE','NOT NULL'):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional) param string:")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS)
        VALUES(?,?,?,?)
        """,(tbl.strip(),col.strip(),vtype.strip(),pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Validation rule added.")
        self.load_vals()

    def remove_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        if not it:
            return
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove data validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

# End of PART 3
#!/usr/bin/env python
"""
BRM TOOL – PART 4
Fully expanded main window, approvals (with Reject), global/critical admin,
hierarchy, lineage, user mgmt, group mgmt, custom groups, control tables,
analytics, version history, etc. Fully self-contained; no references to other parts.
"""

import sys
import json
import math
import logging
import pyodbc
from datetime import datetime
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTabWidget, QLineEdit, QMessageBox, QAbstractItemView, QComboBox,
    QTableWidget, QTableWidgetItem, QPlainTextEdit, QDialog, QInputDialog,
    QTextEdit, QGroupBox, QFileDialog
)
import pyqtgraph as pg

logging.basicConfig(
    filename='brm_tool_part4.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# DB + AUDIT HELPERS
###############################################################################
def get_cursor_rows_part4(cursor):
    """
    Fetch all rows from a cursor safely; returns a list of dicts if column info present.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return [dict(zip(cols, r)) for r in rows]
    return rows

def get_cursor_one_part4(cursor):
    """
    Fetch a single row from a cursor; returns a dict if column info present.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return dict(zip(cols, row))
    return None

def add_audit_log_part4(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert a record into BRM_AUDIT_LOG capturing old/new JSON data.
    """
    c = conn.cursor()
    import json
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """, (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# APPROVAL PIPELINE WIDGET
###############################################################################
class ApprovalPipelineWidgetPart4(QWidget):
    """
    A small horizontal layout to show stage statuses with colored circles.
    Example usage: pipeline = {"BG1":"Approved","BG2":"Pending","BG3":"Rejected","FINAL":"NotStarted"}
    """
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(5)

        stages = ["BG1","BG2","BG3","FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")

            status = stage_status_map.get(st, "NotStarted")
            if status == "Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status == "Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status == "Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")

            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

###############################################################################
# MULTI-STEP APPROVAL TAB
###############################################################################
class MultiStepApprovalTabPart4(QWidget):
    """
    Displays approvals assigned to the logged-in user, allowing Approve/Reject.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)

        self.appr_table = QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels(["Rule ID","Group Name","Rule Name","Stage","Approved?","Approve","Reject"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        """
        Only load approvals for current user, also filter out those not in the current minimal stage.
        """
        c = self.connection.cursor()
        query = """
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """
        c.execute(query, (self.logged_in_username,))
        rows = c.fetchall()

        # helper to find minimal stage for each rule
        def get_current_stage_for_rule(rid_):
            c2 = self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) as stage
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """, (rid_,))
            ro = c2.fetchone()
            if ro and ro[0]:
                return ro[0]
            return None

        minimal_rows=[]
        for rd in rows:
            rule_id = rd[0]
            stage = rd[4]
            cur_st = get_current_stage_for_rule(rule_id)
            # Only show row if its stage == minimal unapproved stage
            if cur_st == stage:
                minimal_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r_i = self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)

            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(rd[0])))  # rule_id
            self.appr_table.setItem(r_i,1,QTableWidgetItem(rd[1]))       # group
            self.appr_table.setItem(r_i,2,QTableWidgetItem(rd[5]))       # rule_name
            self.appr_table.setItem(r_i,3,QTableWidgetItem(str(rd[4])))  # stage
            self.appr_table.setItem(r_i,4,QTableWidgetItem(str(rd[3])))  # approved?

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rowidx=r_i: self.do_approve(rowidx))
            self.appr_table.setCellWidget(r_i,5,approve_btn)

            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rowidx=r_i: self.do_reject(rowidx))
            self.appr_table.setCellWidget(r_i,6,reject_btn)

    def do_approve(self, row_i):
        rid_item = self.appr_table.item(row_i,0)
        grp_item = self.appr_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid = int(rid_item.text())
        grp = grp_item.text()

        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))

        # find if more approvals needed or not
        def get_current_stage_for_rule(rid_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) as stage
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            if ro and ro[0]:
                return ro[0]
            return None

        nxt = get_current_stage_for_rule(rid)
        if nxt is None:
            # fully approved
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?",(rid,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?",(rid,))

        # add audit
        old_data={"APPROVED_FLAG":0}
        new_data={"APPROVED_FLAG":1}
        add_audit_log_part4(self.connection,"UPDATE","BRM_RULE_APPROVALS",rid,self.logged_in_username,old_data,new_data)

        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} was approved.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item = self.appr_table.item(row_i,0)
        grp_item = self.appr_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid = int(rid_item.text())
        grp = grp_item.text()

        confirm = QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm != QMessageBox.Yes:
            return

        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))

        c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?",(rid,))

        add_audit_log_part4(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"REJECTED":True})

        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} rejected.")
        self.load_approvals()

###############################################################################
# GLOBAL/CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTabPart4(QWidget):
    """
    Allows Admin to set is_global, critical_rule, critical_scope on rules,
    plus manage BRM_GLOBAL_CRITICAL_LINKS parent->child references.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)

        if user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return

        # Filter row
        filter_h = QHBoxLayout()
        self.show_only_gcr_cb = QCheckBox("Show only Global/Critical")
        self.show_only_gcr_cb.setChecked(True)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        filter_h.addWidget(self.show_only_gcr_cb)
        filter_h.addWidget(ref_btn)
        filter_h.addStretch()
        layout.addLayout(filter_h)

        # Rule table
        self.rule_table = QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels(["Rule ID","Rule Name","Owner Group","IS_GLOBAL","CRITICAL_RULE","CRITICAL_SCOPE","STATUS","UPDATED_BY"])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        # GCS row
        gcs_h = QHBoxLayout()
        self.global_cb = QCheckBox("Set Global?")
        gcs_h.addWidget(self.global_cb)
        self.critical_cb = QCheckBox("Set Critical?")
        gcs_h.addWidget(self.critical_cb)
        gcs_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        gcs_h.addWidget(self.scope_combo)
        apply_btn = QPushButton("Apply Flags/Scope to Selected")
        apply_btn.clicked.connect(self.apply_flags_to_selected)
        gcs_h.addWidget(apply_btn)
        gcs_h.addStretch()
        layout.addLayout(gcs_h)

        # Link row
        link_box = QHBoxLayout()
        self.gcr_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Parent GCR Rule:"))
        link_box.addWidget(self.gcr_rule_combo)
        self.child_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Child Rule:"))
        link_box.addWidget(self.child_rule_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_box.addWidget(link_btn)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_box.addWidget(unlink_btn)
        link_box.addStretch()
        layout.addLayout(link_box)

        # Link view
        self.link_view = QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        # refresh
        ref_all = QPushButton("Refresh Everything")
        ref_all.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        if self.show_only_gcr_cb.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.rule_table.setItem(r_i,col_i,QTableWidgetItem(str(val)))
        self.rule_table.resizeColumnsToContents()

    def populate_gcr_rule_combo(self):
        self.gcr_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows = c.fetchall()
        for r_ in rows:
            rid = r_[0]
            rname = r_[1]
            disp = f"ID:{rid} - {rname}"
            self.gcr_rule_combo.addItem(disp, rid)

    def populate_child_rule_combo(self):
        self.child_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for row in rows:
            rid=row[0]
            rname=row[1]
            disp=f"ID:{rid} - {rname}"
            self.child_rule_combo.addItem(disp, rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))
        self.link_view.resizeColumnsToContents()

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def apply_flags_to_selected(self):
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No Selection","Select rule(s) first.")
            return

        is_global=1 if self.global_cb.isChecked() else 0
        is_crit=1 if self.critical_cb.isChecked() else 0
        scope_val=self.scope_combo.currentText().upper()

        confirm=QMessageBox.question(
            self,"Confirm",
            f"Set IS_GLOBAL={is_global}, CRITICAL_RULE={is_crit}, SCOPE={scope_val} for {len(rids)} rule(s)?"
        )
        if confirm != QMessageBox.Yes:
            return

        c=self.connection.cursor()
        for rid in rids:
            c.execute("""
            UPDATE BRM_RULES
            SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
            WHERE RULE_ID=?
            """,(is_global, is_crit, scope_val, rid))
        self.connection.commit()

        QMessageBox.information(self,"Done",f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def link_child(self):
        pid=self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No Parent GCR","Select a parent GCR rule.")
            return
        cid=self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self,"No Child","Select a child rule.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c=self.connection.cursor()
        # add audit
        old_data=None
        new_data={"parent":pid,"child":cid}
        c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(pid,cid))
        add_audit_log_part4(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",old_data,new_data)
        self.connection.commit()

        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_rule_combo.currentData()
        cid=self.child_rule_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c=self.connection.cursor()
        old_data={"parent":pid,"child":cid}
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
        add_audit_log_part4(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",old_data,None)
        self.connection.commit()

        QMessageBox.information(self,"Unlinked",f"Child {cid} from {pid}")
        self.load_link_view()

###############################################################################
# HIERARCHY VIEW
###############################################################################
class HierarchyViewTabPart4(QWidget):
    """
    Shows a tree of BRM_RULE_GROUPS (top) and child BRM_RULES. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Group / Rule"])
        layout.addWidget(self.tree)

        ref_btn=QPushButton("Refresh Hierarchy")
        ref_btn.clicked.connect(self.load_hierarchy)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_rows=c.fetchall()
        grp_map={}
        for g in grp_rows:
            gid=g[0]
            gname=g[1]
            it=QTreeWidgetItem([f"{gname} (ID={gid})"])
            self.tree.addTopLevelItem(it)
            grp_map[gid]=it

        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID FROM BRM_RULES ORDER BY RULE_ID")
        rule_rows=c.fetchall()
        for rr in rule_rows:
            rid=rr[0]
            rnm=rr[1]
            g_id=rr[2]
            if g_id in grp_map:
                parent_it=grp_map[g_id]
                child=QTreeWidgetItem([f"Rule {rid}: {rnm}"])
                parent_it.addChild(child)
        self.tree.expandAll()

###############################################################################
# ENHANCED LINEAGE GRAPH
###############################################################################
class EnhancedLineageGraphWidgetPart4(QtWidgets.QGraphicsView):
    """
    A QGraphicsView-based widget that draws rules as nodes (rect or ellipse),
    plus edges for parent->child or for rule->table dependencies, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        self.scene=QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.children_map={}
        self.parents_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rules=c.fetchall()
        if not rules:
            txt_item=QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(txt_item)
            return

        # Build adjacency
        all_ids=set()
        for row in rules:
            rid=row[0]
            pid=row[2]
            all_ids.add(rid)
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                self.parents_map[rid]=pid

        # BFS from roots
        from collections import deque
        child_ids=set(self.parents_map.keys())
        roots=list(all_ids - child_ids)
        rule_lookup={}
        for row in rules:
            rule_lookup[row[0]]={
                "RULE_ID":row[0],
                "RULE_NAME":row[1],
                "PARENT_RULE_ID":row[2],
                "STATUS":row[3],
                "RULE_TYPE_ID":row[4],
                "CLUSTER_NAME":row[5],
                "IS_GLOBAL":row[6],
                "CRITICAL_RULE":row[7]
            }

        queue=deque()
        level_map={}
        visited=set()
        for rt in roots:
            queue.append((rt,0))

        while queue:
            rid, depth=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info=rule_lookup[rid]
            count_at_level=level_map.get(depth,0)
            level_map[depth]=count_at_level+1
            x=depth*220
            y=count_at_level*120

            node_item=self.create_node(info)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid]=node_item

            if rid in self.children_map:
                for ch_ in self.children_map[rid]:
                    queue.append((ch_, depth+1))

        # draw edges
        for row in rules:
            rid=row[0]
            pid=row[2]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # table deps
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps=c.fetchall()
        tbl_map={}
        idx=0
        for d_ in deps:
            drid=d_[0]
            dbn=d_[1]
            tbn=d_[2]
            cop=d_[4]
            key=f"{dbn}.{tbn}".lower().strip(".")
            if key not in tbl_map:
                t_item=QtWidgets.QGraphicsEllipseItem(0,0,100,40)
                t_item.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
                t_item.setToolTip(f"Table: {key}")
                t_item.setPos(800, idx*60)
                self.scene.addItem(t_item)
                tbl_map[key]=t_item
                idx+=1
            if drid in self.node_map:
                color=QtGui.QColor("darkblue") if cop=="READ" else QtGui.QColor("darkred")
                self.draw_edge(self.node_map[drid], tbl_map[key], color)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, info):
        """
        Create a QGraphicsItem (rect or ellipse) representing a rule.
        Color-coded by status or cluster, thicker pen if critical, etc.
        """
        rtype=info["RULE_TYPE_ID"]
        status=info["STATUS"]
        cluster=info["CLUSTER_NAME"] or ""
        is_g=info["IS_GLOBAL"]
        is_c=info["CRITICAL_RULE"]

        if rtype==1:
            node=QtWidgets.QGraphicsRectItem(0,0,120,50)
        else:
            node=QtWidgets.QGraphicsEllipseItem(0,0,120,50)

        if status.lower()=="active":
            basecol=QtGui.QColor("lightgreen")
        else:
            basecol=QtGui.QColor("tomato")
        if cluster:
            hv=abs(hash(cluster))%360
            basecol=QtGui.QColor.fromHsv(hv,128,255)
        node.setBrush(QtGui.QBrush(basecol))

        pen=QtGui.QPen(QtCore.Qt.black,2)
        if is_c==1:
            pen=QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)

        disp=info["RULE_NAME"]
        if is_g==1:
            disp=f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=QtWidgets.QGraphicsLineItem(p1.x(),p1.y(),p2.x(),p2.y())
        line.setPen(QtGui.QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button()==QtCore.Qt.LeftButton:
            item=self.itemAt(event.pos())
            if isinstance(item,(QtWidgets.QGraphicsRectItem,QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self,"Rule Details",item.toolTip())
        super().mousePressEvent(event)

###############################################################################
# METRICS
###############################################################################
class MetricsDashboardTabPart4(QWidget):
    """
    A tab that displays a bar chart of how many rules are in each status, using pyqtgraph.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.chart=pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        ref_btn=QPushButton("Refresh Metrics")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()

        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]

        self.chart.clear()
        if statuses:
            x=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(x), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(x, statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True, y=True)

###############################################################################
# CONTROL TABLES TAB
###############################################################################
class CtrlTablesTabPart4(QWidget):
    """
    A tab that allows you to select a known table and view up to 1000 rows of data read-only.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)

        self.table_list = [
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS"
        ]

        self.table_combo=QComboBox()
        for t_ in self.table_list:
            self.table_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn=QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def on_load_data(self):
        tbl=self.table_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error getting columns",str(ex))
            return
        try:
            c.execute(f"SELECT * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error retrieving data",str(ex))
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)

        for row in rows:
            r_=self.data_table.rowCount()
            self.data_table.insertRow(r_)
            for j,val in enumerate(row):
                self.data_table.setItem(r_,j,QTableWidgetItem(str(val)))

###############################################################################
# GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTabPart4(QWidget):
    """
    A tab for Admin to manage business groups, membership, group permissions, group approvers, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # Groups & Membership sub-tab
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        grp_btns.addWidget(add_grp_btn)

        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        grp_btns.addWidget(rename_grp_btn)

        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        grp_btns.addWidget(del_grp_btn)

        grp_btns.addStretch()
        grp_layout.addLayout(grp_btns)
        gm_layout.addWidget(grp_box)

        membership_box=QGroupBox("Membership Management")
        membership_layout=QVBoxLayout(membership_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btns.addWidget(add_usr_btn)

        rem_usr_btn=QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btns.addWidget(rem_usr_btn)

        memb_btns.addStretch()
        membership_layout.addLayout(memb_btns)
        gm_layout.addWidget(membership_box)

        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # Permissions sub-tab
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)
        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)

        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.on_add_permission)
        ph.addWidget(addp_btn)

        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.on_remove_permission)
        ph.addWidget(remp_btn)
        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # Approvers sub-tab
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btns=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btns.addWidget(add_appr_btn)
        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btns.addWidget(del_appr_btn)
        appr_btns.addStretch()
        appr_layout.addLayout(appr_btns)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        # refresh
        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.groups_table.setRowCount(0)
        for row in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            self.groups_table.setItem(r_i,0,QTableWidgetItem(row[0]))
            self.groups_table.setItem(r_i,1,QTableWidgetItem(row[1] if row[1] else ""))
            self.groups_table.setItem(r_i,2,QTableWidgetItem(row[2] if row[2] else ""))

    def get_selected_group(self):
        i=self.groups_table.currentRow()
        if i<0:
            return None
        it=self.groups_table.item(i,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",(name.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def on_rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' renamed to '{new_name}'.")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def on_delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group removed.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            self.users_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.users_table.setItem(r_i,1,QTableWidgetItem(row[1]))
            self.users_table.setItem(r_i,2,QTableWidgetItem(row[2]))

    def get_selected_user(self):
        i=self.users_table.currentRow()
        if i<0:
            return None
        it=self.users_table.item(i,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldg=c.fetchone()
        if not oldg:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if oldg[0]==grp.strip():
            QMessageBox.warning(self,"Error","User is already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user from group => user moves to BG1.")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def load_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.perm_group_combo.clear()
        for row in rows:
            self.perm_group_combo.addItem(row[0],row[0])

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=c.fetchall()
        self.perm_table.setRowCount(0)
        for r_ in rows:
            rr=self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(r_[0]))

    def on_add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        table,ok=QInputDialog.getText(self,"Add Permission","Table name (e.g. 'dbo.Credit_Portfolio'):")
        if not ok or not table.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),table.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission added.")
        self.load_permissions()

    def on_remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","No group selected.")
            return
        row=self.perm_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No permission selected.")
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        table_name=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{table_name}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp.strip(),table_name))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    def load_appr_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        self.appr_group_combo.clear()
        for row in rows:
            self.appr_group_combo.addItem(row[0],row[0])

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp.strip(),))
        rows=c.fetchall()
        self.appr_table.setRowCount(0)
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(row[1]))

    def on_add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self,"No Group","Select a group first.")
            return
        usern,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usern.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(),usern.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver '{usern}' added to {grp}.")
        self.load_approvers()

    def on_remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No approver selected.")
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        app_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver ID={app_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(app_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

###############################################################################
# USER MANAGEMENT TAB
###############################################################################
class UserManagementTabPart4(QWidget):
    """
    A tab for Admin to manage users: add, delete, change password.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        layout=QVBoxLayout(self)

        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["User ID","Username","Password","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.on_add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.on_delete_user)
        bh.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.on_change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            self.user_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.user_table.setItem(r_i,1,QTableWidgetItem(row[1]))
            self.user_table.setItem(r_i,2,QTableWidgetItem(row[2]))
            self.user_table.setItem(r_i,3,QTableWidgetItem(row[3]))

    def get_selected_user_id(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user(self):
        name,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not name.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username already in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(name.strip(),pwd.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","User added.")
        self.load_users()

    def on_delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","User removed.")
        self.load_users()

    def on_change_password(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Password changed.")
        self.load_users()

###############################################################################
# CUSTOM RULE GROUPS TAB
###############################################################################
class CustomRuleGroupEnhancedTabPart4(QWidget):
    """
    A tab to manage custom rule groups, BFS backups, membership, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Custom Group / Rule"])
        self.tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        right_widget.setLayout(rw_layout)
        splitter.addWidget(right_widget)

        layout.addWidget(splitter)
        self.setLayout(layout)

        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for row in groups:
            cg_id=row[0]
            cg_name=row[1]
            owner=row[2]
            disp=f"{cg_name} ({owner})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0,Qt.UserRole,cg_id)
            g_item.setBackground(0,QtGui.QBrush(QtGui.QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for rr in assigned:
                rid=rr[0]
                rname=rr[1]
                isg=rr[2]
                iscrit=rr[3]
                txt=f"Rule {rid}: {rname}"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0,Qt.UserRole,rid)
                if isg==1:
                    rr_item.setBackground(0,QtGui.QBrush(QtGui.QColor("lightblue")))
                if iscrit==1:
                    rr_item.setBackground(0,QtGui.QBrush(QtGui.QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)

        rows=c.fetchall()
        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set(x[0] for x in c2.fetchall())

        for r in rows:
            rid=r[0]
            rname=r[1]
            og=r[2]
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rname} (Owner {og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # child => rule
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id,rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed.")
                self.refresh_all()

    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP)
        VALUES(?,?,?,GETDATE())
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return None,None
        item=sel[0]
        par=item.parent()
        if par:
            item=par
        gid=item.data(0,Qt.UserRole)
        disp=item.text(0)
        return gid,disp

    def rename_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New custom group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        grpname=row[0]

        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[x[0] for x in c.fetchall()]
        backup_data={"group_name":grpname,"members":assigned}

        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 AS new_ver
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1

        import json
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON)
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()

        QMessageBox.information(self,"Backup",f"Backup version {new_ver} for group {gid} created.")
        self.refresh_all()

    def restore_group(self):
        gid,disp=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return

        items=[f"Version {r[0]} (ts {r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return

        import re
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        ver=int(m.group(1))

        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return

        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup not found.")
            return

        import json
        backup_data=json.loads(backup_json)
        new_name=backup_data["group_name"]
        members=backup_data["members"]

        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_name,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected in the tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)

        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return

        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()

        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()

###############################################################################
# ALERTS & DASHBOARDS TAB
###############################################################################
class AlertsAndDashboardsTabPart4(QWidget):
    """
    A tab that shows old approvals, upcoming schedules, etc. 
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # find approvals older than 3 days
        c.execute("""
        SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
               DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(SELECT MIN(APPROVAL_STAGE)
                                FROM BRM_RULE_APPROVALS
                                WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0)
          AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        old_ap=c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for row in old_ap:
                lines.append(f" - Rule {row[0]} stage={row[1]} age={row[3]} => {row[2]}")
        else:
            lines.append("No old approvals found.")

        lines.append("")
        # upcoming schedules in next 24 hours
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upcoming=c.fetchall()
        if upcoming:
            lines.append("Upcoming schedules in next 24h:")
            for up_ in upcoming:
                lines.append(f" - ID={up_[0]}, rule={up_[1]}, time={up_[2]}")
        else:
            lines.append("No upcoming schedules in next 24h.")

        self.alert_text.setPlainText("\n".join(lines))

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewerPart4(QDialog):
    """
    A dialog to show up to 1000 lines from BRM_AUDIT_LOG, with search and CSV export.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        self.setWindowTitle("Audit Logs – Part 4")
        self.resize(800,600)

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table=QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels(["Audit ID","Action","Table","Record ID","Action By","Old Data","New Data","Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)
        exp_btn=QPushButton("Export to CSV")
        exp_btn.clicked.connect(self.export_csv)
        bh.addWidget(exp_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.audit_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_=self.audit_table.rowCount()
            self.audit_table.insertRow(r_)
            self.audit_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.audit_table.setItem(r_,1,QTableWidgetItem(row[1]))
            self.audit_table.setItem(r_,2,QTableWidgetItem(row[2]))
            self.audit_table.setItem(r_,3,QTableWidgetItem(row[3]))
            self.audit_table.setItem(r_,4,QTableWidgetItem(row[4]))

            oldtxt=""
            if row[5]:
                try:
                    d_=json.loads(row[5])
                    oldtxt=json.dumps(d_,indent=2)
                except:
                    oldtxt=row[5]
            self.audit_table.setItem(r_,5,QTableWidgetItem(oldtxt))

            newtxt=""
            if row[6]:
                try:
                    d2=json.loads(row[6])
                    newtxt=json.dumps(d2,indent=2)
                except:
                    newtxt=row[6]
            self.audit_table.setItem(r_,6,QTableWidgetItem(newtxt))

            self.audit_table.setItem(r_,7,QTableWidgetItem(str(row[7])))

    def perform_search(self, text):
        txt_l=text.lower()
        for row in range(self.audit_table.rowCount()):
            show=False
            for col in (1,2,4):
                it=self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    show=True
                    break
            self.audit_table.setRowHidden(row, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Save CSV","","CSV Files (*.csv)")
        if not path:
            return
        import csv
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row):
                    continue
                rowdata=[]
                for col in range(self.audit_table.columnCount()):
                    it=self.audit_table.item(row,col)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported","Audit logs exported.")

###############################################################################
# SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialogPart4(QDialog):
    """
    A simple search for rules by name/SQL snippet. 
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group

        self.setWindowTitle("Search Rules – Part 4")
        self.resize(800,600)

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        rb=QPushButton("Refresh")
        rb.clicked.connect(self.load_results)
        layout.addWidget(rb)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        c=self.connection.cursor()
        txt=self.search_edit.text().strip()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_=self.res_table.rowCount()
            self.res_table.insertRow(r_)
            for i_ in range(6):
                self.res_table.setItem(r_,i_,QTableWidgetItem(str(row[i_])))

###############################################################################
# VERSION HISTORY
###############################################################################
class VersionHistoryDialogPart4(QDialog):
    """
    Shows an audit trail of INSERT/UPDATE actions on a rule, allowing rollback to old_data if present.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id

        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(800,400)

        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["Audit ID","Action","Timestamp","Old Data","New Data"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb=QPushButton("Rollback Selected")
        rb.clicked.connect(self.do_rollback)
        bh.addWidget(rb)

        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)

        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()

        self.table.setRowCount(0)
        for row in rows:
            rr=self.table.rowCount()
            self.table.insertRow(rr)
            self.table.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(rr,1,QTableWidgetItem(row[1]))
            self.table.setItem(rr,2,QTableWidgetItem(str(row[2])))
            self.table.setItem(rr,3,QTableWidgetItem(row[3] if row[3] else ""))
            self.table.setItem(rr,4,QTableWidgetItem(row[4] if row[4] else ""))

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected for rollback.")
            return
        row=sel[0].row()
        old_data_item=self.table.item(row,3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self,"No Old Data","No old_data found in that row.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to selected version?")
        if confirm!=QMessageBox.Yes:
            return

        import json
        try:
            old_data=json.loads(old_data_item.text())
            self.apply_rollback(old_data)
            QMessageBox.information(self,"Rolled Back","Rule rollback done.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def apply_rollback(self, old_data):
        """
        Attempt to set BRM_RULES back to the fields from old_data (like RULE_NAME, RULE_SQL, OWNER_GROUP).
        Then re-insert table deps from the SQL if needed.
        """
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()

        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            raise ValueError("Rule not found for rollback.")

        c.execute("BEGIN TRANSACTION")
        new_sql=old_data["RULE_SQL"]
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rid))

        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        # We might want to parse the new_sql to get actual table references; for brevity, do a sample:
        # In real usage, parse for tables & columns, then re-insert.
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
          RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
        ) VALUES(?,?,?,?,?)
        """,(rid,"dbo","RolledBackTable","RolledBackCol","READ"))

        c.execute("COMMIT")

###############################################################################
# MAIN WINDOW – PART 4
###############################################################################
class BRMToolPart4Main(QMainWindow):
    """
    A large main window with tabs:
     - Approvals
     - Global/Critical admin
     - Hierarchy
     - Lineage
     - Custom groups
     - Scheduling
     - Control tables
     - Metrics
     - Alerts & dashboards
     - Group mgmt
     - User mgmt
    Tools menu => Audit logs, search rule, version history
    """
    def __init__(self, connection, user_id, logged_in_username, user_group):
        super().__init__()
        self.connection=connection
        self.user_id=user_id
        self.logged_in_username=logged_in_username
        self.user_group=user_group

        self.setWindowTitle("BRM Tool – Part 4 (Full Integration)")
        self.resize(1300,850)

        menubar=self.menuBar()
        # we can define file or help menus as needed
        fileMenu=menubar.addMenu("File")
        helpMenu=menubar.addMenu("Help")
        # (optionally add actions here)

        cw=QWidget()
        layout=QVBoxLayout(cw)

        # If user_group=Admin, we can place a user-switch combo, etc. 
        # (for brevity or advanced usage, you may add that if you like)

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # 1) Approvals
        self.approv_tab=MultiStepApprovalTabPart4(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # 2) Global/Critical
        self.gcr_tab=GlobalCriticalAdminTabPart4(self.connection, self.user_group)
        self.tabs.addTab(self.gcr_tab, "Global/Critical Admin")

        # 3) Hierarchy
        self.hierarchy_tab=HierarchyViewTabPart4(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy")

        # 4) Lineage
        self.lineage_tab=EnhancedLineageGraphWidgetPart4(self.connection)
        lin_widget=QWidget()
        lin_layout=QVBoxLayout(lin_widget)
        lb=QLabel("Lineage Visualization (Part 4)")
        lb.setStyleSheet("font-weight:bold;")
        lin_layout.addWidget(lb)
        lin_layout.addWidget(self.lineage_tab)

        line_h=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table..")
        sbtn=QPushButton("Search")
        sbtn.clicked.connect(lambda: self.search_lineage(self.lineage_search.text()))
        rb=QPushButton("Reset View")
        rb.clicked.connect(self.lineage_tab.resetView)
        refb=QPushButton("Refresh Graph")
        refb.clicked.connect(self.lineage_tab.populate_graph)

        line_h.addWidget(self.lineage_search)
        line_h.addWidget(sbtn)
        line_h.addWidget(rb)
        line_h.addWidget(refb)
        line_h.addStretch()

        lin_layout.addLayout(line_h)
        self.tabs.addTab(lin_widget, "Lineage")

        # 5) Custom groups
        self.custom_tab=CustomRuleGroupEnhancedTabPart4(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # 6) Scheduling
        from PyQt5.QtWidgets import QTableWidget  # just ensuring no conflict
        schedule_tab=QWidget()
        # ... or a class-based approach. 
        # For brevity, we might assume a scheduling sub-tab or direct usage from part 3 style.
        # We'll just note it here. You can adapt from Part 3 if needed.

        # 7) Control Tables
        self.ctrl_tab=CtrlTablesTabPart4(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # 8) Metrics
        self.metrics_tab=MetricsDashboardTabPart4(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # 9) Alerts & dashboards
        self.alert_tab=AlertsAndDashboardsTabPart4(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Dashboards")

        # 10) Group mgmt
        self.group_mgmt_tab=GroupManagementTabPart4(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.group_mgmt_tab,"Group Management")

        # 11) User mgmt
        self.user_mgmt_tab=UserManagementTabPart4(self.connection,self.user_group)
        self.tabs.addTab(self.user_mgmt_tab,"User Management")

        # Tools menu => Audit Log, Search Rules, Version History
        toolsMenu=menubar.addMenu("Tools")
        auditAct=QtWidgets.QAction("View Audit Logs",self)
        auditAct.triggered.connect(self.launch_audit_log)
        toolsMenu.addAction(auditAct)

        srAct=QtWidgets.QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_search)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (Enter Rule ID)",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # Timers to auto-refresh approvals, schedules, etc. if needed:
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        # ready
        self.show()

    def search_lineage(self, query):
        """
        Pass user query to lineage_tab for highlighting
        """
        self.lineage_tab.search_nodes(query)

    def launch_audit_log(self):
        dlg=AuditLogViewerPart4(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_search(self):
        dlg=SearchRuleDialogPart4(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialogPart4(self.connection,rid,self)
        dlg.exec_()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()
#!/usr/bin/env python
"""
BRM TOOL – PART 5
Advanced explicit lock management for rules, indicating who is editing.

This part is fully self-contained; it does not import from other parts.
It adds:
  1) A RULE_LOCKS table concept (assumed CREATE TABLE: see notes below).
  2) Lock/unlock logic via lock_rule_part5, unlock_rule_part5, is_rule_locked_part5, etc.
  3) A LockManagementTabPart5 UI tab to display + manage locks.
"""

import sys
import json
import math
import logging
import pyodbc
from datetime import datetime
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QMessageBox, QAbstractItemView, QLineEdit, QInputDialog,
    QComboBox, QDialog
)

logging.basicConfig(
    filename='brm_tool_part5.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# DB/AUDIT HELPERS
###############################################################################
def get_cursor_rows_part5(cursor):
    """
    Fetch all rows from a cursor safely; returns a list of dicts if column info present.
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return [dict(zip(cols, r)) for r in rows]
    return rows

def get_cursor_one_part5(cursor):
    """
    Fetch a single row from the cursor; returns a dict if column info present.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [desc[0] for desc in cursor.description]
        return dict(zip(cols, row))
    return None

def add_audit_log_part5(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert a record into BRM_AUDIT_LOG capturing old/new JSON data.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """, (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# LOCKING LOGIC
###############################################################################
def is_rule_locked_part5(conn, rule_id):
    """
    Return (True, locked_by_username) if the rule is locked, else (False, None).
    """
    c = conn.cursor()
    c.execute("""
    SELECT LOCKED_BY
    FROM RULE_LOCKS
    WHERE RULE_ID=? AND LOCK_ACTIVE=1
    """,(rule_id,))
    row = c.fetchone()
    if row:
        return (True, row[0])
    return (False, None)

def lock_rule_part5(conn, rule_id, username):
    """
    Attempt to lock 'rule_id' for editing by 'username'.
    If it's already locked, raise an error. Otherwise insert or update RULE_LOCKS.
    """
    locked, locked_by = is_rule_locked_part5(conn, rule_id)
    if locked:
        if locked_by == username:
            # already locked by same user => OK or we can treat as "already locked"
            return
        else:
            raise ValueError(f"Rule {rule_id} is already locked by {locked_by}.")

    c=conn.cursor()
    # upsert approach
    c.execute("""
    MERGE RULE_LOCKS AS T
    USING (SELECT ? AS rule_id, ? AS usern) AS S
      ON (T.RULE_ID = S.rule_id)
    WHEN MATCHED THEN
      UPDATE SET LOCK_ACTIVE=1, LOCKED_BY=S.usern, LOCK_TIMESTAMP=GETDATE()
    WHEN NOT MATCHED THEN
      INSERT (RULE_ID,LOCKED_BY,LOCK_TIMESTAMP,LOCK_ACTIVE)
      VALUES(S.rule_id, S.usern, GETDATE(), 1)
    ;
    """,(rule_id, username))
    conn.commit()

    add_audit_log_part5(conn, "LOCK", "RULE_LOCKS", rule_id, username, None, {"locked": True})

def unlock_rule_part5(conn, rule_id, username):
    """
    Unlock the rule if locked by 'username' or if 'username' is Admin. 
    If locked by a different user and not admin => error.
    """
    locked, locked_by = is_rule_locked_part5(conn, rule_id)
    if not locked:
        return  # already unlocked => no-op

    if locked_by != username:
        # Check if user is Admin
        c=conn.cursor()
        c.execute("SELECT USER_GROUP FROM USERS WHERE USERNAME=?",(username,))
        row=c.fetchone()
        if row and row[0]=="Admin":
            pass
        else:
            raise ValueError(f"Rule {rule_id} locked by {locked_by}, cannot unlock unless Admin.")

    c=conn.cursor()
    c.execute("""
    UPDATE RULE_LOCKS
    SET LOCK_ACTIVE=0
    WHERE RULE_ID=? AND LOCK_ACTIVE=1
    """,(rule_id,))
    conn.commit()

    add_audit_log_part5(conn, "UNLOCK", "RULE_LOCKS", rule_id, username, {"locked_by":locked_by}, {"locked":False})

###############################################################################
# LOCK MANAGEMENT TAB
###############################################################################
class LockManagementTabPart5(QWidget):
    """
    A tab that shows all locks from RULE_LOCKS. Allows Admin or the same user to unlock.
    Also can attempt a 'Lock' operation from the UI if needed.
    """
    def __init__(self, connection, current_username, current_user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.current_username=current_username
        self.current_user_group=current_user_group

        layout=QVBoxLayout(self)
        self.lock_table=QTableWidget(0,5)
        self.lock_table.setHorizontalHeaderLabels(["Lock ID","Rule ID","Locked By","Lock Timestamp","Active?"])
        self.lock_table.horizontalHeader().setStretchLastSection(True)
        self.lock_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.lock_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.lock_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Locks")
        ref_btn.clicked.connect(self.load_locks)
        bh.addWidget(ref_btn)

        lock_btn=QPushButton("Lock Rule ID...")
        lock_btn.clicked.connect(self.lock_rule_dialog)
        bh.addWidget(lock_btn)

        unlock_btn=QPushButton("Unlock Selected")
        unlock_btn.clicked.connect(self.unlock_selected)
        bh.addWidget(unlock_btn)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_locks()

    def load_locks(self):
        self.lock_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT LOCK_ID,RULE_ID,LOCKED_BY,LOCK_TIMESTAMP,LOCK_ACTIVE
        FROM RULE_LOCKS
        ORDER BY LOCK_ID DESC
        """)
        rows=c.fetchall()

        for row in rows:
            r_i=self.lock_table.rowCount()
            self.lock_table.insertRow(r_i)
            self.lock_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.lock_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))
            self.lock_table.setItem(r_i,2,QTableWidgetItem(row[2] if row[2] else ""))
            self.lock_table.setItem(r_i,3,QTableWidgetItem(str(row[3])))
            self.lock_table.setItem(r_i,4,QTableWidgetItem("1" if row[4] else "0"))

        self.lock_table.resizeColumnsToContents()

    def lock_rule_dialog(self):
        """
        Prompt user for rule_id to lock.
        """
        rule_id,ok=QInputDialog.getInt(self,"Lock a Rule","Enter Rule ID to lock:")
        if not ok:
            return
        try:
            lock_rule_part5(self.connection, rule_id, self.current_username)
            QMessageBox.information(self,"Locked",f"Rule {rule_id} locked by {self.current_username}.")
            self.load_locks()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def unlock_selected(self):
        row=self.lock_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No lock selected.")
            return
        lock_id_item=self.lock_table.item(row,0)
        rule_id_item=self.lock_table.item(row,1)
        if not lock_id_item or not rule_id_item:
            return
        rule_id=int(rule_id_item.text())

        confirm=QMessageBox.question(self,"Confirm",f"Unlock rule {rule_id}?")
        if confirm!=QMessageBox.Yes:
            return

        try:
            unlock_rule_part5(self.connection, rule_id, self.current_username)
            QMessageBox.information(self,"Unlocked",f"Rule {rule_id} unlocked.")
            self.load_locks()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# EXAMPLE MAIN WINDOW – PART 5
###############################################################################
class BRMToolPart5Main(QMainWindow):
    """
    Demonstrates how one might integrate the LockManagementTabPart5 into a larger application.
    Standalone for Part 5 demonstration.
    """
    def __init__(self, connection, current_username, current_user_group):
        super().__init__()
        self.connection=connection
        self.current_username=current_username
        self.current_user_group=current_user_group

        self.setWindowTitle("BRM Tool – Part 5 (Lock Management)")
        self.resize(1000,600)

        cw=QWidget()
        layout=QVBoxLayout(cw)
        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        self.lock_tab=LockManagementTabPart5(self.connection,self.current_username,self.current_user_group)
        self.tabs.addTab(self.lock_tab,"Lock Management")

        cw.setLayout(layout)
        self.setCentralWidget(cw)
        self.show()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()