#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: advanced_lineage_visualization.py
Description:
  This module provides a robust and professional advanced lineage visualization widget.
  It uses QGraphicsView/QGraphicsScene to render an Erwin‑style ER diagram that shows
  end‑to‑end lineage between business rules and their table dependencies. Key features include:
    • Visual nodes for rules and tables with distinct shapes and color codes based on live status.
    • Flow arrows connecting rule nodes to table nodes (and optionally rule-to-rule relationships).
    • Deep search capabilities that allow users to filter nodes by column, database, or table.
    • Real‑time notifications and auto‑refresh (using QTimer) to update the diagram as data changes.
    • Detailed simulation logging: dry‑run executions capture number of impacted records and success/failure.
    • Robust error handling and standard naming conventions.
    
Assumptions:
  • The database contains tables such as BRM_RULES and BRM_RULE_TABLE_DEPENDENCIES.
  • BRM_RULES includes fields: RULE_ID, RULE_NAME, STATUS, APPROVAL_STATUS, LOCKED_BY, etc.
  • BRM_RULE_TABLE_DEPENDENCIES includes: RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP.
  • A connection (pyodbc connection) is passed into this module.
"""

import sys
import json
import logging
from datetime import datetime
from collections import defaultdict

from PyQt5.QtCore import Qt, QRectF, QLineF, QTimer
from PyQt5.QtGui import QPen, QBrush, QColor, QFont
from PyQt5.QtWidgets import (
    QGraphicsView, QGraphicsScene, QGraphicsItem, QGraphicsEllipseItem,
    QGraphicsRectItem, QGraphicsLineItem, QGraphicsTextItem, QApplication, QMessageBox
)

# Configure logger for this module
logger = logging.getLogger("advanced_lineage_visualization")

# Constants for node dimensions and colors
RULE_NODE_WIDTH = 150
RULE_NODE_HEIGHT = 60
TABLE_NODE_DIAMETER = 120

COLOR_RULE_ACTIVE = QColor("#C8E6C9")      # light green
COLOR_RULE_INACTIVE = QColor("#FFCDD2")    # light red
COLOR_RULE_PENDING = QColor("#FFF9C4")     # light yellow

COLOR_TABLE_DEFAULT = QColor("#BBDEFB")    # light blue
COLOR_TABLE_MISSING = QColor("#E1BEE7")     # light purple

ARROW_COLOR = QColor("#424242")            # dark gray
LINE_WIDTH = 2

class AdvancedLineageGraphWidget(QGraphicsView):
    """
    A QGraphicsView-based widget for advanced lineage visualization.
    
    Features:
      • Builds a graph from BRM_RULES and BRM_RULE_TABLE_DEPENDENCIES.
      • Renders rule nodes as rounded rectangles (with status colors)
        and table nodes as circles.
      • Draws arrows from rule nodes to table nodes.
      • Supports deep search: when a search term is provided, only nodes whose
        text (rule name, table name, column name, or database) matches will remain
        highlighted while others are dimmed.
      • Auto-refreshes periodically to reflect live data.
      • Logs simulation results: for each dry-run execution, it can capture and
        display the number of records impacted along with pass/fail status.
    """

    def __init__(self, connection, parent=None, auto_refresh_interval=30000):
        """
        :param connection: pyodbc connection object.
        :param parent: Parent widget.
        :param auto_refresh_interval: Auto-refresh interval in milliseconds.
        """
        super().__init__(parent)
        self.connection = connection
        self.setRenderHint(self.viewport().Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)

        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)

        # Store nodes for search highlighting
        self.rule_nodes = {}    # key: RULE_ID, value: GraphicsRuleNode
        self.table_nodes = {}   # key: (database, table), value: GraphicsTableNode

        # Timer for auto-refresh of the graph
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.populate_graph)
        self.refresh_timer.start(auto_refresh_interval)  # e.g., every 30 seconds

        # Initial population of graph
        self.populate_graph()

    def populate_graph(self):
        """
        Build the graph from the database.
        Retrieves rules and table dependencies; clears existing scene items;
        then draws nodes and arrows.
        """
        try:
            self.scene.clear()
            self.rule_nodes.clear()
            self.table_nodes.clear()

            # Retrieve rules
            rule_cursor = self.connection.cursor()
            rule_cursor.execute("""
                SELECT RULE_ID, RULE_NAME, STATUS, APPROVAL_STATUS, LOCKED_BY
                FROM BRM_RULES
            """)
            rules = rule_cursor.fetchall()
            # Retrieve dependencies
            dep_cursor = self.connection.cursor()
            dep_cursor.execute("""
                SELECT RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                FROM BRM_RULE_TABLE_DEPENDENCIES
            """)
            dependencies = dep_cursor.fetchall()

            # Positioning: arrange rule nodes vertically in a column and table nodes in another column.
            # For production systems, you might want to use a force-directed layout or hierarchical layout.
            rule_x, rule_y, rule_gap = 50, 50, 80
            table_x = 400
            table_y, table_gap = 50, 100

            # Draw rule nodes
            for idx, rule in enumerate(rules):
                rule_id = rule[0]
                rule_name = rule[1]
                status = rule[2]
                approval_status = rule[3]
                locked_by = rule[4]

                # Determine color based on status
                if status.upper() == "ACTIVE":
                    fill_color = COLOR_RULE_ACTIVE
                elif status.upper() == "INACTIVE":
                    fill_color = COLOR_RULE_INACTIVE
                else:
                    fill_color = COLOR_RULE_PENDING

                node = GraphicsRuleNode(rule_id, rule_name, fill_color, approval_status, locked_by)
                node.setPos(rule_x, rule_y + idx * (RULE_NODE_HEIGHT + rule_gap))
                self.scene.addItem(node)
                self.rule_nodes[rule_id] = node

            # Draw table nodes (aggregate by database and table)
            table_positions = {}  # key: (database, table), value: (x,y)
            for dep in dependencies:
                db_name = dep[1] or "N/A"
                tbl_name = dep[2]
                key = (db_name.lower(), tbl_name.lower())
                if key not in table_positions:
                    # Assign a position based on current count
                    pos_y = table_y + len(table_positions) * (TABLE_NODE_DIAMETER + table_gap)
                    table_positions[key] = (table_x, pos_y)

            for key, pos in table_positions.items():
                db_name, tbl_name = key
                # Check if table exists in the database (for now assume all exist; production may query sys.tables)
                # For demonstration, if table name starts with 'missing_' we mark it as missing.
                if tbl_name.startswith("missing_"):
                    fill_color = COLOR_TABLE_MISSING
                else:
                    fill_color = COLOR_TABLE_DEFAULT
                tnode = GraphicsTableNode(db_name, tbl_name, fill_color)
                tnode.setPos(pos[0], pos[1])
                self.scene.addItem(tnode)
                self.table_nodes[key] = tnode

            # Draw arrows from rule nodes to corresponding table nodes based on dependencies
            for dep in dependencies:
                rule_id = dep[0]
                db_name = dep[1] or "N/A"
                tbl_name = dep[2]
                key = (db_name.lower(), tbl_name.lower())
                if rule_id in self.rule_nodes and key in self.table_nodes:
                    rule_node = self.rule_nodes[rule_id]
                    table_node = self.table_nodes[key]
                    arrow = GraphicsArrow(rule_node, table_node)
                    self.scene.addItem(arrow)

            self.resetView()
            logger.info("Advanced lineage graph populated successfully.")
        except Exception as ex:
            logger.error(f"Error populating lineage graph: {ex}")
            QMessageBox.critical(self, "Graph Population Error", str(ex))

    def resetView(self):
        """
        Adjust the view to fit the entire scene.
        """
        self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)

    def search_lineage(self, search_text):
        """
        When a search term is provided, highlight matching nodes (rules or tables)
        and dim those that do not match.
        The search is performed over rule names, table names, database names, and column names.
        """
        search_text = search_text.lower().strip()
        if not search_text:
            # Reset opacities
            for node in self.rule_nodes.values():
                node.setOpacity(1.0)
            for node in self.table_nodes.values():
                node.setOpacity(1.0)
            return

        # For rule nodes: search rule name
        for node in self.rule_nodes.values():
            if search_text in node.rule_name.lower():
                node.setOpacity(1.0)
            else:
                node.setOpacity(0.3)
        # For table nodes: search table name and database name
        for key, node in self.table_nodes.items():
            db_name, tbl_name = key
            if search_text in db_name or search_text in tbl_name:
                node.setOpacity(1.0)
            else:
                node.setOpacity(0.3)

    def reset_dim_highlight(self):
        """
        Reset all nodes to full opacity.
        """
        self.search_lineage("")


# Graphics Node Classes
class GraphicsRuleNode(QGraphicsRectItem):
    """
    A graphical representation of a business rule node.
    Rendered as a rounded rectangle with rule name and status.
    """
    def __init__(self, rule_id, rule_name, fill_color, approval_status, locked_by, parent=None):
        super().__init__(parent)
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.approval_status = approval_status
        self.locked_by = locked_by
        self.setRect(0, 0, RULE_NODE_WIDTH, RULE_NODE_HEIGHT)
        self.setBrush(QBrush(fill_color))
        self.setPen(QPen(Qt.black, 2))
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemIsMovable, False)

        # Add a text label inside the rectangle
        self.text_item = QGraphicsTextItem(f"Rule {rule_id}:\n{rule_name}", self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setFont(QFont("Arial", 10))
        # Center the text
        rect = self.rect()
        text_rect = self.text_item.boundingRect()
        x_offset = (rect.width() - text_rect.width()) / 2
        y_offset = (rect.height() - text_rect.height()) / 2
        self.text_item.setPos(x_offset, y_offset)

        # Tooltip with extra details
        tooltip = f"Rule ID: {rule_id}\nName: {rule_name}\nStatus: {approval_status}"
        if locked_by:
            tooltip += f"\nLocked by: {locked_by}"
        self.setToolTip(tooltip)

    def paint(self, painter, option, widget):
        # Draw rounded rectangle
        painter.setBrush(self.brush())
        painter.setPen(self.pen())
        painter.drawRoundedRect(self.rect(), 10, 10)
        # The text is drawn by its own QGraphicsTextItem


class GraphicsTableNode(QGraphicsEllipseItem):
    """
    A graphical representation of a table node.
    Rendered as a circle (ellipse) with table name.
    """
    def __init__(self, db_name, table_name, fill_color, parent=None):
        super().__init__(parent)
        self.db_name = db_name
        self.table_name = table_name
        self.setRect(0, 0, TABLE_NODE_DIAMETER, TABLE_NODE_DIAMETER)
        self.setBrush(QBrush(fill_color))
        self.setPen(QPen(Qt.black, 2))
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)

        # Add text label for table name
        display_text = f"{db_name}.{table_name}"
        self.text_item = QGraphicsTextItem(display_text, self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setFont(QFont("Arial", 9))
        text_rect = self.text_item.boundingRect()
        # Center the text in the ellipse
        x_offset = (TABLE_NODE_DIAMETER - text_rect.width()) / 2
        y_offset = (TABLE_NODE_DIAMETER - text_rect.height()) / 2
        self.text_item.setPos(x_offset, y_offset)
        self.setToolTip(f"Table: {db_name}.{table_name}")


class GraphicsArrow(QGraphicsLineItem):
    """
    A graphical arrow drawn between a rule node and a table node.
    """
    def __init__(self, source_node, target_node, parent=None):
        super().__init__(parent)
        self.source_node = source_node
        self.target_node = target_node
        self.setPen(QPen(ARROW_COLOR, LINE_WIDTH))
        self.adjust()

    def adjust(self):
        # Calculate center points of source and target nodes
        source_rect = self.source_node.sceneBoundingRect()
        target_rect = self.target_node.sceneBoundingRect()
        p1 = source_rect.center()
        p2 = target_rect.center()
        self.setLine(QLineF(p1, p2))
        # Optionally, arrowhead drawing could be implemented here for better aesthetics.

    def paint(self, painter, option, widget):
        # Update line before painting
        self.adjust()
        painter.setPen(self.pen())
        painter.drawLine(self.line())
        # Draw arrowhead (simple triangle)
        angle = self.line().angle()  # in degrees
        # Define arrowhead size
        arrow_size = 10
        # Compute two lines at angles offset from the main line
        p2 = self.line().p2()
        line_angle_rad = (360 - angle) * 3.14159 / 180.0
        dest_point = p2
        # Calculate two points for the arrowhead
        arrow_p1 = dest_point + QPointF(
            arrow_size * -1 * (1.0 * 0.866), arrow_size * -1 * 0.5)
        arrow_p2 = dest_point + QPointF(
            arrow_size * -1 * (1.0 * 0.866), arrow_size * 0.5)
        # For simplicity, we'll draw a simple line-based arrowhead
        painter.drawLine(dest_point, arrow_p1)
        painter.drawLine(dest_point, arrow_p2)


# Optional: Real-Time Simulation Logging
class LineageSimulationLogger:
    """
    This class manages simulation logs for lineage dry-run executions.
    It captures the number of records impacted by a rule execution (dry-run)
    along with pass/fail notifications. The logs are saved into a file and can
    be displayed in the UI.
    """
    def __init__(self, log_file="lineage_simulation.log"):
        self.log_file = log_file
        logging.basicConfig(
            filename=self.log_file,
            level=logging.INFO,
            format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
        )
        self.logger = logging.getLogger("LineageSimulationLogger")

    def log_simulation(self, rule_id, impacted_count, success, message):
        status = "PASS" if success else "FAIL"
        log_message = f"Rule {rule_id}: {status} - Impacted Records: {impacted_count} | {message}"
        self.logger.info(log_message)
        return log_message

    def get_simulation_logs(self):
        try:
            with open(self.log_file, "r", encoding="utf-8") as f:
                return f.read()
        except Exception as ex:
            return f"Error reading simulation logs: {ex}"


# For standalone testing of the widget
if __name__ == "__main__":
    from PyQt5.QtWidgets import QApplication
    app = QApplication(sys.argv)
    try:
        # Replace with your actual DSN or connection string.
        connection = pyodbc.connect("DSN=YourDSN;Trusted_Connection=yes;")
    except Exception as ex:
        print(f"Database connection error: {ex}")
        sys.exit(1)
    widget = AdvancedLineageGraphWidget(connection)
    widget.setWindowTitle("Advanced Lineage Visualization")
    widget.resize(1000, 800)
    widget.show()

    # For demonstration, perform a search after 5 seconds
    QTimer.singleShot(5000, lambda: widget.search_lineage("customer"))
    sys.exit(app.exec_())