#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: advanced_decision_tables.py
Description:
  Provides an advanced module for managing decision tables, separate from 
  the basic one in advanced_lineage. This version includes:
    • A DecisionTableEngine that logs each execution in a DECISION_TABLE_LOGS table (if present).
    • AdvancedDecisionTablesTab, a QWidget with:
        - QTableWidget for listing decision tables
        - add/edit/delete
        - an “Execute” button that runs the decision query in a dry-run transaction
          and logs results (impacted records, pass/fail, etc.)
    • Extended searching, plus an optional “Export to CSV” feature for the list.

Assumptions:
  - DECISION_TABLES table with columns:
      DECISION_TABLE_ID int PK,
      TABLE_NAME varchar(...),
      DESCRIPTION varchar(...),
      DECISION_QUERY text,
      ...
  - DECISION_TABLE_LOGS (optional):
      LOG_ID int PK IDENTITY,
      DECISION_TABLE_ID int,
      EXEC_TIMESTAMP datetime,
      SUCCESS_FLAG bit,
      RECORD_COUNT int,
      MESSAGE varchar(...)
"""

import sys
import logging
import pyodbc
from datetime import datetime
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QMessageBox, QLineEdit, QInputDialog, QPlainTextEdit,
    QFileDialog, QLabel
)

from core_foundation import logger, insert_audit_log

# Optional logs function if DECISION_TABLE_LOGS table exists
def log_decision_table_execution(conn, dt_id, success_flag, message, record_count):
    """
    Insert a row into DECISION_TABLE_LOGS if it exists.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO DECISION_TABLE_LOGS(
                DECISION_TABLE_ID, EXEC_TIMESTAMP, SUCCESS_FLAG, MESSAGE, RECORD_COUNT
            )
            VALUES(?, GETDATE(), ?, ?, ?)
        """,(dt_id, 1 if success_flag else 0, message, record_count))
        conn.commit()
        logger.debug(f"DT {dt_id} execution logged, success={success_flag}, records={record_count}")
    except Exception as ex:
        logger.error(f"Error logging DT execution for {dt_id}: {ex}")

class DecisionTableEngine:
    """
    Encapsulates decision table execution, possibly with extended logging into DECISION_TABLE_LOGS.
    """
    @staticmethod
    def run_decision_table_query(conn, dt_id, query):
        c = conn.cursor()
        c.execute("BEGIN TRANSACTION")
        success = False
        msg = ""
        impacted = 0
        try:
            c.execute(query)
            try:
                rows = c.fetchall()
            except:
                rows = []
            impacted = len(rows)
            # For demonstration, we consider success if it doesn't error
            success = True
            msg = f"Impacted {impacted} rows."
            c.execute("ROLLBACK")  # always dry-run
        except Exception as ex:
            c.execute("ROLLBACK")
            success = False
            msg = f"Error: {ex}"
            logger.error(f"DT {dt_id} run error: {ex}")
        # log if table exists
        log_decision_table_execution(conn, dt_id, success, msg, impacted)
        insert_audit_log(conn, "RUN_DECISION_TABLE","DECISION_TABLES", dt_id,
                         "DecisionTableEngine", None, {"impacted":impacted,"msg":msg})
        return success, msg, impacted

# -----------------------------------------------------------------------------
# 1. AdvancedDecisionTablesTab – main UI
# -----------------------------------------------------------------------------
class AdvancedDecisionTablesTab(QWidget):
    """
    A more advanced approach to managing decision tables than the one in advanced_lineage.
    Includes:
      - Searching
      - Export to CSV
      - Execution logs in DECISION_TABLE_LOGS if available
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Advanced Decision Tables (Full)")
        layout = QVBoxLayout(self)

        # Searching
        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by table name or description...")
        self.search_edit.textChanged.connect(self.load_tables)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)

        # Main table
        self.dt_table = QTableWidget(0,4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","Table Name","Description","Decision Query"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        btn_layout.addWidget(add_btn)

        update_btn = QPushButton("Update DT")
        update_btn.clicked.connect(self.update_dt)
        btn_layout.addWidget(update_btn)

        delete_btn = QPushButton("Delete DT")
        delete_btn.clicked.connect(self.delete_dt)
        btn_layout.addWidget(delete_btn)

        exec_btn = QPushButton("Execute DT")
        exec_btn.clicked.connect(self.execute_dt)
        btn_layout.addWidget(exec_btn)

        export_btn = QPushButton("Export CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addWidget(export_btn)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tables)
        btn_layout.addWidget(refresh_btn)

        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.exec_log = QPlainTextEdit()
        self.exec_log.setReadOnly(True)
        self.exec_log.setPlaceholderText("Decision Table Execution Log...")
        layout.addWidget(self.exec_log)

        self.setLayout(layout)
        self.load_tables()

    def load_tables(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            search_txt = self.search_edit.text().strip()
            if search_txt:
                c.execute("""
                    SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY
                    FROM DECISION_TABLES
                    WHERE TABLE_NAME LIKE ? OR DESCRIPTION LIKE ? OR DECISION_QUERY LIKE ?
                    ORDER BY DECISION_TABLE_ID
                """,(f"%{search_txt}%",f"%{search_txt}%",f"%{search_txt}%"))
            else:
                c.execute("""
                    SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION, DECISION_QUERY
                    FROM DECISION_TABLES
                    ORDER BY DECISION_TABLE_ID
                """)
            rows = c.fetchall()
            for row in rows:
                ridx = self.dt_table.rowCount()
                self.dt_table.insertRow(ridx)
                for col_i, val in enumerate(row):
                    self.dt_table.setItem(ridx, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading DTs: {ex}")

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add DT", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Description", "Optional desc:")
        if not ok2:
            desc = ""
        query, ok3 = QInputDialog.getMultiLineText(self, "Decision Query", "Enter SQL:")
        if not ok3 or not query.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION,DECISION_QUERY) VALUES(?,?,?)",
                      (name.strip(), desc.strip(), query.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "New DT created.")
            insert_audit_log(self.connection, "ADD_DECISION_TABLE","DECISION_TABLES", None,
                             "User", None, {"table_name":name})
            self.load_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def update_dt(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "No selection", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        cur_name = self.dt_table.item(row,1).text()
        cur_desc = self.dt_table.item(row,2).text()
        cur_query = self.dt_table.item(row,3).text()

        name, ok = QInputDialog.getText(self, "Edit Table Name", "New name:", text=cur_name)
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getMultiLineText(self, "Edit Description", "New desc:", text=cur_desc)
        if not ok2:
            desc = cur_desc
        query, ok3 = QInputDialog.getMultiLineText(self, "Edit Query", "New SQL:", text=cur_query)
        if not ok3 or not query.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE DECISION_TABLES
                SET TABLE_NAME=?, DESCRIPTION=?, DECISION_QUERY=?
                WHERE DECISION_TABLE_ID=?
            """,(name.strip(), desc.strip(), query.strip(), dt_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"DT {dt_id} updated.")
            insert_audit_log(self.connection, "EDIT_DECISION_TABLE","DECISION_TABLES", dt_id,
                             "User", None, {"table_name":name})
            self.load_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Update Error", str(ex))

    def delete_dt(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "No selection", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete DT {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"DT {dt_id} deleted.")
            insert_audit_log(self.connection, "DELETE_DECISION_TABLE","DECISION_TABLES", dt_id,
                             "User", None, {"deleted":True})
            self.load_tables()
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))

    def execute_dt(self):
        row = self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self, "No selection", "No DT selected.")
            return
        dt_id = int(self.dt_table.item(row,0).text())
        query = self.dt_table.item(row,3).text()
        if not query:
            QMessageBox.warning(self, "No Query", "No query in DT.")
            return
        (ok, msg, impacted) = DecisionTableEngine.run_decision_table_query(self.connection, dt_id, query)
        result_str = f"DT {dt_id} => success={ok}, impacted={impacted}, msg={msg}"
        self.exec_log.appendPlainText(result_str)
        QMessageBox.information(self, "Executed", result_str)

    def export_csv(self):
        """
        Exports the current DT table to a CSV file.
        """
        path, _ = QFileDialog.getSaveFileName(self, "Export CSV", "decision_tables.csv", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                header = ["DT_ID","TABLE_NAME","DESCRIPTION","DECISION_QUERY"]
                f.write(",".join(header)+"\n")
                for row_i in range(self.dt_table.rowCount()):
                    row_vals = []
                    for col_i in range(self.dt_table.columnCount()):
                        val = self.dt_table.item(row_i, col_i).text()
                        row_vals.append(val.replace(",", ";"))  # or use csv writer for safety
                    f.write(",".join(row_vals)+"\n")
            QMessageBox.information(self, "Exported", f"Exported to {path}")
        except Exception as ex:
            QMessageBox.critical(self, "Export Error", str(ex))