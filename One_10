#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Module: brm_tool_main.py
Description: Main integration module for the BRM Tool production suite.
This module integrates all advanced features from our 10‑module design:
  1. brm_tool_connection      – DB connection and login dialogs
  2. brm_tool_helpers         – Common helpers (logging, audit, validations, etc.)
  3. brm_tool_dashboard       – Business Rules Dashboard and Rule Editor
  4. brm_tool_approvals       – Multi‑step approvals and Global‑Critical Admin
  5. brm_tool_hierarchy       – Hierarchy view and advanced ER‑style Lineage visualization
  6. brm_tool_scheduling      – Scheduling and Schedule Management (with dry‑run logging)
  7. brm_tool_control         – Control tables, Metrics Dashboard, Group & User Management
  8. brm_tool_simulations     – Chain, Group, and Single‑rule simulations (with record counts)
  9. brm_tool_audit           – Audit Log Viewer, Rule Search, and Version History with diff
 10. brm_tool_custom          – Custom Rule Groups and Alerts/Dashboards
All features are integrated, with real‑time auto‑refresh and simulation logging.
"""

import sys
import json
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QAction, QInputDialog, QMessageBox, QComboBox, QDialog
)
from PyQt5.QtCore import QTimer

# Import our advanced modules (assumed to be in the same package)
from brm_tool_connection import DatabaseConnectionDialog, LoginDialog
from brm_tool_helpers import sync_metadata_improved, run_data_validations, execute_rule, insert_audit_log
from brm_tool_dashboard import RuleDashboard, RuleEditorDialog
from brm_tool_approvals import MultiStepApprovalTab, GlobalCriticalAdminTab
from brm_tool_hierarchy import HierarchyViewTab, EnhancedLineageGraphWidget
from brm_tool_scheduling import ScheduleManagementTab
from brm_tool_control import CtrlTablesTab, MetricsDashboardTab, GroupManagementTab, UserManagementTab
from brm_tool_simulations import ChainSimulationDialog, GroupSimulationDialog, SingleRuleSimulationDialog
from brm_tool_audit import AuditLogViewer, RuleSearchDialog, VersionHistoryDialog
from brm_tool_custom import CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab

# Configure logging for the main module
logging.basicConfig(
    filename='brm_tool_production.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger("brm_tool_main")

class BRMToolMain(QMainWindow):
    """
    Main application window that integrates all modules.
    It provides:
      • A menubar with file, tools, and help actions.
      • A tab‑based central widget for business rules dashboard, approvals, hierarchy/lineage,
        scheduling, control/metrics, custom groups/alerts, group management, and user management.
      • Auto‑refresh timers for approvals and scheduling.
      • Simulation logging that records dry‑run impacts (record counts, success/failure).
    """
    def __init__(self, connection, user_id, username, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.username = username
        self.user_group = user_group
        self.setWindowTitle("BRM Tool – Integrated Production Suite")
        self.resize(1400, 900)
        self.init_ui()

    def init_ui(self):
        # Set up the menubar with File, Tools, and Help menus.
        menubar = self.menuBar()
        fileMenu = menubar.addMenu("File")
        syncMetaAction = QAction("Sync Metadata", self)
        syncMetaAction.triggered.connect(self.sync_metadata)
        fileMenu.addAction(syncMetaAction)

        runValidationsAction = QAction("Run Data Validations", self)
        runValidationsAction.triggered.connect(self.run_validations)
        fileMenu.addAction(runValidationsAction)

        perfTrendAction = QAction("Performance Trends", self)
        perfTrendAction.triggered.connect(self.show_performance_trends)
        fileMenu.addAction(perfTrendAction)

        simChainAction = QAction("Simulate Rule Chain", self)
        simChainAction.triggered.connect(self.simulate_rule_chain)
        fileMenu.addAction(simChainAction)

        simGroupAction = QAction("Simulate Custom Group", self)
        simGroupAction.triggered.connect(self.simulate_custom_group)
        fileMenu.addAction(simGroupAction)

        helpMenu = menubar.addMenu("Help")
        tipsAction = QAction("Usage Tips", self)
        tipsAction.triggered.connect(self.show_usage_tips)
        helpMenu.addAction(tipsAction)

        toolsMenu = menubar.addMenu("Tools")
        auditAction = QAction("View Audit Logs", self)
        auditAction.triggered.connect(self.open_audit_logs)
        toolsMenu.addAction(auditAction)

        searchAction = QAction("Search Rules", self)
        searchAction.triggered.connect(self.open_rule_search)
        toolsMenu.addAction(searchAction)

        versionAction = QAction("Version History", self)
        versionAction.triggered.connect(self.open_version_history)
        toolsMenu.addAction(versionAction)

        # Central widget with a vertical layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # For Admin, add an impersonation option
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            self.impersonate_combo = QComboBox()
            self.impersonate_combo.currentIndexChanged.connect(self.switch_user)
            imp_layout.addWidget(QMessageBox(QMessageBox.Information, "Impersonate:", "Select a user to impersonate", None))
            imp_layout.addWidget(self.impersonate_combo)
            self.load_impersonation_options()
            main_layout.addLayout(imp_layout)

        # Create a tab widget for the major modules
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # Tab 1: Business Rules Dashboard (CRUD and Simulation Logging)
        self.dashboard_tab = RuleDashboard(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.dashboard_tab, "Business Rules")

        # Tab 2: Approvals – Multi‑step approvals
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.username, self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")

        # Tab 3: Global‑Critical Admin (Admin only)
        if self.user_group == "Admin":
            self.gcr_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_admin_tab, "Global/Critical Admin")

        # Tab 4: Hierarchy & Advanced Lineage Visualization (ER‑style with flow arrows)
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy")
        self.lineage_tab = QWidget()
        lineage_layout = QVBoxLayout(self.lineage_tab)
        self.lineage_view = EnhancedLineageGraphWidget(self.connection)
        lineage_layout.addWidget(self.lineage_view)
        # Add a search bar for lineage (by column, table, or database)
        lineage_search_layout = QHBoxLayout()
        self.lineage_search_edit = QLineEdit()
        self.lineage_search_edit.setPlaceholderText("Search lineage by column/table/DB...")
        lineage_search_layout.addWidget(self.lineage_search_edit)
        lineage_search_btn = QAction("Search", self)
        search_btn = QPushButton("Search")
        search_btn.clicked.connect(self.search_lineage)
        lineage_search_layout.addWidget(search_btn)
        reset_lineage_btn = QPushButton("Reset")
        reset_lineage_btn.clicked.connect(self.lineage_view.reset_view)
        lineage_search_layout.addWidget(reset_lineage_btn)
        lineage_search_layout.addStretch()
        lineage_layout.addLayout(lineage_search_layout)
        self.tabs.addTab(self.lineage_tab, "Lineage")

        # Tab 5: Custom Rule Groups & Alerts/Dashboards
        self.custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_groups_tab, "Custom Groups")

        # Tab 6: Scheduling – Schedule management with dry‑run simulation logging
        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Scheduling")

        # Tab 7: Control Tables & Metrics Dashboard (Performance and usage stats)
        self.control_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.control_tab, "Control Tables")
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics")

        # Tab 8: Alerts & Dashboards (including approval alerts, upcoming schedules, performance alerts)
        self.alerts_tab = AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.alerts_tab, "Alerts & Dashboards")

        # Tab 9: Group Management
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.group_mgmt_tab, "Group Management")

        # Tab 10: User Management (Admin only)
        if self.user_group == "Admin":
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")

        # Set up auto‑refresh timers for approvals and schedule checks
        self.setup_timers()

    def setup_timers(self):
        # Refresh approvals every 5 seconds
        self.approval_timer = QTimer(self)
        self.approval_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approval_timer.start(5000)
        # Check due schedules every minute
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules)
        self.schedule_timer.start(60000)

    def load_impersonation_options(self):
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for (uid, uname, ugroup) in c.fetchall():
                self.impersonate_combo.addItem(f"{uname} ({ugroup})", (uid, ugroup))
        except Exception as ex:
            logger.error(f"Error loading impersonation options: {ex}")

    def switch_user(self):
        data = self.impersonate_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = c.fetchone()
        self.username = row[0] if row else "UnknownUser"
        QMessageBox.information(self, "User Switched", f"Now impersonating: {self.username} / {self.user_group}")
        # Refresh all relevant modules
        self.approvals_tab.logged_in_username = self.username
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.dashboard_tab.user_id = self.user_id
        self.dashboard_tab.user_group = self.user_group
        self.dashboard_tab.load_rules()
        if hasattr(self, "gcr_admin_tab"):
            self.gcr_admin_tab.load_rule_list()
        if hasattr(self, "hierarchy_tab"):
            self.hierarchy_tab.load_hierarchy()
        if hasattr(self, "alerts_tab"):
            self.alerts_tab.check_alerts()
        if hasattr(self, "group_mgmt_tab"):
            self.group_mgmt_tab.load_data()
        if hasattr(self, "user_mgmt_tab"):
            self.user_mgmt_tab.load_users()

    def sync_metadata(self):
        try:
            msg = sync_metadata_improved(self.connection)
            QMessageBox.information(self, "Sync Metadata", msg)
        except Exception as ex:
            QMessageBox.critical(self, "Sync Error", str(ex))

    def run_validations(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Validations", "All data validations executed successfully.")
        except Exception as ex:
            QMessageBox.critical(self, "Validation Error", str(ex))

    def show_performance_trends(self):
        self.metrics_tab.load_metrics()
        QMessageBox.information(self, "Performance Trends", "Performance metrics refreshed. See Metrics tab.")

    def simulate_rule_chain(self):
        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()

    def simulate_custom_group(self):
        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()

    def open_audit_logs(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def open_rule_search(self):
        dlg = RuleSearchDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def open_version_history(self):
        rid, ok = QInputDialog.getInt(self, "Version History", "Enter Rule ID:")
        if ok:
            dlg = VersionHistoryDialog(self.connection, rid, self)
            dlg.exec_()

    def check_schedules(self):
        # Check scheduled rules and perform dry-run execution logging.
        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c = self.connection.cursor()
        c.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, RUN_DATA_VALIDATIONS
            FROM RULE_SCHEDULES
            WHERE STATUS = 'Scheduled' AND SCHEDULE_TIME <= ?
        """, (now_str,))
        due_schedules = c.fetchall()
        for (sch_id, rule_id, sched_time, run_valid_flag) in due_schedules:
            c2 = self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            success = False
            record_count = 0
            try:
                c2.execute("SELECT RULE_SQL, OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
                row = c2.fetchone()
                if row:
                    sql_text, op_type = row
                    if op_type.upper() == "DECISION_TABLE":
                        success = True
                    else:
                        c2.execute(sql_text)
                        rows = c2.fetchall()
                        record_count = len(rows) if rows else 0
                        success = (rows and rows[0][0] == 1) or (not rows)
                if run_valid_flag:
                    run_data_validations(self.connection)
                if success:
                    c2.execute("COMMIT")
                    c2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Executed' WHERE SCHEDULE_ID = ?", (sch_id,))
                else:
                    c2.execute("ROLLBACK")
                    c2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (sch_id,))
                self.connection.commit()
            except Exception as ex:
                c2.execute("ROLLBACK")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS = 'Failed' WHERE SCHEDULE_ID = ?", (sch_id,))
                self.connection.commit()
                success = False
            # Log simulation details: record count and status
            sim_log = f"Dry-run Schedule {sch_id}: Rule {rule_id} dry-run {'PASS' if success else 'FAIL'}, Records Impacted: {record_count}"
            logger.info(sim_log)
        self.schedule_tab.load_schedules()

    def search_lineage(self):
        search_text = self.lineage_search_edit.text().strip()
        if search_text:
            self.lineage_view.search_lineage(search_text)
        else:
            self.lineage_view.reset_view()

    def show_usage_tips(self):
        tips = (
            "BRM Tool – Production Suite Usage Tips:\n"
            "• Use the Business Rules tab to add, update, and simulate rules (dry‑runs log record counts).\n"
            "• Approvals are auto‑refreshed; only the minimal stage is available for action.\n"
            "• The Hierarchy tab supports drag‑and‑drop re‑parenting (subject to rule locks).\n"
            "• The Lineage tab displays an advanced ER‑style diagram with flow arrows and color‑coding; use the search bar to filter by column, table, or database.\n"
            "• Custom Groups allow advanced rule grouping, backup/restore, and integration with multi‑step approvals.\n"
            "• Scheduling supports dry‑run simulations that log the number of records impacted and the pass/fail status.\n"
            "• Control Tables and Metrics tabs display real‑time performance and usage stats.\n"
            "• Alerts & Dashboards show approvals overdue, upcoming schedules, and performance alerts.\n"
            "• Group and User Management are available (Admin only).\n"
            "• All actions are logged for audit and simulation analysis."
        )
        QMessageBox.information(self, "Usage Tips", tips)

    def closeEvent(self, event):
        try:
            self.connection.close()
        except Exception:
            pass
        event.accept()

def main():
    app = QApplication(sys.argv)
    # Step 1: Establish DB connection
    from brm_tool_connection import DatabaseConnectionDialog, LoginDialog
    conn_dialog = DatabaseConnectionDialog()
    if conn_dialog.exec_() == QDialog.Accepted:
        connection = conn_dialog.get_connection()
        if not connection:
            sys.exit(1)
    else:
        sys.exit(0)
    # Step 2: Login
    login_dialog = LoginDialog(connection)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dialog.user_id
    user_group = login_dialog.user_group
    c = connection.cursor()
    c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (user_id,))
    row = c.fetchone()
    username = row[0] if row else "UnknownUser"

    # Create main window
    main_window = BRMToolMain(connection, user_id, username, user_group)
    main_window.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()