#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_contextual_inline_editing.py

Description:
  Provides a "Contextual / Inline Editing" UI for the BRM Tool:
    • A QTableView that displays a subset of BRM_RULES fields (e.g., RULE_ID, RULE_NAME, STATUS, OWNER_GROUP).
    • Double-click (or click) to edit certain columns in place.
    • On commit, it checks permissions, lock status, and validations, then updates the DB.
    • If there's an error, it reverts or shows a message.

Implementation Details:
  - We use a custom QAbstractTableModel (or QSqlTableModel approach).
  - The "InlineEditingTab" displays the table. The user can sort or filter, optionally.
  - "Lock on edit" approach: once the user tries to edit a row, we attempt to lock the rule. 
    If locking fails (someone else locked it), we show an error.
  - "Permission check": if the user doesn’t have permission for the group or table references, we show an error on commit.

Integration:
  - If your BFS or scheduling needs direct edits, it can read the updated data from DB.
  - This is an alternative to the separate "RuleEditorDialog" for quick changes.

Dependencies:
  - brm_core_foundation for logging, DB connection, fetch helpers
  - brm_rule_engine or your advanced CRUD logic (like update_rule, lock_rule_for_edit, etc.)
"""

import sys
import logging
from PyQt5.QtCore import (
    QAbstractTableModel, Qt, QModelIndex, QVariant
)
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableView, QPushButton, QMessageBox
)

# from brm_core_foundation import logger
# from brm_rule_engine import lock_rule_for_edit, unlock_rule_for_edit, user_has_table_permission

###############################################################################
# 1) InlineEditModel
###############################################################################
class InlineEditModel(QAbstractTableModel):
    """
    A custom table model that loads data from BRM_RULES into memory,
    allows certain columns to be edited, and on commit updates the DB.

    For demonstration, we handle:
      - columns: RULE_ID (read-only), RULE_NAME (editable), STATUS (editable?), OWNER_GROUP (editable).
    We store data in a local list of dictionaries. On setData => we do validations/updates.

    For advanced usage, you might do a QSqlTableModel, but that typically lacks custom checks. 
    This approach gives full control over locks, permissions, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.columns=["RULE_ID","RULE_NAME","STATUS","OWNER_GROUP"]  # example subset
        self.data_rows=[]  # list of dict
        self.fetch_data()

    def fetch_data(self):
        """
        Load some rows from BRM_RULES into data_rows.
        For demonstration, we limit to top 200, or all if small.
        """
        self.beginResetModel()
        c=self.connection.cursor()
        c.execute("""
            SELECT TOP 200 RULE_ID, RULE_NAME, STATUS, OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
        """)
        rows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        self.data_rows=[]
        for row in rows:
            d=dict(zip(colnames,row))
            self.data_rows.append(d)
        self.endResetModel()

    def rowCount(self, parent=QModelIndex()):
        return len(self.data_rows)

    def columnCount(self, parent=QModelIndex()):
        return len(self.columns)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role in (Qt.DisplayRole, Qt.EditRole):
            row=index.row()
            col=index.column()
            colname=self.columns[col]
            val=self.data_rows[row].get(colname)
            return str(val) if val is not None else ""
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation==Qt.Horizontal and role==Qt.DisplayRole:
            return self.columns[section]
        return super().headerData(section, orientation, role)

    def flags(self, index):
        if not index.isValid():
            return Qt.ItemIsEnabled
        colname=self.columns[index.column()]
        if colname=="RULE_ID":
            # read-only
            return Qt.ItemIsEnabled | Qt.ItemIsSelectable
        # else editable columns
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsEditable

    def setData(self, index, value, role=Qt.EditRole):
        """
        Called when user commits an edit. We do a DB update if permitted.
        """
        if role==Qt.EditRole and index.isValid():
            row=index.row()
            col=index.column()
            colname=self.columns[col]
            old_val=self.data_rows[row].get(colname)
            new_val=value.strip() if isinstance(value, str) else value

            if new_val==old_val:
                return True  # no change

            # Check lock, permission, etc.
            rule_id=self.data_rows[row]["RULE_ID"]

            # Attempt to lock if not locked
            try:
                self.attempt_lock(rule_id)
            except Exception as ex:
                QMessageBox.warning(None,"Lock Error",f"Cannot lock rule {rule_id}: {ex}")
                return False

            # If permission is needed => check
            if colname=="OWNER_GROUP":
                # check if user can put it in that group
                if not self.user_can_assign_group(new_val):
                    QMessageBox.warning(None,"Permission Denied",f"You cannot assign rule to group {new_val}.")
                    return False

            # Attempt DB update
            ok=self.update_rule_in_db(rule_id, colname, new_val)
            if not ok:
                return False

            # If success => update local cache
            self.data_rows[row][colname]=new_val
            # If you want to unlock or keep locked => depends. 
            # We'll do an immediate unlock, or keep locked until user closes tab.
            try:
                self.unlock_rule(rule_id)
            except:
                pass

            self.dataChanged.emit(index, index, [Qt.DisplayRole, Qt.EditRole])
            return True
        return False

    def user_can_assign_group(self, group_name):
        """
        Check if the current user (self.user_group) can assign a rule to group_name. 
        This can be domain-specific. For demonstration, Admin can do anything, 
        or you can check some membership rules.
        """
        if self.user_group=="Admin":
            return True
        # else more logic
        return (group_name==self.user_group)

    def attempt_lock(self, rule_id):
        """
        Attempt to lock the rule. If already locked by someone else => raise Exception.
        We'll do a force=False approach.
        """
        c=self.connection.cursor()
        # from brm_rule_engine import lock_rule_for_edit
        # or replicate logic here
        # Pseudocode:
        # lock_rule_for_edit(self.connection, rule_id, self.user_id, force=False)
        # For demonstration:
        c.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rule_id,))
        row=c.fetchone()
        if row:
            locked_by=row[0]
            if str(locked_by)!=str(self.user_id) and self.user_group!="Admin":
                raise ValueError(f"Already locked by user {locked_by}.")
        else:
            # create new lock
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, ACTIVE_LOCK)
                VALUES(?,?,GETDATE(),1)
            """,(rule_id,self.user_id))
            self.connection.commit()

    def unlock_rule(self, rule_id):
        """
        Optional immediate unlock.
        """
        c=self.connection.cursor()
        # from brm_rule_engine import unlock_rule_for_edit
        # or replicate
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND LOCKED_BY=? AND ACTIVE_LOCK=1
        """,(rule_id,self.user_id))
        self.connection.commit()

    def update_rule_in_db(self, rule_id, colname, new_val):
        """
        Actually run an UPDATE statement in DB with validations.
        For demonstration, we only handle the columns in self.columns except RULE_ID.
        """
        c=self.connection.cursor()
        try:
            if colname=="RULE_NAME":
                c.execute("""
                    UPDATE BRM_RULES
                    SET RULE_NAME=?,
                        UPDATED_BY=?,
                        VERSION=VERSION+1
                    WHERE RULE_ID=?
                """,(new_val,str(self.user_id), rule_id))
            elif colname=="STATUS":
                # we can enforce that only "INACTIVE" or "ACTIVE" are allowed, for example
                if new_val.upper() not in ("ACTIVE","INACTIVE"):
                    QMessageBox.warning(None,"Invalid Value",f"Status must be ACTIVE or INACTIVE.")
                    return False
                c.execute("""
                    UPDATE BRM_RULES
                    SET STATUS=?,
                        UPDATED_BY=?,
                        VERSION=VERSION+1
                    WHERE RULE_ID=?
                """,(new_val.upper(), str(self.user_id), rule_id))
            elif colname=="OWNER_GROUP":
                c.execute("""
                    UPDATE BRM_RULES
                    SET OWNER_GROUP=?,
                        UPDATED_BY=?,
                        VERSION=VERSION+1
                    WHERE RULE_ID=?
                """,(new_val,str(self.user_id), rule_id))
            else:
                return False
            self.connection.commit()
            return True
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(None,"DB Error",str(ex))
            return False


###############################################################################
# 2) InlineEditingTab
###############################################################################
class InlineEditingTab(QWidget):
    """
    A UI that hosts a QTableView with the InlineEditModel, 
    plus a refresh button. 
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.model=InlineEditModel(connection, user_id, user_group, self)
        layout=QVBoxLayout(self)

        self.table=QTableView()
        self.table.setModel(self.model)
        # optional: self.table.setSortingEnabled(True) => might need override
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Data")
        ref_btn.clicked.connect(self.refresh_data)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)

    def refresh_data(self):
        self.model.fetch_data()
        # The model triggers beginResetModel/endResetModel => table refresh