#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: advanced_approvals_and_lineage.py
Description:
  Provides multi-step approvals with possible branching, global/critical admin interface,
  and a drag-and-drop HierarchyView for rule groups.

Database Requirements:
  - BRM_RULE_APPROVALS(
      RULE_ID, GROUP_NAME, USERNAME, APPROVAL_STAGE, APPROVED_FLAG,
      APPROVED_TIMESTAMP, FORK_ID (nullable), ...
    )
  - BRM_RULES(RULE_ID, RULE_NAME, OWNER_GROUP, STATUS, LOCK_STATUS, LOCKED_BY, PARENT_RULE_ID, ... )
  - RULE_LOCKS for concurrency
"""

import sys
import logging
import pyodbc
from datetime import datetime
from collections import defaultdict

from PyQt5.QtCore import Qt, QTimer, QMimeData
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QMessageBox, QInputDialog, QLabel, QTreeWidget, QTreeWidgetItem,
    QAbstractItemView
)

from core_foundation import logger, insert_audit_log, LockManager

# -----------------------------------------------------------------------------
# 1. MultiStepApprovalTab – branching approvals
# -----------------------------------------------------------------------------
class MultiStepApprovalTab(QWidget):
    """
    Displays pending approvals for the current user. 
    If a rule fails (reject), we can fork references or statuses.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        self.init_ui()
        self.load_approvals()
        self.start_auto_refresh()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.approval_table = QTableWidget(0, 10)
        self.approval_table.setHorizontalHeaderLabels([
            "Rule ID", "Group", "Rule Name", "Stage", "Approved?",
            "Fork ID", "Approve", "Reject", "Lock Status", "Force Unlock"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approval_table)
        self.setLayout(layout)

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE,
                       A.APPROVED_FLAG, A.FORK_ID, R.LOCK_STATUS, R.LOCKED_BY
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.USERNAME=?
                  AND A.APPROVED_FLAG=0  -- 0 means 'pending'
                ORDER BY A.RULE_ID
            """,(self.logged_in_username,))
            rows = c.fetchall()

            self.approval_table.setRowCount(len(rows))
            for idx, row in enumerate(rows):
                rule_id, group_name, rule_name, stage, approved_flag, fork_id, lock_status, locked_by = row
                self.approval_table.setItem(idx, 0, QTableWidgetItem(str(rule_id)))
                self.approval_table.setItem(idx, 1, QTableWidgetItem(str(group_name)))
                self.approval_table.setItem(idx, 2, QTableWidgetItem(str(rule_name)))
                self.approval_table.setItem(idx, 3, QTableWidgetItem(str(stage)))
                self.approval_table.setItem(idx, 4, QTableWidgetItem(str(approved_flag)))
                self.approval_table.setItem(idx, 5, QTableWidgetItem(str(fork_id) if fork_id else ""))

                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, r=rule_id, g=group_name: self.approve_rule(r,g))
                self.approval_table.setCellWidget(idx, 6, approve_btn)

                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, r=rule_id, g=group_name: self.reject_rule(r,g))
                self.approval_table.setCellWidget(idx, 7, reject_btn)

                lock_text = "UNLOCKED" if lock_status==0 else f"LOCKED by {locked_by}"
                self.approval_table.setItem(idx,8, QTableWidgetItem(lock_text))

                force_unlock_btn = QPushButton("Force Unlock")
                force_unlock_btn.clicked.connect(lambda _, r=rule_id: self.force_unlock(r))
                force_unlock_btn.setEnabled(self.user_group=="Admin")
                self.approval_table.setCellWidget(idx,9, force_unlock_btn)

        except Exception as ex:
            logger.error(f"Error loading approvals: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def approve_rule(self, rule_id, group_name):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
            """,(rule_id, group_name, self.logged_in_username))

            # Check if any pending stages remain for this rule
            c.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rule_id,))
            pending_stage = c.fetchone()[0]
            if pending_stage is None:
                # no more pending -> rule is active
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                    WHERE RULE_ID=?
                """,(rule_id,))
            else:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
                    WHERE RULE_ID=?
                """,(rule_id,))
            self.connection.commit()
            insert_audit_log(self.connection, "APPROVE_RULE","BRM_RULE_APPROVALS", rule_id,
                             self.logged_in_username, None, {"approved":True})
            QMessageBox.information(self, "Approved", f"Rule {rule_id} was approved at group {group_name}.")
            self.load_approvals()
        except Exception as ex:
            logger.error(f"approve_rule error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def reject_rule(self, rule_id, group_name):
        c = self.connection.cursor()
        try:
            # set approved_flag=2 for 'rejected'
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
                WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
            """,(rule_id, group_name, self.logged_in_username))

            # rule is 'rejected'
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """,(rule_id,))
            self.connection.commit()
            insert_audit_log(self.connection, "REJECT_RULE","BRM_RULE_APPROVALS", rule_id,
                             self.logged_in_username, None, {"rejected":True})
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} was rejected.")
            self.load_approvals()
        except Exception as ex:
            logger.error(f"reject_rule error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def force_unlock(self, rule_id):
        if self.user_group!="Admin":
            QMessageBox.warning(self, "Denied", "Only Admin can force unlock.")
            return
        try:
            LockManager.unlock_rule(self.connection, rule_id, "AdminOverride", force=True)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} forcibly unlocked.")
            self.load_approvals()
        except Exception as ex:
            logger.error(f"force_unlock error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def start_auto_refresh(self):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.load_approvals)
        self.timer.start(5000)  # every 5s

# -----------------------------------------------------------------------------
# 2. GlobalCriticalAdminTab – Admin-only features
# -----------------------------------------------------------------------------
class GlobalCriticalAdminTab(QWidget):
    """
    Admin-only interface to manage global or critical rules. 
    Can force updates or activation/deactivation, show GCR links, etc.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.init_ui()
        if self.user_group!="Admin":
            QMessageBox.warning(self, "Access Denied", "This tab is for Admin only.")
        else:
            self.load_rule_list()

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.notice_label = QLabel("Global/Critical Admin (Admin only)")
        layout.addWidget(self.notice_label)

        self.rule_table = QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","OwnerGroup","IsGlobal","CriticalRule",
            "Status","Lock","Actions"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        self.setLayout(layout)

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                       STATUS, LOCK_STATUS, LOCKED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.rule_table.rowCount()
                self.rule_table.insertRow(r_idx)
                # columns
                rid, rname, ogroup, isg, crit, stat, lstatus, lby = row
                self.rule_table.setItem(r_idx,0, QTableWidgetItem(str(rid)))
                self.rule_table.setItem(r_idx,1, QTableWidgetItem(str(rname)))
                self.rule_table.setItem(r_idx,2, QTableWidgetItem(str(ogroup)))
                self.rule_table.setItem(r_idx,3, QTableWidgetItem(str(isg)))
                self.rule_table.setItem(r_idx,4, QTableWidgetItem(str(crit)))
                self.rule_table.setItem(r_idx,5, QTableWidgetItem(str(stat)))
                if lstatus==0:
                    self.rule_table.setItem(r_idx,6, QTableWidgetItem("Unlocked"))
                else:
                    self.rule_table.setItem(r_idx,6, QTableWidgetItem(f"Locked by {lby}"))
                # Action cell
                actions_wid = QWidget()
                hl = QHBoxLayout(actions_wid)
                hl.setContentsMargins(0,0,0,0)

                lock_btn = QPushButton("Lock/Unlock")
                lock_btn.clicked.connect(lambda _, rr=rid: self.toggle_lock(rr))
                hl.addWidget(lock_btn)

                force_upd_btn = QPushButton("Set G/C")
                force_upd_btn.clicked.connect(lambda _, rr=rid: self.set_global_crit(rr))
                hl.addWidget(force_upd_btn)

                hl.addStretch()
                self.rule_table.setCellWidget(r_idx,7, actions_wid)

            self.rule_table.resizeColumnsToContents()
        except Exception as ex:
            logger.error(f"load_rule_list error: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def toggle_lock(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("SELECT LOCK_STATUS, LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not Found", f"Rule {rule_id} not found.")
                return
            lstatus, lby = row
            if lstatus==0:
                # lock it
                LockManager.lock_rule(self.connection, rule_id, "AdminOverride", force=True)
                QMessageBox.information(self, "Locked", f"Rule {rule_id} locked by Admin.")
            else:
                # unlock
                LockManager.unlock_rule(self.connection, rule_id, "AdminOverride", force=True)
                QMessageBox.information(self, "Unlocked", f"Rule {rule_id} unlocked by Admin.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_rule_list()

    def set_global_crit(self, rule_id):
        # Let user choose is_global, critical_rule
        is_global, ok = QInputDialog.getInt(self, "Set is_global", "Enter 0 or 1:", 1)
        if not ok:
            return
        crit_rule, ok2 = QInputDialog.getInt(self, "Set critical_rule", "Enter 0 or 1:", 0)
        if not ok2:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULES
                SET IS_GLOBAL=?, CRITICAL_RULE=?
                WHERE RULE_ID=?
            """,(is_global, crit_rule, rule_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Rule {rule_id} updated to global={is_global}, crit={crit_rule}")
            insert_audit_log(self.connection, "SET_GLOBAL_CRIT","BRM_RULES", rule_id,
                             "Admin", None, {"is_global":is_global,"crit":crit_rule})
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_rule_list()

# -----------------------------------------------------------------------------
# 3. HierarchyViewTab – drag-and-drop QTreeWidget for re-parenting
# -----------------------------------------------------------------------------
class HierarchyViewTab(QTreeWidget):
    """
    Displays groups and their rules in a tree. 
    Allows drag-and-drop to re-parent rules or move them to a different group.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setHeaderLabels(["Group / Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)

        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c = self.connection.cursor()
        # load groups
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
            groups = c.fetchall()
            grp_items = {}
            for (gid, gname) in groups:
                item = QTreeWidgetItem([f"{gname} (ID={gid})"])
                item.setData(0, Qt.UserRole, ("group", gid))
                self.addTopLevelItem(item)
                grp_items[gid] = item

            # load rules
            c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
            rules = c.fetchall()
            rule_items = {}

            # place top-level rules (PARENT_RULE_ID is null) under the group
            for (rid, rname, gid, pid) in rules:
                if pid is None:
                    if gid in grp_items:
                        child_item = QTreeWidgetItem([f"Rule {rid}: {rname}"])
                        child_item.setData(0, Qt.UserRole, ("rule", rid))
                        grp_items[gid].addChild(child_item)
                        rule_items[rid] = child_item

            # place child rules under their parents
            # we do repeated pass or store them in a map
            for (rid, rname, gid, pid) in rules:
                if pid is not None:
                    parent_item = rule_items.get(pid)
                    if parent_item:
                        child_item = QTreeWidgetItem([f"Rule {rid}: {rname}"])
                        child_item.setData(0, Qt.UserRole, ("rule", rid))
                        parent_item.addChild(child_item)
                        rule_items[rid] = child_item

            self.expandAll()

        except Exception as ex:
            logger.error(f"Error loading hierarchy: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def dropEvent(self, event):
        """
        Called after drag-and-drop. We update the DB to reflect new parent or group.
        """
        super().dropEvent(event)
        self.update_database_reparenting()

    def update_database_reparenting(self):
        """
        Traverse the tree and update each rule's parent_rule_id and group_id.
        """
        c = self.connection.cursor()
        top_count = self.topLevelItemCount()
        try:
            c.execute("BEGIN TRANSACTION")
            for i in range(top_count):
                group_item = self.topLevelItem(i)
                if not group_item:
                    continue
                gdata = group_item.data(0, Qt.UserRole)
                if gdata and gdata[0]=="group":
                    group_id = gdata[1]
                    # children
                    for child_i in range(group_item.childCount()):
                        child_item = group_item.child(child_i)
                        self.recur_update(child_item, None, group_id, c)
            c.execute("COMMIT")
            QMessageBox.information(self, "Hierarchy Updated", "Drag-and-drop changes have been saved.")
            self.load_hierarchy()
        except Exception as ex:
            c.execute("ROLLBACK")
            logger.error(f"Error updating hierarchy: {ex}")
            QMessageBox.critical(self, "Error", str(ex))

    def recur_update(self, item, parent_rule_id, group_id, cursor):
        data = item.data(0, Qt.UserRole)
        if data and data[0]=="rule":
            rule_id = data[1]
            cursor.execute("""
                UPDATE BRM_RULES
                SET PARENT_RULE_ID=?, GROUP_ID=?, UPDATED_BY='HierarchyDragDrop', VERSION=VERSION+1
                WHERE RULE_ID=?
            """,(parent_rule_id, group_id, rule_id))
            # process children
            for ci in range(item.childCount()):
                self.recur_update(item.child(ci), rule_id, group_id, cursor)