#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_custom_groups_and_alerts.py
Description:
  Provides:
    • CustomRuleGroupEnhancedTab:
       - Manage custom rule groups (create, rename, delete)
       - Backup/restore with versioning
       - Assign/remove rules from groups
       - Real-time context menu for removing a rule or forced lock/unlock
       - Color-coded rule properties (global, critical, decision table, etc.)

    • AlertsAndDashboardsTab:
       - Displays real-time alerts about:
         * Overdue approvals (>3 days)
         * Stale or old locks
         * Upcoming schedules (< 24 hours)
         * Performance outliers from rule execution logs
       - Auto-refresh with QTimer

Dependencies:
  - brm_core_foundation (for LockManager, insert_audit_log)
  - BFS logic from brm_rule_engine if we want to skip BFS for a forced removal, etc.
"""

import sys
import json
import logging
import re
from datetime import datetime, timedelta
from collections import deque

# PyQt5
from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox,
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QMenu, QCheckBox
)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QBrush, QColor

# from brm_core_foundation
from brm_core_foundation import logger, LockManager, insert_audit_log

###############################################################################
# 1) CustomRuleGroupEnhancedTab
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Provides an advanced UI for:
      - Create, rename, delete custom groups
      - Backup/restore group config with versioning
      - Assign/remove rules
      - Context menus for rule removal or forced lock
      - Color-coded rule properties in the tree
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)

        # top bar => create, rename, delete, backup/restore
        top_h = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        # Splitter => left tree, right list
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        layout.addWidget(splitter)

        # left => tree of groups => assigned rules
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Rule"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.group_tree)

        # right => search + rule list => assign
        right_widget = QWidget()
        rw_layout = QVBoxLayout(right_widget)
        self.rule_search_edit = QLineEdit()
        self.rule_search_edit.setPlaceholderText("Search available rules...")
        self.rule_search_edit.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search_edit)

        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)

        rw_layout.addStretch()
        right_widget.setLayout(rw_layout)
        splitter.addWidget(right_widget)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    # ---------------------------
    # Load group tree
    # ---------------------------
    def load_group_tree(self):
        self.group_tree.clear()
        c = self.connection.cursor()
        c.execute("""
            SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
            FROM BRM_CUSTOM_RULE_GROUPS
            ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups = c.fetchall()
        for (gid, gname, owner) in groups:
            disp = f"{gname} (Owner={owner})"
            g_item = QTreeWidgetItem([disp])
            g_item.setData(0, Qt.UserRole, gid)
            g_item.setBackground(0, QBrush(QColor("lightgray")))
            self.group_tree.addTopLevelItem(g_item)

            # assigned rules
            c2 = self.connection.cursor()
            c2.execute("""
                SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE,
                       R.OPERATION_TYPE, L.LOCKED_BY
                FROM BRM_CUSTOM_GROUP_MEMBERS M
                JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
                LEFT JOIN BRM_RULE_LOCKS L ON R.RULE_ID=L.RULE_ID AND L.ACTIVE_LOCK=1
                WHERE M.CUSTOM_GROUP_ID=?
            """,(gid,))
            assigned = c2.fetchall()
            for (rid,rn,isg,isc,optype,lockedby) in assigned:
                txt=f"Rule {rid}: {rn}"
                # color code
                rule_item = QTreeWidgetItem([txt])
                rule_item.setData(0, Qt.UserRole, rid)
                if isg==1:
                    # global => lightblue
                    rule_item.setBackground(0, QBrush(QColor("#D5EEFF")))
                if isc==1:
                    # critical => lightred
                    rule_item.setBackground(0, QBrush(QColor("#FFD1D1")))
                if (optype or "").upper()=="DECISION_TABLE":
                    # pale yellow
                    rule_item.setBackground(0, QBrush(QColor("#FFFFCC")))
                if lockedby:
                    rule_item.setToolTip(0, f"Locked by {lockedby}")
                g_item.addChild(rule_item)
        self.group_tree.expandAll()

    # ---------------------------
    # Load available rules
    # ---------------------------
    def load_available_rules(self):
        self.rule_list.clear()
        txt = self.rule_search_edit.text().strip()
        c = self.connection.cursor()
        if txt:
            c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        rows = c.fetchall()

        # skip those already assigned to any custom group
        c2 = self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned = set(r[0] for r in c2.fetchall())

        for (rid,rn,og) in rows:
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rn} (Owner={og})"
            it = QListWidgetItem(disp)
            it.setData(Qt.UserRole, rid)
            self.rule_list.addItem(it)

    # ---------------------------
    # Tree context => remove rule
    # ---------------------------
    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            # user right-clicked on rule => we can remove
            menu = QMenu()
            rem_act = menu.addAction("Remove Rule from Group")
            chosen = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id = parent.data(0, Qt.UserRole)
                rule_id = item.data(0, Qt.UserRole)
                self.remove_rule_from_group(group_id, rule_id)

    def remove_rule_from_group(self, group_id, rule_id):
        try:
            # check lock => if locked by someone else => error
            lockedby = self.get_rule_lock_owner(rule_id)
            if lockedby and lockedby!=f"User:{self.user_id}" and self.user_group!="Admin":
                QMessageBox.warning(self,"Locked",f"Rule {rule_id} locked by {lockedby}. Cannot remove.")
                return

            c=self.connection.cursor()
            c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
            """,(group_id,rule_id))
            self.connection.commit()
            QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def get_rule_lock_owner(self, rule_id):
        """
        Return locked_by or None
        """
        c=self.connection.cursor()
        c.execute("SELECT LOCKED_BY FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rule_id,))
        row=c.fetchone()
        if row:
            return row[0]
        return None

    # ---------------------------
    # Create group
    # ---------------------------
    def create_group(self):
        nm = self.new_group_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO BRM_CUSTOM_RULE_GROUPS(
              CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP
            )
            VALUES(?,?,?,GETDATE())
        """,(nm, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Custom group '{nm}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def rename_group(self):
        sel = self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"Error","No group selected in the tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        group_id = g_item.data(0,Qt.UserRole)
        old_label = g_item.text(0)
        new_name,ok = QInputDialog.getText(self,"Rename Group",f"Enter new name for group {old_label}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME=?
                WHERE CUSTOM_GROUP_ID=?
            """,(new_name.strip(), group_id))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group {group_id} => '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        sel=self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"Error","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        confirm=QMessageBox.question(self,"Confirm",f"Delete group {gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    # ---------------------------
    # Backup/restore
    # ---------------------------
    def backup_group(self):
        sel=self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        if not gid:
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","Group not found.")
            return
        group_name=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        members=[rr[0] for rr in c.fetchall()]
        backup_data={
            "group_name":group_name,
            "members":members,
            "backup_user":self.user_id,
            "ts":datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        c.execute("""
            SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
            FROM BRM_CUSTOM_GROUP_BACKUPS
            WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rowv=c.fetchone()
        new_ver=rowv[0] if rowv else 1
        c.execute("""
            INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
              CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
            )
            VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Group {gid} => version {new_ver} created.")
        self.refresh_all()

    def restore_group(self):
        sel=self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        if not gid:
            return
        c=self.connection.cursor()
        c.execute("""
            SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
            FROM BRM_CUSTOM_GROUP_BACKUPS
            WHERE CUSTOM_GROUP_ID=?
            ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        backups=c.fetchall()
        if not backups:
            QMessageBox.information(self,"None","No backups found for this group.")
            return
        items = [f"Version {bk[0]} (ts={bk[1]})" for bk in backups]
        selver,ok=QInputDialog.getItem(self,"Restore","Select version:", items,0,False)
        if not ok or not selver:
            return
        import re
        m=re.search(r"Version\s+(\d+)", selver)
        if not m:
            return
        ver=int(m.group(1))
        backup_json=None
        for bk in backups:
            if bk[0]==ver:
                backup_json=bk[2]
                break
        if not backup_json:
            QMessageBox.warning(self,"Error","Backup version not found.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            data=json.loads(backup_json)
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"JSON parse error: {ex}")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            # rename group
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME=?
                WHERE CUSTOM_GROUP_ID=?
            """,(data["group_name"],gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            # reassign members if they are not locked
            for mid in data["members"]:
                lockedby = self.get_rule_lock_owner(mid)
                if lockedby and lockedby!=f"User:{self.user_id}" and self.user_group!="Admin":
                    # skip
                    continue
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                    VALUES(?,?)
                """,(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver} restored.")
            self.refresh_all()
        except Exception as ex2:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex2))

    # ---------------------------
    # Assign rules
    # ---------------------------
    def assign_rules(self):
        sel=self.group_tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"Error","No custom group selected in the tree.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        if not gid:
            return
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self,"None","No rules selected from the list.")
            return
        c=self.connection.cursor()
        assigned_count=0
        for it in selected_rules:
            rid = it.data(Qt.UserRole)
            lockedby = self.get_rule_lock_owner(rid)
            if lockedby and lockedby!=f"User:{self.user_id}" and self.user_group!="Admin":
                continue
            try:
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                    VALUES(?,?)
                """,(gid,rid))
                assigned_count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{assigned_count} rule(s) assigned to group {gid}.")
        self.refresh_all()


###############################################################################
# 2) AlertsAndDashboardsTab
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    """
    Shows:
      - Overdue approvals (>3 days)
      - Stale locks (> X hours)
      - Upcoming schedules (<24h)
      - Performance outliers (>some threshold in last 7 days)
    Auto-refresh every N seconds if desired.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)

        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        ref_btn = QPushButton("Refresh Alerts")
        ref_btn.clicked.connect(self.check_alerts)
        layout.addWidget(ref_btn)

        self.setLayout(layout)

        # optional auto-refresh
        self.alert_timer = QTimer(self)
        self.alert_timer.timeout.connect(self.check_alerts)
        self.alert_timer.start(60000)  # every 60s

        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # 1) Overdue approvals > 3 days
        try:
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                       DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) as AgeDays
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.APPROVED_FLAG=0
                  AND A.APPROVAL_STAGE=(
                      SELECT MIN(APPROVAL_STAGE)
                      FROM BRM_RULE_APPROVALS
                      WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
                  )
                  AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE())>3
            """)
            overdue = c.fetchall()
            if overdue:
                lines.append("** Approvals older than 3 days **")
                for (rid, stg, rn, age) in overdue:
                    lines.append(f" - Rule {rid} '{rn}', stage={stg}, age={age} days")
            else:
                lines.append("No overdue approvals >3 days.")
        except Exception as ex:
            lines.append(f"Error checking overdue approvals: {ex}")

        lines.append("")

        # 2) Stale locks => older than 6 hours
        try:
            c.execute("""
                SELECT L.RULE_ID, L.LOCKED_BY, R.RULE_NAME,
                       DATEDIFF(HOUR, L.LOCK_TIMESTAMP, GETDATE()) as locked_hours
                FROM BRM_RULE_LOCKS L
                JOIN BRM_RULES R ON L.RULE_ID=R.RULE_ID
                WHERE L.ACTIVE_LOCK=1
                  AND DATEDIFF(HOUR, L.LOCK_TIMESTAMP, GETDATE())>6
            """)
            stale=c.fetchall()
            if stale:
                lines.append("** Stale Locks (>6 hours) **")
                for (rid, usern, rn, hours) in stale:
                    lines.append(f" - Rule {rid} '{rn}' locked by {usern} for {hours}h")
            else:
                lines.append("No stale locks >6 hours.")
        except Exception as ex:
            lines.append(f"Error checking stale locks: {ex}")

        lines.append("")

        # 3) Upcoming schedules <24h
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled'
                  AND SCHEDULE_TIME>=GETDATE()
                  AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules=c.fetchall()
            if schedules:
                lines.append("** Upcoming schedules (<24h) **")
                for (sid,rid,sts) in schedules:
                    lines.append(f" - Sched {sid}: rule {rid} => {sts}")
            else:
                lines.append("No schedules due in next 24h.")
        except Exception as ex:
            lines.append(f"Error checking schedules: {ex}")

        lines.append("")

        # 4) Perf outliers => e.g. > 2 seconds in last 7 days
        threshold_ms=2000
        try:
            c.execute("""
                SELECT LOG_ID, RULE_ID, EXECUTION_TIME_MS, EXECUTION_TIMESTAMP
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP>=DATEADD(DAY,-7,GETDATE())
                  AND EXECUTION_TIME_MS>?
                ORDER BY EXECUTION_TIMESTAMP DESC
            """,(threshold_ms,))
            perf=c.fetchall()
            if perf:
                lines.append(f"** Perf outliers (> {threshold_ms} ms in last 7 days) **")
                for (lid,rid,ms,ts) in perf:
                    lines.append(f" - Log {lid}, rule {rid}, time={ms}ms, ts={ts}")
            else:
                lines.append("No performance outliers detected.")
        except Exception as ex:
            lines.append(f"Error checking perf outliers: {ex}")

        self.alert_text.setPlainText("\n".join(lines))
        logger.info("Alerts updated in brm_custom_groups_and_alerts.")


###############################################################################
# End of brm_custom_groups_and_alerts
###############################################################################