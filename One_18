#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module: brm_tool_main.py (Refined Aggregator)

This is the refined and bug‑fixed final aggregator for the BRM Tool.
It groups functionality into strategic categories with sub‑tabs.
All modules are imported with corrected references.
Ensure all referenced modules exist in the same directory or proper import path.
"""

import sys
import logging
from datetime import datetime

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QAction, QLabel, QComboBox, QPushButton, QMessageBox, QDialog
)
from PyQt5.QtCore import QTimer, Qt

# --------------------------
# 1) Core and Authentication
# --------------------------
from brm_core_foundation import DatabaseConnectionDialog, LoginDialog, logger

# --------------------------
# 2) Rules Management
# --------------------------
# Use InlineEditingTab as the business rules management UI.
from brm_contextual_inline_editing import InlineEditingTab
# SQL-to-Business converter (module defines SqlToBusinessConverterTab)
from brm_sql_to_business_converter import SqlToBusinessConverterTab

# --------------------------
# 3) Approvals and Lineage
# --------------------------
from brm_advanced_approvals_and_lineage import (
    MultiStepApprovalTab, GlobalCriticalAdminTab, HierarchyViewTab, EnhancedLineageGraphWidget
)

# --------------------------
# 4) Scheduling and Simulation
# --------------------------
# Note: The scheduling module file is named "brm_simulation_scheduler.py"
from brm_simulation_scheduler import ScheduleManagementTab, ChainSimulationDialog, GroupSimulationDialog

# --------------------------
# 5) Defects and Audit Logging
# --------------------------
from brm_defect_management import DefectManagementTab
from brm_audit_activity_tracking import ActivityTrackingTab

# --------------------------
# 6) Decision Tables
# --------------------------
from brm_advanced_decision_tables import AdvancedDecisionTablesTab

# --------------------------
# 7) Custom Groups and Alerts
# --------------------------
from brm_custom_rule_groups_and_alerts import CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab

# --------------------------
# 8) Metrics, Control, and Administration
# --------------------------
from brm_metrics_and_control_management import (
    MetricsDashboardTab, ControlTablesTab, GroupManagementTab, UserManagementTab
)

# --------------------------
# 9) Dashboard Cards
# --------------------------
from brm_dashboard_cards import DashboardCardsTab

# --------------------------
# 10) Collaboration
# --------------------------
from brm_live_collaboration import CollaborationManager, CollaborationTab

# --------------------------
# 11) Performance Alerting and Trends
# --------------------------
from brm_performance_alerting_and_trends import PerformanceAlertingTab

# --------------------------
# 12) Data Validations
# --------------------------
from brm_data_validations import DataValidationManagerTab
# For consistency, alias as DataValidationTab
DataValidationTab = DataValidationManagerTab

# --------------------------
# 13) Pipeline / Workflow
# --------------------------
from brm_enhanced_workflow_pipeline import PipelineDesignerTab


class BRMTool(QMainWindow):
    """
    Refined Aggregator with strategically grouped and sub‑tabbed UI components.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Refined Aggregator")
        self.resize(1600, 1000)

        self.connection = None
        self.user_id = None
        self.user_group = None
        self.logged_in_username = None

        # Step 1: Database Connection
        db_dialog = DatabaseConnectionDialog()
        if db_dialog.exec_() == QDialog.Accepted:
            conn = db_dialog.get_connection()
            if not conn:
                sys.exit(1)
            self.connection = conn
        else:
            sys.exit(0)

        # Step 2: Login
        login_dialog = LoginDialog(self.connection)
        if login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dialog.user_id
        self.user_group = login_dialog.user_group

        # Fetch username
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = c.fetchone()
        self.logged_in_username = row[0] if row else "UnknownUser"

        self.init_ui()

    def init_ui(self):
        # Create the central widget with a main QTabWidget for top-level grouping
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # Menu Bar
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        about_act = QAction("About", self)
        about_act.triggered.connect(self.show_about)
        file_menu.addAction(about_act)

        tools_menu = menubar.addMenu("Tools")
        chain_sim_act = QAction("Chain BFS Simulation", self)
        chain_sim_act.triggered.connect(self.launch_chain_sim)
        tools_menu.addAction(chain_sim_act)
        group_sim_act = QAction("Group BFS Simulation", self)
        group_sim_act.triggered.connect(self.launch_group_sim)
        tools_menu.addAction(group_sim_act)
        search_act = QAction("Search Rules", self)
        search_act.triggered.connect(self.launch_rule_search)
        tools_menu.addAction(search_act)

        # Top-level grouping using a QTabWidget
        self.top_tabs = QTabWidget()
        main_layout.addWidget(self.top_tabs)

        # --------------------------
        # Dashboard Group
        # --------------------------
        dashboard_widget = QWidget()
        dashboard_layout = QVBoxLayout(dashboard_widget)
        dashboard_subtabs = QTabWidget()
        dashboard_layout.addWidget(dashboard_subtabs)
        # Dashboard Cards
        dashboard_cards = DashboardCardsTab(self.connection)
        dashboard_subtabs.addTab(dashboard_cards, "Cards Dashboard")
        # Metrics & Performance sub-tabs
        metrics_perf_tabs = QTabWidget()
        metrics_dashboard = MetricsDashboardTab(self.connection)
        perf_trends = PerformanceAlertingTab(self.connection)
        metrics_perf_tabs.addTab(metrics_dashboard, "Metrics Dashboard")
        metrics_perf_tabs.addTab(perf_trends, "Performance Trends")
        dashboard_subtabs.addTab(metrics_perf_tabs, "Metrics & Performance")
        self.top_tabs.addTab(dashboard_widget, "Dashboard")

        # --------------------------
        # Rules Management Group
        # --------------------------
        rules_widget = QWidget()
        rules_layout = QVBoxLayout(rules_widget)
        rules_subtabs = QTabWidget()
        # Business Rules (using Inline Editing as a proxy)
        business_rules_tab = InlineEditingTab(self.connection, self.user_id, self.user_group)
        rules_subtabs.addTab(business_rules_tab, "Business Rules")
        # SQL Converter
        sql_converter_tab = SqlToBusinessConverterTab(self.connection)
        rules_subtabs.addTab(sql_converter_tab, "SQL Converter")
        # Approvals & Lineage sub-tabs
        approvals_lineage_tabs = QTabWidget()
        approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        approvals_lineage_tabs.addTab(approvals_tab, "Approvals")
        if self.user_group == "Admin":
            gcr_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            approvals_lineage_tabs.addTab(gcr_tab, "GCR Admin")
        hier_tab = HierarchyViewTab(self.connection)
        approvals_lineage_tabs.addTab(hier_tab, "Hierarchy")
        lineage_graph_tab = EnhancedLineageGraphWidget(self.connection)
        approvals_lineage_tabs.addTab(lineage_graph_tab, "Lineage")
        rules_subtabs.addTab(approvals_lineage_tabs, "Approvals & Lineage")
        # Custom Groups & Alerts
        custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        rules_subtabs.addTab(custom_groups_tab, "Custom Groups")
        # Scheduling
        sched_tab = ScheduleManagementTab(self.connection)
        rules_subtabs.addTab(sched_tab, "Scheduling")
        rules_layout.addWidget(rules_subtabs)
        self.top_tabs.addTab(rules_widget, "Rules Management")

        # --------------------------
        # Defects & Audits Group
        # --------------------------
        defects_widget = QWidget()
        defects_layout = QVBoxLayout(defects_widget)
        defects_subtabs = QTabWidget()
        defect_mgmt_tab = DefectManagementTab(self.connection)
        defects_subtabs.addTab(defect_mgmt_tab, "Defects")
        activity_tab = ActivityTrackingTab(self.connection)
        defects_subtabs.addTab(activity_tab, "Activity Logs")
        defects_layout.addWidget(defects_subtabs)
        self.top_tabs.addTab(defects_widget, "Defects & Audits")

        # --------------------------
        # Administration Group
        # --------------------------
        admin_widget = QWidget()
        admin_layout = QVBoxLayout(admin_widget)
        admin_subtabs = QTabWidget()
        control_tab = ControlTablesTab(self.connection, self.user_group)
        admin_subtabs.addTab(control_tab, "Control Tables")
        group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        admin_subtabs.addTab(group_mgmt_tab, "Group Management")
        if self.user_group == "Admin":
            user_mgmt_tab = UserManagementTab(self.connection)
            admin_subtabs.addTab(user_mgmt_tab, "User Management")
        data_val_tab = DataValidationTab(self.connection)
        admin_subtabs.addTab(data_val_tab, "Data Validations")
        admin_layout.addWidget(admin_subtabs)
        self.top_tabs.addTab(admin_widget, "Administration")

        # --------------------------
        # Collaboration Group
        # --------------------------
        collab_widget = QWidget()
        collab_layout = QVBoxLayout(collab_widget)
        self.collab_manager = CollaborationManager(self.connection, poll_interval_ms=5000, parent=self)
        collab_tab = CollaborationTab(self.connection, self.collab_manager)
        collab_layout.addWidget(collab_tab)
        self.top_tabs.addTab(collab_widget, "Collaboration")

        # --------------------------
        # Pipeline / Workflow Group
        # --------------------------
        pipeline_widget = QWidget()
        pipeline_layout = QVBoxLayout(pipeline_widget)
        pipeline_designer_tab = PipelineDesignerTab(self.connection)
        pipeline_layout.addWidget(pipeline_designer_tab)
        self.top_tabs.addTab(pipeline_widget, "Pipeline Workflow")

        # Set central widget
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

        # --------------------------
        # Timers for Periodic Refresh
        # --------------------------
        self.setup_timers()

        self.show()

    def setup_timers(self):
        # Approvals auto-refresh every 4 seconds (searching for the sub-tab "Approvals")
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(
            lambda: self.find_subtab("Approvals", self.top_tabs).load_approvals()
        )
        self.approvals_timer.start(4000)

        # Scheduling auto-refresh every 60 seconds
        self.sched_timer = QTimer(self)
        self.sched_timer.timeout.connect(
            lambda: self.find_subtab("Scheduling", self.top_tabs).load_schedules()
        )
        self.sched_timer.start(60000)

        # Alerts auto-refresh every 120 seconds (if Alerts tab exists in Custom Groups/Alerts)
        self.alerts_timer = QTimer(self)
        self.alerts_timer.timeout.connect(
            lambda: self.find_subtab("Alerts", self.top_tabs).check_alerts()
        )
        self.alerts_timer.start(120000)

    def find_subtab(self, title_keyword, parent_tabwidget):
        """
        Recursively search for a sub-tab whose title contains the given keyword.
        """
        for i in range(parent_tabwidget.count()):
            widget = parent_tabwidget.widget(i)
            tab_text = parent_tabwidget.tabText(i)
            if title_keyword.lower() in tab_text.lower():
                return widget
            # If the widget itself contains a QTabWidget child, search recursively.
            child_tabs = widget.findChildren(QTabWidget)
            for ct in child_tabs:
                result = self.find_subtab(title_keyword, ct)
                if result is not None:
                    return result
        return None

    def launch_chain_sim(self):
        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()

    def launch_rule_search(self):
        QMessageBox.information(self, "Rule Search", "This would launch the advanced rule search module.")

    def show_about(self):
        msg = (
            "BRM Tool Aggregator (Refined Version)\n"
            "Strategically grouped UI components with sub-tabs.\n"
            "Categories include: Dashboard, Rules Management, Defects & Audits, Administration, Collaboration, and Pipeline Workflow.\n"
            "Version: 1.0"
        )
        QMessageBox.information(self, "About / Usage", msg)

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except Exception as ex:
                logging.error(f"Error closing connection: {ex}")
        event.accept()


def main():
    app = QApplication(sys.argv)
    tool = BRMTool()
    tool.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
