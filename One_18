#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
File: brm_tool_main.py
Description:
  The final, production-ready main window aggregator for the advanced BRM Tool,
  integrating all modules and features:

   1) DatabaseConnectionDialog & LoginDialog for secure login.
   2) Possibly OnboardingWizard if user is new.
   3) A QMainWindow that:
       - Creates a menu bar with "File", "Help", "Tools" entries.
       - Handles "Sync Metadata", "View Metrics", "Chain Simulation", etc.
       - Optionally has an Admin impersonation combo if user_group == "Admin".
       - Contains a QTabWidget with:
         • Business Rules Dashboard / Inline Editing
         • MultiStepApprovalTab
         • GlobalCriticalAdminTab (if admin)
         • HierarchyViewTab
         • EnhancedLineageGraphWidget
         • CustomRuleGroupEnhancedTab
         • Scheduling Tab
         • ControlTablesTab
         • MetricsDashboardTab
         • AlertsAndDashboardsTab
         • GroupManagementTab
         • UserManagementTab (if admin)
         • DecisionTablesTab / ConflictPriorityManagerTab / CompositeRulesTab / etc.
         • (New advanced modules) CollaborationTab, PerformanceAlertingTab, ActivityTrackingTab, ...
         • DashboardCardsTab as a landing page or final add.
       - Manages timers for auto-refresh of approvals or schedules.

Integration:
  - Each advanced tab is imported from your separate modules (e.g. brm_core_foundation, brm_rule_engine, etc.).
  - Replace placeholders with real module/class imports.

"""

import sys
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QAction, QMenuBar, QLabel, QComboBox, QPushButton, QMessageBox, QDialog
)
from PyQt5.QtCore import QTimer

# ========== Suppose these come from your modules ==========

# from brm_core_foundation import DatabaseConnectionDialog, LoginDialog, OnboardingWizard
# from brm_core_foundation import send_email_notification, logger
# from brm_rule_engine import execute_rules_with_bfs, lock_rule_for_edit, unlock_rule_for_edit
# from brm_scheduling_simulation import ScheduleManagementTab, SingleRuleSimulationDialog, ChainSimulationDialog
# from brm_approvals_lineage import MultiStepApprovalTab, GlobalCriticalAdminTab, HierarchyViewTab, EnhancedLineageGraphWidget
# from brm_metrics_controls import MetricsDashboardTab, ControlTablesTab, GroupManagementTab, UserManagementTab
# from brm_custom_groups_alerts import CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab
# from brm_defect_management import DefectManagementTab  # if you have a separate defect management
# from brm_advanced_decision_tables import AdvancedDecisionTablesTab
# from brm_advanced_simulation import SimulationManagerWidget  # or so
# from brm_audit_activity_tracking import ActivityTrackingTab, record_activity_event
# from brm_sql_to_business_converter import SqlToBusinessConverterTab
# from brm_performance_alerting_and_trends import PerformanceAlertingTab
# from brm_live_collaboration import CollaborationManager, CollaborationTab
# from brm_contextual_inline_editing import InlineEditingTab
# from brm_dashboard_cards import DashboardCardsTab


class BRMTool(QMainWindow):
    """
    The final aggregator main window, referencing all modules/tabs. 
    1) DB Connection
    2) Login
    3) OnboardingWizard (optional)
    4) QTabWidget for each advanced module
    5) Impersonation if Admin
    6) Menu actions (Sync Metadata, BFS chain sim, etc.)
    7) Timers for approvals refresh, schedule checks, alerts, collaboration poll
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Final Aggregator")
        self.resize(1400, 900)

        self.connection = None
        self.user_id = None
        self.user_group = None
        self.logged_in_username = None

        # Step 1: Database Connection
        db_dlg = DatabaseConnectionDialog()
        if db_dlg.exec_() == QDialog.Accepted:
            conn = db_dlg.get_connection()
            if not conn:
                sys.exit(1)
            self.connection = conn
        else:
            sys.exit(0)

        # Step 2: Login
        login_dlg = LoginDialog(self.connection)
        if login_dlg.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = login_dlg.user_id
        self.user_group = login_dlg.user_group

        # fetch actual username
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = c.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "Unknown"

        # Step 3: Optional OnboardingWizard
        # wiz = OnboardingWizard(self.connection)
        # wiz.exec_()

        self.init_ui()

    def init_ui(self):
        # create a menubar with some actions
        menubar = self.menuBar()

        file_menu = menubar.addMenu("File")
        # Example: sync metadata
        sync_act = QAction("Sync Metadata", self)
        sync_act.triggered.connect(self.sync_metadata)
        file_menu.addAction(sync_act)

        # BFS chain sim
        chain_act = QAction("Simulate BFS Chain", self)
        chain_act.triggered.connect(self.launch_chain_sim)
        file_menu.addAction(chain_act)

        # BFS group sim
        group_act = QAction("Simulate Custom Group BFS", self)
        group_act.triggered.connect(self.launch_group_sim)
        file_menu.addAction(group_act)

        # Tools menu
        tools_menu = menubar.addMenu("Tools")
        # Audit logs
        audit_act = QAction("View Activity Logs", self)
        audit_act.triggered.connect(self.launch_activity_logs)
        tools_menu.addAction(audit_act)

        # rule search
        search_act = QAction("Search Rules", self)
        search_act.triggered.connect(self.launch_rule_search)
        tools_menu.addAction(search_act)

        # help menu
        help_menu = menubar.addMenu("Help")
        about_act = QAction("About / Usage", self)
        about_act.triggered.connect(self.show_about)
        help_menu.addAction(about_act)

        # central widget
        cw = QWidget()
        main_layout = QVBoxLayout(cw)

        # If Admin, create impersonation row
        if self.user_group=="Admin":
            top_h = QHBoxLayout()
            self.impersonate_combo = QComboBox()
            self.impersonate_btn = QPushButton("Switch User")
            self.impersonate_btn.clicked.connect(self.switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.impersonate_combo)
            top_h.addWidget(self.impersonate_btn)
            top_h.addStretch()
            main_layout.addLayout(top_h)
            self.load_impersonation_options()

        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # =============== Add Modules/Tabs ===============

        # Possibly a "Cards" dashboard as a first tab
        self.cards_tab = DashboardCardsTab(self.connection)
        self.tabs.addTab(self.cards_tab, "Dashboard")

        # 1) Business Rules Dashboard or Inline Editing
        #   e.g. InlineEditingTab or RuleDashboard
        self.inline_edit_tab = InlineEditingTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.inline_edit_tab, "Inline Edit (BRM_RULES)")

        # or if you prefer the older RuleDashboard approach:
        # self.rule_dashboard = RuleDashboard(self.connection, self.user_id, self.user_group)
        # self.tabs.addTab(self.rule_dashboard, "Business Rules")

        # 2) Multi-step approvals
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")

        # 3) GCR admin if admin
        if self.user_group=="Admin":
            self.gcr_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_tab, "Global/Critical Admin")

        # 4) Hierarchy
        self.hier_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab, "Hierarchy")

        # 5) Enhanced lineage
        lineage_wrapper = QWidget()
        lw_layout = QVBoxLayout(lineage_wrapper)
        self.lineage_graph = EnhancedLineageGraphWidget(self.connection)
        lw_layout.addWidget(self.lineage_graph)
        lineage_wrapper.setLayout(lw_layout)
        self.tabs.addTab(lineage_wrapper, "Lineage")

        # 6) custom groups
        self.custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_groups_tab, "Custom Groups")

        # 7) scheduling
        self.sched_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sched_tab, "Scheduling")

        # 8) control tables
        self.ctrl_tab = ControlTablesTab(self.connection, self.user_group)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        # 9) metrics
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics")

        # 10) alerts
        self.alerts_tab = AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.alerts_tab, "Alerts & Dashboards")

        # 11) group mgmt
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.group_mgmt_tab, "Group Management")

        # 12) user mgmt if admin
        if self.user_group=="Admin":
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")

        # 13) Defect management (if you have a separate module)
        # self.defect_tab = DefectManagementTab(self.connection)
        # self.tabs.addTab(self.defect_tab, "Defects")

        # 14) advanced decision tables
        self.decision_tab = AdvancedDecisionTablesTab(self.connection)
        self.tabs.addTab(self.decision_tab,"Decision Tables")

        # 15) Performance alerting
        self.perf_alert_tab = PerformanceAlertingTab(self.connection)
        self.tabs.addTab(self.perf_alert_tab, "Perf Trends")

        # 16) Activity tracking
        self.activity_tab = ActivityTrackingTab(self.connection)
        self.tabs.addTab(self.activity_tab, "Activity Logs")

        # 17) SQL-to-business converter
        self.sql_convert_tab = SqlToBusinessConverterTab(self.connection)
        self.tabs.addTab(self.sql_convert_tab,"SQL→Business")

        # 18) Collaboration manager + tab
        self.collab_manager = CollaborationManager(self.connection, poll_interval_ms=5000, parent=self)
        self.collab_tab = CollaborationTab(self.connection, self.collab_manager)
        self.tabs.addTab(self.collab_tab, "Collaboration")

        cw.setLayout(main_layout)
        self.setCentralWidget(cw)

        # Timers => refresh approvals, schedules, alerts, or do BFS
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approvals_timer.start(4000)  # every 4 seconds

        # schedule check
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)  # every 60s

        # alerts auto-check
        self.alerts_timer = QTimer(self)
        self.alerts_timer.timeout.connect(self.alerts_tab.check_alerts)
        self.alerts_timer.start(120000)  # every 2 minutes

        self.show()

    # ----------------------------------------------------------------------
    # Implementation stubs for menu actions
    # ----------------------------------------------------------------------
    def sync_metadata(self):
        try:
            sync_msg = sync_metadata_improved(self.connection)  # or some function
            QMessageBox.information(self,"Sync",sync_msg)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def launch_chain_sim(self):
        dlg=ChainSimulationDialog(self.connection,self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=GroupSimulationDialog(self.connection,self)
        dlg.exec_()

    def launch_activity_logs(self):
        self.tabs.setCurrentWidget(self.activity_tab)

    def launch_rule_search(self):
        # example
        sr_dlg = RuleSearchDialog(self.connection, self.user_group, self)
        sr_dlg.exec_()

    def show_about(self):
        msg=(
            "BRM Tool – Final aggregator with advanced modules.\n"
            "Features:\n"
            " - BFS-based rule engine\n"
            " - Multi-step approvals, GCR admin\n"
            " - Scheduling, data validations, real-time presence\n"
            " - Performance alerts, inline editing, advanced lineage\n"
            " - Dashboard cards, collaboration, etc."
        )
        QMessageBox.information(self,"About",msg)

    def load_impersonation_options(self):
        try:
            c=self.connection.cursor()
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows=c.fetchall()
            for (uid, uname, ugrp) in rows:
                disp=f"{uname} ({ugrp})"
                self.impersonate_combo.addItem(disp,(uid,ugrp))
        except Exception as ex:
            logging.error(f"Error loading impersonation: {ex}")

    def switch_user(self):
        data=self.impersonate_combo.currentData()
        if not data:
            return
        new_uid, new_grp=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(new_uid,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="Unknown"

        QMessageBox.information(self,"Switched",f"Now impersonating user {self.logged_in_username} ({new_grp}).")

        # refresh relevant tabs
        self.approvals_tab.logged_in_username=self.logged_in_username
        self.approvals_tab.user_group=self.user_group
        self.approvals_tab.load_approvals()

        # inline editing model user/group
        self.inline_edit_tab.model.user_id=self.user_id
        self.inline_edit_tab.model.user_group=self.user_group
        self.inline_edit_tab.refresh_data()

        # if we had a rule dashboard, we’d set rule_dashboard.user_id=...
        # plus other logic.

        self.alerts_tab.user_id=self.user_id
        self.alerts_tab.user_group=self.user_group
        self.alerts_tab.check_alerts()

        self.group_mgmt_tab.user_id=self.user_id
        self.group_mgmt_tab.user_group=self.user_group
        self.group_mgmt_tab.load_data()

        if hasattr(self,"user_mgmt_tab") and self.user_group!="Admin":
            # possibly disable that tab or hide it
            pass

    def check_due_schedules(self):
        """
        Periodically check if any scheduled rule is now due => run it => log results.
        """
        now_str=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
            FROM RULE_SCHEDULES
            WHERE STATUS='Scheduled'
              AND SCHEDULE_TIME<=?
        """,(now_str,))
        due=c.fetchall()
        for (sid,rid,ts) in due:
            # do a BFS or run_single_rule approach. 
            # or call an advanced function from scheduling. We omit details for brevity
            pass
        # then refresh schedule tab
        self.sched_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()


def main():
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())


if __name__=="__main__":
    main()