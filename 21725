#!/usr/bin/env python
"""
BRM TOOL – PART 1 of 5
Core Modules:
  • Logging configuration and email notification setup.
  • Database connection dialog and user login dialog.
  • Advanced SQL parser for extracting tables, CTEs, alias mappings, and columns.
  
This module has been fully integrated and enhanced compared to previous versions,
with no references to legacy code.
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
from datetime import datetime
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog
)
import pyqtgraph as pg
from sqlparse.sql import Identifier, IdentifierList, Parenthesis
from sqlparse.tokens import Keyword, DML

###############################################################################
# Logging Configuration
###############################################################################
logging.basicConfig(
    filename='brm_tool_enhanced.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

###############################################################################
# Email Configuration and Notification Function
###############################################################################
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Sends an email notification using the EMAIL_CONFIG settings.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# Database Connection Dialog
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Provides a dialog for the user to select a SQL Server ODBC DSN or enter a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection - Enhanced Part 1")
        self.resize(400, 200)
        layout = QVBoxLayout(self)
        
        lbl = QLabel("Select a SQL Server ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)
        
        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)
        
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        layout.addWidget(self.conn_str_edit)
        
        btn_layout = QHBoxLayout()
        connect_btn = QPushButton("Connect")
        connect_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(connect_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

###############################################################################
# Login Dialog
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Provides a login dialog where the user enters username and password.
    It validates credentials against the USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login - Enhanced Part 1")
        self.resize(300, 150)
        layout = QVBoxLayout(self)
        
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)
        
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)
        
        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        layout.addWidget(login_btn)
        
        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = c.fetchone()
        if row:
            self.user_id = row[0]
            self.user_group = row[1]
            self.accept()
        else:
            QMessageBox.warning(self, "Failed", "Invalid credentials.")

###############################################################################
# Advanced SQL Parser Functions
###############################################################################
def enhanced_advanced_extract_tables(sql_text: str):
    """
    Parses the SQL statement and returns a dictionary containing:
      - "tables": list of tuples (schema, table, alias, is_subselect)
      - "cte_tables": list of tuples (CTE name, list of referenced tables)
      - "alias_map": mapping from alias to (schema, table)
      - "columns": list of tuples (column name, is_dml_target, in_select_list)
    """
    statements = sqlparse.parse(sql_text)
    final_tables = []
    cte_info = []
    alias_map = {}
    columns = []
    for stmt in statements:
        cte_dict = _extract_with_clauses(stmt)
        for cte_name, refs in cte_dict.items():
            cte_info.append((cte_name, refs))
        main_refs, main_alias = _extract_main_from(stmt.tokens, set(cte_dict.keys()))
        final_tables.extend(main_refs)
        alias_map.update(main_alias)
        cols = _extract_columns(stmt)
        columns.extend(cols)
    return {
        "tables": list(set(final_tables)),
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }

def _extract_with_clauses(statement):
    cte_map = {}
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
        else:
            i += 1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    while i < len(tokens):
        tk = tokens[i]
        if tk.value.upper() == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens(tokens):
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    results.append(_parse_identifier(ident, set()))
            elif isinstance(tk, Identifier):
                results.append(_parse_identifier(tk, set()))
        i += 1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper() == "SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_ctes):
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    res = _parse_identifier(ident, known_ctes)
                    results.append(res)
                    if res[2]:
                        alias_map[res[2]] = (res[0], res[1])
            elif isinstance(tk, Identifier):
                res = _parse_identifier(tk, known_ctes)
                results.append(res)
                if res[2]:
                    alias_map[res[2]] = (res[0], res[1])
        i += 1
    return results, alias_map

def _parse_identifier(ident, known_ctes):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema = ident.get_parent_name()
    if real_name and real_name.upper() in (cte.upper() for cte in known_ctes):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema, real_name, alias, False)

def _extract_columns(statement):
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is DML:
            dml = tk.value.upper()
            if dml == "SELECT":
                cols = _parse_select_list(tokens, i+1)
                for col in cols:
                    results.append((col, False, True))
            elif dml in ("INSERT", "UPDATE"):
                cols = _parse_dml_columns(tokens, i, dml)
                for col in cols:
                    results.append((col, True, False))
        i += 1
    return results

def _parse_select_list(tokens, start):
    cols = []
    i = start
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("FROM", "JOIN", "WHERE", "GROUP", "ORDER", "UNION", "INTERSECT"):
            break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                name = ident.get_name()
                if name and name.upper() not in ("DISTINCT", "TOP", "ALL"):
                    cols.append(name)
        elif isinstance(tk, Identifier):
            name = tk.get_name()
            if name and name.upper() not in ("DISTINCT", "TOP", "ALL"):
                cols.append(name)
        i += 1
    return cols

def _parse_dml_columns(tokens, start, dml):
    cols = []
    if dml == "INSERT":
        i = start
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                for sub in tk.tokens:
                    if isinstance(sub, IdentifierList):
                        for ident in sub.get_identifiers():
                            cols.append(ident.get_name())
                    elif isinstance(sub, Identifier):
                        cols.append(sub.get_name())
                return cols
            i += 1
    elif dml == "UPDATE":
        i = start
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is Keyword and tk.value.upper() == "SET":
                i += 1
                cols.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return cols

def _parse_update_set_list(tokens, start):
    cols = []
    i = start
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE", "FROM"):
            break
        if isinstance(tk, Identifier):
            cols.append(tk.get_name())
        i += 1
    return cols

# End of Part 1
#!/usr/bin/env python
"""
BRM TOOL – PART 2 of 5
This module implements:
  • BFS rule execution with critical/global handling and logging.
  • Multi‑step approval creation (including propagation of child rule owner groups).
  • Rule CRUD functions: add_rule, update_rule, deactivate_rule, and delete_rule.
All functions include group permission checks, audit logging, and approval re‑initialization.
"""

import json
from datetime import datetime
from collections import deque

# Import functions from Part 1 (ensure Part 1 is integrated)
from part1 import enhanced_advanced_extract_tables, detect_operation_type, add_audit_log

###############################################################################
# BFS Rule Execution and Related Helpers
###############################################################################
def build_rule_adjacency(conn):
    """
    Builds an adjacency mapping for rules based on their PARENT_RULE_ID.
    Returns a tuple (children_map, roots) where:
      - children_map: dict mapping parent rule ID to list of child rule IDs.
      - roots: list of rule IDs that have no parent.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for row in c.fetchall():
        rid, pid = row[0], row[1]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [x for x in all_ids if x not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    """
    Loads global-critical link relationships from BRM_GLOBAL_CRITICAL_LINKS.
    Returns a dictionary mapping a global/critical rule ID to a set of target rule IDs.
    """
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    link_map = {}
    for row in c.fetchall():
        gcr, tgt = row[0], row[1]
        link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    """
    Retrieves all rules from BRM_RULES and returns a dictionary mapping RULE_ID to the rule record.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    cols = [desc[0] for desc in c.description]
    rules = {}
    for row in rows:
        d = dict(zip(cols, row))
        rules[d["RULE_ID"]] = d
    return rules

def skip_descendants(child_id, children_map, skipped):
    """
    Marks all descendant rule IDs (via BFS) as skipped.
    """
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Inserts an execution log record for a rule into RULE_EXECUTION_LOGS.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID,
      EXECUTION_TIMESTAMP,
      PASS_FLAG,
      MESSAGE,
      RECORD_COUNT
    )
    VALUES(?, GETDATE(), ?, ?, ?)
    """, (rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()

def execute_rules_in_order(conn):
    """
    Executes all rules in breadth-first order.
    For each rule, executes its RULE_SQL inside a transaction.
    If a rule fails and it is critical/global (and its CRITICAL_SCOPE is not 'NONE'),
    then all of its descendants (and those linked via global-critical links) are skipped.
    Each rule’s outcome is logged in RULE_EXECUTION_LOGS.
    
    Returns a tuple (executed, skipped) where:
      - executed: list of RULE_IDs that executed successfully.
      - skipped: set of RULE_IDs that were skipped due to failure propagation.
    """
    children_map, roots = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)
    executed = []
    skipped = set()
    c = conn.cursor()
    queue = list(roots)
    while queue:
        rid = queue.pop(0)
        if rid in skipped or rid not in rule_lookup:
            continue
        rinfo = rule_lookup[rid]
        sql_ = rinfo["RULE_SQL"]
        # Determine if rule is critical/global
        is_crit = (rinfo.get("CRITICAL_RULE", 0) == 1 or rinfo.get("IS_GLOBAL", 0) == 1)
        crit_scope = (rinfo.get("CRITICAL_SCOPE", "NONE") or "NONE").upper()
        c.execute("BEGIN TRANSACTION")
        success = False
        msg = ""
        record_count = 0
        try:
            c.execute(sql_)
            rows = c.fetchall()
            if rows:
                record_count = len(rows)
                val = rows[0][0]
                success = (val == 1)
                msg = f"Returned: {val}"
            else:
                success = True
                msg = "No rows => PASS"
            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            success = False
            msg = str(ex)
            record_count = 0
        insert_rule_execution_log(conn, rid, success, msg, record_count)
        if success:
            executed.append(rid)
            if rid in children_map:
                for child in children_map[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            if is_crit and crit_scope != "NONE":
                if rid in children_map:
                    for child in children_map[rid]:
                        skip_descendants(child, children_map, skipped)
                if rid in gcr_links:
                    for child in gcr_links[rid]:
                        skip_descendants(child, children_map, skipped)
        # End while loop
    return executed, skipped

def get_child_rules_bfs(conn, start_rule_id):
    """
    Returns a set of all descendant rule IDs (via BFS), including those linked by global-critical relationships.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    children_map = {}
    for row in c.fetchall():
        rid, pid = row[0], row[1]
        if pid:
            children_map.setdefault(pid, []).append(rid)
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gl_map = {}
    for row in c.fetchall():
        g_parent, g_child = row[0], row[1]
        gl_map.setdefault(g_parent, []).append(g_child)
    visited = set()
    queue = [start_rule_id]
    result = set()
    while queue:
        curr = queue.pop(0)
        if curr in visited:
            continue
        visited.add(curr)
        if curr in children_map:
            for child in children_map[curr]:
                result.add(child)
                queue.append(child)
        if curr in gl_map:
            for child in gl_map[curr]:
                result.add(child)
                queue.append(child)
    return result

###############################################################################
# Multi-step Approval Creation and Impact Analysis
###############################################################################
def find_impacted_business_groups(conn, rule_id):
    """
    Determines impacted business groups for a rule.
    Includes the rule's own owner group and owner groups of all descendant rules.
    Returns a set of group names.
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row[0])
    child_ids = get_child_rules_bfs(conn, rule_id)
    for cid in child_ids:
        c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (cid,))
        r = c.fetchone()
        if r:
            impacted.add(r[0])
    return impacted

def create_multistep_approvals(conn, rule_id):
    """
    Creates multi-step approval records for a rule.
    The rule's own owner group is included, plus any groups impacted via descendant rules.
    Approval stages are assigned based on a base order.
    """
    impacted = find_impacted_business_groups(conn, rule_id)
    base_order = ["BG1", "BG2", "BG3", "FINAL"]
    c = conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_id,))
    stage = 1
    pipeline = []
    for grp in base_order:
        if grp == "FINAL":
            pipeline.append(grp)
        else:
            if grp in impacted:
                pipeline.append(grp)
    for grp in pipeline:
        if grp == "FINAL":
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, ACTION_TYPE
            )
            VALUES(?, ?, ?, 0, ?, 'CREATE_OR_UPDATE')
            """, (rule_id, "FINAL", "final_approver", stage))
        else:
            c2 = conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (grp,))
            for (username,) in c2.fetchall():
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, ACTION_TYPE
                )
                VALUES(?, ?, ?, 0, ?, 'CREATE_OR_UPDATE')
                """, (rule_id, grp, username, stage))
        stage += 1
    conn.commit()

###############################################################################
# Rule CRUD Functions
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    """
    Inserts a new rule into BRM_RULES after performing validations:
      - Duplicate rule name in the same group.
      - Duplicate SQL is not allowed.
      - Group permission enforcement based on GROUP_PERMISSIONS.
    Also parses the SQL to extract table dependencies and inserts them into BRM_RULE_TABLE_DEPENDENCIES.
    If the rule is not global, initializes multi-step approvals.
    Returns the new RULE_ID.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
              (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise Exception("Duplicate rule name in that group.")
    new_sql = rule_data["RULE_SQL"].strip()
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?", (new_sql,))
    if c.fetchone():
        raise Exception("Another rule with the same SQL exists.")
    if rule_data.get("IS_GLOBAL", 0) == 1 and user_group != "Admin":
        raise Exception("Only Admin can create global rules.")
    op_type = detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"] = op_type
    owner_grp = rule_data["OWNER_GROUP"]
    c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (owner_grp,))
    allowed_tables = set(r[0].lower() for r in c.fetchall())
    parse_info = enhanced_advanced_extract_tables(new_sql)
    for sch, tbl, alias, _ in parse_info["tables"]:
        if tbl:
            schema_part = sch if sch else "dbo"
            full_name = f"{schema_part}.{tbl}".lower()
            if full_name not in allowed_tables:
                raise Exception(f"Group '{owner_grp}' does not have permission for table '{full_name}'.")
    row = c.execute("""
    INSERT INTO BRM_RULES(
      GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
      EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
      CREATED_BY, DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
      CREATED_TIMESTAMP, UPDATED_BY, OWNER_GROUP, CLUSTER_NAME,
      APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE,
      DECISION_TABLE_ID
    )
    OUTPUT inserted.RULE_ID
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        rule_data.get("STATUS", "INACTIVE"),
        1,
        created_by,
        rule_data.get("DESCRIPTION", ""),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME", ""),
        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL", 0),
        rule_data.get("CRITICAL_RULE", 0),
        rule_data.get("CRITICAL_SCOPE", "NONE"),
        rule_data.get("CDC_TYPE", "NONE"),
        rule_data.get("DECISION_TABLE_ID")
    )).fetchone()
    if not row:
        raise Exception("Insert failed; no RULE_ID returned.")
    new_id = row[0]
    col_op = "WRITE" if op_type in ("INSERT", "UPDATE", "DELETE") else "READ"
    for sch, tbl, alias, _ in parse_info["tables"]:
        if tbl and not tbl.startswith("(CTE)"):
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """, (new_id, sch if sch else "N/A", tbl, "DerivedCol", col_op))
    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()
    if rule_data.get("IS_GLOBAL", 0) == 0:
        create_multistep_approvals(conn, new_id)
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    """
    Updates an existing rule.
    Performs validations similar to add_rule:
      - Checks for duplicate rule name within the group.
      - Checks for duplicate SQL.
      - Enforces group permissions.
    Updates the rule's dependencies and re-initializes approvals (if not global).
    """
    c = conn.cursor()
    rid = rule_data["RULE_ID"]
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
    old = c.fetchone()
    if not old:
        raise Exception("Rule not found.")
    old_data = dict(zip([d[0] for d in c.description], old))
    new_owner = rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"])
    new_name = rule_data.get("RULE_NAME", old_data["RULE_NAME"]).strip()
    if new_owner != old_data["OWNER_GROUP"] or new_name != old_data["RULE_NAME"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (new_owner, new_name))
        du = c.fetchone()
        if du and du[0] != rid:
            raise Exception(f"Duplicate rule '{new_name}' in group '{new_owner}'.")
    new_sql = rule_data["RULE_SQL"].strip()
    if new_sql != old_data["RULE_SQL"].strip():
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?", (new_sql,))
        rowx = c.fetchone()
        if rowx and rowx[0] != rid:
            raise Exception("Another rule with the same SQL exists.")
    if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise Exception("Only Admin can update a global rule.")
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise Exception("Only Admin can set IS_GLOBAL=1.")
    op_type = detect_operation_type(new_sql)
    rule_data["OPERATION_TYPE"] = op_type
    c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (new_owner,))
    allowed = set(r[0].lower() for r in c.fetchall())
    parse_info = enhanced_advanced_extract_tables(new_sql)
    for sch, tbl, alias, _ in parse_info["tables"]:
        if tbl:
            full_name = f"{sch if sch else 'dbo'}.{tbl}".lower()
            if full_name not in allowed:
                raise Exception(f"Group '{new_owner}' not permitted for table '{full_name}'.")
    c.execute("""
    UPDATE BRM_RULES
    SET GROUP_ID=?, PARENT_RULE_ID=?, RULE_TYPE_ID=?, RULE_NAME=?, RULE_SQL=?,
        EFFECTIVE_START_DATE=?, EFFECTIVE_END_DATE=?, STATUS='INACTIVE', VERSION=VERSION+1,
        UPDATED_BY=?, DESCRIPTION=?, OPERATION_TYPE=?, BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?, CLUSTER_NAME=?, APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?, CDC_TYPE=?, DECISION_TABLE_ID=?
    WHERE RULE_ID=?
    """, (
        rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_name,
        new_sql,
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
        op_type,
        rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
        new_owner,
        rule_data.get("CLUSTER_NAME", old_data.get("CLUSTER_NAME", "")),
        rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
        rule_data.get("DECISION_TABLE_ID"),
        rid
    ))
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
    col_op = "WRITE" if op_type in ("INSERT", "UPDATE", "DELETE") else "READ"
    for sch, tbl, alias, _ in parse_info["tables"]:
        if tbl and not tbl.startswith("(CTE)"):
            c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
              RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
            )
            VALUES(?,?,?,?,?)
            """, (rid, sch if sch else "N/A", tbl, "DerivedCol", col_op))
    new_data = old_data.copy()
    new_data.update(rule_data)
    new_data["VERSION"] = old_data["VERSION"] + 1
    add_audit_log(conn, "UPDATE", "BRM_RULES", rid, updated_by, old_data, new_data)
    conn.commit()
    if rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]) == 0:
        create_multistep_approvals(conn, rid)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    """
    Deactivates a rule.
    Validates that:
      - The rule exists.
      - Its approval status is 'APPROVED'.
      - Global rules can only be deactivated by Admin.
      - No active child rules exist.
    Updates the rule status to INACTIVE and logs the action.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = c.fetchone()
    if not old:
        raise Exception("Rule not found.")
    old_data = dict(zip([d[0] for d in c.description], old))
    if old_data["APPROVAL_STATUS"] != "APPROVED":
        raise Exception("Cannot deactivate unless the rule is fully approved.")
    if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise Exception("Only Admin can deactivate a global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    if c.fetchone():
        raise Exception("Deactivate child rules first.")
    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE', UPDATED_BY=?, VERSION=VERSION+1
    WHERE RULE_ID=?
    """, (updated_by, rule_id))
    new_data = old_data.copy()
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old_data["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    """
    Deletes a rule.
    Validates that:
      - The rule exists.
      - Global rules require Admin privileges.
      - The rule's approval status is 'APPROVED'.
      - The rule is INACTIVE.
      - No child rules exist.
      - No column mappings remain (in BRM_COLUMN_MAPPING).
    Deletes the rule and logs the action.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = c.fetchone()
    if not old:
        raise Exception("Rule not found.")
    old_data = dict(zip([d[0] for d in c.description], old))
    if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise Exception("Only Admin can delete a global rule.")
    if old_data["APPROVAL_STATUS"] != "APPROVED":
        raise Exception("Cannot delete unless the rule is fully approved.")
    if old_data["STATUS"] != "INACTIVE":
        raise Exception("Rule must be INACTIVE before deletion.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    if c.fetchone():
        raise Exception("Child rules exist; cannot delete.")
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    if c.fetchone():
        raise Exception("Re-map or remove column references first.")
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

# End of Part 2
#!/usr/bin/env python
"""
BRM TOOL – PART 3 of 5
This module implements advanced simulation, scheduling, and feature tabs:
  • Dry‑run simulation function for rule SQL execution.
  • Single‑rule, chain, and custom group simulation dialogs.
  • Enhanced scheduling dialog and a schedule management tab.
  • Advanced feature tabs:
       – Decision Tables
       – Conflict Priority Manager
       – Composite Rules Manager
       – Snapshot Manager
       – Tags Manager
       – Data Validation
All UI components are built with PyQt5.
"""

import json
import math
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QPlainTextEdit, QLineEdit, QComboBox, QCalendarWidget, QTableWidget,
    QTableWidgetItem, QListWidget, QListWidgetItem, QMessageBox, QInputDialog,
    QTextEdit, QWidget
)
from PyQt5.QtCore import Qt, QDateTime, QDate
from PyQt5.QtGui import QFont

###############################################################################
# DRY-RUN SIMULATION FUNCTION
###############################################################################
def run_rule_sql_dry_run(conn, rule_sql):
    """
    Executes the given SQL in a transaction and then rolls back.
    Returns a tuple (success, message), where success is True if the SQL returns a row with 1,
    otherwise False.
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    try:
        c.execute(rule_sql)
        rows = c.fetchall()
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
    except Exception as ex:
        success = False
        msg = str(ex)
    c.execute("ROLLBACK")
    return success, msg

###############################################################################
# SINGLE RULE SIMULATION DIALOG
###############################################################################
class SingleRuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.sql_text = sql_text
        self.setWindowTitle(f"Simulate Rule {rule_id}")
        self.resize(500, 300)
        layout = QVBoxLayout(self)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def do_sim(self):
        success, msg = run_rule_sql_dry_run(self.connection, self.sql_text)
        self.result_text.setPlainText(f"{'PASS' if success else 'FAIL'} => {msg}")

###############################################################################
# CHAIN SIMULATION DIALOG
###############################################################################
class ChainSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Rule Chain - Dry-run")
        self.resize(500, 300)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.parent_rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            self.parent_rule_combo.addItem(f"{row[0]} - {row[1]}", row[0])
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        sim_btn = QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.simulate_chain)
        btn_layout.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def simulate_chain(self):
        pid = self.parent_rule_combo.currentData()
        executed, skipped = self.do_chain_sim(pid)
        msg = f"Chain from rule {pid}\nExecuted: {executed}\nSkipped: {list(skipped)}"
        self.result_text.setPlainText(msg)
    
    def do_chain_sim(self, start_rule):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rules = {}
        children = {}
        for row in c.fetchall():
            rid, pid, sql_text = row[0], row[1], row[2]
            rules[rid] = sql_text
            if pid:
                children.setdefault(pid, []).append(rid)
        executed = []
        skipped = set()
        queue = [start_rule]
        while queue:
            rid = queue.pop(0)
            if rid in skipped or rid not in rules:
                continue
            ok, msg = run_rule_sql_dry_run(self.connection, rules[rid])
            if ok:
                executed.append(rid)
                if rid in children:
                    queue.extend(children[rid])
            else:
                skipped.add(rid)
        return executed, skipped

###############################################################################
# CUSTOM GROUP SIMULATION DIALOG
###############################################################################
class GroupSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Custom Group - Dry-run")
        self.resize(500, 300)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.group_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for row in c.fetchall():
            self.group_combo.addItem(f"{row[0]} - {row[1]}", row[0])
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        sim_btn = QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.simulate_group)
        btn_layout.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def simulate_group(self):
        group_id = self.group_combo.currentData()
        executed, fails = self.do_group_sim(group_id)
        msg = f"Group {group_id}\nExecuted: {executed}\nFails: {fails}"
        self.result_text.setPlainText(msg)
    
    def do_group_sim(self, group_id):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
        group_rules = [row[0] for row in c.fetchall()]
        c.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES")
        rule_map = {row[0]: row[1] for row in c.fetchall()}
        executed = []
        fails = []
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            ok, msg = run_rule_sql_dry_run(self.connection, rule_map[rid])
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return executed, fails

###############################################################################
# ENHANCED SCHEDULING DIALOG AND MANAGEMENT TAB
###############################################################################
class EnhancedScheduleDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling - Create")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            self.rule_combo.addItem(f"{row[0]} - {row[1]}", row[0])
        form.addRow("Select Rule:", self.rule_combo)
        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)
        self.time_edit = QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)
        layout.addLayout(form)
        btn_layout = QHBoxLayout()
        schedule_btn = QPushButton("Schedule")
        schedule_btn.clicked.connect(self.schedule_rule)
        btn_layout.addWidget(schedule_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
    
    def schedule_rule(self):
        rid = self.rule_combo.currentData()
        date_str = self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str = self.time_edit.time().toString("HH:mm:ss")
        dt_str = f"{date_str} {time_str}"
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP) VALUES(?, ?, 'Scheduled', GETDATE())", (rid, dt_str))
        self.connection.commit()
        QMessageBox.information(self, "Scheduled", f"Rule {rid} scheduled at {dt_str}.")
        self.close()

class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 5)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID", "Rule ID", "Schedule Time", "Status", "Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Schedules")
        refresh_btn.clicked.connect(self.load_schedules)
        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_schedules()
    
    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        for row in c.fetchall():
            r_i = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            for j in range(4):
                self.schedule_table.setItem(r_i, j, QTableWidgetItem(str(row[j])))
            action_widget = QWidget()
            action_layout = QHBoxLayout(action_widget)
            action_layout.setContentsMargins(0, 0, 0, 0)
            update_btn = QPushButton("Update")
            update_btn.clicked.connect(lambda _, idx=r_i: self.update_schedule(idx))
            delete_btn = QPushButton("Delete")
            delete_btn.clicked.connect(lambda _, idx=r_i: self.delete_schedule(idx))
            action_layout.addWidget(update_btn)
            action_layout.addWidget(delete_btn)
            action_layout.addStretch()
            self.schedule_table.setCellWidget(r_i, 4, action_widget)
        self.schedule_table.resizeColumnsToContents()
    
    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()
    
    def update_schedule(self, row_idx):
        sch_id_item = self.schedule_table.item(row_idx, 0)
        if not sch_id_item:
            return
        sch_id = int(sch_id_item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?", (new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()
    
    def delete_schedule(self, row_idx):
        sch_id_item = self.schedule_table.item(row_idx, 0)
        if not sch_id_item:
            return
        sch_id = int(sch_id_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {sch_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sch_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Schedule {sch_id} deleted.")
        self.load_schedules()

###############################################################################
# DECISION TABLES TAB
###############################################################################
class DecisionTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["Decision Table ID", "Table Name", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_decision_table)
        del_btn = QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.delete_decision_table)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_decision_tables)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_decision_tables()
    
    def load_decision_tables(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in c.fetchall():
            r_i = self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            self.dt_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.dt_table.setItem(r_i, 1, QTableWidgetItem(row[1]))
            self.dt_table.setItem(r_i, 2, QTableWidgetItem(row[2] if row[2] else ""))
    
    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional description:")
        if not ok2:
            desc = ""
        c = self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES(?, ?)", (name.strip(), desc.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Decision table added.")
        self.load_decision_tables()
    
    def delete_decision_table(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No decision table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete decision table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Decision table deleted.")
        self.load_decision_tables()

###############################################################################
# CONFLICT PRIORITY MANAGER TAB
###############################################################################
class ConflictPriorityManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["Conflict ID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(set_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()
    
    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        for row in c.fetchall():
            r_i = self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            for j in range(4):
                self.cf_table.setItem(r_i, j, QTableWidgetItem(str(row[j])))
    
    def add_conflict(self):
        r1, ok = QInputDialog.getInt(self, "Add Conflict", "Rule ID1:")
        if not ok:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Rule ID2:")
        if not ok2:
            return
        pri, ok3 = QInputDialog.getInt(self, "Priority", "Enter priority (integer):")
        if not ok3:
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?, ?, ?)", (r1, r2, pri))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Conflict added.")
        self.load_conflicts()
    
    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        new_pri, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c = self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_pri, cf_id))
        self.connection.commit()
        QMessageBox.information(self, "Updated", "Conflict priority updated.")
        self.load_conflicts()
    
    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Conflict deleted.")
        self.load_conflicts()

###############################################################################
# COMPOSITE RULES TAB
###############################################################################
class CompositeRulesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["Composite Rule ID", "Name", "Logic Expression", "Action on Pass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite_rule)
        del_btn = QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.delete_composite_rule)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_composite_rules)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_composite_rules()
    
    def load_composite_rules(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        for row in c.fetchall():
            r_i = self.cr_table.rowCount()
            self.cr_table.insertRow(r_i)
            for j in range(4):
                self.cr_table.setItem(r_i, j, QTableWidgetItem(str(row[j]) if row[j] is not None else ""))
    
    def add_composite_rule(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getText(self, "Logic Expression", "Enter logic (e.g., 'Rule1==PASS AND Rule2==PASS'):")
        if not ok2:
            expr = ""
        act, ok3 = QInputDialog.getText(self, "Action on Pass", "Optional action:")
        if not ok3:
            act = ""
        c = self.connection.cursor()
        c.execute("INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS) VALUES(?, ?, ?)", (name.strip(), expr.strip(), act.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Composite rule added.")
        self.load_composite_rules()
    
    def delete_composite_rule(self):
        row = self.cr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No composite rule selected.")
            return
        cid = int(self.cr_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {cid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (cid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Composite rule deleted.")
        self.load_composite_rules()

###############################################################################
# SNAPSHOT MANAGER TAB
###############################################################################
class SnapshotManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["Snapshot ID", "Name", "Created By", "Timestamp", "Snapshot JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)
        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(take_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_snapshots()
    
    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
        for row in c.fetchall():
            r_i = self.ss_table.rowCount()
            self.ss_table.insertRow(r_i)
            for j in range(5):
                self.ss_table.setItem(r_i, j, QTableWidgetItem(str(row[j]) if row[j] is not None else ""))
    
    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Take Snapshot", "Snapshot Name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows = c.fetchall()
        cols = [d[0] for d in c.description]
        snapshot_data = [dict(zip(cols, row)) for row in rows]
        snapshot_json = json.dumps(snapshot_data)
        c.execute("INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON) VALUES(?, ?, ?)", (name.strip(), "SnapshotUser", snapshot_json))
        self.connection.commit()
        QMessageBox.information(self, "Snapshot", "Snapshot taken.")
        self.load_snapshots()
    
    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        ssid = int(self.ss_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {ssid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (ssid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Snapshot deleted.")
        self.load_snapshots()

###############################################################################
# TAGS MANAGER TAB
###############################################################################
class TagsManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["Tag ID", "Rule ID", "Tag Name"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        rem_btn = QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tags)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(rem_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_tags()
    
    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        for row in c.fetchall():
            r_i = self.tags_table.rowCount()
            self.tags_table.insertRow(r_i)
            for j in range(3):
                self.tags_table.setItem(r_i, j, QTableWidgetItem(str(row[j]) if row[j] is not None else ""))
    
    def add_tag(self):
        rid, ok = QInputDialog.getInt(self, "Add Tag", "Rule ID:")
        if not ok:
            return
        tag, ok2 = QInputDialog.getText(self, "Tag", "Tag Name:")
        if not ok2 or not tag.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?, ?)", (rid, tag.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Tag added.")
        self.load_tags()
    
    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        tag_id = int(self.tags_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Tag removed.")
        self.load_tags()

###############################################################################
# DATA VALIDATION TAB
###############################################################################
class DataValidationTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.dv_table = QTableWidget(0, 5)
        self.dv_table.setHorizontalHeaderLabels(["Validation ID", "Table Name", "Column Name", "Validation Type", "Params"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        del_btn = QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_validation)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()
    
    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        for row in c.fetchall():
            r_i = self.dv_table.rowCount()
            self.dv_table.insertRow(r_i)
            for j in range(5):
                self.dv_table.setItem(r_i, j, QTableWidgetItem(str(row[j]) if row[j] is not None else ""))
    
    def add_validation(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Table Name:")
        if not ok or not tbl.strip():
            return
        col, ok2 = QInputDialog.getText(self, "Column", "Column Name:")
        if not ok2 or not col.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "Validation Type (e.g., RANGE, NOT NULL):")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Params", "Optional parameters:")
        if not ok4:
            params = ""
        c = self.connection.cursor()
        c.execute("INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS) VALUES(?, ?, ?, ?)",
                  (tbl.strip(), col.strip(), vtype.strip(), params.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Validation added.")
        self.load_validations()
    
    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        vid = int(self.dv_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation {vid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Validation removed.")
        self.load_validations()

# End of Part 3
#!/usr/bin/env python
"""
BRM TOOL – PART 4 of 5
Main Window – Fully Expanded Advanced UI

This module integrates the following components:
  • Business Rules Dashboard and Editor (with explicit lock indicators)
  • Multi‑step Approvals (with re‑approval workflows)
  • Global/Critical Administration (Admin only)
  • Hierarchy View, Enhanced Lineage Graph, Metrics Dashboard, Control Tables
  • Group Management, User Management (Admin only), Custom Rule Groups (with backup/restore)
  • Scheduling, Alerts & Dashboards, Audit Log Viewer, Rule Search, and Version History
All features include advanced error handling and role‑based access.
"""

import json
import math
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTabWidget, QLineEdit, QMessageBox, QAbstractItemView, QComboBox,
    QTableWidget, QTableWidgetItem, QPlainTextEdit, QFormLayout, QCheckBox,
    QDialog, QTreeWidget, QTreeWidgetItem, QListWidget, QListWidgetItem,
    QFileDialog, QInputDialog, QTextEdit, QGroupBox, QAction
)
from PyQt5.QtCore import Qt, QTimer, QDateTime
from PyQt5.QtGui import QColor
import pyqtgraph as pg

# Import modules from Parts 1, 2, and 3
from part1 import (enhanced_advanced_extract_tables, detect_operation_type, add_audit_log,
                   send_email_notification, DatabaseConnectionDialog, LoginDialog)
from part2 import (add_rule, update_rule, deactivate_rule, delete_rule,
                   execute_rules_in_order, create_multistep_approvals,
                   get_child_rules_bfs)
from part3 import (SingleRuleSimulationDialog, ChainSimulationDialog, GroupSimulationDialog,
                   EnhancedScheduleDialog, ScheduleManagementTab, DecisionTablesTab,
                   ConflictPriorityManagerTab, CompositeRulesTab, SnapshotManagerTab,
                   TagsManagerTab, DataValidationTab, AlertsAndDashboardsTab,
                   GroupManagementTab, UserManagementTab, SearchRuleDialog, AuditLogViewer,
                   VersionHistoryDialog)

# (Optional) If EnhancedLineageGraphWidget is defined in Part 1, import it.
# Otherwise, you may have to implement your own. For this example, we assume it exists.
try:
    from part1 import EnhancedLineageGraphWidget
except ImportError:
    # Minimal stub if not defined – replace with your actual implementation
    from PyQt5.QtWidgets import QGraphicsView, QGraphicsScene
    class EnhancedLineageGraphWidget(QGraphicsView):
        def __init__(self, connection, parent=None):
            super().__init__(parent)
            self.connection = connection
            self.scene = QGraphicsScene(self)
            self.setScene(self.scene)
        def populate_graph(self):
            self.scene.clear()
        def search_nodes(self, query):
            pass
        def resetView(self):
            pass

logger = logging.getLogger(__name__)

###############################################################################
# Rule Dashboard (with Lock/Unlock Buttons)
###############################################################################
class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1
        
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL snippet...")
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_layout.addWidget(QLabel("Status:"))
        top_layout.addWidget(self.status_filter)
        # Lock/Unlock buttons
        lock_btn = QPushButton("Lock Rule")
        lock_btn.clicked.connect(self.lock_rule)
        top_layout.addWidget(lock_btn)
        unlock_btn = QPushButton("Unlock Rule")
        unlock_btn.clicked.connect(self.unlock_rule)
        top_layout.addWidget(unlock_btn)
        layout.addLayout(top_layout)
        
        self.rule_table = QTableWidget(0, 10)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Name", "SQL", "Status", "Version", "Owner Group",
            "Created TS", "Approval Status", "Locked By", "DecisionTableID"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule)
        layout.addWidget(self.rule_table)
        
        nav_layout = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        self.page_label = QLabel("Page 1/1")
        nav_layout.addWidget(self.prev_btn)
        nav_layout.addWidget(self.page_label)
        nav_layout.addWidget(self.next_btn)
        layout.addLayout(nav_layout)
        
        self.setLayout(layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.load_rules()
    
    def build_filter_query(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params
    
    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        count_query = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_query, params)
        total = c.fetchone()[0]
        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        if self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page
        data_query = f"""
        SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
               CREATED_TIMESTAMP, APPROVAL_STATUS, LOCKED_BY, DECISION_TABLE_ID
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_query, (*params, offset, self.records_per_page))
        self.rule_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for j, val in enumerate(row):
                item = QTableWidgetItem(str(val) if val is not None else "")
                if j == 3:  # Status column
                    st = str(val).lower()
                    if st == "active":
                        item.setBackground(QColor(144,238,144))
                    elif st == "inactive":
                        item.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_i, j, item)
    
    def update_selected_rule(self):
        sel = self.rule_table.selectedItems()
        if sel:
            self.selected_rule_id = int(self.rule_table.item(sel[0].row(), 0).text())
        else:
            self.selected_rule_id = None
    
    def get_selected_rule_ids(self):
        ids = []
        for index in self.rule_table.selectionModel().selectedRows():
            row = index.row()
            item = self.rule_table.item(row, 0)
            if item:
                ids.append(int(item.text()))
        return ids
    
    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()
    
    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()
    
    def lock_rule(self):
        # Import enhanced lock functions from Part 5
        from part5 import lock_rule_enhanced
        ids = self.get_selected_rule_ids()
        if len(ids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to lock.")
            return
        rid = ids[0]
        try:
            lock_rule_enhanced(self.connection, rid, f"User:{self.user_id}")
            QMessageBox.information(self, "Locked", f"Rule {rid} is now locked.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Lock Error", str(ex))
    
    def unlock_rule(self):
        from part5 import unlock_rule_enhanced
        ids = self.get_selected_rule_ids()
        if len(ids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to unlock.")
            return
        rid = ids[0]
        try:
            unlock_rule_enhanced(self.connection, rid, f"User:{self.user_id}")
            QMessageBox.information(self, "Unlocked", f"Rule {rid} is now unlocked.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Unlock Error", str(ex))

###############################################################################
# Main Application Window
###############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Enhanced")
        self.resize(1300, 850)
        self.connection = None
        
        # Show DB connection dialog
        from part1 import DatabaseConnectionDialog, LoginDialog
        db_dlg = DatabaseConnectionDialog()
        if db_dlg.exec_() == QDialog.Accepted:
            self.connection = db_dlg.get_connection()
            if not self.connection:
                import sys
                sys.exit(1)
        else:
            import sys
            sys.exit(0)
        
        # Show Login dialog
        login_dlg = LoginDialog(self.connection)
        if login_dlg.exec_() != QDialog.Accepted:
            import sys
            sys.exit(0)
        self.user_id = login_dlg.user_id
        c = self.connection.cursor()
        c.execute("SELECT USERNAME, USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = c.fetchone()
        if not row:
            import sys
            sys.exit(0)
        self.logged_in_username, self.user_group = row[0], row[1]
        
        self.init_ui()
    
    def init_ui(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        
        sync_act = QAction("Sync Metadata", self)
        sync_act.triggered.connect(self.sync_metadata)
        file_menu.addAction(sync_act)
        
        metrics_act = QAction("Metrics Dashboard", self)
        metrics_act.triggered.connect(self.show_metrics_dialog)
        file_menu.addAction(metrics_act)
        
        sched_act = QAction("New Schedule", self)
        sched_act.triggered.connect(self.launch_schedule)
        file_menu.addAction(sched_act)
        
        chain_act = QAction("Simulate Chain", self)
        chain_act.triggered.connect(self.launch_chain_sim)
        file_menu.addAction(chain_act)
        
        grp_act = QAction("Simulate Custom Group", self)
        grp_act.triggered.connect(self.launch_group_sim)
        file_menu.addAction(grp_act)
        
        help_menu = menubar.addMenu("Help")
        usage_act = QAction("Usage Tips", self)
        usage_act.triggered.connect(lambda: QMessageBox.information(self, "Help", "Use the tabs to manage rules, approvals, scheduling, etc."))
        help_menu.addAction(usage_act)
        
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        
        # Admin user switch (if user is Admin)
        if self.user_group == "Admin":
            switch_layout = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.switch_user)
            switch_layout.addWidget(QLabel("Impersonate:"))
            switch_layout.addWidget(self.switch_combo)
            switch_layout.addWidget(self.switch_btn)
            switch_layout.addStretch()
            main_layout.addLayout(switch_layout)
            self.populate_switch_combo()
        
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)
        
        # Business Rules Tab
        br_widget = QWidget()
        br_layout = QVBoxLayout(br_widget)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule)
        update_btn = QPushButton("Update Rule")
        update_btn.clicked.connect(self.update_rule)
        deactivate_btn = QPushButton("Deactivate")
        deactivate_btn.clicked.connect(self.deactivate_rule)
        delete_btn = QPushButton("Delete")
        delete_btn.clicked.connect(self.delete_rule)
        etl_btn = QPushButton("Run ETL")
        etl_btn.clicked.connect(self.run_etl)
        sim_btn = QPushButton("Simulate Rule")
        sim_btn.clicked.connect(self.simulate_rule)
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(update_btn)
        btn_layout.addWidget(deactivate_btn)
        btn_layout.addWidget(delete_btn)
        btn_layout.addWidget(etl_btn)
        btn_layout.addWidget(sim_btn)
        btn_layout.addStretch()
        br_layout.addLayout(btn_layout)
        self.rule_dashboard = RuleDashboard(self.connection, self.user_id, self.user_group)
        br_layout.addWidget(self.rule_dashboard)
        br_widget.setLayout(br_layout)
        self.tabs.addTab(br_widget, "Business Rules")
        
        # Approvals Tab
        from part2 import create_multistep_approvals  # For proper approval workflow
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")
        
        # Global/Critical Administration Tab (Admin only)
        if self.user_group == "Admin":
            # Assume GlobalCriticalAdminTab is defined in part4 or earlier module
            from part4_global import GlobalCriticalAdminTab  # Replace with your module name if needed
            self.gcr_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_tab, "Global/Critical Admin")
        
        # Hierarchy Tab
        from part4_hierarchy import HierarchyViewTab  # Replace with your module name if needed
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy")
        
        # Lineage Tab
        lin_widget = QWidget()
        lin_layout = QVBoxLayout(lin_widget)
        lin_label = QLabel("Lineage Visualization")
        lin_label.setStyleSheet("font-weight:bold;")
        lin_layout.addWidget(lin_label)
        self.lineage_graph = EnhancedLineageGraphWidget(self.connection)
        lin_layout.addWidget(self.lineage_graph)
        line_btn_layout = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table...")
        search_btn = QPushButton("Search")
        search_btn.clicked.connect(lambda: self.lineage_graph.search_nodes(self.lineage_search.text()))
        reset_btn = QPushButton("Reset")
        reset_btn.clicked.connect(self.lineage_graph.resetView)
        refresh_btn = QPushButton("Refresh Graph")
        refresh_btn.clicked.connect(self.lineage_graph.populate_graph)
        line_btn_layout.addWidget(self.lineage_search)
        line_btn_layout.addWidget(search_btn)
        line_btn_layout.addWidget(reset_btn)
        line_btn_layout.addWidget(refresh_btn)
        line_btn_layout.addStretch()
        lin_layout.addLayout(line_btn_layout)
        lin_widget.setLayout(lin_layout)
        self.tabs.addTab(lin_widget, "Lineage")
        
        # Custom Groups Tab
        from part3 import CustomRuleGroupEnhancedTab
        self.custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_groups_tab, "Custom Groups")
        
        # Scheduling Tab
        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Scheduling")
        
        # Control Tables Tab
        from part3 import CtrlTablesTab  # Ensure CtrlTablesTab is defined in part3
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")
        
        # Metrics Tab
        from part3 import MetricsDashboardTab  # Ensure MetricsDashboardTab is defined in part3
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics")
        
        # Alerts & Dashboards Tab
        from part3 import AlertsAndDashboardsTab  # Ensure AlertsAndDashboardsTab is defined in part3
        self.alerts_tab = AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.alerts_tab, "Alerts & Dashboards")
        
        # Group Management Tab
        from part3 import GroupManagementTab  # Ensure GroupManagementTab is defined in part3
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.group_mgmt_tab, "Group Management")
        
        # User Management Tab (Admin only)
        if self.user_group == "Admin":
            from part3 import UserManagementTab
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")
        
        # Tools Menu
        tools_menu = self.menuBar().addMenu("Tools")
        from part3 import AuditLogViewer, SearchRuleDialog, VersionHistoryDialog
        audit_act = QAction("Audit Logs", self)
        audit_act.triggered.connect(self.launch_audit_log)
        tools_menu.addAction(audit_act)
        search_act = QAction("Search Rules", self)
        search_act.triggered.connect(self.launch_search)
        tools_menu.addAction(search_act)
        version_act = QAction("Version History", self)
        version_act.triggered.connect(self.launch_version_history)
        tools_menu.addAction(version_act)
        
        self.setCentralWidget(central_widget)
        
        # Timers for approvals and schedule checking
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approvals_timer.start(5000)
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules)
        self.schedule_timer.start(60000)
        
        self.show()
    
    def sync_metadata(self):
        from part1 import sync_metadata_improved  # Ensure sync_metadata_improved is defined in Part 1
        sync_metadata_improved(self.connection)
    
    def show_metrics_dialog(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800, 600)
        layout = QVBoxLayout(dlg)
        chart = self.metrics_tab  # Reuse the MetricsDashboardTab widget if desired
        layout.addWidget(chart)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        layout.addWidget(close_btn)
        dlg.exec_()
    
    def launch_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
    
    def launch_chain_sim(self):
        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()
    
    def launch_group_sim(self):
        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()
    
    def launch_audit_log(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()
    
    def launch_search(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()
    
    def launch_version_history(self):
        rid, ok = QInputDialog.getInt(self, "Version History", "Enter rule ID:")
        if ok:
            dlg = VersionHistoryDialog(self.connection, rid, self)
            dlg.exec_()
    
    def add_rule(self):
        from part3 import RuleEditorDialog
        dlg = RuleEditorDialog(self.connection, self.user_group, None, self)
        if dlg.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Success", "New rule added.")
            self.rule_dashboard.load_rules()
    
    def update_rule(self):
        from part3 import RuleEditorDialog
        rids = self.rule_dashboard.get_selected_rule_ids()
        if len(rids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to update.")
            return
        rid = rids[0]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"No rule with ID {rid}.")
            return
        cols = [d[0] for d in c.description]
        rule_data = dict(zip(cols, row))
        dlg = RuleEditorDialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Updated", f"Rule {rid} updated.")
            self.rule_dashboard.load_rules()
    
    def deactivate_rule(self):
        rids = self.rule_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        success = 0
        errors = []
        for rid in rids:
            try:
                deactivate_rule(self.connection, rid, f"User:{self.user_id}", self.user_group)
                success += 1
            except Exception as ex:
                errors.append(str(ex))
        msg = f"Deactivation complete. Success: {success}."
        if errors:
            msg += "\nErrors:\n" + "\n".join(errors)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dashboard.load_rules()
    
    def delete_rule(self):
        rids = self.rule_dashboard.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        errors = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, f"User:{self.user_id}", self.user_group)
                success += 1
            except Exception as ex:
                errors.append(str(ex))
        msg = f"Deletion complete. Success: {success}."
        if errors:
            msg += "\nErrors:\n" + "\n".join(errors)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dashboard.load_rules()
    
    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL executed: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self, "ETL", msg)
        self.rule_dashboard.load_rules()
    
    def simulate_rule(self):
        rids = self.rule_dashboard.get_selected_rule_ids()
        if len(rids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to simulate.")
            return
        rid = rids[0]
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", "Rule not found.")
            return
        dlg = SingleRuleSimulationDialog(self.connection, rid, row[0], self)
        dlg.exec_()
    
    def check_schedules(self):
        c = self.connection.cursor()
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute("SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME FROM RULE_SCHEDULES WHERE STATUS='Scheduled' AND SCHEDULE_TIME<=?", (now,))
        due = c.fetchall()
        for row in due:
            sch_id, rid, _ = row
            c2 = self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rid,))
                rule_row = c2.fetchone()
                if rule_row:
                    try:
                        c2.execute(rule_row[0])
                    except Exception as ex:
                        logger.error(f"Scheduled rule {rid} failed: {ex}")
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?", (sch_id,))
                        self.connection.commit()
                        continue
                c2.execute("COMMIT")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?", (sch_id,))
            except Exception as ex:
                logger.error(f"Schedule error: {ex}")
            self.connection.commit()
        self.schedule_tab.load_schedules()
    
    def sync_metadata(self):
        from part1 import sync_metadata_improved
        sync_metadata_improved(self.connection)
    
    def switch_user(self):
        data = self.switch_combo.currentData()
        if data:
            self.user_id, self.user_group = data
            QMessageBox.information(self, "Switched", f"Now impersonating user {self.user_id} with group {self.user_group}.")
    
    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            self.switch_combo.addItem(f"{row[1]} ({row[2]})", (row[0], row[2]))
    
    def launch_audit_log(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()
    
    def launch_search(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()
    
    def launch_version_history(self):
        rid, ok = QInputDialog.getInt(self, "Version History", "Enter rule ID:")
        if ok:
            dlg = VersionHistoryDialog(self.connection, rid, self)
            dlg.exec_()
    
    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

# End of Part 4
#!/usr/bin/env python
"""
BRM TOOL – PART 5 of 5
Enhanced Explicit Locking and Plugin Hooks

This module implements advanced explicit locking functions:
  • lock_rule: Attempts to lock a rule for editing, auto‑expiring stale locks.
  • unlock_rule: Unlocks a rule (only the locking user can unlock).
  • get_lock_info: Retrieves current lock information.
  • auto_expire_locks: Scans and clears expired locks.
  • Plugin hooks: Register external functions to be notified on lock/unlock events.
All events are audit‑logged using add_audit_log.
"""

import json
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

# Assume add_audit_log is defined in Part 1; if not, you may replace this with your own implementation.
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG (
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES (?, ?, ?, ?, ?, ?, GETDATE())
    """, (action, table_name, str(record_id), action_by,
          json.dumps(old_data) if old_data else None,
          json.dumps(new_data) if new_data else None))
    conn.commit()

###############################################################################
# Explicit Locking Functions
###############################################################################
def lock_rule(conn, rule_id, username, lock_duration_minutes=30):
    """
    Locks the specified rule for editing.

    If the rule is already locked by another user and the lock is still valid,
    an Exception is raised. If the lock is expired, it is automatically released.

    Parameters:
      conn (pyodbc.Connection): The database connection.
      rule_id (int): The ID of the rule to lock.
      username (str): The username requesting the lock.
      lock_duration_minutes (int): The duration (in minutes) for which the lock is valid.
    
    Raises:
      Exception if the rule is locked by another active user.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception("Rule not found.")
    
    current_lock, lock_ts = row[0], row[1]
    now = datetime.now()
    
    if current_lock is not None:
        # Assume lock_ts is stored as a datetime or a string in the proper format.
        if isinstance(lock_ts, str):
            lock_time = datetime.strptime(lock_ts, "%Y-%m-%d %H:%M:%S.%f")
        else:
            lock_time = lock_ts
        if now - lock_time > timedelta(minutes=lock_duration_minutes):
            # Lock has expired; automatically clear it.
            unlock_rule(conn, rule_id, current_lock)
        elif current_lock != username:
            raise Exception(f"Rule {rule_id} is currently locked by {current_lock}.")
        else:
            # Already locked by the same user.
            return

    # Set the lock for the rule.
    c.execute("""
    UPDATE BRM_RULES
    SET LOCKED_BY = ?, LOCK_TIMESTAMP = GETDATE()
    WHERE RULE_ID = ?
    """, (username, rule_id))
    conn.commit()
    add_audit_log(conn, "LOCK", "BRM_RULES", rule_id, username, None, {"LOCKED_BY": username})
    _notify_lock_event(conn, rule_id, username, "lock")

def unlock_rule(conn, rule_id, username):
    """
    Unlocks the rule if it is currently locked by the requesting user.

    Raises an Exception if the rule is locked by another user.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception("Rule not found.")
    current_lock = row[0]
    if current_lock is None:
        return  # Already unlocked.
    if current_lock != username:
        raise Exception(f"Rule {rule_id} is locked by {current_lock}; you cannot unlock it.")
    c.execute("UPDATE BRM_RULES SET LOCKED_BY = NULL, LOCK_TIMESTAMP = NULL WHERE RULE_ID = ?", (rule_id,))
    conn.commit()
    add_audit_log(conn, "UNLOCK", "BRM_RULES", rule_id, username, {"LOCKED_BY": current_lock}, None)
    _notify_lock_event(conn, rule_id, username, "unlock")

def get_lock_info(conn, rule_id):
    """
    Retrieves the current lock information for the specified rule.
    
    Returns:
      A tuple (locked_by, lock_timestamp), or (None, None) if no lock is present.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        return row[0], row[1]
    return None, None

def auto_expire_locks(conn, lock_duration_minutes=30):
    """
    Scans all rules for locks older than lock_duration_minutes and clears them.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE LOCKED_BY IS NOT NULL")
    now = datetime.now()
    expired = []
    for rule_id, locked_by, lock_ts in c.fetchall():
        if lock_ts is None:
            continue
        if isinstance(lock_ts, str):
            lock_time = datetime.strptime(lock_ts, "%Y-%m-%d %H:%M:%S.%f")
        else:
            lock_time = lock_ts
        if now - lock_time > timedelta(minutes=lock_duration_minutes):
            expired.append((rule_id, locked_by))
    for rule_id, locked_by in expired:
        c.execute("UPDATE BRM_RULES SET LOCKED_BY = NULL, LOCK_TIMESTAMP = NULL WHERE RULE_ID = ?", (rule_id,))
        add_audit_log(conn, "AUTO_UNLOCK", "BRM_RULES", rule_id, locked_by, {"LOCKED_BY": locked_by}, {"LOCKED_BY": None})
    if expired:
        conn.commit()

###############################################################################
# Plugin Hooks for Lock Events
###############################################################################
_lock_plugins = []

def register_lock_plugin(plugin_func):
    """
    Registers an external plugin function to be notified on lock/unlock events.
    The plugin function should accept parameters: (conn, rule_id, username, action).
    """
    _lock_plugins.append(plugin_func)

def _notify_lock_event(conn, rule_id, username, action):
    """
    Notifies all registered plugins about a lock/unlock event.
    """
    for plugin in _lock_plugins:
        try:
            plugin(conn, rule_id, username, action)
        except Exception as ex:
            logger.error(f"Lock plugin error: {ex}")

###############################################################################
# Enhanced Wrappers
###############################################################################
def lock_rule_enhanced(conn, rule_id, username, lock_duration_minutes=30):
    """
    Enhanced locking function that wraps lock_rule and notifies plugins.
    """
    lock_rule(conn, rule_id, username, lock_duration_minutes)
    _notify_lock_event(conn, rule_id, username, "lock")

def unlock_rule_enhanced(conn, rule_id, username):
    """
    Enhanced unlocking function that wraps unlock_rule and notifies plugins.
    """
    unlock_rule(conn, rule_id, username)
    _notify_lock_event(conn, rule_id, username, "unlock")

# End of Part 5