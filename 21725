#!/usr/bin/env python
"""
BRM TOOL – Full Enhanced (Merged Version)

This single file combines the following components:
  • Core components (logging, email config, database connection, basic DSL parser,
    DB helpers, and login dialog)
  • Advanced decision table evaluation and rule execution (including BFS-based execution
    and multi‑step approvals)
  • Simulation dialogs, scheduling UI, and advanced feature tabs (for decision tables,
    conflicts, composite rules, snapshots, tags, and data validations)
  • A fully expanded main window integrating approvals, hierarchy and lineage views,
    metrics, group/user management, alerts, audit log viewer, search/version history,
    and a rule dashboard with a rule editor
  • Explicit locking functions (lock_rule, unlock_rule, get_lock_info)
  
To run the tool, simply execute this file.
"""

import sys
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
from datetime import datetime
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog, QAbstractItemView
)
import pyqtgraph as pg

###############################################################################
# Logging and Email Configuration (Core Components)
###############################################################################
logging.basicConfig(
    filename='brm_tool_enhanced.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    Sends an email using the EMAIL_CONFIG.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info(f"Email sent to: {', '.join(recipients)}")
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# Database Connection and Helper Functions
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Allows user to select a SQL Server ODBC DSN or enter a custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection - Enhanced")
        self.resize(400, 200)
        layout = QVBoxLayout(self)
        lbl = QLabel("Select a SQL Server ODBC DSN or enter a custom connection string:")
        layout.addWidget(lbl)
        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)
        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        layout.addWidget(self.conn_str_edit)
        btn_layout = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

def get_cursor_rows(cursor):
    """
    Fetch all rows from a cursor and return a list of dictionaries (if column info is present).
    """
    try:
        rows = cursor.fetchall()
    except:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, r)) for r in rows]
    return rows

def get_cursor_one(cursor):
    """
    Fetch a single row from a cursor and return it as a dictionary (if column info is present).
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return None

def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Inserts an audit record into BRM_AUDIT_LOG.
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?, ?, ?, ?, ?, ?, GETDATE())
    """, (action, table_name, str(record_id), action_by,
          json.dumps(old_data) if old_data else None,
          json.dumps(new_data) if new_data else None))
    conn.commit()

###############################################################################
# Login Dialog
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    """
    Prompts for username and password.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login - Enhanced")
        self.resize(300, 150)
        layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)
        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Failed", "Invalid credentials.")

###############################################################################
# Basic Utils and DSL Parser
###############################################################################
def detect_operation_type(sql_text: str) -> str:
    """
    Determines the SQL operation type by examining the first keyword.
    """
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def enhanced_advanced_extract_tables(sql_text: str):
    """
    Parses the SQL and returns a minimal structure with 'tables' and 'columns'.
    (Stub – extend with full sqlparse logic as needed.)
    """
    return {
        "tables": [],
        "columns": []
    }

def safe_eval_condition_expr(expr: str, context: dict) -> bool:
    """
    Safely evaluates a condition expression (e.g., "colA > 100 and status=='ACTIVE'")
    using a restricted AST.
    """
    import ast
    try:
        code_ast = ast.parse(expr, mode='eval')
    except Exception:
        return False
    allowed_nodes = (
        ast.Expression, ast.BoolOp, ast.BinOp, ast.UnaryOp,
        ast.Compare, ast.Name, ast.Load, ast.Constant,
        ast.Eq, ast.NotEq, ast.Lt, ast.LtE, ast.Gt, ast.GtE,
        ast.And, ast.Or, ast.In, ast.NotIn, ast.Is, ast.IsNot
    )
    for node in ast.walk(code_ast):
        if not isinstance(node, allowed_nodes):
            return False
    try:
        val = eval(expr, {"__builtins__": None}, context)
        return bool(val)
    except Exception:
        return False

###############################################################################
# Advanced Decision Table Evaluation and Rule Execution (BFS and Approvals)
###############################################################################
def evaluate_decision_table(conn, decision_table_id, context: dict) -> (bool, str, int):
    """
    Evaluates a decision table based on row-level conditions.
    Returns a tuple: (pass_flag, message, record_count)
    """
    c = conn.cursor()
    c.execute("""
        SELECT ROW_ID, CONDITION_EXPR, OUTCOME_VALUE, PRIORITY, STOP_ON_MATCH
        FROM DECISION_TABLE_ROWS
        WHERE DECISION_TABLE_ID=?
        ORDER BY PRIORITY DESC, ROW_ID
    """, (decision_table_id,))
    rows = c.fetchall()
    if not rows:
        return True, f"Decision table {decision_table_id}: no rows – default pass", 0

    def safe_eval_condition_expr_local(expr: str, context: dict) -> bool:
        import ast
        try:
            code_ast = ast.parse(expr, mode='eval')
        except Exception:
            return False
        allowed_nodes = (
            ast.Expression, ast.BoolOp, ast.BinOp, ast.UnaryOp,
            ast.Compare, ast.Name, ast.Load, ast.Constant,
            ast.Eq, ast.NotEq, ast.Lt, ast.LtE, ast.Gt, ast.GtE,
            ast.And, ast.Or, ast.In, ast.NotIn, ast.Is, ast.IsNot
        )
        for node in ast.walk(code_ast):
            if not isinstance(node, allowed_nodes):
                return False
        try:
            result = eval(expr, {"__builtins__": None}, context)
            return bool(result)
        except Exception:
            return False

    matches = []
    for row in rows:
        row_id, cond_expr, outcome_val, priority, stop_on_match = row
        if safe_eval_condition_expr_local(cond_expr, context):
            matches.append((row_id, outcome_val.strip(), priority, bool(stop_on_match)))
            if bool(stop_on_match):
                break

    if not matches:
        return True, f"Decision table {decision_table_id}: no conditions matched – default pass", 0

    fail_count = sum(1 for m in matches if m[1].upper() == "FAIL")
    pass_count = sum(1 for m in matches if m[1].upper() == "PASS")
    if fail_count > 0 and pass_count == 0:
        return False, f"{len(matches)} row(s) matched with FAIL outcome", len(matches)
    elif pass_count > 0 and fail_count == 0:
        return True, f"{len(matches)} row(s) matched with PASS outcome", len(matches)
    else:
        return False, f"Mixed outcomes in decision table – overall fail", len(matches)

def execute_one_rule(conn, rule_info, context: dict = None) -> (bool, str, int):
    """
    Executes a single rule. If DECISION_TABLE_ID is provided, evaluates the decision table.
    Otherwise, executes RULE_SQL (expecting 1 for pass).
    Returns (pass_flag, message, record_count).
    """
    if context is None:
        context = {}
    if rule_info.get("DECISION_TABLE_ID"):
        return evaluate_decision_table(conn, rule_info["DECISION_TABLE_ID"], context)
    else:
        sql_ = rule_info["RULE_SQL"]
        c = conn.cursor()
        c.execute("BEGIN TRANSACTION")
        try:
            c.execute(sql_)
            rows = c.fetchall()
            if rows:
                val = rows[0][0]
                pass_flag = (val == 1)
                msg = f"SQL returned {val}"
                rec_count = len(rows)
            else:
                pass_flag = True
                msg = "No rows returned – pass"
                rec_count = 0
            if pass_flag:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
            return pass_flag, msg, rec_count
        except Exception as ex:
            c.execute("ROLLBACK")
            return False, str(ex), 0

def build_rule_adjacency(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r[0]
        pid = r[1]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [x for x in all_ids if x not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = c.fetchall()
    link_map = {}
    for r in rows:
        gcr = r[0]
        tgt = r[1]
        link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    if not rows:
        return {}
    cols = [desc[0] for desc in c.description]
    rules_dict = {}
    for row in rows:
        rule = dict(zip(cols, row))
        rules_dict[rule["RULE_ID"]] = rule
    return rules_dict

def skip_descendants(child_id, children_map, skipped):
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    c = conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
    )
    VALUES(?, GETDATE(), ?, ?, ?)
    """, (rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()

def execute_rules_in_order(conn, context: dict = None):
    """
    Executes rules using a BFS approach.
    Returns (list of executed rule IDs, set of skipped rule IDs).
    """
    if context is None:
        context = {}
    children_map, roots = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    rule_lookup = get_all_rules_as_dict(conn)
    executed = []
    skipped = set()
    queue = list(roots)
    while queue:
        rid = queue.pop(0)
        if rid in skipped or rid not in rule_lookup:
            continue
        rule_info = rule_lookup[rid]
        is_crit = (rule_info.get("CRITICAL_RULE") == 1 or rule_info.get("IS_GLOBAL") == 1)
        crit_scope = (rule_info.get("CRITICAL_SCOPE") or "NONE").upper()
        pass_flag, msg, rec_ct = execute_one_rule(conn, rule_info, context)
        insert_rule_execution_log(conn, rid, pass_flag, msg, rec_ct)
        if pass_flag:
            executed.append(rid)
            if rid in children_map:
                for child in children_map[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            if is_crit and crit_scope != "NONE":
                if rid in children_map:
                    for sub in children_map[rid]:
                        skip_descendants(sub, children_map, skipped)
                if rid in gcr_links:
                    for child2 in gcr_links[rid]:
                        skip_descendants(child2, children_map, skipped)
    return executed, skipped

def get_child_rules_bfs(conn, start_rule_id):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    all_rows = c.fetchall()
    children_map = {}
    for row in all_rows:
        rid = row[0]
        pid = row[1]
        if pid:
            children_map.setdefault(pid, []).append(rid)
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    glinks = c.fetchall()
    gl_map = {}
    for row in glinks:
        g_parent = row[0]
        g_child = row[1]
        gl_map.setdefault(g_parent, []).append(g_child)
    visited = set()
    queue = [start_rule_id]
    results = set()
    while queue:
        cur = queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in children_map:
            for ch in children_map[cur]:
                results.add(ch)
                queue.append(ch)
        if cur in gl_map:
            for ch in gl_map[cur]:
                results.add(ch)
                queue.append(ch)
    return results

def find_impacted_business_groups(conn, rule_id):
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row[0])
    childs = get_child_rules_bfs(conn, rule_id)
    for cid in childs:
        c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (cid,))
        r2 = c.fetchone()
        if r2:
            impacted.add(r2[0])
    return impacted

def create_multistep_approvals(conn, rule_id, action_type="CREATE_OR_UPDATE"):
    """
    Creates multi-step approval records for a rule based on impacted business groups.
    """
    c = conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND ACTION_TYPE=?", (rule_id, action_type))
    base_order = ["BG1", "BG2", "BG3", "FINAL"]
    impacted = find_impacted_business_groups(conn, rule_id)
    pipeline = []
    stage_ctr = 1
    for stg in base_order:
        if stg == "FINAL":
            pipeline.append(stg)
        else:
            if stg in impacted:
                pipeline.append(stg)
    for step in pipeline:
        if step == "FINAL":
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, ACTION_TYPE
            )
            VALUES(?, ?, ?, 0, ?, ?)
            """, (rule_id, "FINAL", "final_approver", stage_ctr, action_type))
            stage_ctr += 1
        else:
            c2 = conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (step,))
            for ap in c2.fetchall():
                c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, ACTION_TYPE
                )
                VALUES(?, ?, ?, 0, ?, ?)
                """, (rule_id, step, ap[0], stage_ctr, action_type))
            stage_ctr += 1
    conn.commit()

###############################################################################
# Simulation Dialogs and Advanced Feature Tabs (Part 3)
###############################################################################
class SingleRuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_id, sql_text, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.sql_text = sql_text
        self.setWindowTitle(f"Simulate Rule {rule_id}")
        self.resize(500, 300)
        layout = QVBoxLayout(self)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Dry-Run")
        run_btn.clicked.connect(self.do_sim)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_sim(self):
        success, msg = execute_one_rule(self.connection, {"RULE_SQL": self.sql_text}, {})
        self.result_text.setPlainText(f"{'PASS' if success else 'FAIL'} => {msg}")

class ChainSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Rule Chain - Dry-run")
        self.resize(500, 300)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.parent_rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for r in c.fetchall():
            rid, rname = r[0], r[1]
            self.parent_rule_combo.addItem(f"{rid} - {rname}", rid)
        form.addRow("Parent Rule:", self.parent_rule_combo)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        sim_btn = QPushButton("Simulate Chain")
        sim_btn.clicked.connect(self.sim_chain)
        btn_layout.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def sim_chain(self):
        pid = self.parent_rule_combo.currentData()
        executed, skipped = self.do_chain_sim(pid)
        txt = f"Chain from rule {pid}\nExecuted: {executed}\nSkipped: {skipped}"
        self.result_text.setPlainText(txt)

    def do_chain_sim(self, start_rule):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID, RULE_SQL FROM BRM_RULES")
        rows = c.fetchall()
        rule_map = {r[0]: r[2] for r in rows}
        children_map = {}
        for r in rows:
            rid, pid, _ = r
            if pid:
                children_map.setdefault(pid, []).append(rid)
        executed = []
        skipped = set()
        queue = [start_rule]
        while queue:
            rid = queue.pop(0)
            if rid in skipped:
                continue
            if rid not in rule_map:
                skipped.add(rid)
                continue
            sql_ = rule_map[rid]
            ok, msg = execute_one_rule(self.connection, {"RULE_SQL": sql_}, {})
            if ok:
                executed.append(rid)
                if rid in children_map:
                    for ch in children_map[rid]:
                        if ch not in skipped:
                            queue.append(ch)
            else:
                skipped.add(rid)
        return executed, skipped

class GroupSimulationDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Simulate Custom Group - Dry-run")
        self.resize(500, 300)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for row in c.fetchall():
            cg_id, cg_name = row[0], row[1]
            self.group_combo.addItem(f"{cg_id} - {cg_name}", cg_id)
        form.addRow("Custom Group:", self.group_combo)
        layout.addLayout(form)
        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        btn_layout = QHBoxLayout()
        sim_btn = QPushButton("Simulate Group")
        sim_btn.clicked.connect(self.sim_group)
        btn_layout.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def sim_group(self):
        cg_id = self.group_combo.currentData()
        executed, fails = self.do_sim(cg_id)
        msg = f"Group {cg_id}\nExecuted: {executed}\nFails: {fails}"
        self.result_text.setPlainText(msg)

    def do_sim(self, custom_group_id):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
        group_rules = [r[0] for r in c.fetchall()]
        c.execute("SELECT RULE_ID, RULE_SQL FROM BRM_RULES")
        all_rows = c.fetchall()
        rule_map = {r[0]: r[1] for r in all_rows}
        executed = []
        fails = []
        for rid in group_rules:
            if rid not in rule_map:
                fails.append(rid)
                continue
            sql_ = rule_map[rid]
            ok, msg = execute_one_rule(self.connection, {"RULE_SQL": sql_}, {})
            if ok:
                executed.append(rid)
            else:
                fails.append(rid)
        return executed, fails

class EnhancedScheduleDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        form = QFormLayout()
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            rid, rname = row[0], row[1]
            self.rule_combo.addItem(f"{rid} - {rname}", rid)
        form.addRow("Select Rule:", self.rule_combo)
        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)
        self.time_edit = QLineEdit()
        self.time_edit.setPlaceholderText("HH:MM:SS")
        self.time_edit.setText("12:00:00")
        form.addRow("Time:", self.time_edit)
        layout.addLayout(form)
        btn_layout = QHBoxLayout()
        sched_btn = QPushButton("Schedule")
        sched_btn.clicked.connect(self.do_schedule)
        btn_layout.addWidget(sched_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_str = self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str = self.time_edit.text().strip()
        dt_str = f"{date_str} {time_str}"
        c = self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP)
        VALUES(?, ?, 'Scheduled', GETDATE())
        """, (rid, dt_str))
        self.connection.commit()
        QMessageBox.information(self, "Scheduled", f"Rule {rid} scheduled at {dt_str}.")
        self.close()

class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 5)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID", "Rule ID", "Schedule Time", "Status", "Actions"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Schedules")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(refresh_btn)
        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        for row in c.fetchall():
            r_i = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r_i)
            self.schedule_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.schedule_table.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
            self.schedule_table.setItem(r_i, 2, QTableWidgetItem(str(row[2])))
            self.schedule_table.setItem(r_i, 3, QTableWidgetItem(row[3]))
            action_widget = QWidget()
            act_layout = QHBoxLayout(action_widget)
            act_layout.setContentsMargins(0, 0, 0, 0)
            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, idx=r_i: self.update_schedule(idx))
            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, idx=r_i: self.delete_schedule(idx))
            act_layout.addWidget(upd_btn)
            act_layout.addWidget(del_btn)
            act_layout.addStretch()
            self.schedule_table.setCellWidget(r_i, 4, action_widget)
        self.schedule_table.resizeColumnsToContents()

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_idx):
        sch_item = self.schedule_table.item(row_idx, 0)
        if not sch_item:
            return
        sch_id = int(sch_item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "Enter new datetime (YYYY-MM-DD HH:MM:SS):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?", (new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, row_idx):
        sch_item = self.schedule_table.item(row_idx, 0)
        if not sch_item:
            return
        sch_id = int(sch_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {sch_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sch_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Schedule {sch_id} removed.")
        self.load_schedules()

class DecisionTablesTab(QWidget):
    """
    Advanced management for Decision Tables and their rows.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.dt_table = QTableWidget(0, 5)
        self.dt_table.setHorizontalHeaderLabels(["ID", "Table Name", "Version", "Locked By", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)
        top_layout = QHBoxLayout()
        add_btn = QPushButton("Add Table")
        add_btn.clicked.connect(self.add_decision_table)
        top_layout.addWidget(add_btn)
        lock_btn = QPushButton("Lock Table")
        lock_btn.clicked.connect(self.lock_table)
        top_layout.addWidget(lock_btn)
        unlock_btn = QPushButton("Unlock Table")
        unlock_btn.clicked.connect(self.unlock_table)
        top_layout.addWidget(unlock_btn)
        del_btn = QPushButton("Delete Table")
        del_btn.clicked.connect(self.delete_table)
        top_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh Tables")
        refresh_btn.clicked.connect(self.load_tables)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.rows_table = QTableWidget(0, 5)
        self.rows_table.setHorizontalHeaderLabels(["Row ID", "Condition Expr", "Outcome", "Priority", "Stop On Match"])
        self.rows_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rows_table)
        row_layout = QHBoxLayout()
        add_row_btn = QPushButton("Add Row")
        add_row_btn.clicked.connect(self.add_dt_row)
        row_layout.addWidget(add_row_btn)
        del_row_btn = QPushButton("Delete Row")
        del_row_btn.clicked.connect(self.delete_dt_row)
        row_layout.addWidget(del_row_btn)
        refresh_rows_btn = QPushButton("Refresh Rows")
        refresh_rows_btn.clicked.connect(self.load_dt_rows)
        row_layout.addWidget(refresh_rows_btn)
        row_layout.addStretch()
        layout.addLayout(row_layout)
        self.dt_table.itemSelectionChanged.connect(self.load_dt_rows)
        self.setLayout(layout)
        self.load_tables()

    def load_tables(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT DECISION_TABLE_ID, TABLE_NAME, VERSION, LOCKED_BY, DESCRIPTION 
        FROM DECISION_TABLES
        ORDER BY DECISION_TABLE_ID
        """)
        for row in c.fetchall():
            r_i = self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.dt_table.setItem(r_i, j, QTableWidgetItem(str(val) if val is not None else ""))
    
    def get_selected_table_id(self):
        row = self.dt_table.currentRow()
        if row < 0:
            return None
        it = self.dt_table.item(row, 0)
        if not it:
            return None
        return int(it.text())
    
    def add_decision_table(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Table Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional description:")
        if not ok2:
            desc = ""
        c = self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES(?, ?)", (name.strip(), desc.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Decision table added.")
        self.load_tables()

    def lock_table(self):
        dtid = self.get_selected_table_id()
        if not dtid:
            QMessageBox.warning(self, "None", "No table selected.")
            return
        usern, ok = QInputDialog.getText(self, "Lock Table", "Enter your username:")
        if not ok or not usern.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT IS_LOCKED, LOCKED_BY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dtid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Error", "Decision table not found.")
            return
        is_locked = row[0]
        locked_by = row[1]
        if is_locked and locked_by != usern:
            QMessageBox.warning(self, "Locked", f"Table is locked by {locked_by}.")
            return
        c.execute("""
        UPDATE DECISION_TABLES
        SET IS_LOCKED = 1, LOCKED_BY = ?, LOCKED_TIMESTAMP = GETDATE()
        WHERE DECISION_TABLE_ID = ?
        """, (usern, dtid))
        self.connection.commit()
        QMessageBox.information(self, "Locked", f"Table {dtid} locked by {usern}.")
        self.load_tables()

    def unlock_table(self):
        dtid = self.get_selected_table_id()
        if not dtid:
            return
        usern, ok = QInputDialog.getText(self, "Unlock Table", "Enter your username:")
        if not ok or not usern.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT IS_LOCKED, LOCKED_BY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dtid,))
        row = c.fetchone()
        if not row:
            return
        is_locked = row[0]
        locked_by = row[1]
        if not is_locked:
            return
        if locked_by != usern:
            QMessageBox.warning(self, "Mismatch", f"Table locked by {locked_by}, not {usern}.")
            return
        c.execute("""
        UPDATE DECISION_TABLES
        SET IS_LOCKED = 0, LOCKED_BY = NULL, LOCKED_TIMESTAMP = NULL
        WHERE DECISION_TABLE_ID = ?
        """, (dtid,))
        self.connection.commit()
        QMessageBox.information(self, "Unlocked", f"Table {dtid} unlocked.")
        self.load_tables()

    def delete_table(self):
        dtid = self.get_selected_table_id()
        if not dtid:
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete decision table {dtid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLE_ROWS WHERE DECISION_TABLE_ID=?", (dtid,))
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dtid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Table {dtid} deleted.")
        self.load_tables()
        self.rows_table.setRowCount(0)

    def load_dt_rows(self):
        self.rows_table.setRowCount(0)
        dtid = self.get_selected_table_id()
        if not dtid:
            return
        c = self.connection.cursor()
        c.execute("""
        SELECT ROW_ID, CONDITION_EXPR, OUTCOME_VALUE, PRIORITY, STOP_ON_MATCH
        FROM DECISION_TABLE_ROWS
        WHERE DECISION_TABLE_ID=?
        ORDER BY PRIORITY DESC, ROW_ID
        """, (dtid,))
        for row in c.fetchall():
            r_i = self.rows_table.rowCount()
            self.rows_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.rows_table.setItem(r_i, j, QTableWidgetItem(str(val) if val is not None else ""))
    
    def get_selected_row_id(self):
        row = self.rows_table.currentRow()
        if row < 0:
            return None
        it = self.rows_table.item(row, 0)
        if not it:
            return None
        return int(it.text())
    
    def add_dt_row(self):
        dtid = self.get_selected_table_id()
        if not dtid:
            QMessageBox.warning(self, "No Table", "Select a decision table first.")
            return
        cond, ok = QInputDialog.getText(self, "Condition Expression", "Enter condition (e.g., colA > 100):")
        if not ok or not cond.strip():
            return
        outcome, ok2 = QInputDialog.getText(self, "Outcome Value", "Enter outcome (e.g., PASS, FAIL):")
        if not ok2:
            outcome = ""
        priority, ok3 = QInputDialog.getInt(self, "Priority", "Enter priority (higher numbers processed first):", value=1)
        if not ok3:
            priority = 1
        stop_val, ok4 = QInputDialog.getItem(self, "Stop on Match", "Stop on match?", ["0", "1"], 0, False)
        stop_on = True if stop_val == "1" else False
        c = self.connection.cursor()
        c.execute("""
        INSERT INTO DECISION_TABLE_ROWS(DECISION_TABLE_ID, CONDITION_EXPR, OUTCOME_VALUE, PRIORITY, STOP_ON_MATCH)
        VALUES(?, ?, ?, ?, ?)
        """, (dtid, cond.strip(), outcome.strip(), priority, 1 if stop_on else 0))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Row added to decision table.")
        self.load_dt_rows()

    def delete_dt_row(self):
        rowid = self.get_selected_row_id()
        if not rowid:
            QMessageBox.warning(self, "None", "No row selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete row {rowid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLE_ROWS WHERE ROW_ID=?", (rowid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Row deleted.")
        self.load_dt_rows()

class ConflictPriorityManagerTab(QWidget):
    """
    Basic CRUD for managing rule conflicts.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["Conflict ID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        btn_layout.addWidget(set_btn)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        for row in c.fetchall():
            r_i = self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.cf_table.setItem(r_i, j, QTableWidgetItem(str(val)))
    
    def add_conflict(self):
        r1, ok = QInputDialog.getInt(self, "Add Conflict", "Enter Rule ID1:")
        if not ok:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter Rule ID2:")
        if not ok2:
            return
        pri, ok3 = QInputDialog.getInt(self, "Priority", "Enter Priority (integer):", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?, ?, ?)", (r1, r2, pri))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Conflict added.")
        self.load_conflicts()
    
    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_item = self.cf_table.item(row, 0)
        if not cf_item:
            return
        cf_id = int(cf_item.text())
        newp, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:", value=1)
        if not ok:
            return
        c = self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (newp, cf_id))
        self.connection.commit()
        QMessageBox.information(self, "Updated", "Conflict priority updated.")
        self.load_conflicts()
    
    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_item = self.cf_table.item(row, 0)
        if not cf_item:
            return
        cf_id = int(cf_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Conflict deleted.")
        self.load_conflicts()

class CompositeRulesTab(QWidget):
    """
    Manage composite rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["Composite Rule ID", "Name", "Logic Expr", "Action On Pass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_crule)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.delete_crule)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_crules)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_crules()

    def load_crules(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        for row in c.fetchall():
            r_i = self.cr_table.rowCount()
            self.cr_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.cr_table.setItem(r_i, j, QTableWidgetItem(str(val) if val is not None else ""))
    
    def add_crule(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Enter Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getText(self, "Logic Expression", "Enter logic expression (e.g., 'Rule1==PASS and Rule2==PASS'):")
        if not ok2:
            expr = ""
        action, ok3 = QInputDialog.getText(self, "Action On Pass", "Enter action on pass (optional):")
        if not ok3:
            action = ""
        c = self.connection.cursor()
        c.execute("INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS) VALUES(?, ?, ?)", (name.strip(), expr.strip(), action.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Composite rule added.")
        self.load_crules()

    def delete_crule(self):
        row = self.cr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No composite rule selected.")
            return
        cr_item = self.cr_table.item(row, 0)
        if not cr_item:
            return
        cr_id = int(cr_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {cr_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (cr_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Composite rule deleted.")
        self.load_crules()

class SnapshotManagerTab(QWidget):
    """
    Manage snapshots of the BRM_RULES table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["Snapshot ID", "Name", "Created By", "Timestamp", "Snapshot JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)
        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_layout.addWidget(take_btn)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        for row in c.fetchall():
            r_i = self.ss_table.rowCount()
            self.ss_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.ss_table.setItem(r_i, j, QTableWidgetItem(str(val) if val is not None else ""))
    
    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Take Snapshot", "Enter snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows = c.fetchall()
        colnames = [desc[0] for desc in c.description]
        rules_list = [dict(zip(colnames, row)) for row in rows]
        snapshot_json = json.dumps(rules_list)
        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
        VALUES(?, 'SnapshotUser', ?)
        """, (name.strip(), snapshot_json))
        self.connection.commit()
        QMessageBox.information(self, "Snapshot", "Snapshot taken.")
        self.load_snapshots()

    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        ss_item = self.ss_table.item(row, 0)
        if not ss_item:
            return
        ss_id = int(ss_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {ss_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (ss_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Snapshot deleted.")
        self.load_snapshots()

class TagsManagerTab(QWidget):
    """
    Manage rule tags.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["Tag ID", "Rule ID", "Tag Name"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        btn_layout.addWidget(add_btn)
        rem_btn = QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        btn_layout.addWidget(rem_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tags)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        for row in c.fetchall():
            r_i = self.tags_table.rowCount()
            self.tags_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.tags_table.setItem(r_i, j, QTableWidgetItem(str(val)))
    
    def add_tag(self):
        rid, ok = QInputDialog.getInt(self, "Add Tag", "Enter Rule ID:")
        if not ok:
            return
        tag, ok2 = QInputDialog.getText(self, "Tag Name", "Enter tag name:")
        if not ok2 or not tag.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?, ?)", (rid, tag.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Tag added.")
        self.load_tags()
    
    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        tag_item = self.tags_table.item(row, 0)
        if not tag_item:
            return
        tag_id = int(tag_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Tag removed.")
        self.load_tags()

class DataValidationTab(QWidget):
    """
    Manage data validation rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.dv_table = QTableWidget(0, 5)
        self.dv_table.setHorizontalHeaderLabels(["Validation ID", "Table Name", "Column Name", "Validation Type", "Params"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_layout.addWidget(add_btn)
        rem_btn = QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_validation)
        btn_layout.addWidget(rem_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        for row in c.fetchall():
            r_i = self.dv_table.rowCount()
            self.dv_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.dv_table.setItem(r_i, j, QTableWidgetItem(str(val) if val is not None else ""))
    
    def add_validation(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Enter Table Name:")
        if not ok or not tbl.strip():
            return
        col, ok2 = QInputDialog.getText(self, "Column Name", "Enter Column Name:")
        if not ok2 or not col.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "Enter Validation Type (e.g., RANGE, NOT NULL):")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "Optional parameters:")
        if not ok4:
            params = ""
        c = self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS)
        VALUES(?, ?, ?, ?)
        """, (tbl.strip(), col.strip(), vtype.strip(), params.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Validation rule added.")
        self.load_validations()

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        it = self.dv_table.item(row, 0)
        if not it:
            return
        vid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete validation {vid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Validation deleted.")
        self.load_validations()

###############################################################################
# Fully Expanded Main Window and Related Feature Tabs (Part 4)
###############################################################################
class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.appr_table = QTableWidget(0, 7)
        self.appr_table.setHorizontalHeaderLabels(["Rule ID", "Group", "Rule Name", "Stage", "Approved?", "Approve", "Reject"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.appr_table)
        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        c = self.connection.cursor()
        query = """
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, A.APPROVAL_STAGE,
               R.RULE_NAME, R.APPROVAL_STATUS, A.ACTION_TYPE
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """
        c.execute(query, (self.logged_in_username,))
        rows = c.fetchall()
        def get_current_stage(rid, action_type):
            c2 = self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND ACTION_TYPE=? AND APPROVED_FLAG=0
            """, (rid, action_type))
            r2 = c2.fetchone()
            return r2[0] if r2 and r2[0] is not None else None
        filtered = []
        for rd in rows:
            rule_id = rd[0]
            stage = rd[4]
            action_type = rd[7]
            current_stage = get_current_stage(rule_id, action_type)
            if current_stage == stage:
                filtered.append(rd)
        self.appr_table.setRowCount(0)
        for rd in filtered:
            r_i = self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i, 0, QTableWidgetItem(str(rd[0])))
            self.appr_table.setItem(r_i, 1, QTableWidgetItem(rd[1]))
            self.appr_table.setItem(r_i, 2, QTableWidgetItem(rd[5]))
            self.appr_table.setItem(r_i, 3, QTableWidgetItem(str(rd[4])))
            self.appr_table.setItem(r_i, 4, QTableWidgetItem(str(rd[3])))
            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, idx=r_i: self.do_approve(idx))
            self.appr_table.setCellWidget(r_i, 5, approve_btn)
            reject_btn = QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, idx=r_i: self.do_reject(idx))
            self.appr_table.setCellWidget(r_i, 6, reject_btn)

    def do_approve(self, row_index):
        c = self.connection.cursor()
        rid = int(self.appr_table.item(row_index, 0).text())
        grp = self.appr_table.item(row_index, 1).text()
        c.execute("SELECT ACTION_TYPE FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0",
                  (rid, grp, self.logged_in_username))
        row = c.fetchone()
        if not row:
            return
        action_type = row[0]
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rid, grp, self.logged_in_username))
        c.execute("SELECT MIN(APPROVAL_STAGE) FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND ACTION_TYPE=? AND APPROVED_FLAG=0",
                  (rid, action_type))
        next_stage = c.fetchone()[0]
        if next_stage is None:
            if action_type == "CREATE_OR_UPDATE":
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?", (rid,))
            elif action_type == "DEACTIVATE":
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='INACTIVE' WHERE RULE_ID=?", (rid,))
            elif action_type == "DELETE":
                c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rid,))
                c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
                c.execute("DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID=? OR SOURCE_RULE_ID=?", (rid, rid))
        else:
            if action_type == "CREATE_OR_UPDATE":
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?", (rid,))
            elif action_type == "DEACTIVATE":
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='DEACTIVATE_IN_PROGRESS' WHERE RULE_ID=?", (rid,))
            elif action_type == "DELETE":
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='DELETE_IN_PROGRESS' WHERE RULE_ID=?", (rid,))
        from __main__ import add_audit_log
        old_data = {"APPROVED_FLAG": 0}
        new_data = {"APPROVED_FLAG": 1, "ACTION_TYPE": action_type}
        add_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rid, self.logged_in_username, old_data, new_data)
        self.connection.commit()
        QMessageBox.information(self, "Approved", f"Rule {rid} approved at current stage.")
        self.load_approvals()

    def do_reject(self, row_index):
        c = self.connection.cursor()
        rid = int(self.appr_table.item(row_index, 0).text())
        grp = self.appr_table.item(row_index, 1).text()
        confirm = QMessageBox.question(self, "Confirm", f"Reject rule {rid}?")
        if confirm != QMessageBox.Yes:
            return
        c.execute("SELECT ACTION_TYPE FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0",
                  (rid, grp, self.logged_in_username))
        row = c.fetchone()
        if not row:
            return
        action_type = row[0]
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """, (rid, grp, self.logged_in_username))
        if action_type == "CREATE_OR_UPDATE":
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?", (rid,))
        elif action_type == "DEACTIVATE":
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='ACTIVE' WHERE RULE_ID=?", (rid,))
        elif action_type == "DELETE":
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?", (rid,))
        from __main__ import add_audit_log
        add_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rid, self.logged_in_username, None, {"REJECTED": True, "ACTION_TYPE": action_type})
        self.connection.commit()
        QMessageBox.information(self, "Rejected", f"Rule {rid} rejected.")
        self.load_approvals()

class GlobalCriticalAdminTab(QWidget):
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        filter_layout = QHBoxLayout()
        self.show_only_gcr = QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_rule_list)
        filter_layout.addWidget(self.show_only_gcr)
        filter_layout.addWidget(refresh_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)
        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels(["Rule ID", "Rule Name", "Owner Group", "IS_GLOBAL", "CRITICAL_RULE", "CRITICAL_SCOPE", "STATUS", "UPDATED_BY"])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)
        gcs_layout = QHBoxLayout()
        self.global_cb = QCheckBox("Set Global?")
        gcs_layout.addWidget(self.global_cb)
        self.critical_cb = QCheckBox("Set Critical?")
        gcs_layout.addWidget(self.critical_cb)
        gcs_layout.addWidget(QLabel("Critical Scope:"))
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        gcs_layout.addWidget(self.scope_combo)
        apply_btn = QPushButton("Apply to Selected")
        apply_btn.clicked.connect(self.apply_flags)
        gcs_layout.addWidget(apply_btn)
        gcs_layout.addStretch()
        layout.addLayout(gcs_layout)
        link_layout = QHBoxLayout()
        self.gcr_rule_combo = QComboBox()
        link_layout.addWidget(QLabel("Parent GCR Rule:"))
        link_layout.addWidget(self.gcr_rule_combo)
        self.child_rule_combo = QComboBox()
        link_layout.addWidget(QLabel("Child Rule:"))
        link_layout.addWidget(self.child_rule_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_layout.addWidget(link_btn)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_layout.addWidget(unlink_btn)
        link_layout.addStretch()
        layout.addLayout(link_layout)
        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID", "Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)
        ref_all_btn = QPushButton("Refresh All")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, STATUS, UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, STATUS, UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        for row in c.fetchall():
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.rule_table.setItem(r_i, j, QTableWidgetItem(str(val)))
        self.rule_table.resizeColumnsToContents()

    def populate_gcr_combo(self):
        self.gcr_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        for row in c.fetchall():
            rid, rname = row[0], row[1]
            self.gcr_rule_combo.addItem(f"ID:{rid} - {rname}", rid)

    def populate_child_combo(self):
        self.child_rule_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            rid, rname = row[0], row[1]
            self.child_rule_combo.addItem(f"ID:{rid} - {rname}", rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        for row in c.fetchall():
            r_i = self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
        self.link_view.resizeColumnsToContents()

    def apply_flags(self):
        selected_rows = self.rule_table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self, "No Selection", "Select rule(s) first.")
            return
        is_global = 1 if self.global_cb.isChecked() else 0
        is_crit = 1 if self.critical_cb.isChecked() else 0
        scope_val = self.scope_combo.currentText().upper()
        confirm = QMessageBox.question(self, "Confirm", f"Apply flags to {len(selected_rows)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        for idx in selected_rows:
            row_idx = idx.row()
            rid = int(self.rule_table.item(row_idx, 0).text())
            c.execute("UPDATE BRM_RULES SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=? WHERE RULE_ID=?", (is_global, is_crit, scope_val, rid))
        self.connection.commit()
        QMessageBox.information(self, "Done", "Flags updated.")
        self.load_rule_list()

    def link_child(self):
        pid = self.gcr_rule_combo.currentData()
        cid = self.child_rule_combo.currentData()
        if not pid or not cid:
            QMessageBox.warning(self, "Error", "Select both parent and child.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Link child {cid} to parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        from __main__ import add_audit_log
        c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID) VALUES(?, ?)", (pid, cid))
        add_audit_log(self.connection, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{pid}->{cid}", "Admin", None, {"parent": pid, "child": cid})
        self.connection.commit()
        QMessageBox.information(self, "Linked", f"Child {cid} linked to parent {pid}.")
        self.load_link_view()

    def unlink_child(self):
        pid = self.gcr_rule_combo.currentData()
        cid = self.child_rule_combo.currentData()
        if not pid or not cid:
            return
        confirm = QMessageBox.question(self, "Confirm", f"Unlink child {cid} from parent {pid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        from __main__ import add_audit_log
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?", (pid, cid))
        add_audit_log(self.connection, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{pid}->{cid}", "Admin", {"parent": pid, "child": cid}, None)
        self.connection.commit()
        QMessageBox.information(self, "Unlinked", f"Child {cid} unlinked from parent {pid}.")
        self.load_link_view()

class HierarchyViewTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.tree = QTreeWidget()
        self.tree.setHeaderLabels(["Group / Rule"])
        layout.addWidget(self.tree)
        refresh_btn = QPushButton("Refresh Hierarchy")
        refresh_btn.clicked.connect(self.load_hierarchy)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.tree.clear()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        grp_map = {}
        for row in c.fetchall():
            gid, gname = row[0], row[1]
            item = QTreeWidgetItem([f"{gname} (ID={gid})"])
            self.tree.addTopLevelItem(item)
            grp_map[gid] = item
        c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            rid, rname, gid = row
            if gid in grp_map:
                parent_item = grp_map[gid]
                child = QTreeWidgetItem([f"Rule {rid}: {rname}"])
                parent_item.addChild(child)
        self.tree.expandAll()

class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.node_map = {}
        self.children_map = {}
        self.parents_map = {}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()
        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, RULE_TYPE_ID, CLUSTER_NAME, IS_GLOBAL, CRITICAL_RULE
        FROM BRM_RULES ORDER BY RULE_ID
        """)
        rows = c.fetchall()
        if not rows:
            self.scene.addText("No rules found.")
            return
        all_ids = set()
        for row in rows:
            rid = row[0]
            pid = row[2]
            all_ids.add(rid)
            if pid:
                self.children_map.setdefault(pid, []).append(rid)
                self.parents_map[rid] = pid
        roots = list(all_ids - set(self.parents_map.keys()))
        rule_lookup = {}
        for row in rows:
            rule_lookup[row[0]] = {
                "RULE_ID": row[0],
                "RULE_NAME": row[1],
                "PARENT_RULE_ID": row[2],
                "STATUS": row[3],
                "RULE_TYPE_ID": row[4],
                "CLUSTER_NAME": row[5] or "",
                "IS_GLOBAL": row[6],
                "CRITICAL_RULE": row[7]
            }
        from collections import deque
        queue = deque()
        level_map = {}
        visited = set()
        for rt in roots:
            queue.append((rt, 0))
        while queue:
            rid, depth = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            count = level_map.get(depth, 0)
            level_map[depth] = count + 1
            x = depth * 220
            y = count * 120
            node = self.create_node(rule_lookup[rid])
            node.setPos(x, y)
            self.scene.addItem(node)
            self.node_map[rid] = node
            if rid in self.children_map:
                for child in self.children_map[rid]:
                    queue.append((child, depth + 1))
        for row in rows:
            rid = row[0]
            pid = row[2]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, info):
        rtype = info["RULE_TYPE_ID"]
        status = info["STATUS"].lower()
        cluster = info["CLUSTER_NAME"]
        is_global = info["IS_GLOBAL"]
        is_crit = info["CRITICAL_RULE"]
        if rtype == 1:
            node = QtWidgets.QGraphicsRectItem(0, 0, 120, 50)
        else:
            node = QtWidgets.QGraphicsEllipseItem(0, 0, 120, 50)
        if status == "active":
            color = QColor("lightgreen")
        else:
            color = QColor("tomato")
        if cluster:
            hv = abs(hash(cluster)) % 360
            color = QColor.fromHsv(hv, 128, 255)
        node.setBrush(QtGui.QBrush(color))
        pen = QtGui.QPen(Qt.black, 2)
        if is_crit == 1:
            pen = QtGui.QPen(QColor("red"), 3)
        node.setPen(pen)
        disp = info["RULE_NAME"]
        if is_global == 1:
            disp = f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}")
        return node

    def draw_edge(self, item1, item2, color=QColor("darkblue")):
        r1 = item1.sceneBoundingRect()
        r2 = item2.sceneBoundingRect()
        p1 = r1.center()
        p2 = r2.center()
        line = QtWidgets.QGraphicsLineItem(p1.x(), p1.y(), p2.x(), p2.y())
        line.setPen(QtGui.QPen(color, 2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.chart = pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) as cnt FROM BRM_RULES GROUP BY STATUS")
        rows = c.fetchall()
        statuses = [r[0] for r in rows]
        counts = [r[1] for r in rows]
        self.chart.clear()
        if statuses:
            x = range(len(statuses))
            bar = pg.BarGraphItem(x=list(x), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar)
            self.chart.getAxis("bottom").setTicks([list(zip(x, statuses))])
            self.chart.setLabel("left", "Count")
            self.chart.setLabel("bottom", "Status")
            self.chart.showGrid(x=True, y=True)

class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.table_combo = QComboBox()
        tables = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS", "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE", "BRM_GROUP_BACKUPS", "BRM_COLUMN_MAPPING", "BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS", "BUSINESS_GROUP_APPROVERS", "BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS", "BRM_GLOBAL_CRITICAL_LINKS", "RULE_SCHEDULES",
            "BRM_RULE_COMMENTS", "DECISION_TABLES", "RULE_CONFLICTS", "COMPOSITE_RULES",
            "RULE_SNAPSHOTS", "RULE_TAGS", "DATA_VALIDATIONS", "RULE_EXECUTION_LOGS"
        ]
        for t in tables:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)
        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)
        self.data_table = QTableWidget(0, 0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
            return
        try:
            c.execute(f"SELECT * FROM {tbl}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            r_i = self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.data_table.setItem(r_i, j, QTableWidgetItem(str(val)))

class GroupManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)
        # Groups & Membership
        group_tab = QWidget()
        group_layout = QVBoxLayout(group_tab)
        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name", "Description", "Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        group_layout.addWidget(self.groups_table)
        btn_layout = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.add_group)
        btn_layout.addWidget(add_grp_btn)
        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.rename_group)
        btn_layout.addWidget(rename_grp_btn)
        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.delete_group)
        btn_layout.addWidget(del_grp_btn)
        btn_layout.addStretch()
        group_layout.addLayout(btn_layout)
        group_tab.setLayout(group_layout)
        self.tabs.addTab(group_tab, "Groups & Membership")
        # Permissions Tab
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        top_layout = QHBoxLayout()
        top_layout.addWidget(QLabel("Select Group:"))
        self.perm_group_combo = QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_layout.addWidget(self.perm_group_combo)
        top_layout.addStretch()
        perm_layout.addLayout(top_layout)
        self.perm_table = QTableWidget(0, 1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_layout.addWidget(self.perm_table)
        p_btn_layout = QHBoxLayout()
        addp_btn = QPushButton("Add Permission")
        addp_btn.clicked.connect(self.add_permission)
        p_btn_layout.addWidget(addp_btn)
        remp_btn = QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.remove_permission)
        p_btn_layout.addWidget(remp_btn)
        p_btn_layout.addStretch()
        perm_layout.addLayout(p_btn_layout)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab, "Permissions")
        # Approvers Tab
        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        top_appr = QHBoxLayout()
        top_appr.addWidget(QLabel("Group:"))
        self.appr_group_combo = QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        top_appr.addWidget(self.appr_group_combo)
        top_appr.addStretch()
        appr_layout.addLayout(top_appr)
        self.appr_table = QTableWidget(0, 2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID", "Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)
        a_btn_layout = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.add_approver)
        a_btn_layout.addWidget(add_appr_btn)
        del_appr_btn = QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.remove_approver)
        a_btn_layout.addWidget(del_appr_btn)
        a_btn_layout.addStretch()
        appr_layout.addLayout(a_btn_layout)
        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab, "Approvers")
        refresh_all = QPushButton("Refresh All")
        refresh_all.clicked.connect(self.load_data)
        layout.addWidget(refresh_all)
        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_group_combo()
        self.load_approvers()

    def load_groups(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        self.groups_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            self.groups_table.setItem(r_i, 0, QTableWidgetItem(row[0]))
            self.groups_table.setItem(r_i, 1, QTableWidgetItem(row[1] if row[1] else ""))
            self.groups_table.setItem(r_i, 2, QTableWidgetItem(row[2] if row[2] else ""))
    
    def load_group_combo(self):
        self.perm_group_combo.clear()
        self.appr_group_combo.clear()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            self.perm_group_combo.addItem(row[0], row[0])
            self.appr_group_combo.addItem(row[0], row[0])
    
    def add_group(self):
        name, ok = QInputDialog.getText(self, "Add Group", "Group Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self, "Error", "Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?, ?, ?)",
                  (name.strip(), desc.strip(), ""))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Group created.")
        self.load_data()
    
    def rename_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        grp = self.groups_table.item(row, 0).text().strip()
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self, "Error", "New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), grp))
            c.execute("COMMIT")
            QMessageBox.information(self, "Renamed", f"Group '{grp}' renamed to '{new_name}'.")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))
    
    def delete_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        grp = self.groups_table.item(row, 0).text().strip()
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{grp}'?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (grp,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Group removed.")
        self.load_data()
    
    def add_permission(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self, "No Group", "Select a group first.")
            return
        table, ok = QInputDialog.getText(self, "Add Permission", "Table Name (e.g., dbo.Table):")
        if not ok or not table.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME, TARGET_TABLE) VALUES(?, ?)", (grp.strip(), table.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Permission added.")
        self.load_permissions()
    
    def remove_permission(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self, "No Group", "Select a group.")
            return
        row = self.perm_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No permission selected.")
            return
        table_name = self.perm_table.item(row, 0).text().strip()
        confirm = QMessageBox.question(self, "Confirm", f"Remove permission '{table_name}' from {grp}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?", (grp.strip(), table_name))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Permission removed.")
        self.load_permissions()
    
    def load_permissions(self):
        grp = self.perm_group_combo.currentData()
        if not grp:
            return
        c = self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?", (grp.strip(),))
        self.perm_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i, 0, QTableWidgetItem(row[0]))
    
    def add_approver(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            QMessageBox.warning(self, "No Group", "Select a group first.")
            return
        usern, ok = QInputDialog.getText(self, "Add Approver", "Username:")
        if not ok or not usern.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES(?, ?)", (grp.strip(), usern.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", f"Approver '{usern}' added to {grp}.")
        self.load_approvers()
    
    def remove_approver(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        row = self.appr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No approver selected.")
            return
        appr_id = int(self.appr_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove approver {appr_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?", (appr_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Approver removed.")
        self.load_approvers()
    
    def load_approvers(self):
        grp = self.appr_group_combo.currentData()
        if not grp:
            return
        c = self.connection.cursor()
        c.execute("SELECT APPROVER_ID, USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (grp.strip(),))
        self.appr_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i, 1, QTableWidgetItem(row[1]))

class UserManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["User ID", "Username", "Password", "Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_layout.addWidget(del_btn)
        pass_btn = QPushButton("Change Password")
        pass_btn.clicked.connect(self.change_password)
        btn_layout.addWidget(pass_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_users)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            r_i = self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            for j, val in enumerate(row):
                self.user_table.setItem(r_i, j, QTableWidgetItem(str(val)))
    
    def add_user(self):
        name, ok = QInputDialog.getText(self, "Add User", "Username:")
        if not ok or not name.strip():
            return
        pwd, ok2 = QInputDialog.getText(self, "Password", "Password:")
        if not ok2 or not pwd.strip():
            return
        grp, ok3 = QInputDialog.getText(self, "Group", "Enter group (e.g., BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?", (name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self, "Error", "Username already exists.")
            return
        c.execute("INSERT INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?, ?, ?)", (name.strip(), pwd.strip(), grp.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Created", "User added.")
        self.load_users()

    def delete_user(self):
        row = self.user_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        uid = int(self.user_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete user ID {uid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?", (uid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "User removed.")
        self.load_users()

    def change_password(self):
        row = self.user_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        uid = int(self.user_table.item(row, 0).text())
        new_pwd, ok = QInputDialog.getText(self, "Change Password", "Enter new password:")
        if not ok or not new_pwd.strip():
            return
        c = self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?", (new_pwd.strip(), uid))
        self.connection.commit()
        QMessageBox.information(self, "Updated", "Password changed.")
        self.load_users()

class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_layout.addWidget(self.new_group_edit)
        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_layout.addWidget(create_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_layout.addWidget(del_btn)
        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_layout.addWidget(backup_btn)
        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_layout.addWidget(restore_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        splitter = QtWidgets.QSplitter(Qt.Horizontal)
        self.tree = QTreeWidget()
        self.tree.setHeaderLabels(["Custom Group / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)
        right_widget = QWidget()
        rw_layout = QVBoxLayout(right_widget)
        self.rule_search = QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules...")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)
        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)
        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID DESC")
        for row in c.fetchall():
            cg_id, cg_name, owner = row
            display = f"{cg_name} ({owner})"
            group_item = QTreeWidgetItem([display])
            group_item.setData(0, Qt.UserRole, cg_id)
            group_item.setBackground(0, QtGui.QBrush(QColor("lightgray")))
            self.tree.addTopLevelItem(group_item)
            c2 = self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """, (cg_id,))
            for r in c2.fetchall():
                rid, rname, is_global, is_crit = r
                child_item = QTreeWidgetItem([f"Rule {rid}: {rname}"])
                child_item.setData(0, Qt.UserRole, rid)
                if is_global == 1:
                    child_item.setBackground(0, QtGui.QBrush(QColor("lightblue")))
                if is_crit == 1:
                    child_item.setBackground(0, QtGui.QBrush(QColor("lightcoral")))
                group_item.addChild(child_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt = self.rule_search.text().strip()
        c = self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """, (f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        rows = c.fetchall()
        c2 = self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned = set(r[0] for r in c2.fetchall())
        for r in rows:
            rid, rname, owner = r
            if rid in assigned:
                continue
            display = f"Rule {rid}: {rname} (Owner {owner})"
            item = QListWidgetItem(display)
            item.setData(Qt.UserRole, rid)
            self.rule_list.addItem(item)

    def on_tree_context(self, pos):
        item = self.tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent:
            menu = QMenu()
            remove_act = menu.addAction("Remove Rule from Group")
            chosen = menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen == remove_act:
                group_id = parent.data(0, Qt.UserRole)
                rule_id = item.data(0, Qt.UserRole)
                c = self.connection.cursor()
                c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?", (group_id, rule_id))
                self.connection.commit()
                QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group.")
                self.refresh_all()

    def get_selected_group(self):
        sel = self.tree.selectedItems()
        if not sel:
            return None, None
        item = sel[0]
        if item.parent():
            item = item.parent()
        return item.data(0, Qt.UserRole), item.text(0)

    def create_group(self):
        name = self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Error", "No group name provided.")
            return
        c = self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP)
        VALUES(?, ?, ?, GETDATE())
        """, (name, self.user_group, f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self, "Created", f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def rename_group(self):
        group_id, disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", "Enter new custom group name:")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?", (new_name.strip(), group_id))
            self.connection.commit()
            QMessageBox.information(self, "Renamed", f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_group(self):
        group_id, disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete custom group {group_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group {group_id} deleted.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def backup_group(self):
        group_id, disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Error", "Group not found.")
            return
        grp_name = row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
        members = [r[0] for r in c.fetchall()]
        backup_data = {"group_name": grp_name, "members": members}
        c.execute("SELECT ISNULL(MAX(BACKUP_VERSION), 0) + 1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
        new_ver = c.fetchone()[0]
        backup_json = json.dumps(backup_data)
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON)
        VALUES(?, GETDATE(), ?, ?)
        """, (group_id, new_ver, backup_json))
        self.connection.commit()
        QMessageBox.information(self, "Backup", f"Backup version {new_ver} created for group {group_id}.")
        self.refresh_all()

    def restore_group(self):
        group_id, disp = self.get_selected_group()
        if not group_id:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        c = self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """, (group_id,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self, "None", "No backups found.")
            return
        items = [f"Version {r[0]} (ts {r[1]})" for r in rows]
        sel, ok = QInputDialog.getItem(self, "Restore", "Select backup version:", items, 0, False)
        if not ok or not sel:
            return
        import re
        m = re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver = int(m.group(1))
        confirm = QMessageBox.question(self, "Confirm", f"Restore group {group_id} to version {ver}?")
        if confirm != QMessageBox.Yes:
            return
        backup_json = None
        for r in rows:
            if r[0] == ver:
                backup_json = r[2]
                break
        if not backup_json:
            QMessageBox.warning(self, "Error", "Backup not found.")
            return
        backup_data = json.loads(backup_json)
        new_name = backup_data["group_name"]
        members = backup_data["members"]
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?", (new_name, group_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            for mid in members:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?, ?)", (group_id, mid))
            c.execute("COMMIT")
            QMessageBox.information(self, "Restored", f"Group {group_id} restored to version {ver}.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))

    def assign_rules(self):
        sel_items = self.tree.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "None", "No group selected in the tree.")
            return
        group_item = sel_items[0]
        if group_item.parent():
            group_item = group_item.parent()
        group_id = group_item.data(0, Qt.UserRole)
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "None", "No rules selected in the list.")
            return
        c = self.connection.cursor()
        count = 0
        for item in selected_rules:
            rid = item.data(Qt.UserRole)
            try:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?, ?)", (group_id, rid))
                count += 1
            except Exception:
                pass
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"{count} rule(s) assigned.")
        self.refresh_all()

class AlertsAndDashboardsTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)
        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)
        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
               DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE = (SELECT MIN(APPROVAL_STAGE) FROM BRM_RULE_APPROVALS WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0)
          AND DATEDIFF(DAY, ISNULL(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) > 3
        """)
        old_ap = c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for row in old_ap:
                lines.append(f" - Rule {row[0]} (Stage {row[1]}), Age {row[3]} days, Rule: {row[2]}")
        else:
            lines.append("No old approvals found.")
        lines.append("")
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME BETWEEN GETDATE() AND DATEADD(HOUR, 24, GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upcoming = c.fetchall()
        if upcoming:
            lines.append("Upcoming schedules in next 24 hours:")
            for up in upcoming:
                lines.append(f" - ID {up[0]}, Rule {up[1]}, Time {up[2]}")
        else:
            lines.append("No upcoming schedules.")
        self.alert_text.setPlainText("\n".join(lines))

class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs – Full Integration")
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        layout.addLayout(top_layout)
        self.audit_table = QTableWidget(0, 8)
        self.audit_table.setHorizontalHeaderLabels(["Audit ID", "Action", "Table", "Record ID", "Action By", "Old Data", "New Data", "Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_layout.addWidget(refresh_btn)
        export_btn = QPushButton("Export to CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addWidget(export_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.audit_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        for row in c.fetchall():
            r_i = self.audit_table.rowCount()
            self.audit_table.insertRow(r_i)
            self.audit_table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.audit_table.setItem(r_i, 1, QTableWidgetItem(row[1]))
            self.audit_table.setItem(r_i, 2, QTableWidgetItem(row[2]))
            self.audit_table.setItem(r_i, 3, QTableWidgetItem(row[3]))
            self.audit_table.setItem(r_i, 4, QTableWidgetItem(row[4]))
            old_txt = ""
            if row[5]:
                try:
                    old_txt = json.dumps(json.loads(row[5]), indent=2)
                except Exception:
                    old_txt = row[5]
            self.audit_table.setItem(r_i, 5, QTableWidgetItem(old_txt))
            new_txt = ""
            if row[6]:
                try:
                    new_txt = json.dumps(json.loads(row[6]), indent=2)
                except Exception:
                    new_txt = row[6]
            self.audit_table.setItem(r_i, 6, QTableWidgetItem(new_txt))
            self.audit_table.setItem(r_i, 7, QTableWidgetItem(str(row[7])))

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            show = False
            for col in (1, 2, 4):
                item = self.audit_table.item(row, col)
                if item and txt_l in item.text().lower():
                    show = True
                    break
            self.audit_table.setRowHidden(row, not show)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Save CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        import csv
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            headers = [self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row):
                    continue
                row_data = []
                for col in range(self.audit_table.columnCount()):
                    item = self.audit_table.item(row, col)
                    row_data.append(item.text() if item else "")
                writer.writerow(row_data)
        QMessageBox.information(self, "Exported", "Audit logs exported.")

class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules – Full Integration")
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter rule name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        layout.addLayout(top_layout)
        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID", "Name", "SQL", "Status", "Version", "Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_results)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """, (f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        self.res_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for j in range(6):
                self.res_table.setItem(r_i, j, QTableWidgetItem(str(row[j])))

class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id}")
        self.resize(800, 400)
        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 5)
        self.table.setHorizontalHeaderLabels(["Audit ID", "Action", "Timestamp", "Old Data", "New Data"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)
        btn_layout = QHBoxLayout()
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.rollback_selected)
        btn_layout.addWidget(rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT', 'UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """, (self.rule_id,))
        for row in c.fetchall():
            r_i = self.table.rowCount()
            self.table.insertRow(r_i)
            self.table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.table.setItem(r_i, 1, QTableWidgetItem(row[1]))
            self.table.setItem(r_i, 2, QTableWidgetItem(str(row[2])))
            self.table.setItem(r_i, 3, QTableWidgetItem(row[3] if row[3] else ""))
            self.table.setItem(r_i, 4, QTableWidgetItem(row[4] if row[4] else ""))
    
    def rollback_selected(self):
        sel_items = self.table.selectedItems()
        if not sel_items:
            QMessageBox.warning(self, "None", "No row selected for rollback.")
            return
        row = sel_items[0].row()
        old_data_item = self.table.item(row, 3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self, "No Data", "No old data available for rollback.")
            return
        confirm = QMessageBox.question(self, "Confirm", "Rollback to selected version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_data_item.text())
            self.apply_rollback(old_data)
            QMessageBox.information(self, "Rolled Back", "Rollback completed.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    
    def apply_rollback(self, old_data):
        rid = old_data["RULE_ID"]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        if not c.fetchone():
            raise Exception("Rule not found for rollback.")
        c.execute("BEGIN TRANSACTION")
        new_sql = old_data["RULE_SQL"]
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME = ?,
            RULE_SQL = ?,
            OWNER_GROUP = ?,
            STATUS = 'INACTIVE',
            VERSION = VERSION + 1,
            UPDATED_BY = 'Rollback',
            APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS'
        WHERE RULE_ID = ?
        """, (old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rid))
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
        from __main__ import enhanced_advanced_extract_tables, detect_operation_type
        op_type = detect_operation_type(new_sql)
        parse_info = enhanced_advanced_extract_tables(new_sql)
        col_op = "WRITE" if op_type in ("INSERT", "UPDATE", "DELETE") else "READ"
        for (sch, tbl, alias, _) in parse_info["tables"]:
            if tbl and not tbl.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP)
                VALUES(?, ?, ?, ?, ?)
                """, (rid, sch if sch else "N/A", tbl, "RolledBackCol", col_op))
        c.execute("COMMIT")

class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL snippet...")
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_layout.addWidget(QLabel("Status:"))
        top_layout.addWidget(self.status_filter)
        lock_btn = QPushButton("Lock Rule")
        lock_btn.clicked.connect(self.lock_rule)
        top_layout.addWidget(lock_btn)
        unlock_btn = QPushButton("Unlock Rule")
        unlock_btn.clicked.connect(self.unlock_rule)
        top_layout.addWidget(unlock_btn)
        layout.addLayout(top_layout)
        self.rule_table = QTableWidget(0, 10)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Name", "SQL", "Status", "Version", "Owner Group",
            "Created TS", "Approval Status", "Locked By", "DecisionTableID"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule)
        layout.addWidget(self.rule_table)
        nav_layout = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        self.page_label = QLabel("Page 1/1")
        nav_layout.addWidget(self.prev_btn)
        nav_layout.addWidget(self.page_label)
        nav_layout.addWidget(self.next_btn)
        layout.addLayout(nav_layout)
        self.setLayout(layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.load_rules()

    def build_filter_query(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        count_q = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q, params)
        total = c.fetchone()[0]
        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        if self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page
        data_q = f"""
        SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
               CREATED_TIMESTAMP, APPROVAL_STATUS, LOCKED_BY, DECISION_TABLE_ID
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*params, offset, self.records_per_page))
        self.rule_table.setRowCount(0)
        for row in c.fetchall():
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for j, val in enumerate(row):
                item = QTableWidgetItem(str(val) if val is not None else "")
                if j == 3:
                    st = str(val).lower()
                    if st == "active":
                        item.setBackground(QColor(144, 238, 144))
                    elif st == "inactive":
                        item.setBackground(QColor(255, 182, 193))
                self.rule_table.setItem(r_i, j, item)

    def update_selected_rule(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
        else:
            self.selected_rule_id = int(self.rule_table.item(sel[0].row(), 0).text())

    def get_selected_rule_ids(self):
        ids = []
        for index in self.rule_table.selectionModel().selectedRows():
            row = index.row()
            item = self.rule_table.item(row, 0)
            if item:
                ids.append(int(item.text()))
        return ids

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

    def lock_rule(self):
        from __main__ import lock_rule
        rids = self.get_selected_rule_ids()
        if len(rids) != 1:
            QMessageBox.warning(self, "Select One", "Select exactly one rule to lock.")
            return
        rid = rids[0]
        user_name = f"User:{self.user_id}"
        try:
            lock_rule(self.connection, rid, user_name)
            QMessageBox.information(self, "Locked", f"Rule {rid} locked by {user_name}.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def unlock_rule(self):
        from __main__ import unlock_rule
        rids = self.get_selected_rule_ids()
        if len(rids) != 1:
            QMessageBox.warning(self, "Select One", "Select exactly one rule to unlock.")
            return
        rid = rids[0]
        user_name = f"User:{self.user_id}"
        try:
            unlock_rule(self.connection, rid, user_name)
            QMessageBox.information(self, "Unlocked", f"Rule {rid} unlocked.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class RuleEditorDialog(QDialog):
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = rule_data is not None
        title = "Update Rule" if self.is_update else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(800, 600)
        self.main_layout = QVBoxLayout(self)
        form = QFormLayout()
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            disp = f"{row[1]} (ID={row[0]})"
            self.group_combo.addItem(disp, row[0])
        form.addRow("Rule Group:", self.group_combo)
        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            disp = f"{row[1]} (ID={row[0]})"
            self.parent_combo.addItem(disp, row[0])
        form.addRow("Parent Rule:", self.parent_combo)
        self.name_edit = QLineEdit()
        form.addRow("Rule Name:", self.name_edit)
        self.rule_type_combo = QComboBox()
        c.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for row in c.fetchall():
            self.rule_type_combo.addItem(row[1], row[0])
        form.addRow("Rule Type:", self.rule_type_combo)
        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE", "ACTIVE"])
        form.addRow("Status:", self.status_combo)
        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form.addRow("Effective Start:", self.start_dt)
        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form.addRow("Effective End:", self.end_dt)
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, 0 => FAIL.")
        form.addRow("Rule SQL:", self.sql_edit)
        self.desc_edit = QTextEdit()
        form.addRow("Description:", self.desc_edit)
        self.just_edit = QTextEdit()
        form.addRow("Justification:", self.just_edit)
        self.global_cb = None
        if self.user_group == "Admin":
            self.global_cb = QCheckBox("Global (Admin only)")
            form.addRow("Global Rule:", self.global_cb)
        self.critical_cb = QCheckBox()
        form.addRow("Critical Rule:", self.critical_cb)
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        form.addRow("Critical Scope:", self.scope_combo)
        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "UPSERT", "INSERT_ONLY"])
        form.addRow("CDC Type:", self.cdc_combo)
        self.decision_combo = QComboBox()
        self.decision_combo.addItem("(None)", None)
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in c.fetchall():
            disp = f"{row[1]} (ID={row[0]})"
            self.decision_combo.addItem(disp, row[0])
        form.addRow("Decision Table:", self.decision_combo)
        self.main_layout.addLayout(form)
        btn_layout = QHBoxLayout()
        self.save_btn = QPushButton("Save" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_layout.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        self.main_layout.addLayout(btn_layout)
        self.setLayout(self.main_layout)
        if self.is_update and self.rule_data:
            self.load_existing()

    def load_existing(self):
        rd = self.rule_data
        gid = rd.get("GROUP_ID")
        if gid:
            ix = self.group_combo.findData(gid)
            if ix >= 0:
                self.group_combo.setCurrentIndex(ix)
        pid = rd.get("PARENT_RULE_ID")
        if pid:
            ix2 = self.parent_combo.findData(pid)
            if ix2 >= 0:
                self.parent_combo.setCurrentIndex(ix2)
        else:
            self.parent_combo.setCurrentIndex(0)
        self.name_edit.setText(rd.get("RULE_NAME", ""))
        rt_id = rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3 = self.rule_type_combo.findData(rt_id)
            if ix3 >= 0:
                self.rule_type_combo.setCurrentIndex(ix3)
        st = rd.get("STATUS", "INACTIVE")
        ix4 = self.status_combo.findText(st)
        if ix4 >= 0:
            self.status_combo.setCurrentIndex(ix4)
        fmt = "%Y-%m-%d %H:%M:%S"
        sd = rd.get("EFFECTIVE_START_DATE", "")
        if sd:
            try:
                dt_obj = datetime.strptime(sd, fmt)
                self.start_dt.setDateTime(QDateTime(dt_obj))
            except Exception:
                pass
        ed = rd.get("EFFECTIVE_END_DATE", "")
        if ed:
            try:
                dt_obj2 = datetime.strptime(ed, fmt)
                self.end_dt.setDateTime(QDateTime(dt_obj2))
            except Exception:
                pass
        self.sql_edit.setPlainText(rd.get("RULE_SQL", ""))
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        if self.user_group == "Admin" and "IS_GLOBAL" in rd:
            if rd["IS_GLOBAL"] == 1 and self.global_cb:
                self.global_cb.setChecked(True)
        if rd.get("CRITICAL_RULE", 0) == 1:
            self.critical_cb.setChecked(True)
        scp = rd.get("CRITICAL_SCOPE", "NONE")
        ix5 = self.scope_combo.findText(scp)
        if ix5 >= 0:
            self.scope_combo.setCurrentIndex(ix5)
        cdcv = rd.get("CDC_TYPE", "NONE")
        ix6 = self.cdc_combo.findText(cdcv)
        if ix6 >= 0:
            self.cdc_combo.setCurrentIndex(ix6)
        dtid = rd.get("DECISION_TABLE_ID")
        if dtid:
            ix7 = self.decision_combo.findData(dtid)
            if ix7 >= 0:
                self.decision_combo.setCurrentIndex(ix7)

    def on_save(self):
        nm = self.name_edit.text().strip()
        sql_ = self.sql_edit.toPlainText().strip()
        if not nm:
            QMessageBox.warning(self, "Error", "Rule name is required.")
            return
        if not sql_:
            QMessageBox.warning(self, "Error", "SQL cannot be empty.")
            return
        group_id = self.group_combo.currentData()
        parent_id = self.parent_combo.currentData()
        rt_id = self.rule_type_combo.currentData()
        st = self.status_combo.currentText()
        sd = self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        ed = self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        desc_ = self.desc_edit.toPlainText().strip()
        just_ = self.just_edit.toPlainText().strip()
        is_g = 0
        if self.user_group == "Admin" and self.global_cb and self.global_cb.isChecked():
            is_g = 1
        isc = 1 if self.critical_cb.isChecked() else 0
        scp_ = self.scope_combo.currentText()
        cdcv = self.cdc_combo.currentText()
        dtid = self.decision_combo.currentData()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?", (group_id,))
        row = c.fetchone()
        gname = row[0] if row else "BG1"
        rule_dict = {
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id if parent_id else None,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sd,
            "EFFECTIVE_END_DATE": ed,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": is_g,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdcv,
            "OWNER_GROUP": gname,
            "DECISION_TABLE_ID": dtid
        }
        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm", "Update rule?")
            if confirm != QMessageBox.Yes:
                return
            from __main__ import update_rule
            try:
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self, "Success", f"Rule '{nm}' updated. Re-approval triggered.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
        else:
            confirm = QMessageBox.question(self, "Confirm", "Add new rule?")
            if confirm != QMessageBox.Yes:
                return
            from __main__ import add_rule
            try:
                new_id = add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self, "Success", f"Rule '{nm}' created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Enhanced")
        self.resize(1300, 850)
        self.connection = None
        from __main__ import DatabaseConnectionDialog
        dbdlg = DatabaseConnectionDialog()
        if dbdlg.exec_() == QDialog.Accepted:
            self.connection = dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)
        from __main__ import LoginDialog
        logdlg = LoginDialog(self.connection)
        if logdlg.exec_() != QDialog.Accepted:
            sys.exit(0)
        self.user_id = logdlg.user_id
        c = self.connection.cursor()
        c.execute("SELECT USERNAME, USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        row = c.fetchone()
        if not row:
            sys.exit(0)
        self.logged_in_username = row[0]
        self.user_group = row[1]
        self.init_ui()

    def init_ui(self):
        from __main__ import (
            MultiStepApprovalTab, RuleDashboard, ChainSimulationDialog, GroupSimulationDialog,
            EnhancedScheduleDialog, ScheduleManagementTab, DecisionTablesTab, ConflictPriorityManagerTab,
            CompositeRulesTab, SnapshotManagerTab, TagsManagerTab, DataValidationTab, CtrlTablesTab,
            MetricsDashboardTab, AlertsAndDashboardsTab, GroupManagementTab, UserManagementTab,
            CustomRuleGroupEnhancedTab, AuditLogViewer, SearchRuleDialog, VersionHistoryDialog, sync_metadata_improved
        )
        menubar = self.menuBar()
        fileMenu = menubar.addMenu("File")
        syncAct = QAction("Sync Metadata", self)
        syncAct.triggered.connect(self.sync_metadata)
        fileMenu.addAction(syncAct)
        metricsAct = QAction("View Metrics Dashboard", self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)
        schedAct = QAction("New Schedule (Dialog)", self)
        schedAct.triggered.connect(self.launch_schedule)
        fileMenu.addAction(schedAct)
        chainAct = QAction("Simulate Rule Chain", self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)
        grpAct = QAction("Simulate Custom Group", self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)
        helpMenu = menubar.addMenu("Help")
        usageAct = QAction("Show Tips", self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        if self.user_group == "Admin":
            top_h = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            main_layout.addLayout(top_h)
            self.populate_switch_combo()
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)
        # Business Rules Tab
        br_widget = QWidget()
        br_layout = QVBoxLayout(br_widget)
        btn_layout = QHBoxLayout()
        add_rule_btn = QPushButton("Add Rule")
        add_rule_btn.clicked.connect(self.add_rule)
        btn_layout.addWidget(add_rule_btn)
        update_rule_btn = QPushButton("Update Rule")
        update_rule_btn.clicked.connect(self.update_rule)
        btn_layout.addWidget(update_rule_btn)
        deactivate_rule_btn = QPushButton("Deactivate")
        deactivate_rule_btn.clicked.connect(self.deactivate_rule)
        btn_layout.addWidget(deactivate_rule_btn)
        delete_rule_btn = QPushButton("Delete")
        delete_rule_btn.clicked.connect(self.delete_rule)
        btn_layout.addWidget(delete_rule_btn)
        etl_btn = QPushButton("Run ETL (BFS)")
        etl_btn.clicked.connect(self.run_etl)
        btn_layout.addWidget(etl_btn)
        sim_rule_btn = QPushButton("Simulate Rule")
        sim_rule_btn.clicked.connect(self.simulate_rule)
        btn_layout.addWidget(sim_rule_btn)
        btn_layout.addStretch()
        br_layout.addLayout(btn_layout)
        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        br_layout.addWidget(self.rule_dash)
        br_widget.setLayout(br_layout)
        self.tabs.addTab(br_widget, "Business Rules")
        # Approvals Tab
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")
        # Global/Critical Admin (Admin only)
        if self.user_group == "Admin":
            from __main__ import GlobalCriticalAdminTab
            self.gcr_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_tab, "Global/Critical Admin")
        # Hierarchy Tab
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hierarchy_tab, "Hierarchy")
        # Lineage Tab
        from __main__ import EnhancedLineageGraphWidget
        lin_widget = QWidget()
        lin_layout = QVBoxLayout(lin_widget)
        lin_label = QLabel("Lineage Visualization")
        lin_label.setStyleSheet("font-weight:bold;")
        lin_layout.addWidget(lin_label)
        self.lineage_graph = EnhancedLineageGraphWidget(self.connection)
        lin_layout.addWidget(self.lineage_graph)
        line_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table...")
        search_btn = QPushButton("Search")
        search_btn.clicked.connect(lambda: self.lineage_graph.search_nodes(self.lineage_search.text()))
        reset_btn = QPushButton("Reset")
        reset_btn.clicked.connect(self.lineage_graph.resetView)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.lineage_graph.populate_graph)
        line_h.addWidget(self.lineage_search)
        line_h.addWidget(search_btn)
        line_h.addWidget(reset_btn)
        line_h.addWidget(refresh_btn)
        line_h.addStretch()
        lin_layout.addLayout(line_h)
        lin_widget.setLayout(lin_layout)
        self.tabs.addTab(lin_widget, "Lineage")
        # Custom Groups Tab
        from __main__ import CustomRuleGroupEnhancedTab
        self.custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_groups_tab, "Custom Groups")
        # Scheduling Tab
        from __main__ import ScheduleManagementTab
        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Scheduling")
        # Control Tables Tab
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")
        # Metrics Tab
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics")
        # Alerts & Dashboards Tab
        from __main__ import AlertsAndDashboardsTab
        self.alert_tab = AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.alert_tab, "Alerts & Dashboards")
        # Group Management Tab
        from __main__ import GroupManagementTab
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.group_mgmt_tab, "Group Management")
        # User Management Tab (Admin only)
        if self.user_group == "Admin":
            from __main__ import UserManagementTab
            self.user_mgmt_tab = UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab, "User Management")
        # Tools Menu
        tools_menu = self.menuBar().addMenu("Tools")
        from __main__ import AuditLogViewer, SearchRuleDialog, VersionHistoryDialog
        audit_act = QAction("Audit Logs", self)
        audit_act.triggered.connect(self.launch_audit_log)
        tools_menu.addAction(audit_act)
        search_act = QAction("Search Rules", self)
        search_act.triggered.connect(self.launch_search)
        tools_menu.addAction(search_act)
        version_act = QAction("Version History", self)
        version_act.triggered.connect(self.launch_version_history)
        tools_menu.addAction(version_act)
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)
        self.approvals_timer = QTimer(self)
        self.approvals_timer.timeout.connect(self.approvals_tab.load_approvals)
        self.approvals_timer.start(5000)
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules)
        self.schedule_timer.start(60000)
        self.show()

    def sync_metadata(self):
        from __main__ import sync_metadata_improved
        sync_metadata_improved(self.connection)

    def show_metrics_dialog(self):
        from __main__ import MetricsDashboardTab
        dlg = QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800, 600)
        layout = QVBoxLayout(dlg)
        chart = MetricsDashboardTab(self.connection)
        layout.addWidget(chart)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        layout.addWidget(close_btn)
        dlg.exec_()

    def launch_schedule(self):
        from __main__ import EnhancedScheduleDialog
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()

    def launch_chain_sim(self):
        from __main__ import ChainSimulationDialog
        dlg = ChainSimulationDialog(self.connection, self)
        dlg.exec_()

    def launch_group_sim(self):
        from __main__ import GroupSimulationDialog
        dlg = GroupSimulationDialog(self.connection, self)
        dlg.exec_()

    def show_help(self):
        QMessageBox.information(self, "Help", "Use the tabs to manage rules, approvals, scheduling, and more.")

    def switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid == self.user_id and new_grp == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        QMessageBox.information(self, "Switched", f"Now impersonating user {new_uid} with group {new_grp}.")

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            uid, uname, ugrp = row
            self.switch_combo.addItem(f"{uname} ({ugrp})", (uid, ugrp))

    def add_rule(self):
        from __main__ import RuleEditorDialog
        dlg = RuleEditorDialog(self.connection, self.user_group, None, self)
        if dlg.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Success", "New rule added.")
            self.rule_dash.load_rules()

    def update_rule(self):
        from __main__ import RuleEditorDialog, lock_rule
        rids = self.rule_dash.get_selected_rule_ids()
        if len(rids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule to update.")
            return
        rid = rids[0]
        try:
            lock_rule(self.connection, rid, f"User:{self.user_id}")
        except Exception as ex:
            QMessageBox.critical(self, "Lock Error", str(ex))
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", f"Rule {rid} not found.")
            return
        cols = [desc[0] for desc in c.description]
        rule_data = dict(zip(cols, row))
        dlg = RuleEditorDialog(self.connection, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Updated", f"Rule {rid} updated.")
            self.rule_dash.load_rules()

    def deactivate_rule(self):
        from __main__ import deactivate_rule
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        success = 0
        fails = []
        for rid in rids:
            try:
                deactivate_rule(self.connection, rid, f"User:{self.user_id}", self.user_group)
                success += 1
            except Exception as ex:
                fails.append(str(ex))
        msg = f"Deactivation complete. Success: {success}."
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dash.load_rules()

    def delete_rule(self):
        from __main__ import delete_rule
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        fails = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, f"User:{self.user_id}", self.user_group)
                success += 1
            except Exception as ex:
                fails.append(str(ex))
        msg = f"Deletion complete. Success: {success}."
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dash.load_rules()

    def run_etl(self):
        from __main__ import execute_rules_in_order
        executed, skipped = execute_rules_in_order(self.connection, {})
        msg = f"ETL BFS executed: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self, "ETL BFS", msg)
        self.rule_dash.load_rules()

    def simulate_rule(self):
        from __main__ import SingleRuleSimulationDialog
        rids = self.rule_dash.get_selected_rule_ids()
        if len(rids) != 1:
            QMessageBox.warning(self, "Error", "Select exactly one rule.")
            return
        rid = rids[0]
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Not Found", "Rule not found.")
            return
        sql_ = row[0]
        dlg = SingleRuleSimulationDialog(self.connection, rid, sql_, self)
        dlg.exec_()

    def launch_audit_log(self):
        from __main__ import AuditLogViewer
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search(self):
        from __main__ import SearchRuleDialog
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_version_history(self):
        from __main__ import VersionHistoryDialog
        rid, ok = QInputDialog.getInt(self, "Version History", "Enter rule ID:")
        if not ok:
            return
        dlg = VersionHistoryDialog(self.connection, rid, self)
        dlg.exec_()

    def check_schedules(self):
        c = self.connection.cursor()
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled' AND SCHEDULE_TIME<=?
        """, (now,))
        due = c.fetchall()
        for d in due:
            sch_id, rid = d[0], d[1]
            c2 = self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rid,))
                row = c2.fetchone()
                if row:
                    try:
                        c2.execute(row[0])
                    except Exception as ex:
                        logger.error(f"Scheduled rule {rid} failed: {ex}")
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?", (sch_id,))
                        self.connection.commit()
                        continue
                c2.execute("COMMIT")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?", (sch_id,))
            except Exception as ex:
                logger.error(f"Schedule error: {ex}")
            self.connection.commit()
        self.schedule_tab.load_schedules()

    def sync_metadata(self):
        from __main__ import sync_metadata_improved
        sync_metadata_improved(self.connection)

    def switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid == self.user_id and new_grp == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        QMessageBox.information(self, "Switched", f"Now impersonating user {new_uid} with group {new_grp}.")

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            uid, uname, ugrp = row
            self.switch_combo.addItem(f"{uname} ({ugrp})", (uid, ugrp))

###############################################################################
# Explicit Locking Functions (Part 5)
###############################################################################
def lock_rule(conn, rule_id, username):
    """
    Locks a rule by updating the BRM_RULES table.
    If the rule is already locked by another user, an exception is raised.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception("Rule not found.")
    current_lock = row[0]
    if current_lock is not None and current_lock != username:
        raise Exception(f"Rule {rule_id} is already locked by {current_lock}.")
    if current_lock == username:
        return
    c.execute("UPDATE BRM_RULES SET LOCKED_BY = ?, LOCK_TIMESTAMP = GETDATE() WHERE RULE_ID = ?",
              (username, rule_id))
    conn.commit()

def unlock_rule(conn, rule_id, username):
    """
    Unlocks a rule if it is currently locked by the same user.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row is None:
        raise Exception("Rule not found.")
    current_lock = row[0]
    if current_lock is None:
        return
    if current_lock != username:
        raise Exception(f"Rule {rule_id} is locked by {current_lock}. You cannot unlock it.")
    c.execute("UPDATE BRM_RULES SET LOCKED_BY = NULL, LOCK_TIMESTAMP = NULL WHERE RULE_ID = ?", (rule_id,))
    conn.commit()

def get_lock_info(conn, rule_id):
    """
    Returns a tuple (locked_by, lock_timestamp) for the given rule.
    """
    c = conn.cursor()
    c.execute("SELECT LOCKED_BY, LOCK_TIMESTAMP FROM BRM_RULES WHERE RULE_ID = ?", (rule_id,))
    row = c.fetchone()
    if row:
        return row[0], row[1]
    return None, None

###############################################################################
# Main Execution
###############################################################################
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = BRMTool()
    sys.exit(app.exec_())