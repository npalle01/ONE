#!/usr/bin/env python
"""
BRM Tool – Full Integrated Enhanced Version
Supports:
  • SQL Server ODBC (pyodbc)
  • Login with seeded users (from your SQL Server schema)
  • Business Rule Management (CRUD with duplicate checking, dependency mapping using advanced SQL parsing)
  • Multi-step approvals (with Approve and Reject, cycle prevention and re-approvals)
  • BFS-based lineage graph with search (for rules and tables, with rich UI highlighting)
  • Hierarchy view (groups → rule groups → rules with parent/child nesting)  [REQUIRES HierarchyViewTab]
  • Enhanced custom rule groups (with backup/restore and rule assignment)     [REQUIRES BackupRestoreHelpers]
  • Email notifications on rule add/update
  • Group Management & User Management (admin only)                           [REQUIRES UserManagementTab]
  • Global/Critical Admin (with cycle prevention and re-approvals)
  • Control Tables viewer
Advanced Features:
  1. Advanced SQL parsing using sqlparse (to extract table names even for complex queries)
  2. Rule Simulation (dry-run) dialog
  3. Version History and Rollback dialog (via audit logs)
  4. Impact Analysis dialog (descendant rule impact)
  5. Rule Scheduling and a Schedule Management tab (with periodic checking)
  6. Metrics Dashboard (using pyqtgraph)
  7. Audit Log viewer with CSV export
  8. Metadata Synchronization stub (menu action)
"""

import sys, logging, json, math, re, smtplib, csv
from email.mime.text import MIMEText   # <-- Fix for email sending
from datetime import datetime
from collections import deque

import pyodbc
import sqlparse
from sqlparse.sql import IdentifierList, Identifier
from sqlparse.tokens import Keyword, DML

# PyQt5/pyqtgraph imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer
from PyQt5.QtGui import QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget, QTableWidgetItem, QMessageBox,
    QComboBox, QInputDialog, QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView,
    QPlainTextEdit, QSplitter, QCheckBox, QTreeView, QListWidget, QListWidgetItem, QMenu, QFileDialog
)
import pyqtgraph as pg

###############################################################################
# Logging & Email Configuration
###############################################################################
logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",   # Replace with your SMTP server
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

###############################################################################
# Advanced SQL Parsing using sqlparse
###############################################################################
def is_subselect(parsed):
    if not parsed.is_group:
        return False
    for item in parsed.tokens:
        if item.ttype is DML and item.value.upper() == 'SELECT':
            return True
    return False

def extract_from_part(parsed):
    from_seen = False
    for item in parsed.tokens:
        if from_seen:
            if is_subselect(item):
                yield from extract_from_part(item)
            elif item.ttype is Keyword:
                return
            else:
                if isinstance(item, IdentifierList):
                    for identifier in item.get_identifiers():
                        yield identifier.get_real_name()
                elif isinstance(item, Identifier):
                    yield item.get_real_name()
        if item.ttype is Keyword and item.value.upper() == 'FROM':
            from_seen = True

def advanced_extract_tables(sql_text: str):
    """
    Use sqlparse to extract table names from a complex SQL statement.
    Returns a list of unique table names.
    """
    parsed_statements = sqlparse.parse(sql_text)
    tables = []
    for statement in parsed_statements:
        for table in extract_from_part(statement):
            if table and table not in tables:
                tables.append(table)
    return tables

###############################################################################
# DB UTILITIES
###############################################################################
def get_cursor_rows(cursor):
    """
    Return list of dict rows from a pyodbc cursor
    """
    try:
        rows = cursor.fetchall()
    except Exception:
        rows = []
    if cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return [dict(zip(colnames, row)) for row in rows]
    return rows

def get_cursor_one(cursor):
    """
    Return a single dict row from a pyodbc cursor
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [desc[0] for desc in cursor.description]
        return dict(zip(colnames, row))
    return row

def send_email_notification(subject, body, recipients):
    """
    Send plain-text email using standard email.mime.text and smtplib
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        s = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info("Email sent to: " + ", ".join(recipients))
    except Exception as ex:
        logger.error("Error sending email: " + str(ex))

###############################################################################
# Shared "insert if not exists" utility (to replace "INSERT OR IGNORE")
###############################################################################
def insert_if_not_exists_approvals(conn, rule_id, group_name, username, stage):
    """
    T-SQL equivalent of "INSERT OR IGNORE" for BRM_RULE_APPROVALS
    """
    c = conn.cursor()
    c.execute("""
        SELECT COUNT(*) AS cnt
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID = ?
          AND GROUP_NAME = ?
          AND USERNAME = ?
          AND APPROVAL_STAGE = ?
    """, (rule_id, group_name, username, stage))
    row = c.fetchone()
    if row and row[0] == 0:
        c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, APPROVED_TIMESTAMP)
            VALUES(?,?,?,?,?,NULL)
        """, (rule_id, group_name, username, 0, stage))

def insert_if_not_exists_gcr_links(conn, gcr_rule_id, child_rule_id):
    """
    T-SQL equivalent of "INSERT OR IGNORE" for BRM_GLOBAL_CRITICAL_LINKS
    """
    c = conn.cursor()
    c.execute("""
        SELECT COUNT(*) AS cnt
        FROM BRM_GLOBAL_CRITICAL_LINKS
        WHERE GCR_RULE_ID = ?
          AND TARGET_RULE_ID = ?
    """, (gcr_rule_id, child_rule_id))
    row = c.fetchone()
    if row and row[0] == 0:
        c.execute("""
            INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID)
            VALUES(?, ?)
        """, (gcr_rule_id, child_rule_id))

def insert_if_not_exists_custom_group_member(conn, custom_group_id, rule_id):
    """
    T-SQL equivalent of "INSERT OR IGNORE" for BRM_CUSTOM_GROUP_MEMBERS
    """
    c = conn.cursor()
    c.execute("""
        SELECT COUNT(*) AS cnt
        FROM BRM_CUSTOM_GROUP_MEMBERS
        WHERE CUSTOM_GROUP_ID = ?
          AND RULE_ID = ?
    """, (custom_group_id, rule_id))
    row = c.fetchone()
    if row and row[0] == 0:
        c.execute("""
            INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID)
            VALUES(?, ?)
        """, (custom_group_id, rule_id))

###############################################################################
# DATABASE CONNECTION DIALOG (ODBC for SQL Server)
###############################################################################
class DatabaseConnectionDialog(QDialog):
    """
    A simple ODBC connection dialog that only supports SQL Server DSNs or custom strings.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Database Connection")
        layout = QVBoxLayout(self)

        self.conn_label = QLabel("Select a SQL Server ODBC DSN or provide a custom connection string:")
        layout.addWidget(self.conn_label)

        self.conn_type_combo = QComboBox()
        try:
            # This lists all ODBC DSNs; we filter to 'SQL SERVER' in the driver name
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error("Error listing ODBC DSNs: " + str(e))
        layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter a custom SQL Server connection string (optional)")
        layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        layout.addLayout(btn_h)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Connection Error", "No DSN selected or connection string provided.")
                return None
            # For SQL Server integrated auth:
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

###############################################################################
# AUDIT LOG UTILITY
###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    """
    Insert an audit trail entry into BRM_AUDIT_LOG
    """
    c = conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
    VALUES(?,?,?,?,?,?,CURRENT_TIMESTAMP)
    """, (
        action,
        table_name,
        str(record_id),
        action_by,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################################################
# RULE UTILS: Execution, Dependency Mapping, Approvals, etc.
###############################################################################
def get_op_type_from_sql(sql_text: str) -> str:
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def run_rule_sql(conn, rule_sql):
    """
    Execute the given SQL text in T-SQL environment (e.g., SELECT 1 as PassFlag).
    Return (True, '...') if pass, else (False, 'error message').
    """
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = get_cursor_one(c)
        # If no row returned, assume pass
        if not row:
            return True, "No rows returned (assumed PASS)"
        # Otherwise we check the first column's value
        result = list(row.values())[0]
        return (result == 1), f"Returned: {result}"
    except Exception as ex:
        logger.error("Rule execution error: " + str(ex))
        return False, str(ex)

def build_rule_adjacency(conn):
    """
    Return (children_map, roots_list) based on PARENT_RULE_ID in BRM_RULES
    children_map: { parent_id -> [child_ids...] }
    roots_list:   [list of root rule_ids with no parent]
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = get_cursor_rows(c)
    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r["RULE_ID"]
        pid = r["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)
    roots = [rid for rid in all_ids if rid not in parent_ids]
    return children_map, roots

def load_global_critical_links(conn):
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = get_cursor_rows(c)
    link_map = {}
    for r in rows:
        gcr = r["GCR_RULE_ID"]
        tgt = r["TARGET_RULE_ID"]
        link_map.setdefault(gcr, set()).add(tgt)
    return link_map

def get_all_rules_as_dict(conn):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = get_cursor_rows(c)
    return {r["RULE_ID"]: r for r in rows}

def skip_descendants(child_id, children_map, skipped):
    """
    BFS skip all descendants from a child node
    """
    stack = [child_id]
    while stack:
        curr = stack.pop()
        if curr in skipped:
            continue
        skipped.add(curr)
        if curr in children_map:
            stack.extend(children_map[curr])

def execute_rules_in_order(conn):
    """
    BFS across root rules -> children, skipping on critical failures
    Also skip via global critical links
    """
    children_map, root_rules = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    executed = []
    skipped = set()
    queue = list(root_rules)
    rule_lookup = get_all_rules_as_dict(conn)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning("Rule not found: " + str(rid))
            continue

        rinfo = rule_lookup[rid]
        rule_sql = rinfo["RULE_SQL"]
        logger.info(f"Executing rule {rid}: {rinfo['RULE_NAME']}")
        passed, msg = run_rule_sql(conn, rule_sql)
        if passed:
            logger.info(f"Rule {rid} PASSED")
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            logger.warning(f"Rule {rid} FAILED => skipping descendants")
            is_crit = (rinfo["CRITICAL_RULE"] == 1 or rinfo["IS_GLOBAL"] == 1)
            crit_scope = (rinfo["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and crit_scope != "NONE":
                logger.warning(f"Critical/Global => skipping descendants & links. scope={crit_scope}")
                if rid in children_map:
                    for subc in children_map[rid]:
                        skip_descendants(subc, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    logger.info(f"ETL done. executed={executed}, skipped={list(skipped)}")
    return executed, skipped

def find_impacted_business_groups(conn, rule_id):
    """
    Example BFS for impacted groups based on some column mapping, etc.
    """
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    row = get_cursor_one(c)
    if row:
        impacted.add(row["OWNER_GROUP"])

    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?", (curr,))
        for ch in get_cursor_rows(c):
            cid = ch["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (cid,))
            row2 = get_cursor_one(c)
            if row2:
                impacted.add(row2["OWNER_GROUP"])
            queue.append(cid)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    """
    Example multi-step approvals: BG1 -> BG2 -> BG3 -> FINAL (only if they are impacted)
    """
    c = conn.cursor()
    stage_counter = 1
    stage_list = []
    MULTISTEP_ORDER = ["BG1", "BG2", "BG3", "FINAL"]
    for step in MULTISTEP_ORDER:
        if step == "FINAL":
            stage_list.append((step, stage_counter))
            stage_counter += 1
        else:
            if step in impacted_bg_list:
                stage_list.append((step, stage_counter))
                stage_counter += 1

    for bg, st in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            insert_if_not_exists_approvals(conn, rule_id, bg, user_ap, st)
        else:
            c.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (bg,))
            for rap in get_cursor_rows(c):
                insert_if_not_exists_approvals(conn, rule_id, bg, rap["USERNAME"], st)

    conn.commit()

def get_current_approval_stage(conn, rule_id):
    """
    Return the earliest stage that is not approved (or None if all are approved)
    """
    c = conn.cursor()
    c.execute("""
    SELECT MIN(APPROVAL_STAGE) as stage
    FROM BRM_RULE_APPROVALS
    WHERE RULE_ID=? AND APPROVED_FLAG=0
    """, (rule_id,))
    row = get_cursor_one(c)
    if row and row["stage"]:
        return row["stage"]
    return None

def add_rule(conn, rule_data, created_by, user_group):
    c = conn.cursor()
    owner = rule_data["OWNER_GROUP"]
    rule_name = rule_data["RULE_NAME"].strip()

    # Duplicate check
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (owner, rule_name))
    if get_cursor_one(c):
        raise ValueError(f"Rule '{rule_name}' already exists in group '{owner}'")

    # Global only by Admin
    is_global = rule_data.get("IS_GLOBAL", 0)
    if is_global == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create global rule.")

    # Insert
    c.execute("""
    INSERT INTO BRM_RULES(
        GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
        EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION, CREATED_BY,
        DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION, OWNER_GROUP,
        APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, CDC_TYPE,
        CREATED_TIMESTAMP, UPDATED_BY, CLUSTER_NAME
    )
    VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,CURRENT_TIMESTAMP,NULL,?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        "INACTIVE",
        1,
        created_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        rule_data["OWNER_GROUP"],
        "APPROVAL_IN_PROGRESS",
        is_global,
        rule_data.get("CRITICAL_RULE", 0),
        rule_data.get("CRITICAL_SCOPE", "NONE"),
        rule_data.get("CDC_TYPE", "NONE"),
        rule_data.get("CLUSTER_NAME", "")
    ))
    new_id = c.execute("SELECT SCOPE_IDENTITY() AS NewID").fetchone()[0]  # Or you can use OUTPUT if needed

    # Extract table dependencies
    deps = advanced_extract_tables(rule_data["RULE_SQL"])
    for tbn in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (new_id, "", tbn, "DerivedCol"))

    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # Approvals
    if is_global == 1:
        logger.info("Global rule => skip approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)

    # Email notifications
    try:
        subject = f"New Rule Added: {rule_data['RULE_NAME']}"
        body = f"User {created_by} added rule ID {new_id}\n\nDetails:\n{json.dumps(rule_data, indent=2)}"
        impacted_grps = find_impacted_business_groups(conn, new_id)
        recips = []
        for g in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g,))
            r = get_cursor_one(c)
            if r and r["EMAIL"]:
                recips.append(r["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on new rule: " + str(ex))

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")

    old_data = dict(old)
    new_owner = rule_data.get("OWNER_GROUP", old["OWNER_GROUP"])
    new_rname = rule_data.get("RULE_NAME", old["RULE_NAME"]).strip()

    # Duplicate check if changing group or name
    if new_owner != old["OWNER_GROUP"] or new_rname != old["RULE_NAME"]:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (new_owner, new_rname))
        dup = get_cursor_one(c)
        if dup and dup["RULE_ID"] != old["RULE_ID"]:
            raise ValueError(f"Duplicate rule name '{new_rname}' in group '{new_owner}'")

    # Global only admin
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set a rule global.")

    c.execute("""
    UPDATE BRM_RULES
    SET
      GROUP_ID = ?,
      PARENT_RULE_ID = ?,
      RULE_TYPE_ID = ?,
      RULE_NAME = ?,
      RULE_SQL = ?,
      EFFECTIVE_START_DATE = ?,
      EFFECTIVE_END_DATE = ?,
      STATUS = 'INACTIVE',
      VERSION = VERSION + 1,
      UPDATED_BY = ?,
      DESCRIPTION = ?,
      OPERATION_TYPE = ?,
      BUSINESS_JUSTIFICATION = ?,
      OWNER_GROUP = ?,
      APPROVAL_STATUS = 'APPROVAL_IN_PROGRESS',
      IS_GLOBAL = ?,
      CRITICAL_RULE = ?,
      CRITICAL_SCOPE = ?,
      CDC_TYPE = ?,
      CLUSTER_NAME = ?
    WHERE RULE_ID = ?
    """, (
        rule_data.get("GROUP_ID", old["GROUP_ID"]),
        rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"]),
        rule_data["RULE_TYPE_ID"],
        new_rname,
        rule_data["RULE_SQL"],
        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),
        updated_by,
        rule_data.get("DESCRIPTION"),
        rule_data.get("OPERATION_TYPE"),
        rule_data.get("BUSINESS_JUSTIFICATION", ""),
        new_owner,
        rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
        rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
        rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
        rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
        rule_data.get("CLUSTER_NAME", old.get("CLUSTER_NAME", "")),
        rule_data["RULE_ID"]
    ))

    # Rebuild table dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    deps = advanced_extract_tables(rule_data["RULE_SQL"])
    for tbn in deps:
        c.execute("""
        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
        VALUES(?,?,?,?)
        """, (rule_data["RULE_ID"], "", tbn, "DerivedCol"))

    new_data = dict(old_data)
    for k, v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"] + 1

    add_audit_log(conn, "UPDATE", "BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()

    # Approvals
    if old["IS_GLOBAL"] == 1 or rule_data.get("IS_GLOBAL", 0) == 1:
        logger.info("Skipping multi-step approvals for global rule update.")
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

    # Email notifications
    try:
        subject = f"Rule Updated: {new_rname}"
        body = (f"User {updated_by} updated rule ID {rule_data['RULE_ID']}.\n\n"
                f"Old:\n{json.dumps(old_data, indent=2)}\n\n"
                f"New:\n{json.dumps(rule_data, indent=2)}")
        impacted_grps = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        recips = []
        for g_ in impacted_grps:
            c.execute("SELECT EMAIL FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (g_,))
            ro = get_cursor_one(c)
            if ro and ro["EMAIL"]:
                recips.append(ro["EMAIL"])
        if recips:
            send_email_notification(subject, body, recips)
    except Exception as ex:
        logger.error("Email error on rule update: " + str(ex))

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate global rule.")

    # Check for active children
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Deactivate child rules first.")

    old_data = dict(old)
    c.execute("""
    UPDATE BRM_RULES
    SET STATUS='INACTIVE',
        UPDATED_BY=?,
        VERSION=VERSION+1
    WHERE RULE_ID=?
    """, (updated_by, rule_id))

    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")

    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist, cannot delete.")

    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    leftover = get_cursor_rows(c)
    if leftover:
        raise ValueError("Re-map or remove column references first.")

    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))

    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

###############################################################################
# Rule Simulation Dialog
###############################################################################
class RuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_sql, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_sql = rule_sql
        self.setWindowTitle("Rule Simulation (Dry-run)")
        self.resize(600, 400)

        layout = QVBoxLayout(self)
        self.sim_result = QPlainTextEdit()
        self.sim_result.setReadOnly(True)
        layout.addWidget(self.sim_result)

        btn_h = QHBoxLayout()
        self.simulate_btn = QPushButton("Simulate Rule")
        self.simulate_btn.clicked.connect(self.simulate)
        btn_h.addWidget(self.simulate_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def simulate(self):
        self.simulate_btn.setEnabled(False)
        result, msg = run_rule_sql(self.connection, self.rule_sql)
        output = f"Result: {'PASS' if result else 'FAIL'}\nDetail: {msg}"
        self.sim_result.setPlainText(output)
        self.simulate_btn.setEnabled(True)

###############################################################################
# Version History and Rollback Dialog
###############################################################################
class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History for Rule {rule_id}")
        self.resize(800, 400)

        layout = QVBoxLayout(self)
        self.history_table = QTableWidget(0, 5)
        self.history_table.setHorizontalHeaderLabels(["Audit ID", "Action", "Timestamp", "Old Data", "New Data"])
        self.history_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.history_table)

        btn_h = QHBoxLayout()
        self.rollback_btn = QPushButton("Rollback to Selected Version")
        self.rollback_btn.clicked.connect(self.rollback)
        btn_h.addWidget(self.rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c = self.connection.cursor()
        query = """
        SELECT AUDIT_ID, ACTION, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """
        c.execute(query, (self.rule_id,))
        rows = get_cursor_rows(c)

        self.history_table.setRowCount(0)
        for row in rows:
            r = self.history_table.rowCount()
            self.history_table.insertRow(r)
            self.history_table.setItem(r, 0, QTableWidgetItem(str(row["AUDIT_ID"])))
            self.history_table.setItem(r, 1, QTableWidgetItem(row["ACTION"]))
            self.history_table.setItem(r, 2, QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))
            self.history_table.setItem(r, 3, QTableWidgetItem(row["OLD_DATA"] or ""))
            self.history_table.setItem(r, 4, QTableWidgetItem(row["NEW_DATA"] or ""))
        self.history_table.resizeColumnsToContents()

    def rollback(self):
        sel = self.history_table.selectedItems()
        if not sel:
            QMessageBox.warning(self, "No Selection", "Select a version to roll back to.")
            return
        row = sel[0].row()
        old_data_item = self.history_table.item(row, 3)
        if not old_data_item or not old_data_item.text():
            QMessageBox.warning(self, "Cannot Rollback", "No rollback data available for this version.")
            return
        confirm = QMessageBox.question(self, "Confirm Rollback", "Are you sure you want to rollback to the selected version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_data_item.text())
            update_rule(self.connection, old_data, "Admin", "Admin")
            QMessageBox.information(self, "Rolled Back", "Rule rolled back successfully.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# Impact Analysis Dialog
###############################################################################
class ImpactAnalysisDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Impact Analysis for Rule {rule_id}")
        self.resize(600, 400)

        layout = QVBoxLayout(self)
        self.impact_text = QTextEdit()
        self.impact_text.setReadOnly(True)
        layout.addWidget(self.impact_text)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)
        self.analyze()

    def analyze(self):
        children_map, _ = build_rule_adjacency(self.connection)
        visited = set()
        impacted = set()
        stack = [self.rule_id]
        while stack:
            curr = stack.pop()
            if curr in visited:
                continue
            visited.add(curr)
            if curr in children_map:
                for child in children_map[curr]:
                    impacted.add(child)
                    stack.append(child)
        self.impact_text.setPlainText(f"Impacted descendant rule IDs: {sorted(impacted)}")

###############################################################################
# Rule Scheduler Dialog and Schedule Management Tab
###############################################################################
class RuleSchedulerDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Schedule Rule Execution")
        self.resize(400, 200)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for r in get_cursor_rows(c):
            self.rule_combo.addItem(f"{r['RULE_ID']} - {r['RULE_NAME']}", r["RULE_ID"])
        form.addRow("Select Rule:", self.rule_combo)

        self.datetime_edit = QDateTimeEdit(QDateTime.currentDateTime())
        self.datetime_edit.setCalendarPopup(True)
        self.datetime_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        form.addRow("Schedule Time:", self.datetime_edit)

        layout.addLayout(form)

        btn_h = QHBoxLayout()
        schedule_btn = QPushButton("Schedule")
        schedule_btn.clicked.connect(self.schedule_rule)
        btn_h.addWidget(schedule_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def schedule_rule(self):
        rule_id = self.rule_combo.currentData()
        schedule_time = self.datetime_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")

        c = self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP)
        VALUES(?, ?, 'Scheduled', CURRENT_TIMESTAMP)
        """, (rule_id, schedule_time))
        self.connection.commit()

        QMessageBox.information(self, "Scheduled", f"Rule {rule_id} scheduled for {schedule_time}.")

class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.schedule_table = QTableWidget(0, 4)
        self.schedule_table.setHorizontalHeaderLabels(["Schedule ID", "Rule ID", "Schedule Time", "Status"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)

        btn_h = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Schedules")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_h.addWidget(refresh_btn)
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = get_cursor_rows(c)
        self.schedule_table.setRowCount(0)
        for row in rows:
            r = self.schedule_table.rowCount()
            self.schedule_table.insertRow(r)
            self.schedule_table.setItem(r, 0, QTableWidgetItem(str(row["SCHEDULE_ID"])))
            self.schedule_table.setItem(r, 1, QTableWidgetItem(str(row["RULE_ID"])))
            self.schedule_table.setItem(r, 2, QTableWidgetItem(str(row["SCHEDULE_TIME"])))
            self.schedule_table.setItem(r, 3, QTableWidgetItem(row["STATUS"]))
        self.schedule_table.resizeColumnsToContents()

###############################################################################
# Metrics Dashboard Tab
###############################################################################
class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.chart = pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        c.execute("SELECT STATUS, COUNT(*) as count FROM BRM_RULES GROUP BY STATUS")
        rows = get_cursor_rows(c)
        statuses = [r["STATUS"] for r in rows]
        counts = [r["count"] for r in rows]

        self.chart.clear()
        if statuses:
            x = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x, height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(x, statuses))])
            self.chart.setLabel("left", "Count")
            self.chart.setLabel("bottom", "Status")
            self.chart.showGrid(x=True, y=True)

###############################################################################
# Metadata Synchronization Stub
###############################################################################
def sync_metadata(connection):
    logger.info("Synchronizing metadata with external catalog...")
    QMessageBox.information(None, "Sync Metadata", "Metadata synchronization completed successfully.")

###############################################################################
# LOGIN DIALOG
###############################################################################
class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return

        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

###############################################################################
# RULE EDITOR DIALOG
###############################################################################
class RuleEditorDialog(QDialog):
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_types = rule_types  # e.g. {"DQ":1, "DM":2}
        self.logged_in_user = logged_in_user
        self.rule_data = rule_data

        title = "Edit Rule" if rule_data else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(900, 500)

        main_layout = QHBoxLayout(self)

        left_box = QGroupBox("Basic Info")
        left_layout = QFormLayout(left_box)

        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        for r in get_cursor_rows(c):
            self.group_combo.addItem(r["GROUP_NAME"], r["GROUP_ID"])
        left_layout.addRow("Rule Group:", self.group_combo)

        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("None", None)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
        for rr in get_cursor_rows(c):
            self.parent_rule_combo.addItem(f"{rr['RULE_NAME']} (ID:{rr['RULE_ID']})", rr["RULE_ID"])
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit = QLineEdit()
        left_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo = QComboBox()
        for rt_name in self.rule_types:
            self.type_combo.addItem(rt_name)
        left_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["ACTIVE", "INACTIVE"])
        left_layout.addRow("Status (informational):", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:", self.end_dt)

        self.owner_grp_combo = QComboBox()
        c.execute("SELECT DISTINCT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for g in get_cursor_rows(c):
            self.owner_grp_combo.addItem(g["GROUP_NAME"], g["GROUP_NAME"])
        left_layout.addRow("Owner Group:", self.owner_grp_combo)

        self.global_checkbox = None
        if self.logged_in_user == "Admin":
            self.global_checkbox = QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:", self.global_checkbox)

        self.critical_checkbox = QCheckBox()
        left_layout.addRow("Critical Rule?", self.critical_checkbox)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        left_layout.addRow("Critical Scope:", self.scope_combo)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "INSERT_ONLY", "UPSERT"])
        left_layout.addRow("CDC Type:", self.cdc_combo)

        main_layout.addWidget(left_box)

        right_box = QGroupBox("Details & Logic")
        right_layout = QFormLayout(right_box)

        self.sql_editor = QPlainTextEdit()
        font = QtGui.QFont("Courier", 10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"), self.sql_editor)

        self.description_edit = QTextEdit()
        right_layout.addRow(QLabel("Description:"), self.description_edit)

        self.justification_edit = QTextEdit()
        right_layout.addRow(QLabel("Justification:"), self.justification_edit)

        btn_box = QHBoxLayout()
        self.save_btn = QPushButton("Save" if rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)
        right_layout.addRow(btn_box)

        main_layout.addWidget(right_box)
        self.setLayout(main_layout)

        if self.rule_data:
            self.load_rule_data(self.rule_data)

    def load_rule_data(self, rd):
        if rd["GROUP_ID"]:
            idx = self.group_combo.findData(rd["GROUP_ID"])
            if idx >= 0:
                self.group_combo.setCurrentIndex(idx)

        if rd["PARENT_RULE_ID"]:
            idx2 = self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2 >= 0:
                self.parent_rule_combo.setCurrentIndex(idx2)

        self.name_edit.setText(rd["RULE_NAME"])

        for nm, tid in self.rule_types.items():
            if tid == rd["RULE_TYPE_ID"]:
                i = self.type_combo.findText(nm)
                if i >= 0:
                    self.type_combo.setCurrentIndex(i)
                break

        i_st = self.status_combo.findText(rd["STATUS"])
        if i_st >= 0:
            self.status_combo.setCurrentIndex(i_st)

        try:
            sdt = datetime.strptime(rd["EFFECTIVE_START_DATE"], "%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except:
            pass

        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt = datetime.strptime(rd["EFFECTIVE_END_DATE"], "%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except:
                pass

        iog = self.owner_grp_combo.findText(rd["OWNER_GROUP"])
        if iog >= 0:
            self.owner_grp_combo.setCurrentIndex(iog)

        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.global_checkbox and rd.get("IS_GLOBAL", 0) == 1:
            self.global_checkbox.setChecked(True)

        if rd.get("CRITICAL_RULE", 0) == 1:
            self.critical_checkbox.setChecked(True)

        ix_scope = self.scope_combo.findText(rd.get("CRITICAL_SCOPE", "NONE").upper())
        if ix_scope >= 0:
            self.scope_combo.setCurrentIndex(ix_scope)

        ix_cdc = self.cdc_combo.findText(rd.get("CDC_TYPE", "NONE").upper())
        if ix_cdc >= 0:
            self.cdc_combo.setCurrentIndex(ix_cdc)

    def on_save(self):
        if not self.name_edit.text().strip():
            QMessageBox.warning(self, "Error", "Name is empty.")
            return
        sql_text = self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self, "Error", "SQL is empty.")
            return

        op_type = get_op_type_from_sql(sql_text)
        rule_dict = {
            "GROUP_ID": self.group_combo.currentData(),
            "PARENT_RULE_ID": self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID": self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME": self.name_edit.text().strip(),
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
            "CDC_TYPE": self.cdc_combo.currentText().upper()
        }

        created_by = self.logged_in_user
        if self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm", "Update rule?")
            if confirm != QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self, "Success", "Rule updated. Approval re-initiated.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "DB Error", str(ex))
        else:
            confirm = QMessageBox.question(self, "Confirm", "Add new rule?")
            if confirm != QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self, "Success", f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "DB Error", str(ex))

###############################################################################
# Rule Analytics Dialog
###############################################################################
class RuleAnalyticsDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        chart_hbox = QHBoxLayout()

        self.bar_chart = pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)

        self.pie_chart = pg.PlotWidget(title="Rule Status Distribution")
        self.pie_chart.setBackground('w')
        chart_hbox.addWidget(self.pie_chart)

        layout.addLayout(chart_hbox)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)
        self.load_charts()

    def load_charts(self):
        c = self.connection.cursor()

        # Bar chart (Created_By)
        query_bar = "SELECT CREATED_BY, COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY"
        c.execute(query_bar)
        rows = get_cursor_rows(c)
        creators = {r["CREATED_BY"]: r["cnt"] for r in rows if r["CREATED_BY"]}

        # Status distribution
        status_counts = {"ACTIVE": 0, "INACTIVE": 0, "DELETED": 0}
        query_status = "SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS"
        c.execute(query_status)
        for s_ in get_cursor_rows(c):
            key = s_["STATUS"].upper()
            if key in status_counts:
                status_counts[key] = s_["sc"]

        # Deletions from audit log
        query_del = "SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'"
        c.execute(query_del)
        drow = get_cursor_one(c)
        if drow:
            status_counts["DELETED"] = drow["delcnt"]

        # Plot bar chart
        self.bar_chart.clear()
        if creators:
            sorted_creators = sorted(creators.items(), key=lambda x: x[1], reverse=True)
            names = [x[0] for x in sorted_creators]
            vals = [x[1] for x in sorted_creators]
            bar_item = pg.BarGraphItem(x=range(len(names)), height=vals, width=0.6, brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax = self.bar_chart.getAxis("bottom")
            ax.setTicks([list(zip(range(len(names)), names))])
            self.bar_chart.setLabel("left", "Number of Rules")
            self.bar_chart.setLabel("bottom", "Created By")
            self.bar_chart.showGrid(x=True, y=True)

        # Plot pie chart
        self.pie_chart.clear()
        total = sum(status_counts.values())
        if total > 0:
            angles = [360 * (v / total) for v in status_counts.values()]
            start = 90
            color_map = {"ACTIVE": "green", "INACTIVE": "red", "DELETED": "gray"}

            # For actual pie chart you might want a QGraphicsScene overlay,
            # but here we'll approximate. If you want an actual pie, see specialized libs.
            # Below is a simplistic demonstration approach:

            # (Placeholder or simplified approach – or remove if unneeded)
            # We won't fully implement a 'true' pie with pg alone.
            # This code may need a custom QGraphics approach.

            # Example approach: (No actual arcs with pyqtgraph by default)

            # If you do want arcs, you'd do something custom. For brevity:
            pass

###############################################################################
# AUDIT LOG VIEWER WITH CSV export
###############################################################################
class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()

        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action, Table, or Action By...")
        self.search_edit.textChanged.connect(self.perform_search)

        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table = QTableWidget(0, 8)
        self.audit_table.setHorizontalHeaderLabels(["Audit ID", "Action", "Table", "Record ID", "Action By", "Old Data", "New Data", "Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        btn_h.addWidget(ref_btn)

        export_btn = QPushButton("Export to CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_h.addWidget(export_btn)
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        c = self.connection.cursor()
        query = """
        SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """
        c.execute(query)
        rows = get_cursor_rows(c)
        self.audit_table.setRowCount(0)

        for row in rows:
            r = self.audit_table.rowCount()
            self.audit_table.insertRow(r)
            self.audit_table.setItem(r, 0, QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r, 1, QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r, 2, QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r, 3, QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r, 4, QTableWidgetItem(row["ACTION_BY"]))

            oldtxt = ""
            if row["OLD_DATA"]:
                try:
                    p = json.loads(row["OLD_DATA"])
                    oldtxt = json.dumps(p, indent=2)
                except:
                    oldtxt = row["OLD_DATA"]
            self.audit_table.setItem(r, 5, QTableWidgetItem(oldtxt))

            newtxt = ""
            if row["NEW_DATA"]:
                try:
                    p2 = json.loads(row["NEW_DATA"])
                    newtxt = json.dumps(p2, indent=2)
                except:
                    newtxt = row["NEW_DATA"]
            self.audit_table.setItem(r, 6, QTableWidgetItem(newtxt))

            self.audit_table.setItem(r, 7, QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))

        self.audit_table.resizeColumnsToContents()

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            match = False
            for col in (1, 2, 4):
                item = self.audit_table.item(row, col)
                if item and txt_l in item.text().lower():
                    match = True
                    break
            self.audit_table.setRowHidden(row, not match)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Save CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        with open(path, "w", newline="") as f:
            writer = csv.writer(f)
            headers = [self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            writer.writerow(headers)
            for row in range(self.audit_table.rowCount()):
                if self.audit_table.isRowHidden(row):
                    continue
                rowdata = []
                for col in range(self.audit_table.columnCount()):
                    item = self.audit_table.item(row, col)
                    rowdata.append(item.text() if item else "")
                writer.writerow(rowdata)
        QMessageBox.information(self, "Exported", "Audit logs exported successfully.")

###############################################################################
# SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()

        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)

        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID", "Name", "SQL", "Status", "Version", "Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)
        self.setLayout(layout)

        self.load_results()

    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            query = """
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """
            c.execute(query, (f"%{txt}%", f"%{txt}%"))
        else:
            query = """
            SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """
            c.execute(query)

        rows = get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r, 0, QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r, 1, QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r, 2, QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r, 3, QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r, 4, QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r, 5, QTableWidgetItem(row["CREATED_BY"]))

###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        self.status_filter.addItem("DELETED", "DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)

        main_layout.addLayout(top_h)

        self.rule_table = QTableWidget(0, 8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Name", "SQL", "Status", "Version", "Owner Group",
            "Created Timestamp", "Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)

        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)

        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics)
        btn_h.addWidget(analytics_btn)

        simulate_btn = QPushButton("Simulate Rule")
        simulate_btn.clicked.connect(self.simulate_rule)
        btn_h.addWidget(simulate_btn)

        impact_btn = QPushButton("Impact Analysis")
        impact_btn.clicked.connect(self.analyze_impact)
        btn_h.addWidget(impact_btn)

        history_btn = QPushButton("Version History")
        history_btn.clicked.connect(self.show_history)
        btn_h.addWidget(history_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self, "ETL", msg)
        self.load_rules()

    def show_analytics(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()

    def build_filter_query(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])

        st = self.status_filter.currentData()
        if st:
            if st.upper() == "DELETED":
                # Checking "DELETED" means rule was physically removed from BRM_RULES, or
                # we rely on an audit to track. So let's interpret "deleted" as we did:
                filters.append("""RULE_ID IN (
                    SELECT CAST(RECORD_ID AS INT)
                    FROM BRM_AUDIT_LOG
                    WHERE ACTION='DELETE'
                      AND ISNUMERIC(RECORD_ID)=1
                )""")
            else:
                filters.append("STATUS=?")
                params.append(st)

        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params

    def load_rules(self):
        c = self.connection.cursor()

        clause, params = self.build_filter_query()
        count_query = f"SELECT COUNT(*) AS ccount FROM BRM_RULES WHERE {clause}"
        c.execute(count_query, params)
        rowc = get_cursor_one(c)
        total = rowc["ccount"] if rowc else 0

        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        elif self.current_page < 1:
            self.current_page = 1

        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page

        data_query = f"""
        SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
               CREATED_TIMESTAMP, APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """

        c.execute(data_query, (*params, offset, self.records_per_page))
        rows = get_cursor_rows(c)

        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)

            self.rule_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r, 1, QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r, 2, QTableWidgetItem(rd["RULE_SQL"]))

            st_item = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower() == "active":
                st_item.setBackground(QColor(144, 238, 144))
            else:
                st_item.setBackground(QColor(255, 182, 193))
            self.rule_table.setItem(r, 3, st_item)

            self.rule_table.setItem(r, 4, QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r, 5, QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r, 6, QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r, 7, QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row, 0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id = None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

    def simulate_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No Selection", "Please select a rule to simulate.")
            return
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (self.selected_rule_id,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Not Found", "Rule SQL not found.")
            return

        dlg = RuleSimulationDialog(self.connection, row["RULE_SQL"], self)
        dlg.exec_()

    def analyze_impact(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No Selection", "Please select a rule for impact analysis.")
            return
        dlg = ImpactAnalysisDialog(self.connection, self.selected_rule_id, self)
        dlg.exec_()

    def show_history(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "No Selection", "Please select a rule to view version history.")
            return
        dlg = VersionHistoryDialog(self.connection, self.selected_rule_id, self)
        dlg.exec_()

###############################################################################
# BUSINESS RULE MANAGEMENT TAB
###############################################################################
class BusinessRuleManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)

        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)

        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)

        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)

        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)

        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        layout.addWidget(self.rule_dash)
        layout.addStretch()
        self.setLayout(layout)

    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self, "No Selection", "Select a rule first.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Not Found", "No rule with that ID.")
            return
        rule_data = dict(row)

        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rules selected.")
            return

        success = 0
        fails = []
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rr}: {str(ex)}")

        msg = f"Deactivation done. Success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dash.load_rules()

    def on_delete_rule(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None", "No rule(s) selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return

        success = 0
        fails = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success += 1
            except Exception as ex:
                fails.append(f"Rule {rid}: {str(ex)}")

        msg = f"Deletion done. Success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dash.load_rules()

###############################################################################
# GROUP MANAGEMENT TAB (Admin Only)
#   - [If you have references to BackupRestoreHelpers, define or remove them]
###############################################################################
class GroupManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        if user_group != "Admin":
            lay = QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(lay)
            return

        # ... your group mgmt UI ...
        # (Truncated for brevity. If you have the same references to “INSERT OR IGNORE”,
        #  you must replace them with T-SQL checks, or an IF NOT EXISTS approach.)

        layout = QVBoxLayout(self)
        # For demonstration only:
        layout.addWidget(QLabel("(Admin) Group Management goes here."))
        self.setLayout(layout)

        # Remember to remove or rewrite any 'INSERT OR IGNORE' statements,
        # or references to 'BEGIN TRANSACTION', 'ROLLBACK', etc. in T-SQL form.

###############################################################################
# ENHANCED LINEAGE GRAPH WIDGET
###############################################################################
class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    Example lineage graph. Requires BFS or layering approach.
    For brevity, the existing approach is shown. This version
    is T-SQL only, so references to 'PRAGMA table_info' are removed.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.node_map = {}
        self.children_map = {}
        self.parents_map = {}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c = self.connection.cursor()
        c.execute("""
        SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, RULE_TYPE_ID, CLUSTER_NAME,
               IS_GLOBAL, CRITICAL_RULE
        FROM BRM_RULES
        ORDER BY RULE_ID
        """)
        rules = get_cursor_rows(c)
        if not rules:
            txt_item = QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(txt_item)
            return

        for r in rules:
            rid = r["RULE_ID"]
            pid = r["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid, []).append(rid)
                self.parents_map[rid] = pid

        rule_lookup = {r["RULE_ID"]: r for r in rules}
        all_ids = set(r["RULE_ID"] for r in rules)
        child_ids = set(self.parents_map.keys())
        roots = list(all_ids - child_ids)

        from collections import deque
        queue = deque()
        level_map = {}
        visited = set()

        for rt in roots:
            queue.append((rt, 0))

        while queue:
            (rid, depth) = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            rinfo = rule_lookup[rid]
            count_at_level = level_map.get(depth, 0)
            level_map[depth] = count_at_level + 1

            x = depth * 220
            y = count_at_level * 120
            node_item = self.create_node(rinfo)
            node_item.setPos(x, y)
            self.scene.addItem(node_item)
            self.node_map[rid] = node_item

            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch, depth + 1))

        # Draw edges
        for r in rules:
            pid = r["PARENT_RULE_ID"]
            rid = r["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid])

        # Now load table dependencies
        c.execute("SELECT RULE_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps = get_cursor_rows(c)
        table_node_map = {}
        table_index = 0
        for dep in deps:
            key = f"{dep['DATABASE_NAME']}.{dep['TABLE_NAME']}".strip(".")
            if key not in table_node_map:
                t_item = QtWidgets.QGraphicsEllipseItem(0, 0, 100, 40)
                t_item.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
                t_item.setToolTip(f"Table: {key}")
                t_item.setPos(800, table_index * 60)
                self.scene.addItem(t_item)
                table_node_map[key] = t_item
                table_index += 1

            rule_id = dep["RULE_ID"]
            if rule_id in self.node_map:
                self.draw_edge(self.node_map[rule_id], table_node_map[key], color=QtGui.QColor("darkmagenta"))

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, rinfo):
        rtype = rinfo["RULE_TYPE_ID"]
        status = rinfo["STATUS"]
        cluster = rinfo.get("CLUSTER_NAME", "") or ""
        is_global = rinfo["IS_GLOBAL"]
        is_crit = rinfo["CRITICAL_RULE"]

        if rtype == 1:
            node = QtWidgets.QGraphicsRectItem(0, 0, 120, 50)
        else:
            node = QtWidgets.QGraphicsEllipseItem(0, 0, 120, 50)

        if status.lower() == "active":
            basecol = QtGui.QColor("lightgreen")
        else:
            basecol = QtGui.QColor("tomato")

        if cluster:
            hv = abs(hash(cluster)) % 360
            basecol = QtGui.QColor.fromHsv(hv, 128, 255)

        node.setBrush(QtGui.QBrush(basecol))
        pen = QtGui.QPen(QtCore.Qt.black, 2)
        if is_crit == 1:
            pen = QtGui.QPen(QtGui.QColor("red"), 3)
        node.setPen(pen)

        display_name = rinfo["RULE_NAME"]
        if is_global == 1:
            display_name = f"(G) {display_name}"
        node.setToolTip(f"Rule {rinfo['RULE_ID']}: {display_name}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1 = item1.sceneBoundingRect()
        r2 = item2.sceneBoundingRect()
        p1 = r1.center()
        p2 = r2.center()
        line = QtWidgets.QGraphicsLineItem(p1.x(), p1.y(), p2.x(), p2.y())
        line.setPen(QtGui.QPen(color, 2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item, (QtWidgets.QGraphicsRectItem, QtWidgets.QGraphicsEllipseItem)):
                self.show_rule_details(item.toolTip())
        super().mousePressEvent(event)

    def show_rule_details(self, tooltip):
        QMessageBox.information(self, "Rule Details", tooltip)

    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setPen(QtGui.QPen(QtCore.Qt.black, 2))

    def search_nodes(self, query):
        self.clear_highlights()
        ql = query.lower()
        c = self.connection.cursor()

        # Search in BRM_RULES
        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE LOWER(RULE_NAME) LIKE ?
           OR LOWER(RULE_SQL) LIKE ?
           OR LOWER(DESCRIPTION) LIKE ?
           OR LOWER(BUSINESS_JUSTIFICATION) LIKE ?
           OR CAST(RULE_ID AS VARCHAR(50)) LIKE ?
        """, (f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%"))
        found = set(x["RULE_ID"] for x in get_cursor_rows(c))

        # Search column mapping
        c.execute("""
        SELECT RULE_ID
        FROM BRM_COLUMN_MAPPING
        WHERE LOWER(SOURCE_COLUMN_NAME) LIKE ?
           OR LOWER(TARGET_COLUMN_NAME) LIKE ?
        """, (f"%{ql}%", f"%{ql}%"))
        for r in get_cursor_rows(c):
            found.add(r["RULE_ID"])

        # Search table dependencies
        c.execute("""
        SELECT RULE_ID
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE LOWER(DATABASE_NAME) LIKE ?
           OR LOWER(TABLE_NAME) LIKE ?
        """, (f"%{ql}%", f"%{ql}%"))
        for r in get_cursor_rows(c):
            found.add(r["RULE_ID"])

        if not found:
            QMessageBox.information(self, "No Match", f"No match for '{query}'")
            return

        for rid in found:
            if rid in self.node_map:
                self.node_map[rid].setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
                self.highlight_ancestors(rid)
                self.highlight_descendants(rid)

    def highlight_ancestors(self, start_id):
        cur = start_id
        while cur in self.parents_map:
            node = self.node_map.get(cur)
            if node:
                node.setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
            par = self.parents_map[cur]
            if par in self.node_map:
                self.node_map[par].setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
            cur = par

    def highlight_descendants(self, start_id):
        queue = [start_id]
        visited = set()
        while queue:
            cid = queue.pop()
            if cid in visited:
                continue
            visited.add(cid)
            if cid in self.node_map:
                self.node_map[cid].setPen(QtGui.QPen(QtGui.QColor("yellow"), 4))
            if cid in self.children_map:
                queue.extend(self.children_map[cid])

###############################################################################
# MULTISTEP APPROVAL TAB & Pipeline Widget
###############################################################################
class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0, 0, 0, 0)
        self.layout().setSpacing(5)
        stages = ["BG1", "BG2", "BG3", "FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20, 20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st, "NotStarted")
            if status == "Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status == "Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status == "Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        layout = QVBoxLayout(self)

        self.appr_table = QTableWidget(0, 7)
        self.appr_table.setHorizontalHeaderLabels(["Rule ID", "Group Name", "Rule Name", "Stage", "Approved?", "Action", "Pipeline"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        c = self.connection.cursor()
        query = """
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
        WHERE A.USERNAME = ? AND A.APPROVED_FLAG = 0
        ORDER BY A.RULE_ID
        """
        c.execute(query, (self.logged_in_username,))
        rows = get_cursor_rows(c)

        # Build pipeline data for each rule
        pipeline_data = {}
        all_app = self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        for apr in get_cursor_rows(all_app):
            rid = apr["RULE_ID"]
            grp = apr["GROUP_NAME"]
            stage = apr["APPROVAL_STAGE"]
            flag = apr["APPROVED_FLAG"]

            pipeline_data.setdefault(rid, {"BG1": "NotStarted", "BG2": "NotStarted", "BG3": "NotStarted", "FINAL": "NotStarted"})
            if flag == 1:
                pipeline_data[rid][grp] = "Approved"
            else:
                cur_st = get_current_approval_stage(self.connection, rid)
                if cur_st == stage:
                    pipeline_data[rid][grp] = "Pending"
                else:
                    pipeline_data[rid][grp] = "NotStarted"

        # Filter so we only show the current stage rows for the user
        minimal_rows = []
        for rd in rows:
            rid = rd["RULE_ID"]
            st = rd["APPROVAL_STAGE"]
            min_st = get_current_approval_stage(self.connection, rid)
            if min_st == st:
                minimal_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)

            self.appr_table.setItem(r, 0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r, 1, QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r, 2, QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r, 3, QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r, 4, QTableWidgetItem(str(rd["APPROVED_FLAG"])))

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_idx=r: self.do_approve(row_idx))
            self.appr_table.setCellWidget(r, 5, approve_btn)

            pipe_map = pipeline_data.get(rd["RULE_ID"], {"BG1": "NotStarted", "BG2": "NotStarted", "BG3": "NotStarted", "FINAL": "NotStarted"})
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r, 6, pipe_widget)

    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index, 0)
        grp_item = self.appr_table.item(row_index, 1)
        if not rid_item or not grp_item:
            return

        rule_id = int(rid_item.text())
        grp = grp_item.text()

        c = self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """, (rule_id, grp, self.logged_in_username))

        nxt = get_current_approval_stage(self.connection, rule_id)
        if nxt is None:
            # fully approved => rule active
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?", (rule_id,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?", (rule_id,))

        add_audit_log(self.connection, "UPDATE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username,
                      {"APPROVED_FLAG": 0}, {"APPROVED_FLAG": 1})
        self.connection.commit()

        QMessageBox.information(self, "Approved", f"You approved rule {rule_id}.")
        self.load_approvals()

###############################################################################
# CONTROL TABLES TAB (SQL Server version)
###############################################################################
class CtrlTablesTab(QWidget):
    """
    A read-only viewer for known "control tables" in your SQL Server schema.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)

        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES", "BRM_RULE_GROUPS",
            "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG", "BRM_RULE_LINEAGE",
            "BRM_GROUP_BACKUPS", "BRM_COLUMN_MAPPING", "BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS", "BUSINESS_GROUP_APPROVERS",
            "BRM_RULE_APPROVALS", "BRM_CUSTOM_GROUP_BACKUPS", "BRM_GLOBAL_CRITICAL_LINKS",
            "RULE_SCHEDULES"   # etc., as needed
        ]

        self.table_combo = QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.table_view = QTableWidget(0, 0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)

        self.setLayout(layout)

    def on_load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()

        # Retrieve columns from INFORMATION_SCHEMA for T-SQL
        col_query = f"""
            SELECT COLUMN_NAME
            FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_NAME = '{tbl}'
            ORDER BY ORDINAL_POSITION
        """
        c.execute(col_query)
        col_info = c.fetchall()
        col_names = [row[0] for row in col_info]

        # Now select from the table
        data_query = f"SELECT * FROM {tbl}"
        c.execute(data_query)
        rows = c.fetchall()

        self.table_view.setRowCount(0)
        self.table_view.setColumnCount(len(col_names))
        self.table_view.setHorizontalHeaderLabels(col_names)

        for rd in rows:
            r = self.table_view.rowCount()
            self.table_view.insertRow(r)
            for j, cn in enumerate(col_names):
                val = rd[j]
                self.table_view.setItem(r, j, QTableWidgetItem(str(val)))

        self.table_view.resizeColumnsToContents()

###############################################################################
# GLOBAL/CRITICAL ADMIN TAB (Admin only)
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return

        # ... Admin UI for global/critical ...
        # (Truncated for brevity – be sure to remove any "INSERT OR IGNORE" calls,
        # and replace them with the T-SQL checks or your new insert-if-not-exists routines.)

        layout.addWidget(QLabel("(Admin) Global/Critical Admin goes here."))
        self.setLayout(layout)

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Integrated Enhanced Version (SQL Server)")
        self.resize(1200, 800)
        self.connection = None

        # Database connection
        dlg = DatabaseConnectionDialog()
        if dlg.exec_() == QDialog.Accepted:
            self.connection = dlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Login
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() != QDialog.Accepted:
            sys.exit(0)

        self.user_id = self.login_dialog.user_id
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowu = get_cursor_one(c)
        self.logged_in_username = rowu["USERNAME"] if rowu else "Unknown"

        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
        rowg = get_cursor_one(c)
        self.user_group = rowg["USER_GROUP"] if rowg else "Unknown"

        self.init_ui()

    def init_ui(self):
        menubar = self.menuBar()
        fileMenu = menubar.addMenu("File")

        syncAction = QtWidgets.QAction("Sync Metadata", self)
        syncAction.triggered.connect(lambda: sync_metadata(self.connection))
        fileMenu.addAction(syncAction)

        metricsAction = QtWidgets.QAction("View Metrics Dashboard", self)
        metricsAction.triggered.connect(self.show_metrics_dashboard)
        fileMenu.addAction(metricsAction)

        schedAction = QtWidgets.QAction("Schedule a Rule", self)
        schedAction.triggered.connect(lambda: RuleSchedulerDialog(self.connection, self).exec_())
        fileMenu.addAction(schedAction)

        cw = QWidget()
        layout = QVBoxLayout(cw)

        # If admin, allow user switching
        if self.user_group == "Admin":
            top_h = QHBoxLayout()
            self.switch_combo = QComboBox()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Main BRM tab
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")

        # Group mgmt (admin only)
        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")

            # If you have a separate user mgmt tab, define or import it, then do:
            # self.user_mgmt_tab = UserManagementTab(self.connection)
            # self.tabs.addTab(self.user_mgmt_tab, "User Management")

        # Lineage Visualization
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lw_container = QWidget()
        lw_layout = QVBoxLayout(lw_container)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        lw_layout.addWidget(self.lineage_tab)

        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/desc/col/db/table...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        self.tabs.addTab(lw_container, "Lineage Visualization")

        # If you have HierarchyViewTab, define or import it. Example:
        # self.hierarchy_tab = HierarchyViewTab(self.connection)
        # self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")

        # If you have a custom group tab requiring BackupRestoreHelpers, define or import them
        # self.custom_tab = CustomRuleGroupEnhancedTab(...)
        # self.tabs.addTab(self.custom_tab, "Custom Rule Groups")

        # Approvals
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        # Global/Critical Admin
        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        # Control tables
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        # Schedules
        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Schedule Management")

        # Metrics
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics Dashboard")

        cw.setLayout(layout)
        self.setCentralWidget(cw)

        # Timers
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)

        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_due_schedules)
        self.schedule_timer.start(60000)

        self.show()

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in get_cursor_rows(c):
            disp = f"{row['USERNAME']} ({row['USER_GROUP']})"
            self.switch_combo.addItem(disp, (row["USER_ID"], row["USER_GROUP"]))

    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid == self.user_id and new_grp == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        self.reinit_tabs()

    def reinit_tabs(self):
        self.tabs.clear()

        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")

        if self.user_group == "Admin":
            self.grp_mgmt_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_mgmt_tab, "Group Management")

        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        lw_container = QWidget()
        lw_layout = QVBoxLayout(lw_container)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        lw_layout.addWidget(self.lineage_tab)
        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/desc/col/db/table...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        self.tabs.addTab(lw_container, "Lineage Visualization")

        # self.hierarchy_tab = HierarchyViewTab(self.connection)  # if defined
        # self.tabs.addTab(self.hierarchy_tab, "Hierarchy View")

        # self.custom_tab = CustomRuleGroupEnhancedTab(...)        # if defined
        # self.tabs.addTab(self.custom_tab, "Custom Rule Groups")

        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")

        if self.user_group == "Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        self.schedule_tab = ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.schedule_tab, "Schedule Management")

        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab, "Metrics Dashboard")

    def refresh_approvals(self):
        self.approv_tab.load_approvals()

    def check_due_schedules(self):
        c = self.connection.cursor()
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        c.execute("""
        SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE SCHEDULE_TIME <= ? AND STATUS = 'Scheduled'
        """, (now,))
        due = get_cursor_rows(c)

        for schedule in due:
            rule_id = schedule["RULE_ID"]
            c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = get_cursor_one(c)
            if row:
                rule_sql = row["RULE_SQL"]
                result, msg = run_rule_sql(self.connection, rule_sql)
                logger.info(f"Scheduled rule {rule_id} executed: {'PASS' if result else 'FAIL'} - {msg}")

            c.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?", (schedule["SCHEDULE_ID"],))

        self.connection.commit()
        self.schedule_tab.load_schedules()

    def show_metrics_dashboard(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("Operational Metrics Dashboard")
        dlg.resize(800, 600)
        layout = QVBoxLayout(dlg)
        metrics_tab = MetricsDashboardTab(self.connection)
        layout.addWidget(metrics_tab)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.close)
        layout.addWidget(close_btn)
        dlg.exec_()

    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def get_rule_types(self):
        """
        Example: Return a dictionary of name->id for rule types, e.g. {"DQ":1, "DM":2}
        Adjust as needed or fetch from DB
        """
        # Hard-coded example or fetch from DB
        return {"DQ": 1, "DM": 2, "Validation": 3}

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# MAIN
###############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()