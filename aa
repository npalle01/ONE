#!/usr/bin/env python
import sys
import sqlite3
import logging
import json
import math
import re
import smtplib
from email.mime.text import MIMEText
from datetime import datetime
from collections import deque

try:
    import pyodbc
except ImportError:
    pyodbc = None

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog, QDockWidget,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox, QTreeView, QListWidget, QListWidgetItem
)
import pyqtgraph as pg

logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_username",
    "smtp_password": "your_password",
    "sender_email": "noreply@example.com"
}

USE_ODBC = False

###############################################################################
# CROSS-DB UTILS
###############################################################################
def get_last_inserted_id(cursor):
    if USE_ODBC:
        try:
            cursor.execute("SELECT SCOPE_IDENTITY()")
            row = cursor.fetchone()
            if row and row[0] is not None:
                return int(row[0])
        except:
            pass
        cursor.execute("SELECT @@IDENTITY")
        row2 = cursor.fetchone()
        if row2 and row2[0] is not None:
            return int(row2[0])
        return None
    else:
        return cursor.lastrowid

def get_cursor_rows(cursor):
    try:
        rows = cursor.fetchall()
    except:
        return []
    if not rows:
        return []
    if cursor.description:
        cols = [d[0] for d in cursor.description]
        out=[]
        for r in rows:
            dd={}
            for i,c in enumerate(cols):
                dd[c]=r[i]
            out.append(dd)
        return out
    return rows

def get_cursor_one(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [d[0] for d in cursor.description]
        dd={}
        for i,c in enumerate(cols):
            dd[c]=row[i]
        return dd
    return None

def send_email_notification(subject, body, recipients):
    msg = MIMEText(body,'plain')
    msg['Subject']=subject
    msg['From']=EMAIL_CONFIG['sender_email']
    msg['To']=", ".join(recipients)
    try:
        s=smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        s.starttls()
        s.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        s.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        s.quit()
        logger.info("Email sent to: "+", ".join(recipients))
    except Exception as ex:
        logger.error("Error sending email: "+str(ex))

###############################################################################
# DB CONN DIALOG
###############################################################################
class DatabaseConnectionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select DB Connection")
        lay=QVBoxLayout(self)

        self.conn_type_combo=QComboBox()
        self.conn_type_combo.addItem("In-Memory SQLite","memory")
        if pyodbc:
            try:
                dsn_dict=pyodbc.dataSources()
                for dsn_name,driver in dsn_dict.items():
                    if "SQL SERVER" in driver.upper():
                        self.conn_type_combo.addItem(f"ODBC: {dsn_name}", dsn_name)
            except Exception as e:
                logger.error("DSN listing error: "+str(e))

        lay.addWidget(QLabel("Connection Type:"))
        lay.addWidget(self.conn_type_combo)

        self.conn_str_edit=QLineEdit()
        self.conn_str_edit.setPlaceholderText("Optional custom ODBC conn string")
        lay.addWidget(self.conn_str_edit)

        btnh=QHBoxLayout()
        okb=QPushButton("Connect")
        okb.clicked.connect(self.accept)
        cb=QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        btnh.addWidget(okb)
        btnh.addWidget(cb)
        lay.addLayout(btnh)

    def get_connection(self):
        choice=self.conn_type_combo.currentData()
        if choice=="memory":
            return setup_in_memory_db()
        else:
            override=self.conn_str_edit.text().strip()
            if override:
                conn_str=override
            else:
                conn_str=f"DSN={choice};Trusted_Connection=yes;"
            try:
                global USE_ODBC
                USE_ODBC=True
                return pyodbc.connect(conn_str)
            except Exception as ex:
                QMessageBox.critical(self,"Connection Error",str(ex))
                return None

###############################################################################
# SETUP IN-MEMORY
###############################################################################
def setup_in_memory_db():
    conn=sqlite3.connect("file::memory:?cache=shared",uri=True,timeout=10.0)
    conn.execute("PRAGMA foreign_keys=ON;")
    conn.row_factory=sqlite3.Row
    create_tables_and_seed(conn)
    return conn

def create_tables_and_seed(conn):
    c=conn.cursor()
    # Create tables
    c.execute("""
    CREATE TABLE IF NOT EXISTS USERS(
        USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        USERNAME TEXT UNIQUE NOT NULL,
        PASSWORD TEXT NOT NULL,
        USER_GROUP TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
        GROUP_NAME TEXT PRIMARY KEY,
        DESCRIPTION TEXT,
        EMAIL TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS GROUP_PERMISSIONS(
        GROUP_NAME TEXT NOT NULL,
        TARGET_TABLE TEXT NOT NULL,
        PRIMARY KEY(GROUP_NAME,TARGET_TABLE)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
        RULE_TYPE_ID INTEGER PRIMARY KEY,
        RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
        GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT UNIQUE NOT NULL,
        DESCRIPTION TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULES(
        RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_ID INTEGER,
        PARENT_RULE_ID INTEGER,
        RULE_TYPE_ID INTEGER NOT NULL,
        RULE_NAME TEXT NOT NULL,
        RULE_SQL TEXT NOT NULL,
        EFFECTIVE_START_DATE TEXT NOT NULL,
        EFFECTIVE_END_DATE TEXT,
        STATUS TEXT NOT NULL CHECK(STATUS IN ('ACTIVE','INACTIVE')),
        VERSION INTEGER NOT NULL DEFAULT 1,
        CREATED_BY TEXT NOT NULL,
        DESCRIPTION TEXT,
        OPERATION_TYPE TEXT,
        BUSINESS_JUSTIFICATION TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        UPDATED_BY TEXT,
        OWNER_GROUP TEXT NOT NULL,
        CLUSTER_NAME TEXT,
        APPROVAL_STATUS TEXT NOT NULL DEFAULT 'DRAFT',
        IS_GLOBAL INTEGER NOT NULL DEFAULT 0,
        CRITICAL_RULE INTEGER NOT NULL DEFAULT 0,
        CRITICAL_SCOPE TEXT NOT NULL DEFAULT 'NONE',
        CDC_TYPE TEXT NOT NULL DEFAULT 'NONE'
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
        DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        DATABASE_NAME TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        COLUMN_NAME TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        RECORD_ID TEXT NOT NULL,
        ACTION_BY TEXT NOT NULL,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
        LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_INFO TEXT,
        TARGET_INFO TEXT,
        TRANSFORMATION_DETAILS TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
        MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_RULE_ID INTEGER NOT NULL,
        SOURCE_COLUMN_NAME TEXT NOT NULL,
        TARGET_COLUMN_NAME TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_RULE_GROUPS(
        CUSTOM_GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_NAME TEXT NOT NULL UNIQUE,
        OWNER_BUSINESS_GROUP TEXT NOT NULL,
        CREATED_BY TEXT NOT NULL,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_MEMBERS(
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        RULE_ID INTEGER NOT NULL,
        PRIMARY KEY(CUSTOM_GROUP_ID,RULE_ID)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUP_APPROVERS(
        APPROVER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
        RULE_ID INTEGER NOT NULL,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        APPROVED_FLAG INTEGER NOT NULL DEFAULT 0,
        APPROVED_TIMESTAMP DATETIME,
        APPROVAL_STAGE INTEGER NOT NULL DEFAULT 1,
        PRIMARY KEY(RULE_ID,GROUP_NAME,USERNAME)
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GLOBAL_CRITICAL_LINKS(
        LINK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GCR_RULE_ID INTEGER NOT NULL,
        TARGET_RULE_ID INTEGER,
        TARGET_GROUP_ID INTEGER
    );
    """)

    # seed
    groups = [
        ("Admin","Admin group","admin@example.com"),
        ("BG1","Group1","bg1@example.com"),
        ("BG2","Group2","bg2@example.com"),
        ("BG3","Group3","bg3@example.com")
    ]
    for g_ in groups:
        c.execute("INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)", g_)

    users = [
        ("admin","admin","Admin"),
        ("bg1_user","user","BG1"),
        ("bg2_user","user","BG2"),
        ("bg3_user","user","BG3")
    ]
    for u_ in users:
        c.execute("INSERT OR IGNORE INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)", u_)

    perms = [
        ("Admin","TABLE_A"),("Admin","TABLE_B"),("Admin","TABLE_C"),("Admin","TABLE_D"),
        ("BG1","TABLE_A"),("BG1","TABLE_B"),
        ("BG2","TABLE_C"),
        ("BG3","TABLE_D")
    ]
    for pp in perms:
        c.execute("INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)", pp)

    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(1,'DQ')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(2,'DM')")

    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG1','bg1_user')")
    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG2','bg2_user')")
    c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG3','bg3_user')")

    c.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION) VALUES('Finance Rules','Finance data rules')")
    c.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION) VALUES('HR Rules','HR data rules')")

    conn.commit()

###############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    c=conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA)
    VALUES(?,?,?,?,?,?)
    """,(action,table_name,str(record_id),action_by,
         json.dumps(old_data) if old_data else None,
         json.dumps(new_data) if new_data else None))
    conn.commit()

###############################################################################
# We define the multi-step approvals with Approve/Decline
# Then advanced lineage with BFS subgraph searching
###############################################################################

class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=None
        self.user_group=None
        self.setWindowTitle("Login")
        self.setFixedSize(300,200)

        layout=QVBoxLayout(self)

        self.user_edit=QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit=QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn=QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)

    def do_login(self):
        usern=self.user_edit.text().strip()
        passw=self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self,"Error","Enter user/pass.")
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(usern,passw))
        row=get_cursor_one(c)
        if row:
            self.user_id=row["USER_ID"]
            self.user_group=row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")

class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(5)
        for st in ["BG1","BG2","BG3","FINAL"]:
            circle=QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status=stage_status_map.get(st,"NotStarted")
            if status=="Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status=="Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status=="Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        layout=QVBoxLayout(self)
        self.appr_table=QTableWidget(0,8)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID","Group Name","Rule Name","Stage","Approved?","Approve","Decline","Pipeline"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVED_TIMESTAMP,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=get_cursor_rows(c)

        # gather pipeline
        pipe_data={}
        all_app=self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        all_rows=get_cursor_rows(all_app)

        from collections import defaultdict
        stage_map=defaultdict(lambda: {"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})

        def get_cur_stage(rrid):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE) as st
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rrid,))
            ro=get_cursor_one(c2)
            if ro and ro["st"]:
                return ro["st"]
            return None

        c3=self.connection.cursor()
        c3.execute("SELECT RULE_ID FROM BRM_RULES")
        all_rids=get_cursor_rows(c3)
        rule_stage={}
        for r_ in all_rids:
            rrid=r_["RULE_ID"]
            rule_stage[rrid]=get_cur_stage(rrid)

        for apr in all_rows:
            rid=apr["RULE_ID"]
            grp=apr["GROUP_NAME"]
            flg=apr["APPROVED_FLAG"]
            stg=apr["APPROVAL_STAGE"]
            cs=rule_stage[rid]
            if flg==1:
                stage_map[rid][grp]="Approved"
            elif flg==2:
                stage_map[rid][grp]="Rejected"
            else:
                if cs==stg:
                    stage_map[rid][grp]="Pending"
                else:
                    stage_map[rid][grp]="NotStarted"

        pipe_data=dict(stage_map)

        # only rows where user is current stage
        minimal=[]
        for rd in rows:
            rid_=rd["RULE_ID"]
            st_=rd["APPROVAL_STAGE"]
            if rule_stage[rid_]==st_:
                minimal.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r,2,QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r,3,QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r,4,QTableWidgetItem(str(rd["APPROVED_FLAG"])))

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_idx=r: self.do_approve(row_idx))
            self.appr_table.setCellWidget(r,5,approve_btn)

            decline_btn=QPushButton("Decline")
            decline_btn.clicked.connect(lambda _, row_idx=r: self.do_decline(row_idx))
            self.appr_table.setCellWidget(r,6,decline_btn)

            pm=pipe_data.get(rd["RULE_ID"],{"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            pipew=ApprovalPipelineWidget(pm)
            self.appr_table.setCellWidget(r,7,pipew)

    def do_approve(self, row_index):
        rid_item=self.appr_table.item(row_index,0)
        grp_item=self.appr_table.item(row_index,1)
        if not rid_item or not grp_item:
            return
        rule_id=int(rid_item.text())
        grp=grp_item.text()
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id,grp,self.logged_in_username))
        st=self.get_current_stage(rule_id)
        if st is None:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?",(rule_id,))
        else:
            c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?",(rule_id,))

        add_audit_log(self.connection,"APPROVE","BRM_RULE_APPROVALS",rule_id,self.logged_in_username,
                      {"APPROVED_FLAG":0},{"APPROVED_FLAG":1})
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"You approved rule {rule_id}.")
        self.load_approvals()

    def do_decline(self, row_index):
        rid_item=self.appr_table.item(row_index,0)
        grp_item=self.appr_table.item(row_index,1)
        if not rid_item or not grp_item:
            return
        rule_id=int(rid_item.text())
        grp=grp_item.text()
        confirm=QMessageBox.question(self,"Confirm",f"Decline rule {rule_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id,grp,self.logged_in_username))
        c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE' WHERE RULE_ID=?",(rule_id,))
        add_audit_log(self.connection,"DECLINE","BRM_RULE_APPROVALS",rule_id,self.logged_in_username,
                      {"APPROVED_FLAG":0},{"APPROVED_FLAG":2})
        self.connection.commit()
        QMessageBox.information(self,"Declined",f"You declined rule {rule_id}.")
        self.load_approvals()

    def get_current_stage(self, rule_id):
        c=self.connection.cursor()
        c.execute("""
        SELECT MIN(APPROVAL_STAGE) as st
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=? AND APPROVED_FLAG=0
        """,(rule_id,))
        row=get_cursor_one(c)
        if row and row["st"]:
            return row["st"]
        return None

###############################################################################
# ADVANCED END-TO-END LINEAGE
###############################################################################
class LineageSearchDialog(QtWidgets.QDialog):
    def __init__(self, lineage_widget, parent=None):
        super().__init__(parent)
        self.lineage_widget=lineage_widget
        self.setWindowTitle("Search Lineage")
        lay=QVBoxLayout(self)
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search table or rule name/SQL/desc..")
        lay.addWidget(self.search_edit)
        btn=QPushButton("Search")
        btn.clicked.connect(self.do_search)
        lay.addWidget(btn)
        self.setLayout(lay)

    def do_search(self):
        txt=self.search_edit.text().strip()
        self.lineage_widget.search_lineage(txt)
        self.accept()

class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.rule_data={}
        self.rule_adjacency={}
        self.table_refs={}
        self.node_map={}
        self.load_data()
        self.search_lineage("")

    def load_data(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,IS_GLOBAL,CRITICAL_RULE,RULE_SQL,DESCRIPTION
        FROM BRM_RULES
        """)
        rows=get_cursor_rows(c)
        self.rule_data={r_["RULE_ID"]:dict(r_) for r_ in rows}

        self.rule_adjacency={}
        for rid in self.rule_data:
            self.rule_adjacency[rid]=set()

        # parent->child
        for rid,inf in self.rule_data.items():
            pid=inf["PARENT_RULE_ID"]
            if pid in self.rule_data:
                self.rule_adjacency[pid].add(rid)

        # column mapping
        c.execute("SELECT RULE_ID,SOURCE_RULE_ID FROM BRM_COLUMN_MAPPING")
        cmaps=get_cursor_rows(c)
        for cm in cmaps:
            src=cm["SOURCE_RULE_ID"]
            tgt=cm["RULE_ID"]
            if src in self.rule_adjacency:
                self.rule_adjacency[src].add(tgt)

        # table deps
        self.table_refs={}
        for rid in self.rule_data:
            self.table_refs[rid]=set()
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
        drows=get_cursor_rows(c)
        for d_ in drows:
            rr=d_["RULE_ID"]
            dbn=(d_["DATABASE_NAME"] or "")
            tbn=(d_["TABLE_NAME"] or "")
            self.table_refs[rr].add((dbn,tbn))

    def search_lineage(self, query:str):
        q_low=query.lower()
        matched_rules=set()
        for rid,inf in self.rule_data.items():
            rn=(inf["RULE_NAME"] or "").lower()
            rs=(inf["RULE_SQL"] or "").lower()
            rd=(inf["DESCRIPTION"] or "").lower()
            if q_low in rn or q_low in rs or q_low in rd:
                matched_rules.add(rid)

        all_tables=set()
        for rid in self.table_refs:
            for tk in self.table_refs[rid]:
                all_tables.add(tk)
        matched_tables=set()
        for tk in all_tables:
            txt=(tk[0]+"."+tk[1]).lower()
            if q_low in txt:
                matched_tables.add(tk)

        combined={}
        # node => ("rule",rid) or ("table",(db,table))
        for rid in self.rule_data:
            combined[("rule",rid)]=set()
        for tb in all_tables:
            combined[("table",tb)]=set()

        # rule->rule adjacency
        for p, chs in self.rule_adjacency.items():
            for c_ in chs:
                combined[("rule",p)].add(("rule",c_))
                combined[("rule",c_)].add(("rule",p))

        # rule->table
        for rid, tset in self.table_refs.items():
            for tk in tset:
                combined[("rule",rid)].add(("table",tk))
                combined[("table",tk)].add(("rule",rid))

        start_nodes=set()
        for r_ in matched_rules:
            start_nodes.add(("rule",r_))
        for t_ in matched_tables:
            start_nodes.add(("table",t_))

        visited=set()
        from collections import deque
        dq=deque(start_nodes)
        while dq:
            node=dq.popleft()
            if node in visited:
                continue
            visited.add(node)
            if node in combined:
                for nb in combined[node]:
                    if nb not in visited:
                        dq.append(nb)

        self.scene.clear()
        self.node_map={}

        # BFS layout
        queue2=deque()
        for sn in start_nodes:
            if sn in visited:
                queue2.append((sn,0))
        layer_counts={}
        visited_layout=set()

        while queue2:
            (nd,depth)=queue2.popleft()
            if nd in visited_layout:
                continue
            visited_layout.add(nd)
            layer_counts[depth]=layer_counts.get(depth,0)
            x=depth*250
            y=layer_counts[depth]*100
            layer_counts[depth]+=1

            if nd[0]=="rule":
                rid=nd[1]
                item=self.create_rule_node(self.rule_data[rid])
                item.setPos(x,y)
                self.scene.addItem(item)
                self.node_map[nd]=item
            else:
                tk=nd[1]
                item=self.create_table_node(tk)
                item.setPos(x,y)
                self.scene.addItem(item)
                self.node_map[nd]=item

            for nb in combined.get(nd,[]):
                if nb in visited and nb not in visited_layout:
                    queue2.append((nb,depth+1))

        # edges
        for node in visited:
            if node not in self.node_map:
                continue
            for nb in combined[node]:
                if nb in visited and nb in self.node_map:
                    self.draw_edge(self.node_map[node], self.node_map[nb])

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_rule_node(self, rinfo):
        rtype=rinfo["RULE_TYPE_ID"]
        if rtype==1:
            node=QtWidgets.QGraphicsRectItem(0,0,120,50)
        else:
            node=QtWidgets.QGraphicsEllipseItem(0,0,120,50)
        st=rinfo["STATUS"]
        if st.lower()=="active":
            col=QtGui.QColor("lightgreen")
        else:
            col=QtGui.QColor("tomato")
        node.setBrush(QtGui.QBrush(col))

        pen=QtGui.QPen(QtCore.Qt.black,2)
        if rinfo["CRITICAL_RULE"]==1:
            pen=QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)

        disp=rinfo["RULE_NAME"]
        if rinfo["IS_GLOBAL"]==1:
            disp="(G) "+disp
        node.setToolTip(f"Rule {rinfo['RULE_ID']}: {disp}\nSQL: {rinfo['RULE_SQL']}")
        return node

    def create_table_node(self, tk):
        node=QtWidgets.QGraphicsEllipseItem(0,0,100,40)
        node.setBrush(QtGui.QBrush(QtGui.QColor("lightblue")))
        node.setPen(QtGui.QPen(QtGui.QColor("blue"),2))
        txt=f"{tk[0]}.{tk[1]}"
        node.setToolTip(f"Table: {txt}")
        return node

    def draw_edge(self, item1, item2, color=QtGui.QColor("darkblue")):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=QtWidgets.QGraphicsLineItem(p1.x(),p1.y(),p2.x(),p2.y())
        line.setPen(QtGui.QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.items():
            self.fitInView(self.scene.itemsBoundingRect(),Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button()==Qt.LeftButton:
            it=self.itemAt(event.pos())
            if isinstance(it,(QtWidgets.QGraphicsRectItem,QtWidgets.QGraphicsEllipseItem)):
                QMessageBox.information(self,"Node Info", it.toolTip())
        super().mousePressEvent(event)

###############################################################################
# MAIN WINDOW
###############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool â€“ All Features in Single File")
        self.resize(1200,800)

        # DB connect
        self.connection=None
        dlg=DatabaseConnectionDialog()
        if dlg.exec_()==QDialog.Accepted:
            self.connection=dlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # login
        self.login_dialog=LoginDialog(self.connection)
        if self.login_dialog.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=self.login_dialog.user_id

        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        rowu=get_cursor_one(c)
        self.logged_in_username=rowu["USERNAME"] if rowu else "Unknown"

        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(self.user_id,))
        rowg=get_cursor_one(c)
        self.user_group=rowg["USER_GROUP"] if rowg else "Unknown"

        self.init_ui()

    def init_ui(self):
        cw=QWidget()
        lay=QVBoxLayout(cw)

        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            lay.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs=QTabWidget()
        lay.addWidget(self.tabs)

        # 1) Approvals tab
        self.approvals_tab=MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab,"Approvals")

        # 2) End-to-End Lineage
        lineage_container=QWidget()
        lin_lay=QVBoxLayout(lineage_container)
        lb=QLabel("Advanced End-to-End Lineage")
        lb.setStyleSheet("font-weight:bold;")
        lin_lay.addWidget(lb)
        self.lineage_widget=EnhancedLineageGraphWidget(self.connection)
        lin_lay.addWidget(self.lineage_widget)
        srch_h=QHBoxLayout()
        srch_btn=QPushButton("Search Lineage")
        srch_btn.clicked.connect(self.on_lineage_search)
        ref_btn=QPushButton("Show Full Graph")
        ref_btn.clicked.connect(lambda: self.lineage_widget.search_lineage(""))
        rst_btn=QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_widget.resetView)
        srch_h.addWidget(srch_btn)
        srch_h.addWidget(ref_btn)
        srch_h.addWidget(rst_btn)
        srch_h.addStretch()
        lin_lay.addLayout(srch_h)
        self.tabs.addTab(lineage_container,"Lineage")

        # 3) Control Tables
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # 4) Group Management
        self.grp_mgmt_tab=GroupManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # 5) User Management
        if self.user_group=="Admin":
            self.user_mgmt_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        # 6) Hierarchy
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy View")

        # 7) Custom Rule Groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Rule Groups")

        # 8) Global/Critical Admin
        if self.user_group=="Admin":
            self.gc_admin_tab=GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab,"Global/Critical Admin")

        # 9) BRM (Business Rule Management)
        self.brm_tab=BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab,"Business Rule Management")

        # done
        cw.setLayout(lay)
        self.setCentralWidget(cw)

        self.timer=QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)
        self.show()

    def on_lineage_search(self):
        dlg=LineageSearchDialog(self.lineage_widget, self)
        dlg.exec_()

    def populate_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=get_cursor_rows(c)
        for r_ in rows:
            disp=f"{r_['USERNAME']} ({r_['USER_GROUP']})"
            self.switch_combo.addItem(disp,(r_["USER_ID"],r_["USER_GROUP"]))

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        new_uid,new_grp=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        self.reinit_tabs()

    def reinit_tabs(self):
        self.tabs.clear()
        self.approvals_tab=MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab,"Approvals")
        lineage_container=QWidget()
        lin_lay=QVBoxLayout(lineage_container)
        lb=QLabel("Advanced End-to-End Lineage")
        lb.setStyleSheet("font-weight:bold;")
        lin_lay.addWidget(lb)
        self.lineage_widget=EnhancedLineageGraphWidget(self.connection)
        lin_lay.addWidget(self.lineage_widget)
        srch_h=QHBoxLayout()
        srch_btn=QPushButton("Search Lineage")
        srch_btn.clicked.connect(self.on_lineage_search)
        ref_btn=QPushButton("Show Full Graph")
        ref_btn.clicked.connect(lambda: self.lineage_widget.search_lineage(""))
        rst_btn=QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_widget.resetView)
        srch_h.addWidget(srch_btn)
        srch_h.addWidget(ref_btn)
        srch_h.addWidget(rst_btn)
        srch_h.addStretch()
        lin_lay.addLayout(srch_h)
        self.tabs.addTab(lineage_container,"Lineage")

        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        self.grp_mgmt_tab=GroupManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        if self.user_group=="Admin":
            self.user_mgmt_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy View")

        self.custom_tab=CustomRuleGroupEnhancedTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Rule Groups")

        if self.user_group=="Admin":
            self.gc_admin_tab=GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab,"Global/Critical Admin")

        self.brm_tab=BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab,"Business Rule Management")

    def refresh_approvals(self):
        self.approvals_tab.load_approvals()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

###############################################################################
# The following classes implement all the other tabs, fully integrated:
#   - BusinessRuleManagementTab
#   - GroupManagementTab
#   - UserManagementTab
#   - CustomRuleGroupEnhancedTab
#   - GlobalCriticalAdminTab
#   - CtrlTablesTab
#   - HierarchyViewTab
#
# (They were each separately shown before. Here we give them all, fully integrated.)
###############################################################################

class BusinessRuleManagementTab(QWidget):
    """
    Hosts a RuleDashboard + action buttons (Add/Update/Deactivate/Delete, etc.)
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app=main_app
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)
        btn_h=QHBoxLayout()
        addb=QPushButton("Add Rule")
        addb.clicked.connect(self.on_add_rule)
        btn_h.addWidget(addb)

        updb=QPushButton("Update Rule")
        updb.clicked.connect(self.on_update_rule)
        btn_h.addWidget(updb)

        dact=QPushButton("Deactivate Selected")
        dact.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(dact)

        delb=QPushButton("Delete Rule")
        delb.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(delb)

        aud_b=QPushButton("View Audit Logs")
        aud_b.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_b)

        srch_b=QPushButton("Search Rules")
        srch_b.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_b)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.rule_dash=RuleDashboard(self.connection, self.user_id, self.user_group)
        layout.addWidget(self.rule_dash)
        layout.addStretch()
        self.setLayout(layout)

    def on_add_rule(self):
        rtypes=self.main_app.get_rule_types()
        dlg=RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_()==QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_update_rule(self):
        rid=self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self,"No Selection","Select a rule first.")
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=get_cursor_one(c)
        if not row:
            QMessageBox.warning(self,"Not Found","No rule with that ID.")
            return
        rule_data=dict(row)
        rtypes=self.main_app.get_rule_types()
        dlg=RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_()==QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_deactivate_rules(self):
        rids=self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        success=0
        fails=[]
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(f"Rule {rr}: {str(ex)}")
        msg=f"Deactivation done. success={success}"
        if fails:
            msg+="\nFails:\n"+ "\n".join(fails)
        QMessageBox.information(self,"Deactivate",msg)
        self.rule_dash.load_rules()

    def on_delete_rule(self):
        rids=self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(f"Rule {rid}: {str(ex)}")
        msg=f"Deletion done. success={success}"
        if fails:
            msg+="\nFails:\n"+ "\n".join(fails)
        QMessageBox.information(self,"Delete",msg)
        self.rule_dash.load_rules()

# ... and so on for RuleDashboard, RuleEditorDialog, etc.
# (We continue with all needed classes like in your prior code)

# For space, here are more classes fully integrated:
class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.selected_rule_id=None
        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All Statuses",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        self.status_filter.addItem("DELETED","DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Owner Group","Created Timestamp","Approval Status"])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        btn_h=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)

        run_etl_btn=QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)

        analytics_btn=QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics)
        btn_h.addWidget(analytics_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)
        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.load_rules()

    def run_etl(self):
        executed,skipped=execute_rules_in_order(self.connection)
        msg=f"ETL finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self,"ETL",msg)
        self.load_rules()

    def show_analytics(self):
        dlg=RuleAnalyticsDialog(self.connection,self)
        dlg.exec_()

    def build_filter_query(self):
        f=[]
        p=[]
        txt=self.search_edit.text().strip()
        if txt:
            f.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            p.extend([f"%{txt}%", f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            if st.upper()=="DELETED":
                if USE_ODBC:
                    # handle SQL server
                    sub="(SELECT CAST(RECORD_ID as int) FROM BRM_AUDIT_LOG WHERE ACTION='DELETE' AND ISNUMERIC(RECORD_ID)=1)"
                    f.append(f"(RULE_ID IN {sub})")
                else:
                    f.append("(RULE_ID IN (SELECT RECORD_ID FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'))")
            else:
                f.append("STATUS=?")
                p.append(st)
        clause=" AND ".join(f) if f else "1=1"
        return clause,p

    def load_rules(self):
        c=self.connection.cursor()
        clause,p=self.build_filter_query()
        count_q=f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}"
        c.execute(count_q,p)
        rowc=get_cursor_one(c)
        total=rowc["ccount"] if rowc else 0

        self.total_pages=max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        elif self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page
        if USE_ODBC:
            data_q=f"""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
            FROM BRM_RULES
            WHERE {clause}
            ORDER BY RULE_ID DESC
            OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
            """
            c.execute(data_q, (*p, offset, self.records_per_page))
        else:
            data_q=f"""
            SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
            FROM BRM_RULES
            WHERE {clause}
            ORDER BY RULE_ID DESC
            LIMIT ? OFFSET ?
            """
            c.execute(data_q, (*p, self.records_per_page, offset))

        rows=get_cursor_rows(c)
        self.rule_table.setRowCount(0)
        for rd in rows:
            r=self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r,2,QTableWidgetItem(rd["RULE_SQL"]))
            st_item=QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower()=="active":
                st_item.setBackground(QColor(144,238,144))
            else:
                st_item.setBackground(QColor(255,182,193))
            self.rule_table.setItem(r,3,st_item)
            self.rule_table.setItem(r,4,QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r,5,QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r,6,QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r,7,QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel=self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.rule_table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i in idxs:
            row=i.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

class RuleEditorDialog(QDialog):
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_types=rule_types
        self.logged_in_user=logged_in_user
        self.rule_data=rule_data
        title="Edit Rule" if rule_data else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(900,500)

        main_layout=QHBoxLayout(self)
        left_box=QGroupBox("Basic Info")
        left_layout=QFormLayout(left_box)

        self.group_combo=QComboBox()
        self.group_combo.addItem("None",None)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        for r_ in rows:
            self.group_combo.addItem(r_["GROUP_NAME"],r_["GROUP_ID"])
        left_layout.addRow("Rule Group:",self.group_combo)

        self.parent_rule_combo=QComboBox()
        self.parent_rule_combo.addItem("None",None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
        pr_rows=get_cursor_rows(c)
        for rr in pr_rows:
            self.parent_rule_combo.addItem(f"{rr['RULE_NAME']} (ID:{rr['RULE_ID']})", rr["RULE_ID"])
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit=QLineEdit()
        left_layout.addRow("Rule Name:",self.name_edit)

        self.type_combo=QComboBox()
        for rt_name in self.rule_types:
            self.type_combo.addItem(rt_name)
        left_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo=QComboBox()
        self.status_combo.addItems(["ACTIVE","INACTIVE"])
        left_layout.addRow("Status:",self.status_combo)

        self.start_dt=QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:",self.start_dt)

        self.end_dt=QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:",self.end_dt)

        self.owner_grp_combo=QComboBox()
        c.execute("SELECT DISTINCT GROUP_NAME FROM GROUP_PERMISSIONS ORDER BY GROUP_NAME")
        og_rows=get_cursor_rows(c)
        for g_ in og_rows:
            self.owner_grp_combo.addItem(g_["GROUP_NAME"],g_["GROUP_NAME"])
        left_layout.addRow("Owner Group:",self.owner_grp_combo)

        self.global_checkbox=None
        if self.logged_in_user=="Admin":
            self.global_checkbox=QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:",self.global_checkbox)

        self.critical_checkbox=QCheckBox()
        left_layout.addRow("Critical Rule?",self.critical_checkbox)

        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        left_layout.addRow("Critical Scope:",self.scope_combo)

        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","INSERT_ONLY","UPSERT"])
        left_layout.addRow("CDC Type:",self.cdc_combo)

        main_layout.addWidget(left_box)

        right_box=QGroupBox("Details & Logic")
        right_layout=QFormLayout(right_box)

        self.sql_editor=QPlainTextEdit()
        font=QtGui.QFont("Courier",10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"),self.sql_editor)

        self.description_edit=QTextEdit()
        right_layout.addRow(QLabel("Description:"),self.description_edit)

        self.justification_edit=QTextEdit()
        right_layout.addRow(QLabel("Justification:"),self.justification_edit)

        btn_box=QHBoxLayout()
        self.save_btn=QPushButton("Save" if rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)
        c_btn=QPushButton("Cancel")
        c_btn.clicked.connect(self.reject)
        btn_box.addWidget(c_btn)
        right_layout.addRow(btn_box)

        main_layout.addWidget(right_box)
        self.setLayout(main_layout)

        if self.rule_data:
            self.load_rule_data(self.rule_data)

    def load_rule_data(self, rd):
        if rd["GROUP_ID"]:
            idx=self.group_combo.findData(rd["GROUP_ID"])
            if idx>=0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2=self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2>=0:
                self.parent_rule_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"])
        for nm,tid in self.rule_types.items():
            if tid==rd["RULE_TYPE_ID"]:
                i=self.type_combo.findText(nm)
                if i>=0:
                    self.type_combo.setCurrentIndex(i)
                break
        st=rd["STATUS"]
        i_st=self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)
        try:
            from datetime import datetime
            sdt=datetime.strptime(rd["EFFECTIVE_START_DATE"], "%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except:
            pass
        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt=datetime.strptime(rd["EFFECTIVE_END_DATE"], "%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except:
                pass
        og=rd["OWNER_GROUP"]
        iog=self.owner_grp_combo.findText(og)
        if iog>=0:
            self.owner_grp_combo.setCurrentIndex(iog)
        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        if self.global_checkbox and rd.get("IS_GLOBAL",0)==1:
            self.global_checkbox.setChecked(True)
        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_checkbox.setChecked(True)
        scope_val=rd.get("CRITICAL_SCOPE","NONE").upper()
        ix_scope=self.scope_combo.findText(scope_val)
        if ix_scope>=0:
            self.scope_combo.setCurrentIndex(ix_scope)
        cdc_val=rd.get("CDC_TYPE","NONE").upper()
        ix_cdc=self.cdc_combo.findText(cdc_val)
        if ix_cdc>=0:
            self.cdc_combo.setCurrentIndex(ix_cdc)

    def on_save(self):
        if not self.name_edit.text().strip():
            QMessageBox.warning(self,"Error","Name is empty.")
            return
        sql_text=self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self,"Error","SQL is empty.")
            return

        op_type=self.get_op_type_from_sql(sql_text)
        rule_dict={
            "GROUP_ID":self.group_combo.currentData(),
            "PARENT_RULE_ID":self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID":self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME":self.name_edit.text().strip(),
            "RULE_SQL":sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
            "CDC_TYPE": self.cdc_combo.currentText().upper()
        }
        created_by=self.logged_in_user
        if self.rule_data:
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            confirm=QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success","Rule updated. Approval re-initiated.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"DB Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id=add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success",f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"DB Error",str(ex))

    def get_op_type_from_sql(self, sql_text:str)->str:
        txt=sql_text.strip().upper()
        if txt.startswith("INSERT"):
            return "INSERT"
        elif txt.startswith("DELETE"):
            return "DELETE"
        elif txt.startswith("UPDATE"):
            return "UPDATE"
        elif txt.startswith("SELECT"):
            return "SELECT"
        return "OTHER"

###############################################################################
# For analytics
###############################################################################
class RuleAnalyticsDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        chart_hbox=QHBoxLayout()
        self.bar_chart=pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)

        self.pie_chart=pg.PlotWidget(title="Rule Status Distribution")
        self.pie_chart.setBackground('w')
        chart_hbox.addWidget(self.pie_chart)
        layout.addLayout(chart_hbox)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)
        self.load_charts()

    def load_charts(self):
        c=self.connection.cursor()

        # count by creator
        c.execute("SELECT CREATED_BY,COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY")
        rows=get_cursor_rows(c)
        creators={r_["CREATED_BY"]:r_["cnt"] for r_ in rows}

        # status counts
        status_counts={"ACTIVE":0,"INACTIVE":0,"DELETED":0}
        c.execute("SELECT STATUS,COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        srows=get_cursor_rows(c)
        for s_ in srows:
            s_up=s_["STATUS"].upper()
            if s_up in status_counts:
                status_counts[s_up]=s_["sc"]

        c.execute("SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'")
        drow=get_cursor_one(c)
        if drow:
            status_counts["DELETED"]=drow["delcnt"]

        # bar chart
        self.bar_chart.clear()
        if creators:
            sorted_creators=sorted(creators.items(), key=lambda x:x[1], reverse=True)
            names=[x[0] for x in sorted_creators]
            vals=[x[1] for x in sorted_creators]
            bar_item=pg.BarGraphItem(x=range(len(names)),height=vals,width=0.6,brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax=self.bar_chart.getAxis("bottom")
            ax.setTicks([list(zip(range(len(names)),names))])
            self.bar_chart.setLabel("left","Number of Rules")
            self.bar_chart.setLabel("bottom","Created By")
            self.bar_chart.showGrid(x=True,y=True)

        # pie chart
        self.pie_chart.clear()
        total=sum(status_counts.values())
        if total>0:
            angles=[]
            for v in status_counts.values():
                angles.append(360*(v/total))
            start=90
            color_map={"ACTIVE":"green","INACTIVE":"red","DELETED":"gray"}
            scene=self.pie_chart.scene()
            if not scene:
                from PyQt5.QtWidgets import QGraphicsScene
                scene=QGraphicsScene()
                self.pie_chart.setScene(scene)
            keys=list(status_counts.keys())
            import math
            for i,ang in enumerate(angles):
                k=keys[i]
                if ang>0:
                    wedge=QtGui.QPainterPath()
                    wedge.moveTo(0,0)
                    wedge.arcTo(-100,-100,200,200,start,ang)
                    wedge.closeSubpath()
                    brush=QtGui.QBrush(QtGui.QColor(color_map.get(k,"blue")))
                    path_item=pg.QtWidgets.QGraphicsPathItem(wedge)
                    path_item.setBrush(brush)
                    path_item.setPen(pg.mkPen("black"))
                    scene.addItem(path_item)
                    mid=start+(ang/2)
                    rad=(mid*math.pi)/180
                    xx=50*math.cos(rad)
                    yy=50*math.sin(rad)
                    perc=int((ang/360)*100)
                    lab=pg.TextItem(f"{k} ({perc}%)",anchor=(0.5,0.5))
                    lab.setPos(xx,yy)
                    scene.addItem(lab)
                    start+=ang
            self.pie_chart.setAspectLocked(True)

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action,Table,Action By..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.audit_table=QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels(["Audit ID","Action","Table","Record ID","Action By","Old Data","New Data","Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)

        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        c=self.connection.cursor()
        if USE_ODBC:
            query="""
            SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """
            c.execute(query)
        else:
            c.execute("""
            SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
            LIMIT 1000
            """)
        rows=get_cursor_rows(c)
        self.audit_table.setRowCount(0)
        for row in rows:
            r=self.audit_table.rowCount()
            self.audit_table.insertRow(r)
            self.audit_table.setItem(r,0,QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r,1,QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r,2,QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r,3,QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r,4,QTableWidgetItem(row["ACTION_BY"]))

            oldtxt=""
            if row["OLD_DATA"]:
                try:
                    p=json.loads(row["OLD_DATA"])
                    oldtxt=json.dumps(p,indent=2)
                except:
                    oldtxt=row["OLD_DATA"]
            self.audit_table.setItem(r,5,QTableWidgetItem(oldtxt))

            newtxt=""
            if row["NEW_DATA"]:
                try:
                    p2=json.loads(row["NEW_DATA"])
                    newtxt=json.dumps(p2,indent=2)
                except:
                    newtxt=row["NEW_DATA"]
            self.audit_table.setItem(r,6,QTableWidgetItem(newtxt))
            self.audit_table.setItem(r,7,QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))

    def perform_search(self, text):
        txt_l=text.lower()
        for row in range(self.audit_table.rowCount()):
            match=False
            for col in (1,2,4):
                it=self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    match=True
                    break
            self.audit_table.setRowHidden(row, not match)

###############################################################################
# SEARCH RULE DIALOG
###############################################################################
class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules")
        self.resize(800,600)

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table=QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        c=self.connection.cursor()
        txt=self.search_edit.text().strip()
        if txt:
            if USE_ODBC:
                query="""
                SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
                FROM BRM_RULES
                WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(query,(f"%{txt}%",f"%{txt}%"))
            else:
                c.execute("""
                SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
                FROM BRM_RULES
                WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
                ORDER BY RULE_ID DESC
                LIMIT 1000
                """,(f"%{txt}%",f"%{txt}%"))
        else:
            if USE_ODBC:
                query="""
                SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(query)
            else:
                c.execute("""
                SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                LIMIT 1000
                """)
        rows=get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r=self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r,0,QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r,1,QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r,2,QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r,3,QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r,4,QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r,5,QTableWidgetItem(row["CREATED_BY"]))

###############################################################################
# GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app=main_app
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        if user_group!="Admin":
            lay=QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(lay)
            return

        layout=QVBoxLayout(self)
        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        btn_h=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        btn_h.addWidget(add_grp_btn)
        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        btn_h.addWidget(rename_grp_btn)
        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        btn_h.addWidget(del_grp_btn)
        backup_grp_btn=QPushButton("Backup Group")
        backup_grp_btn.clicked.connect(self.on_backup_group)
        btn_h.addWidget(backup_grp_btn)
        restore_grp_btn=QPushButton("Restore Group")
        restore_grp_btn.clicked.connect(self.on_restore_group)
        btn_h.addWidget(restore_grp_btn)
        btn_h.addStretch()
        grp_layout.addLayout(btn_h)
        gm_layout.addWidget(grp_box)

        membership_box=QGroupBox("Membership Management")
        membership_layout=QVBoxLayout(membership_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btn_h=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btn_h.addWidget(add_usr_btn)
        rem_usr_btn=QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btn_h.addWidget(rem_usr_btn)
        memb_btn_h.addStretch()
        membership_layout.addLayout(memb_btn_h)
        gm_layout.addWidget(membership_box)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)
        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)
        ptop_h=QHBoxLayout()
        ptop_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo=QComboBox()
        ptop_h.addWidget(self.perm_group_combo)
        ptop_h.addStretch()
        perm_box_layout.addLayout(ptop_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)
        pbtn_h=QHBoxLayout()
        add_perm_btn=QPushButton("Add Permission")
        add_perm_btn.clicked.connect(self.on_add_permission)
        pbtn_h.addWidget(add_perm_btn)
        rem_perm_btn=QPushButton("Remove Permission")
        rem_perm_btn.clicked.connect(self.on_remove_permission)
        pbtn_h.addWidget(rem_perm_btn)
        pbtn_h.addStretch()
        perm_box_layout.addLayout(pbtn_h)
        perm_layout.addWidget(perm_box)
        self.tabs.addTab(perm_tab,"Group Permissions")

        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)
        ah=QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo=QComboBox()
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)
        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)
        appr_btn_h=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btn_h.addWidget(add_appr_btn)
        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btn_h.addWidget(del_appr_btn)
        appr_btn_h.addStretch()
        appr_layout.addLayout(appr_btn_h)
        self.tabs.addTab(appr_tab,"Approvers Management")

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_data()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        self.groups_table.setRowCount(0)
        for row in rows:
            r=self.groups_table.rowCount()
            self.groups_table.insertRow(r)
            self.groups_table.setItem(r,0,QTableWidgetItem(row["GROUP_NAME"]))
            self.groups_table.setItem(r,1,QTableWidgetItem(row["DESCRIPTION"] or ""))
            self.groups_table.setItem(r,2,QTableWidgetItem(row["EMAIL"] or ""))

    def load_users(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=get_cursor_rows(c)
        self.users_table.setRowCount(0)
        for row in rows:
            rr=self.users_table.rowCount()
            self.users_table.insertRow(rr)
            self.users_table.setItem(rr,0,QTableWidgetItem(str(row["USER_ID"])))
            self.users_table.setItem(rr,1,QTableWidgetItem(row["USERNAME"]))
            self.users_table.setItem(rr,2,QTableWidgetItem(row["USER_GROUP"]))

    def load_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        self.perm_group_combo.clear()
        for r_ in rows:
            self.perm_group_combo.addItem(r_["GROUP_NAME"],r_["GROUP_NAME"])

    def load_appr_group_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=get_cursor_rows(c)
        self.appr_group_combo.clear()
        for r_ in rows:
            self.appr_group_combo.addItem(r_["GROUP_NAME"],r_["GROUP_NAME"])

    def load_permissions(self):
        grp=self.perm_group_combo.currentText().strip()
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows=get_cursor_rows(c)
        self.perm_table.setRowCount(0)
        for row in rows:
            rr=self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(row["TARGET_TABLE"]))

    def load_approvers(self):
        grp=self.appr_group_combo.currentText().strip()
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
        rows=get_cursor_rows(c)
        self.appr_table.setRowCount(0)
        for row in rows:
            r=self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(row["APPROVER_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(row["USERNAME"]))

    def get_selected_group(self):
        idx=self.groups_table.currentRow()
        if idx<0:
            return None
        it=self.groups_table.item(idx,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Add Group","Description:")
        if not ok2:
            desc=""
        email,ok3=QInputDialog.getText(self,"Add Group","Email:")
        if not ok3:
            email=""
        c=self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name.strip(),))
        if get_cursor_one(c):
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",(name.strip(),desc.strip(),email.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Success","Group added.")
        self.load_data()

    def on_rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename Group","New group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if get_cursor_one(c):
            QMessageBox.warning(self,"Error","New group name already exists.")
            return
        try:
            c.execute("BEGIN")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULE_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            add_audit_log(self.connection,"RENAME_GROUP","BUSINESS_GROUPS",grp,"Admin",
                          {"old_group_name":grp},{"new_group_name":new_name.strip()})
            QMessageBox.information(self,"Renamed",f"Renamed to {new_name}")
            self.load_data()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def on_delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group deleted.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def on_backup_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        try:
            ver=BackupRestoreHelpers.backup_group(self.connection,grp,"Admin")
            QMessageBox.information(self,"Backup",f"Group {grp} v{ver} created.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def on_restore_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT BACKUP_VERSION,BACKUP_TIMESTAMP FROM BRM_GROUP_BACKUPS WHERE GROUP_NAME=? ORDER BY BACKUP_VERSION DESC",(grp,))
        rows=get_cursor_rows(c)
        if not rows:
            QMessageBox.information(self,"None",f"No backups for {grp}")
            return
        items=[f"Version {r_['BACKUP_VERSION']} (ts {r_['BACKUP_TIMESTAMP']})" for r_ in rows]
        sel,ok=QInputDialog.getItem(self,"Restore Group","Choose version:",items,0,False)
        if not ok:
            return
        import re
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        chosen_ver=int(m.group(1))
        confirm=QMessageBox.question(self,"Confirm",f"Restore {grp} => version {chosen_ver}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            BackupRestoreHelpers.restore_group(self.connection,grp,chosen_ver,"Admin")
            QMessageBox.information(self,"Restored",f"{grp} => version {chosen_ver}")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def get_selected_user(self):
        rr=self.users_table.currentRow()
        if rr<0:
            return None
        it=self.users_table.item(rr,0)
        if not it:
            return None
        return int(it.text())

    def on_add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not get_cursor_one(c):
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT * FROM USERS WHERE USER_ID=?",(uid,))
        row=get_cursor_one(c)
        if not row:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if row["USER_GROUP"]==grp.strip():
            QMessageBox.warning(self,"Error","User already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User added to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user from group? (Will move user to BG1)")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def on_add_permission(self):
        grp=self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        tbl,ok=QInputDialog.getText(self,"Add Permission","Target table:")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Permission {tbl} => {grp}")
        self.load_permissions()

    def on_remove_permission(self):
        grp=self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"None","No group.")
            return
        rr=self.perm_table.currentRow()
        if rr<0:
            QMessageBox.warning(self,"None","No permission row.")
            return
        it=self.perm_table.item(rr,0)
        if not it:
            return
        tbl=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove {tbl} from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp,tbl))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Removed {tbl} from {grp}")
        self.load_permissions()

    def on_add_approver(self):
        grp=self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"None","No group.")
            return
        username,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not username.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(username.strip(),))
        row=get_cursor_one(c)
        if not row:
            QMessageBox.warning(self,"Error","User not found.")
            return
        c.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(),username.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"{username} => {grp}")
        self.load_approvers()

    def on_remove_approver(self):
        grp=self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"None","No group.")
            return
        row=self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No row.")
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        appr_id=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove Approver {appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

###############################################################################
# USER MANAGEMENT TAB
###############################################################################
class UserManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.users_table=QTableWidget(0,4)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Password","User Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        self.users_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.users_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.users_table)

        btn_row=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_row.addWidget(add_btn)

        upd_btn=QPushButton("Update User")
        upd_btn.clicked.connect(self.update_user)
        btn_row.addWidget(upd_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_row.addWidget(del_btn)

        btn_row.addStretch()
        layout.addLayout(btn_row)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=get_cursor_rows(c)
        self.users_table.setRowCount(0)
        for row in rows:
            r=self.users_table.rowCount()
            self.users_table.insertRow(r)
            self.users_table.setItem(r,0,QTableWidgetItem(str(row["USER_ID"])))
            self.users_table.setItem(r,1,QTableWidgetItem(row["USERNAME"]))
            self.users_table.setItem(r,2,QTableWidgetItem(row["PASSWORD"]))
            self.users_table.setItem(r,3,QTableWidgetItem(row["USER_GROUP"]))

    def get_selected_user_id(self):
        sel=self.users_table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        uid_item=self.users_table.item(row,0)
        if uid_item:
            return int(uid_item.text())
        return None

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not uname.strip():
            return
        pw,ok2=QInputDialog.getText(self,"Add User","Password:")
        if not ok2 or not pw.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Add User","User Group:")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(uname.strip(),pw.strip(),grp.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Success","User added.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def update_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM USERS WHERE USER_ID=?",(uid,))
        row=get_cursor_one(c)
        if not row:
            QMessageBox.warning(self,"None","No user found.")
            return
        old_un=row["USERNAME"]
        old_pw=row["PASSWORD"]
        old_grp=row["USER_GROUP"]
        new_un,ok=QInputDialog.getText(self,"Update User","New Username:", text=old_un)
        if not ok or not new_un.strip():
            return
        new_pw,ok2=QInputDialog.getText(self,"Update User","New Password:", text=old_pw)
        if not ok2 or not new_pw.strip():
            return
        new_grp,ok3=QInputDialog.getText(self,"Update User","New Group:", text=old_grp)
        if not ok3 or not new_grp.strip():
            return
        try:
            c.execute("UPDATE USERS SET USERNAME=?,PASSWORD=?,USER_GROUP=? WHERE USER_ID=?",
                      (new_un.strip(),new_pw.strip(),new_grp.strip(),uid))
            self.connection.commit()
            QMessageBox.information(self,"Success","User updated.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Delete user?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","User removed.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

###############################################################################
# HIERARCHY VIEW
###############################################################################
class HierarchyViewTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.tree_view=QTreeView()
        layout.addWidget(self.tree_view)

        refresh_btn=QPushButton("Refresh Hierarchy")
        refresh_btn.clicked.connect(self.refresh_tree)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.refresh_tree()

    def refresh_tree(self):
        model=QStandardItemModel()
        model.setHorizontalHeaderLabels(["Hierarchy"])
        root_item=QStandardItem("APPLICATION")
        root_item.setEditable(False)
        model.appendRow(root_item)

        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        groups=get_cursor_rows(c)

        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS")
        rg_rows=get_cursor_rows(c)
        rg_map={x["GROUP_ID"]:x["GROUP_NAME"] for x in rg_rows}

        for g_ in groups:
            g_item=QStandardItem(f"{g_['GROUP_NAME']} ({g_['EMAIL']})")
            g_item.setEditable(False)
            root_item.appendRow(g_item)

            c.execute("SELECT * FROM BRM_RULES WHERE OWNER_GROUP=?",(g_["GROUP_NAME"],))
            arr=get_cursor_rows(c)
            group_buckets={}
            ungrouped=[]
            for rr in arr:
                if rr["GROUP_ID"]:
                    group_buckets.setdefault(rr["GROUP_ID"],[]).append(rr)
                else:
                    ungrouped.append(rr)

            def build_tree(rule,childmap):
                item=QStandardItem(f"Rule {rule['RULE_ID']}: {rule['RULE_NAME']}")
                item.setEditable(False)
                if rule["IS_GLOBAL"]==1:
                    item.setBackground(QColor("lightblue"))
                elif rule["CRITICAL_RULE"]==1:
                    item.setBackground(QColor("lightcoral"))
                if rule["RULE_ID"] in childmap:
                    for ch_ in childmap[rule["RULE_ID"]]:
                        item.appendRow(build_tree(ch_,childmap))
                return item

            for gid,subrules in group_buckets.items():
                rgname=rg_map.get(gid,f"Unknown RG {gid}")
                rgitem=QStandardItem(f"Rule Group: {rgname}")
                rgitem.setEditable(False)
                g_item.appendRow(rgitem)

                # adjacency
                submap={}
                for r_ in subrules:
                    pid=r_["PARENT_RULE_ID"]
                    if pid and any(x["RULE_ID"]==pid for x in subrules):
                        submap.setdefault(pid,[]).append(r_)
                all_ids=set(x["RULE_ID"] for x in subrules)
                child_ids=set()
                for kk,vv in submap.items():
                    for x_ in vv:
                        child_ids.add(x_["RULE_ID"])
                real_roots=all_ids-child_ids
                for r_ in subrules:
                    if r_["RULE_ID"] in real_roots:
                        rgitem.appendRow(build_tree(r_,submap))

            if ungrouped:
                unitem=QStandardItem("Ungrouped")
                unitem.setEditable(False)
                g_item.appendRow(unitem)
                submap2={}
                for ru in ungrouped:
                    pid=ru["PARENT_RULE_ID"]
                    if pid and any(x["RULE_ID"]==pid for x in ungrouped):
                        submap2.setdefault(pid,[]).append(ru)
                all_ids2=set(x["RULE_ID"] for x in ungrouped)
                child_ids2=set()
                for kk,vv in submap2.items():
                    for x_ in vv:
                        child_ids2.add(x_["RULE_ID"])
                real_roots2=all_ids2-child_ids2
                for ru2 in ungrouped:
                    if ru2["RULE_ID"] in real_roots2:
                        unitem.appendRow(build_tree(ru2,submap2))

        self.tree_view.setModel(model)
        self.tree_view.expandAll()

###############################################################################
# CUSTOM RULE GROUPS
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app=main_app
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_group_edit)

        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)

        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)

        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)

        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)

        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QSplitter(Qt.Horizontal)
        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["Custom Group / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules ...")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)
        splitter.addWidget(right_widget)
        layout.addWidget(splitter)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID DESC")
        groups=get_cursor_rows(c)
        for g_ in groups:
            g_item=QtWidgets.QTreeWidgetItem([f"{g_['CUSTOM_GROUP_NAME']} ({g_['OWNER_BUSINESS_GROUP']})"])
            g_item.setData(0,Qt.UserRole,g_["CUSTOM_GROUP_ID"])
            g_item.setBackground(0,QColor("lightgray"))
            self.tree.addTopLevelItem(g_item)

            c.execute("""
            SELECT R.*
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(g_["CUSTOM_GROUP_ID"],))
            rule_rows=get_cursor_rows(c)
            for rr in rule_rows:
                txt=f"Rule {rr['RULE_ID']}: {rr['RULE_NAME']}"
                rr_item=QtWidgets.QTreeWidgetItem([txt])
                rr_item.setData(0,Qt.UserRole,rr["RULE_ID"])
                if rr["IS_GLOBAL"]==1:
                    rr_item.setBackground(0,QColor("lightblue"))
                if rr["CRITICAL_RULE"]==1:
                    rr_item.setBackground(0,QColor("lightcoral"))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            if USE_ODBC:
                query="""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(query,(f"%{txt}%",f"%{txt}%"))
            else:
                c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                LIMIT 1000
                """,(f"%{txt}%",f"%{txt}%"))
        else:
            if USE_ODBC:
                query="""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """
                c.execute(query)
            else:
                c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                """)
        rows=get_cursor_rows(c)
        c.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set(x["RULE_ID"] for x in get_cursor_rows(c))
        for r_ in rows:
            if r_["RULE_ID"] in assigned:
                continue
            disp=f"Rule {r_['RULE_ID']}: {r_['RULE_NAME']} (Owner:{r_['OWNER_GROUP']})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,r_["RULE_ID"])
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # rule item
            menu=QtWidgets.QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?",(group_id,rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed.")
                self.refresh_all()

    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No name.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY)
        VALUES(?,?,?)
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Created custom group {name}.")
        self.new_group_edit.clear()
        self.refresh_all()

    def rename_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        new_name,ok=QInputDialog.getText(self,"Rename","New group name:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_name.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed","Group renamed.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        confirm=QMessageBox.question(self,"Confirm","Delete group?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group deleted.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def backup_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        try:
            v=BackupRestoreHelpers.backup_custom_group(self.connection,gid,f"User:{self.user_id}")
            QMessageBox.information(self,"Backup",f"Backup version {v} created.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def restore_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=get_cursor_rows(c)
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {r_['BACKUP_VERSION']} (ts {r_['BACKUP_TIMESTAMP']})" for r_ in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:", items,0,False)
        if not ok:
            return
        import re
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        ver=int(m.group(1))
        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            BackupRestoreHelpers.restore_custom_group(self.connection,gid,ver,f"User:{self.user_id}")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {ver}")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()

###############################################################################
# BACKUP & RESTORE
###############################################################################
class BackupRestoreHelpers:
    @staticmethod
    def backup_group(conn, group_name, action_by="System"):
        c=conn.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE OWNER_GROUP=?",(group_name,))
        rules=get_cursor_rows(c)
        data={"rules":[]}
        for r in rules:
            rd=dict(r)
            rid=r["RULE_ID"]
            c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
            rd["dependencies"]=get_cursor_rows(c)
            c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?",(rid,))
            rd["lineage"]=get_cursor_rows(c)
            c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
            rd["column_mappings"]=get_cursor_rows(c)
            data["rules"].append(rd)
        js=json.dumps(data,default=str)
        c.execute("SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv FROM BRM_GROUP_BACKUPS WHERE GROUP_NAME=?",(group_name,))
        row=get_cursor_one(c)
        nextv=row["mv"]+1
        c.execute("INSERT INTO BRM_GROUP_BACKUPS(GROUP_NAME,BACKUP_VERSION,BACKUP_JSON) VALUES(?,?,?)",(group_name,nextv,js))
        conn.commit()
        add_audit_log(conn,"BACKUP","BRM_GROUP_BACKUPS",group_name,action_by,{"group":group_name},{"version":nextv})
        return nextv

    @staticmethod
    def restore_group(conn, group_name, backup_version, action_by="System"):
        c=conn.cursor()
        c.execute("""
        SELECT BACKUP_JSON
        FROM BRM_GROUP_BACKUPS
        WHERE GROUP_NAME=? AND BACKUP_VERSION=?
        """,(group_name,backup_version))
        row=get_cursor_one(c)
        if not row:
            raise ValueError("No backup found.")
        data=json.loads(row["BACKUP_JSON"])

        c.execute("DELETE FROM BRM_RULE_LINEAGE WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)",(group_name,))
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)",(group_name,))
        c.execute("DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)",(group_name,))
        c.execute("DELETE FROM BRM_RULES WHERE OWNER_GROUP=?",(group_name,))

        for rdict in data["rules"]:
            c.execute("""
            INSERT INTO BRM_RULES(
                RULE_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
                EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,CREATED_BY,
                DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,CREATED_TIMESTAMP,
                UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,GROUP_ID,APPROVAL_STATUS,
                IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
            )
            VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
            """,(
                rdict["RULE_ID"], rdict["PARENT_RULE_ID"], rdict["RULE_TYPE_ID"],
                rdict["RULE_NAME"], rdict["RULE_SQL"], rdict["EFFECTIVE_START_DATE"],
                rdict["EFFECTIVE_END_DATE"], rdict["STATUS"], rdict["VERSION"],
                rdict["CREATED_BY"], rdict["DESCRIPTION"], rdict["OPERATION_TYPE"],
                rdict.get("BUSINESS_JUSTIFICATION",""), rdict["CREATED_TIMESTAMP"],
                rdict["UPDATED_BY"], rdict["OWNER_GROUP"], rdict.get("CLUSTER_NAME",""),
                rdict.get("GROUP_ID",None), rdict.get("APPROVAL_STATUS","DRAFT"),
                rdict.get("IS_GLOBAL",0), rdict.get("CRITICAL_RULE",0),
                rdict.get("CRITICAL_SCOPE","NONE"), rdict.get("CDC_TYPE","NONE")
            ))
            rid=rdict["RULE_ID"]
            for d_ in rdict.get("dependencies",[]):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                    DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME
                ) VALUES(?,?,?,?,?)
                """,(d_["DEPENDENCY_ID"],rid,d_["DATABASE_NAME"],d_["TABLE_NAME"],d_["COLUMN_NAME"]))
            for l_ in rdict.get("lineage",[]):
                c.execute("""
                INSERT INTO BRM_RULE_LINEAGE(
                    LINEAGE_ID,RULE_ID,SOURCE_INFO,TARGET_INFO,TRANSFORMATION_DETAILS,CREATED_TIMESTAMP
                ) VALUES(?,?,?,?,?,?)
                """,(l_["LINEAGE_ID"],rid,l_["SOURCE_INFO"],l_["TARGET_INFO"],l_["TRANSFORMATION_DETAILS"],l_["CREATED_TIMESTAMP"]))
            for m_ in rdict.get("column_mappings",[]):
                c.execute("""
                INSERT INTO BRM_COLUMN_MAPPING(
                    MAPPING_ID,RULE_ID,SOURCE_RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
                ) VALUES(?,?,?,?,?)
                """,(m_["MAPPING_ID"],m_["RULE_ID"],m_["SOURCE_RULE_ID"],m_["SOURCE_COLUMN_NAME"],m_["TARGET_COLUMN_NAME"]))
        conn.commit()
        add_audit_log(conn,"RESTORE","BRM_RULES",group_name,action_by,
                      {"group":group_name,"version":backup_version},None)

    @staticmethod
    def backup_custom_group(conn, custom_group_id, action_by="System"):
        conn.execute("""
        CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
            BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
            CUSTOM_GROUP_ID INTEGER NOT NULL,
            BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
            BACKUP_VERSION INTEGER NOT NULL,
            BACKUP_JSON TEXT NOT NULL
        );
        """)
        c=conn.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        rowg=get_cursor_one(c)
        if not rowg:
            raise ValueError("Custom group ID not found.")

        c.execute("""
        SELECT R.*
        FROM BRM_CUSTOM_GROUP_MEMBERS M
        JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
        WHERE M.CUSTOM_GROUP_ID=?
        """,(custom_group_id,))
        rules=get_cursor_rows(c)
        data={"rules":[]}
        for rule in rules:
            rd=dict(rule)
            rid=rule["RULE_ID"]
            c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
            rd["dependencies"]=get_cursor_rows(c)
            c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?",(rid,))
            rd["lineage"]=get_cursor_rows(c)
            c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
            rd["column_mappings"]=get_cursor_rows(c)
            data["rules"].append(rd)

        c.execute("SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        row=get_cursor_one(c)
        nextv=row["mv"]+1
        js=json.dumps(data,default=str)
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID,BACKUP_VERSION,BACKUP_JSON)
        VALUES(?,?,?)
        """,(custom_group_id,nextv,js))
        conn.commit()
        add_audit_log(conn,"BACKUP_CUSTOM_GROUP","BRM_CUSTOM_GROUP_BACKUPS",custom_group_id,action_by,
                      {"cgid":custom_group_id},{"version":nextv})
        return nextv

    @staticmethod
    def restore_custom_group(conn, custom_group_id, backup_version, action_by="System"):
        conn.execute("""
        CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
            BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
            CUSTOM_GROUP_ID INTEGER NOT NULL,
            BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
            BACKUP_VERSION INTEGER NOT NULL,
            BACKUP_JSON TEXT NOT NULL
        );
        """)
        c=conn.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        rowg=get_cursor_one(c)
        if not rowg:
            raise ValueError("Custom group not found.")

        c.execute("""
        SELECT BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=? AND BACKUP_VERSION=?
        """,(custom_group_id,backup_version))
        rowb=get_cursor_one(c)
        if not rowb:
            raise ValueError("No backup found.")
        data=json.loads(rowb["BACKUP_JSON"])

        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
        mem_ids=[x["RULE_ID"] for x in get_cursor_rows(c)]
        if mem_ids:
            placeholders=",".join(["?"]*len(mem_ids))
            c.execute(f"DELETE FROM BRM_RULE_LINEAGE WHERE RULE_ID IN ({placeholders})", mem_ids)
            c.execute(f"DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID IN ({placeholders})", mem_ids)
            c.execute(f"DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID IN ({placeholders})", mem_ids)
            c.execute(f"DELETE FROM BRM_RULES WHERE RULE_ID IN ({placeholders})", mem_ids)

        for rd in data["rules"]:
            c.execute("""
            INSERT INTO BRM_RULES(
                RULE_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
                EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
                CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
                CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,GROUP_ID,
                APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
            )
            VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
            """,(
                rd["RULE_ID"], rd["PARENT_RULE_ID"], rd["RULE_TYPE_ID"], rd["RULE_NAME"], rd["RULE_SQL"],
                rd["EFFECTIVE_START_DATE"], rd["EFFECTIVE_END_DATE"], rd["STATUS"], rd["VERSION"],
                rd["CREATED_BY"], rd["DESCRIPTION"], rd["OPERATION_TYPE"], rd.get("BUSINESS_JUSTIFICATION",""),
                rd["CREATED_TIMESTAMP"], rd["UPDATED_BY"], rd["OWNER_GROUP"], rd.get("CLUSTER_NAME",""),
                rd.get("GROUP_ID",None), rd.get("APPROVAL_STATUS","DRAFT"), rd.get("IS_GLOBAL",0),
                rd.get("CRITICAL_RULE",0), rd.get("CRITICAL_SCOPE","NONE"), rd.get("CDC_TYPE","NONE")
            ))
            rid=rd["RULE_ID"]
            for d_ in rd.get("dependencies",[]):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                    DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME
                ) VALUES(?,?,?,?,?)
                """,(d_["DEPENDENCY_ID"], d_["RULE_ID"], d_["DATABASE_NAME"], d_["TABLE_NAME"], d_["COLUMN_NAME"]))
            for l_ in rd.get("lineage",[]):
                c.execute("""
                INSERT INTO BRM_RULE_LINEAGE(
                    LINEAGE_ID,RULE_ID,SOURCE_INFO,TARGET_INFO,TRANSFORMATION_DETAILS,CREATED_TIMESTAMP
                ) VALUES(?,?,?,?,?,?)
                """,(l_["LINEAGE_ID"],l_["RULE_ID"],l_["SOURCE_INFO"],l_["TARGET_INFO"],l_["TRANSFORMATION_DETAILS"],l_["CREATED_TIMESTAMP"]))
            for m_ in rd.get("column_mappings",[]):
                c.execute("""
                INSERT INTO BRM_COLUMN_MAPPING(
                    MAPPING_ID,RULE_ID,SOURCE_RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
                ) VALUES(?,?,?,?,?)
                """,(m_["MAPPING_ID"],m_["RULE_ID"],m_["SOURCE_RULE_ID"],m_["SOURCE_COLUMN_NAME"],m_["TARGET_COLUMN_NAME"]))
            c.execute("INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID) VALUES(?,?)",(custom_group_id,rid))
        conn.commit()
        add_audit_log(conn,"RESTORE_CUSTOM_GROUP","BRM_RULE_GROUPS",custom_group_id,action_by,
                      {"cgid":custom_group_id,"version":backup_version},None)

###############################################################################
# GLOBAL/CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app=main_app
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)
        if self.user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: only Admin."))
            self.setLayout(layout)
            return
        filter_layout=QHBoxLayout()
        self.show_only_gcr=QCheckBox("Show only Global/Critical")
        self.show_only_gcr.setChecked(True)
        filter_layout.addWidget(self.show_only_gcr)
        ref_btn=QPushButton("Refresh Rule List")
        ref_btn.clicked.connect(self.load_rule_list)
        filter_layout.addWidget(ref_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Rule Name","Owner Group","IS_GLOBAL",
            "CRITICAL_RULE","CRITICAL_SCOPE","STATUS","UPDATED_BY"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        gcs_layout=QHBoxLayout()
        self.global_checkbox=QCheckBox("Set Global?")
        gcs_layout.addWidget(self.global_checkbox)
        self.critical_checkbox=QCheckBox("Set Critical?")
        gcs_layout.addWidget(self.critical_checkbox)
        gcs_layout.addWidget(QLabel("Critical Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        gcs_layout.addWidget(self.scope_combo)
        apply_btn=QPushButton("Apply Flags/Scope To Selected")
        apply_btn.clicked.connect(self.apply_gcs_to_selected)
        gcs_layout.addWidget(apply_btn)

        impact_btn=QPushButton("Show Impacted Descendants")
        impact_btn.clicked.connect(self.show_impacted_descendants)
        gcs_layout.addWidget(impact_btn)
        gcs_layout.addStretch()
        layout.addLayout(gcs_layout)

        link_box=QHBoxLayout()
        self.gcr_rule_combo=QComboBox()
        link_box.addWidget(QLabel("Select Parent GCR Rule:"))
        link_box.addWidget(self.gcr_rule_combo)
        self.child_rule_combo=QComboBox()
        link_box.addWidget(QLabel("Child Rule to Link/Unlink:"))
        link_box.addWidget(self.child_rule_combo)
        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_box.addWidget(link_btn)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_box.addWidget(unlink_btn)
        link_box.addStretch()
        layout.addLayout(link_box)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_all_btn=QPushButton("Refresh Everything")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()

    def load_rule_list(self):
        c=self.connection.cursor()
        if self.show_only_gcr.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        self.rule_table.setRowCount(0)
        for rd in rows:
            r=self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r,0,QTableWidgetItem(str(rd[0])))
            self.rule_table.setItem(r,1,QTableWidgetItem(rd[1]))
            self.rule_table.setItem(r,2,QTableWidgetItem(rd[2]))
            self.rule_table.setItem(r,3,QTableWidgetItem(str(rd[3])))
            self.rule_table.setItem(r,4,QTableWidgetItem(str(rd[4])))
            self.rule_table.setItem(r,5,QTableWidgetItem(rd[5]))
            self.rule_table.setItem(r,6,QTableWidgetItem(rd[6]))
            self.rule_table.setItem(r,7,QTableWidgetItem(str(rd[7])))

        self.rule_table.resizeColumnsToContents()

    def populate_gcr_rule_combo(self):
        self.gcr_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            rid,rname=row
            disp=f"ID:{rid} - {rname}"
            self.gcr_rule_combo.addItem(disp,rid)

    def populate_child_rule_combo(self):
        self.child_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for r in rows:
            rid,rname=r
            disp=f"ID:{rid} - {rname}"
            self.child_rule_combo.addItem(disp,rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            rr=self.link_view.rowCount()
            self.link_view.insertRow(rr)
            self.link_view.setItem(rr,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(rr,1,QTableWidgetItem(str(row[1])))
        self.link_view.resizeColumnsToContents()

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        rids=[]
        for i in idxs:
            row=i.row()
            it=self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def apply_gcs_to_selected(self):
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No Selection","Select rule(s).")
            return
        is_global=1 if self.global_checkbox.isChecked() else 0
        is_critical=1 if self.critical_checkbox.isChecked() else 0
        scope_val=self.scope_combo.currentText().upper()

        msg=f"Updating {len(rids)} rule(s)...\nIS_GLOBAL={is_global},CRITICAL_RULE={is_critical},SCOPE='{scope_val}'. Proceed?"
        confirm=QMessageBox.question(self,"Confirm",msg)
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            old=get_cursor_one(c)
            if not old:
                continue
            new_data=dict(old)
            old_status=old["APPROVAL_STATUS"]
            new_data["IS_GLOBAL"]=is_global
            new_data["CRITICAL_RULE"]=is_critical
            new_data["CRITICAL_SCOPE"]=scope_val
            try:
                update_rule(self.connection, new_data, "Admin", "Admin")
            except Exception as ex:
                logger.error(f"Error updating rule {rid}: {ex}")
                continue
            was_approved=(old_status=="APPROVED")
            now_gc=(is_global==1 or is_critical==1)
            if was_approved and now_gc:
                c2=self.connection.cursor()
                c2.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                WHERE RULE_ID=?
                """,(rid,))
                c2.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rid,))
                self.connection.commit()
                if is_global==0:
                    impacted=find_impacted_business_groups(self.connection, rid)
                    create_multistep_approvals(self.connection, rid, impacted)
        QMessageBox.information(self,"Done","Global/Critical/Scope updated.")
        self.load_rule_list()

    def show_impacted_descendants(self):
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        children_map, _=build_rule_adjacency(self.connection)
        lines=[]
        for rid in rids:
            visited=set()
            stack=[rid]
            desc=set()
            while stack:
                curr=stack.pop()
                if curr in visited:
                    continue
                visited.add(curr)
                if curr in children_map:
                    for child_id in children_map[curr]:
                        desc.add(child_id)
                        stack.append(child_id)
            lines.append(f"Rule {rid} => {len(desc)} impacted. IDs={sorted(desc)}")
        msg="\n".join(lines)
        QMessageBox.information(self,"Impacted Descendants",msg)

    def link_child(self):
        pid=self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No GCR","Pick a parent GCR.")
            return
        c=self.connection.cursor()
        c.execute("SELECT IS_GLOBAL,CRITICAL_RULE FROM BRM_RULES WHERE RULE_ID=?",(pid,))
        rowp=c.fetchone()
        if not rowp:
            QMessageBox.warning(self,"No Parent Found",f"Rule {pid} not found.")
            return
        if rowp[0]!=1 and rowp[1]!=1:
            QMessageBox.warning(self,"Invalid","Selected rule is not global or critical.")
            return

        cid=self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self,"No Child","Select a child rule.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return

        def would_create_cycle(p_id,c_id):
            full_children_map, _=build_rule_adjacency(self.connection)
            stack=[c_id]
            visited=set()
            while stack:
                node=stack.pop()
                if node in visited:
                    continue
                visited.add(node)
                if node==p_id:
                    return True
                if node in full_children_map:
                    stack.extend(full_children_map[node])
            return False
        if would_create_cycle(pid,cid):
            QMessageBox.warning(self,"Cycle","Linking parent->child creates cycle.")
            return

        try:
            c.execute("INSERT OR IGNORE INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(pid,cid))
            add_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"parent_id":pid,"child_id":cid})
            self.connection.commit()
            QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_rule_combo.currentData()
        if not pid:
            QMessageBox.warning(self,"No GCR","Pick a parent GCR.")
            return
        cid=self.child_rule_combo.currentData()
        if not cid:
            QMessageBox.warning(self,"No Child","Pick a child rule.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink {cid} from {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
            add_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",
                          {"parent_id":pid,"child_id":cid},None)
            self.connection.commit()
            QMessageBox.information(self,"Unlinked",f"Child {cid} from parent {pid}")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_link_view()

###############################################################################
# CONTROL TABLES
###############################################################################
class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES","BRM_RULE_GROUPS",
            "BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG","BRM_RULE_LINEAGE",
            "BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS","BRM_CUSTOM_GROUP_MEMBERS",
            "BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS","BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS"
        ]
        self.table_combo=QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)
        self.load_btn=QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)
        self.table_view=QTableWidget(0,0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)
        self.setLayout(layout)

    def on_load_data(self):
        tbl=self.table_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            col_names=[]
            if not USE_ODBC:
                c.execute(f"PRAGMA table_info({tbl})")
                info=get_cursor_rows(c)
                col_names=[x["name"] for x in info]
            else:
                try:
                    c.execute(f"SELECT TOP 1 * FROM {tbl}")
                    desc=c.description
                    if desc:
                        col_names=[d[0] for d in desc]
                except:
                    pass
            if not col_names:
                if USE_ODBC:
                    c.execute(f"SELECT TOP 1 * FROM {tbl}")
                    if c.description:
                        col_names=[d[0] for d in c.description]
                else:
                    c.execute(f"SELECT * FROM {tbl} LIMIT 1")
                    if c.description:
                        col_names=[d[0] for d in c.description]

            if USE_ODBC:
                c.execute(f"SELECT * FROM {tbl}")
            else:
                c.execute(f"SELECT * FROM {tbl}")

            rows=get_cursor_rows(c)
        except Exception as ex:
            QMessageBox.critical(self,"Error","Failed: "+str(ex))
            return

        if not col_names and rows:
            col_names=list(rows[0].keys())
        self.table_view.setRowCount(0)
        self.table_view.setColumnCount(len(col_names))
        self.table_view.setHorizontalHeaderLabels(col_names)
        for rd in rows:
            r=self.table_view.rowCount()
            self.table_view.insertRow(r)
            for j,cn in enumerate(col_names):
                val=rd[cn] if cn in rd else None
                self.table_view.setItem(r,j,QTableWidgetItem(str(val) if val!=None else ""))

###############################################################################
# RUN
###############################################################################
def main():
    app=QApplication(sys.argv)
    app.setStyle("Fusion")
    w=BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()