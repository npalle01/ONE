Below is an example of the key “replacement modules” you can use to fix the naming mismatches. In our revised code we have:

• A single main() entry point (instead of duplicate main() functions)
• Unified UI class names (for example, the search UI is now called RuleSearchWidget everywhere)
• Consistent names for dialogs such as DatabaseConnectionDialog, LoginDialog, and VersionHistoryDialog

You can replace your corresponding modules with the following code blocks. (Make sure you test and adjust any additional business logic as needed.)

⸻

1. Unified Main Module (MainWindow and main())

Replace your existing main window and main() definitions with the following code:

class MainWindow(QMainWindow):
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        self.setWindowTitle("BRM Tool – Ultimate Production Ready Edition")
        self.resize(2200, 1300)
        self.create_menu_bar()
        self.create_tool_bar()
        self.create_status_bar()

        # Central widget with tabs
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)

        # If Admin, show impersonation bar
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            imp_label = QLabel("Impersonate:")
            imp_label.setStyleSheet("font-weight:bold;")
            self.impersonation_combo = QComboBox()
            self.load_impersonation_options()
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.switch_user)
            imp_layout.addWidget(imp_label)
            imp_layout.addWidget(self.impersonation_combo)
            imp_layout.addWidget(imp_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)

        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)

        # Add tabs (only those allowed for the current user)
        if self.user_group == "Admin":
            self.admin_tab = AdminTab(self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.admin_tab, "Admin")
        self.dashboard_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.dashboard_tab, "Dashboard")
        self.biz_rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.biz_rules_tab, "Business Rules")
        self.approvals_tab = ApprovalsTab(self.connection, self.get_username(), self.user_group)
        self.tabs.addTab(self.approvals_tab, "Approvals")
        self.collab_tab = EnhancedCollaborationTab(self.connection)
        self.tabs.addTab(self.collab_tab, "Collaboration")
        self.audit_log_tab = EnhancedAuditLogAnalysisTab(self.connection)
        self.tabs.addTab(self.audit_log_tab, "Audit Log Analysis")
        self.predictive_tab = PredictiveAnalyticsTab(self.connection)
        self.tabs.addTab(self.predictive_tab, "Predictive Analytics")
        self.lineage_tab = EnhancedLineageAnalysisTab(self.connection)
        self.tabs.addTab(self.lineage_tab, "Enhanced Lineage")
        self.help_tab = HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab, "Help & Feedback")

        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)

        # Right dock for notifications
        self.notifications_dock = QDockWidget("Real-Time Notifications", self)
        self.notifications_widget = AlertsAndDashboardsTab(self.connection)
        self.notifications_dock.setWidget(self.notifications_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, self.notifications_dock)

        # Auto-refresh timer
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_tabs)
        self.refresh_timer.start(30000)

    def create_menu_bar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        help_menu = menubar.addMenu("Help")
        about_action = help_menu.addAction("About")
        about_action.triggered.connect(self.show_about)

    def create_tool_bar(self):
        self.toolbar = self.addToolBar("Main Toolbar")
        refresh_action = self.toolbar.addAction("Refresh")
        refresh_action.triggered.connect(self.refresh_tabs)

    def create_status_bar(self):
        self.status = QStatusBar(self)
        self.setStatusBar(self.status)
        self.status.showMessage(f"Connected | User: {self.get_username()} | Group: {self.user_group}")

    def get_username(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except:
            return "Unknown"

    def load_impersonation_options(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for uid, uname, grp in c.fetchall():
                self.impersonation_combo.addItem(f"{uname} ({grp})", (uid, grp))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def switch_user(self):
        data = self.impersonation_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        QMessageBox.information(self, "Switched", f"Now impersonating {self.get_username()} ({self.user_group}).")
        self.approvals_tab.logged_in_username = self.get_username()
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.biz_rules_tab.user_id = self.user_id
        self.biz_rules_tab.user_group = self.user_group
        self.biz_rules_tab.load_rules()
        self.create_status_bar()

    def refresh_tabs(self):
        try:
            self.approvals_tab.load_approvals()
            self.biz_rules_tab.load_rules()
            self.notifications_widget.check_alerts()
            self.status.showMessage(f"Refreshed at {datetime.now().strftime('%H:%M:%S')}")
        except Exception as ex:
            logger.error(f"Error refreshing: {ex}")

    def logout(self):
        self.close()

    def show_about(self):
        QMessageBox.information(self, "About", "BRM System Production Build.\nVersion 1.0")

def main():
    app = QApplication(sys.argv)
    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    conn = db_dialog.connection
    if not conn:
        sys.exit(1)
    login_dialog = LoginDialog(conn)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dialog.user_id
    user_group = login_dialog.user_group
    window = MainWindow(conn, user_id, user_group)
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()



⸻

2. Replacement for the Rule Search UI

Rename your old RuleSearchDialog to RuleSearchWidget and use this code block:

class RuleSearchWidget(QWidget):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter rule name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)
        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["RuleID", "RuleName", "SQL", "Status", "Version", "CreatedBy"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_results)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        self.res_table.setRowCount(0)
        search_text = self.search_edit.text().strip()
        c = self.connection.cursor()
        try:
            if search_text:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                    FROM BRM_RULES
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC
                """, (f"%{search_text}%", f"%{search_text}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                """)
            for row in c.fetchall():
                r_idx = self.res_table.rowCount()
                self.res_table.insertRow(r_idx)
                for col, val in enumerate(row):
                    self.res_table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))



⸻

3. Version History Dialog

Replace your VersionHistoryDialog with this version (ensure its name is used consistently):

class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id}")
        self.resize(920, 600)
        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["AuditID", "Action", "Timestamp", "OldData", "NewData", "Diff"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)
        btn_layout = QHBoxLayout()
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.do_rollback)
        btn_layout.addWidget(rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
                FROM BRM_AUDIT_LOG
                WHERE TABLE_NAME='BRM_RULES' AND RECORD_ID=? AND ACTION IN ('INSERT','UPDATE')
                ORDER BY ACTION_TIMESTAMP DESC
            """, (self.rule_id,))
            for row in c.fetchall():
                r_idx = self.table.rowCount()
                self.table.insertRow(r_idx)
                self.table.setItem(r_idx, 0, QTableWidgetItem(str(row[0])))
                self.table.setItem(r_idx, 1, QTableWidgetItem(str(row[1])))
                self.table.setItem(r_idx, 2, QTableWidgetItem(str(row[2])))
                old_data = row[3] or ""
                new_data = row[4] or ""
                self.table.setItem(r_idx, 3, QTableWidgetItem(old_data))
                self.table.setItem(r_idx, 4, QTableWidgetItem(new_data))
                diff_btn = QPushButton("Show Diff")
                diff_btn.clicked.connect(lambda _, idx=r_idx: self.show_diff(idx))
                self.table.setCellWidget(r_idx, 5, diff_btn)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def show_diff(self, row_index):
        # Implement a diff view using difflib here (omitted for brevity)
        pass

    def do_rollback(self):
        # Implement rollback logic here (omitted for brevity)
        pass



⸻

4. Removal of Duplicate Main Definitions

Make sure you remove any extra definitions of main() so that only the single main() function shown in section 1 remains.

⸻

Final Notes
	1.	Review your business logic sections (such as rule execution, data validations, etc.) and make sure any names used in your UI code now match the names in these replacement modules.
	2.	Test the integrated version in your environment. You may need to adjust SQL queries or additional error handling based on your database schema.

By replacing the relevant portions of your code with the modules above, your UI modules will be consistent and “match up” with your backend logic. If you need further adjustments or run into any issues, please let me know!