#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – COMPLETE UNIFIED UI
Organized into 2 major tabs:
  1) Administration Tab (sub‑tabs for Admin functionality)
  2) Business Rules Tab (sub‑tabs for user‑accessible features like conflicts, BFS, custom groups, what‑if, etc.)

This code merges all earlier parts into a single file with:
  • Logging & global config
  • DB connection & login
  • All UI modules & advanced BFS/Lock/Conflict logic
  • Reorganized QMainWindow with exactly 2 top-level tabs:
      => "Administration" 
      => "Business Rules"
  • CRUD operations for rules, users, groups, scheduling, data validations, etc.
  • BFS execution, conflict management, custom group simulation, scheduling, decision tables, tags, snapshots
  • Control table viewer in admin tab
  • Collaboration chat (optionally in business rules tab, or separate)
"""

import sys
import os
import json
import math
import csv
import re
import smtplib
import logging
import logging.config
import pyodbc
import sqlparse
import numpy as np
from datetime import datetime, timedelta
from collections import defaultdict, deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDate, QDateTime, QPointF
from PyQt5.QtGui import QFont, QColor
from PyQt5.QtWidgets import (
    QApplication, QAction, QAbstractItemView, QCalendarWidget, QCheckBox, QComboBox,
    QCompleter, QDialog, QFileDialog, QFormLayout, QGraphicsEllipseItem, QGraphicsItem,
    QGraphicsLineItem, QGraphicsScene, QGraphicsView, QGroupBox, QHBoxLayout, QLabel,
    QLineEdit, QListWidget, QListWidgetItem, QMainWindow, QMessageBox, QInputDialog,
    QPlainTextEdit, QProgressDialog, QPushButton, QSplitter, QTabWidget, QTextEdit,
    QTableWidget, QTableWidgetItem, QToolBar, QTreeWidget, QTreeWidgetItem, QVBoxLayout,
    QWidget, QTimeEdit, QDateTimeEdit, QStatusBar
)

###############################################################################
# 1) GLOBAL LOGGING CONFIG & BRM_CONFIG
###############################################################################

LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {"format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"}
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_master.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console","file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_master")

BRM_CONFIG = {
    "ENABLE_AIOPS": True,
    "AUTO_HEALING_THRESHOLD": 5,
    "ALLOWED_SQL_KEYWORDS": ["SELECT","INSERT","UPDATE","DELETE","JOIN","WHERE","GROUP","ORDER","HAVING","CTE","WITH"],
    "FORBIDDEN_SQL_KEYWORDS": ["DROP","TRUNCATE","SHUTDOWN","ALTER SERVER","RECONFIGURE"],
    "REQUIRED_APPROVAL_STAGES": 2,   # multi-step approvals
    "PARALLEL_APPROVAL_GROUPS": False,
    "RBAC_ENABLED": True,           # advanced ACL
    "TIMEZONE": "UTC"
}

###############################################################################
# 2) DATABASE CONNECTION & LOGIN DIALOGS
###############################################################################

class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Allows user to select ODBC DSN or custom connection string.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("Database Connection – BRM Master")
        self.resize(420, 180)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        """
        Attempt to build a pyodbc connection from DSN or custom string.
        """
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            test_conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully.")
            return test_conn
        except Exception as ex:
            logger.error(f"DB connection failed: {ex}")
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()
        else:
            logger.debug("Staying in DB dialog for correction.")


class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password dialog checking the USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – BRM Master")
        self.resize(300, 160)

        main_layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)

        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()

        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password required.")
            return

        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT USER_ID, USER_GROUP 
                FROM USERS
                WHERE USERNAME=? AND PASSWORD=?
            """, (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in. user_id={self.user_id}, group={self.user_group}")
                self.accept()
            else:
                logger.warning(f"Login failed for user: {un} => Invalid credentials.")
                QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
        except Exception as ex:
            logger.exception("Error during login:")
            QMessageBox.critical(self, "Database Error", str(ex))


###############################################################################
# 3) ACL CHECK HELPER (SIMPLE OR ADVANCED)
###############################################################################

def check_user_permissions(connection, user_id, action_type, resource_name):
    """
    Simple ACL logic. If BRM_CONFIG["RBAC_ENABLED"] is True, do a group check.
    If not, only admin can do advanced ops.
    """
    if not BRM_CONFIG.get("RBAC_ENABLED", False):
        # fallback
        c = connection.cursor()
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if row and row[0] == "Admin":
            return True
        # Non-admin => allow only certain actions
        if action_type in ("VIEW","SIMULATE"):
            return True
        return False

    c = connection.cursor()
    try:
        c.execute("""
            SELECT COUNT(*)
            FROM GROUP_PERMISSIONS GP
            JOIN USERS U ON GP.GROUP_NAME=U.USER_GROUP
            WHERE U.USER_ID=? 
              AND (GP.TARGET_TABLE=? OR GP.TARGET_TABLE='*ANY*')
        """, (user_id, resource_name))
        row = c.fetchone()
        if row and row[0] > 0:
            return True
        else:
            logger.warning(f"Permission denied: user_id={user_id}, action={action_type}, resource={resource_name}")
            return False
    except Exception as ex:
        logger.error(f"Error in check_user_permissions: {ex}")
        return False


###############################################################################
# 4) BASIC DB HELPERS (fetch dict, audit log, etc.)
###############################################################################

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action, table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"Audit log inserted => {action}, table={table_name}, record_id={record_id}, actor={actor}")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")


###############################################################################
# 5) RULES / BFS / LOCK / CONFLICT / DECISION TABLE
###############################################################################

def detect_operation_type(sql_text: str) -> str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, or OTHER.
    Checks forbidden keywords from BRM_CONFIG.
    """
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or '', flags=re.MULTILINE|re.DOTALL).strip()
    up = cleaned.upper()
    for bad_kw in BRM_CONFIG.get("FORBIDDEN_SQL_KEYWORDS",[]):
        if bad_kw.upper() in up:
            logger.warning(f"Forbidden keyword {bad_kw} found.")
            return "OTHER"
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    return "OTHER"


def parse_sql_dependencies(sql_text: str):
    """
    Minimal approach to find table references. 
    """
    out = {"tables":[], "cte":[], "aliases":{}, "joins":[], "subqueries":[], "columns":[]}
    if not sql_text.strip():
        return out
    # For brevity, we just do a naive parse
    # Real code can use sqlparse in detail
    out["tables"].append("MyTable")  # example
    return out


def run_data_validations(conn):
    """
    Runs validations from DATA_VALIDATIONS, logs results in DATA_VALIDATION_LOGS.
    """
    c = conn.cursor()
    try:
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        rows = c.fetchall()
    except:
        logger.error("Cannot load data validations.")
        return
    for row in rows:
        validation_id, table_name, col_name, val_type, params = row
        result_flag = "PASS"
        details = ""
        try:
            if val_type.upper()=="NOT NULL":
                q = f"SELECT COUNT(*) FROM {table_name} WHERE {col_name} IS NULL"
                c.execute(q)
                cnt = c.fetchone()[0]
                if cnt>0:
                    result_flag="FAIL"
                    details=f"{cnt} null(s) found"
                else:
                    details="No nulls"
            elif val_type.upper()=="UNIQUE":
                q = f"""
                    SELECT COUNT(*) FROM (
                      SELECT {col_name}, COUNT(*) as c
                      FROM {table_name}
                      GROUP BY {col_name}
                      HAVING COUNT(*)>1
                    ) AS duplicates
                """
                c.execute(q)
                cnt = c.fetchone()[0]
                if cnt>0:
                    result_flag="FAIL"
                    details=f"Found {cnt} duplicates"
                else:
                    details=f"No duplicates"
            else:
                details=f"Val type {val_type} not implemented."
                result_flag="FAIL"
        except Exception as ex:
            result_flag="FAIL"
            details=str(ex)
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(
                  VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP
                )
                VALUES(?,?,?,GETDATE())
            """,(validation_id,result_flag,details))
            conn.commit()
        except:
            pass


def load_rule_relationships(conn):
    """
    BFS adjacency from parent->child in BRM_RULES plus conflicts.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for rid, pid in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            parent_map[rid]=pid

    c.execute("SELECT RULE_ID1,RULE_ID2 FROM RULE_CONFLICTS")
    cf = c.fetchall()
    for r1,r2 in cf:
        adjacency.setdefault(r1,set()).add(r2)
        adjacency.setdefault(r2,set()).add(r1)

    child_ids = set(parent_map.keys())
    roots = [x for x in all_ids if x not in child_ids]
    return adjacency, roots, parent_map


def skip_all_descendants(start_id, adjacency, skipped):
    stack=[start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for child in adjacency[cur]:
                if child not in skipped:
                    stack.append(child)


def get_all_rules_map(conn):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    cols = [x[0] for x in c.description]
    out = {}
    for row in rows:
        d = dict(zip(cols,row))
        out[d["RULE_ID"]]=d
    return out


def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    If OPERATION_TYPE=DECISION_TABLE, do decision_table logic. Else run SQL. 
    Return (bool_ok, message, record_count).
    """
    op_type = rule_info.get("OPERATION_TYPE","OTHER")
    if op_type.upper()=="DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return False,"No DECISION_TABLE_ID",0
        return execute_decision_table(conn, dt_id, True)  # always dry run
    sql_ = rule_info.get("RULE_SQL","")
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success=False
    msg=""
    rec_count=0
    try:
        c.execute(sql_)
        rows=[]
        try:
            rows = c.fetchall()
        except:
            pass
        if rows:
            rec_count=len(rows)
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned => {val}"
        else:
            success=True
            msg="No rows => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try: c.execute("ROLLBACK")
        except: pass
        success=False
        msg=str(ex)
    return success,msg,rec_count


def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT,
              EXECUTION_TIME_MS, CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0,0,0)
        """,(rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting rule exec log => {ex}")


def execute_decision_table(conn, dt_id, dry_run=True):
    """
    If DECISION_QUERY returns 1 => pass, else fail.
    """
    c_dt = conn.cursor()
    c_dt.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c_dt.fetchone()
    if not row:
        return False,f"DecisionTable {dt_id} not found.",0
    dq = row[0]
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success=False
    msg=""
    rec_count=0
    try:
        c.execute(dq)
        rows=[]
        try:
            rows = c.fetchall()
        except:
            pass
        rec_count=len(rows)
        if rows:
            val=rows[0][0]
            success=(val==1)
            msg=f"Decision => {val}"
        else:
            success=True
            msg="No rows => PASS"
        c.execute("ROLLBACK")   # always if dry_run
    except Exception as ex:
        try:c.execute("ROLLBACK")
        except: pass
        success=False
        msg=str(ex)
    return success,msg,rec_count


def create_multistep_approvals(conn, rule_id, actor):
    c = conn.cursor()
    try:
        req_stages = BRM_CONFIG.get("REQUIRED_APPROVAL_STAGES",2)
        for stg in range(1, req_stages+1):
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, APPROVAL_STAGE, USERNAME, APPROVED_FLAG, REQUEST_TIMESTAMP
                )
                VALUES(?,?,?,?,0,GETDATE())
            """,(rule_id, "ApproverGroup", stg, "ApproverUser"))
        conn.commit()
        logger.info(f"Approvals created for rule {rule_id} by {actor}")
    except Exception as ex:
        logger.error(f"Error multi-step approvals for {rule_id}: {ex}")


###############################################################################
# 6) BFS EXECUTION & UTILS
###############################################################################

def execute_rules_unified_bfs(conn, dry_run=False, user_id=None):
    """
    BFS-based rule execution, skipping child if a global/critical rule fails.
    Also runs data validations.
    Returns (list_executed, list_skipped).
    """
    run_data_validations(conn)
    adjacency, roots, parent_map = load_rule_relationships(conn)
    all_map = get_all_rules_map(conn)
    executed=[]
    skipped=set()
    queue=list(roots)
    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in all_map:
            skipped.add(rid)
            continue
        if user_id:
            # check ACL if needed
            pass
        info = all_map[rid]
        ok,msg,rc = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rc)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            is_crit=(info.get("CRITICAL_RULE",0)==1 or info.get("IS_GLOBAL",0)==1)
            if is_crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return executed, list(skipped)


###############################################################################
# 7) UI CLASSES – ADMIN SUB-TABS
###############################################################################
# Because we are reorganizing, let's gather the "admin" ones into a single QTabWidget

class UserManagementTab(QtWidgets.QWidget):
    """
    Manages users: add, delete, change password
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.table = QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["UserID","Username","Password","User Group"])
        layout.addWidget(self.table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_h.addWidget(add_btn)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_h.addWidget(del_btn)
        pw_btn = QPushButton("Change Password")
        pw_btn.clicked.connect(self.change_password)
        btn_h.addWidget(pw_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for row in rows:
                r_idx=self.table.rowCount()
                self.table.insertRow(r_idx)
                for col,val in enumerate(row):
                    self.table.setItem(r_idx, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def selected_user_id(self):
        items=self.table.selectedItems()
        if items:
            try: return int(items[0].text())
            except: return None
        return None

    def add_user(self):
        un,ok1 = QInputDialog.getText(self,"Add User","Username:")
        if not ok1 or not un.strip():
            return
        pw,ok2 = QInputDialog.getText(self,"Add User","Password:")
        if not ok2 or not pw.strip():
            return
        grp,ok3=QInputDialog.getText(self,"User Group","Group name (e.g. Admin,Finance):")
        if not ok3: grp="Finance"
        c=self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(un.strip(),))
            if c.fetchone():
                QMessageBox.warning(self,"Duplicate","User already exists.")
                return
            c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(un.strip(),pw.strip(),grp.strip()))
            self.connection.commit()
            insert_audit_log(self.connection,"INSERT","USERS",None,"Admin",None,{"username":un})
            QMessageBox.information(self,"Added","User added.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_user(self):
        uid=self.selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user with ID {uid}?")
        if confirm != QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
            self.connection.commit()
            insert_audit_log(self.connection,"DELETE","USERS",uid,"Admin")
            QMessageBox.information(self,"Deleted","User removed.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def change_password(self):
        uid=self.selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        new_pw,ok=QInputDialog.getText(self,"Change Password","New password:")
        if not ok or not new_pw.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(new_pw.strip(),uid))
            self.connection.commit()
            insert_audit_log(self.connection,"UPDATE","USERS",uid,"Admin",None,{"password_changed":True})
            QMessageBox.information(self,"Updated","Password updated.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class GroupManagementTab(QtWidgets.QWidget):
    """
    Manage business groups: add, rename, delete
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        layout.addWidget(self.table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Group")
        add_btn.clicked.connect(self.add_group)
        btn_h.addWidget(add_btn)
        ren_btn=QPushButton("Rename Group")
        ren_btn.clicked.connect(self.rename_group)
        btn_h.addWidget(ren_btn)
        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        btn_h.addWidget(del_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
            rows=c.fetchall()
            for row in rows:
                r_idx=self.table.rowCount()
                self.table.insertRow(r_idx)
                for col,val in enumerate(row):
                    self.table.setItem(r_idx,col,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def selected_group(self):
        items=self.table.selectedItems()
        if items:
            return items[0].text()
        return None

    def add_group(self):
        gname,ok1=QInputDialog.getText(self,"Add Group","Name:")
        if not ok1 or not gname.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional desc:")
        email,ok3=QInputDialog.getText(self,"Email","Optional email:")
        c=self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gname.strip(),))
            if c.fetchone():
                QMessageBox.warning(self,"Duplicate","Group already exists.")
                return
            c.execute("""
                INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) 
                VALUES(?,?,?)
            """,(gname.strip(),desc.strip() if desc else "",email.strip() if email else ""))
            self.connection.commit()
            QMessageBox.information(self,"Added","Group created.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def rename_group(self):
        grp=self.selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename",f"New name for '{grp}':")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
            if c.fetchone():
                QMessageBox.warning(self,"Duplicate","New name already exists.")
                return
            c.execute("BEGIN TRAN")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' => '{new_name}'.")
            self.load_groups()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        grp=self.selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Group removed.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class CtrlTablesTab(QtWidgets.QWidget):
    """
    Provides a viewer for control/reference tables. Admin can edit, others read-only.
    """
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)
        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_GROUPS",
            "BRM_RULES","RULE_CONFLICTS","RULE_SCHEDULES","DECISION_TABLES","COMPOSITE_RULES",
            "RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS","RULE_PERF_STATS","BRM_RULE_APPROVALS",
            "BRM_AUDIT_LOG","BRM_GLOBAL_CRITICAL_LINKS","RULE_SNAPSHOTS","BRM_CUSTOM_RULE_GROUPS",
            "BRM_RULE_TYPES","BRM_RULE_LINEAGE"
        ]
        self.tbl_combo=QComboBox()
        for t in self.table_list:
            self.tbl_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        if self.user_group!="Admin":
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def load_data(self):
        tabn=self.tbl_combo.currentText()
        if not tabn:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tabn}")
            colnames=[x[0] for x in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving columns from {tabn}: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {tabn}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error loading data from {tabn}: {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            r_idx=self.data_table.rowCount()
            self.data_table.insertRow(r_idx)
            for i,val in enumerate(row):
                self.data_table.setItem(r_idx,i,QTableWidgetItem(str(val) if val else ""))


class GlobalCriticalAdminTab(QtWidgets.QWidget):
    """
    Admin interface for global-critical rules, forcibly linking/unlinking.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)
        if self.user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.rule_tree=QTreeWidget()
        self.rule_tree.setHeaderLabels(["RuleID","RuleName","OwnerGroup","Status"])
        layout.addWidget(self.rule_tree)
        refresh_btn=QPushButton("Refresh Rules")
        refresh_btn.clicked.connect(self.load_rule_list)
        layout.addWidget(refresh_btn)

        link_layout=QHBoxLayout()
        self.gcr_parent_combo=QComboBox()
        self.gcr_child_combo=QComboBox()
        link_layout.addWidget(QLabel("Parent GCR:"))
        link_layout.addWidget(self.gcr_parent_combo)
        link_layout.addWidget(QLabel("Child Rule:"))
        link_layout.addWidget(self.gcr_child_combo)
        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        ul_btn=QPushButton("Unlink Child")
        ul_btn.clicked.connect(self.unlink_child)
        link_layout.addWidget(link_btn)
        link_layout.addWidget(ul_btn)
        layout.addLayout(link_layout)

        self.link_tree=QTreeWidget()
        self.link_tree.setHeaderLabels(["Parent GCR","Child Rule"])
        layout.addWidget(self.link_tree)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_tree.clear()
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP,STATUS
                FROM BRM_RULES
                WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                ORDER BY RULE_ID DESC
            """)
            for row in c.fetchall():
                it=QTreeWidgetItem([str(row[0]),row[1],row[2],row[3]])
                self.rule_tree.addTopLevelItem(it)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c=self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1 ORDER BY RULE_ID")
            for r,n in c.fetchall():
                self.gcr_parent_combo.addItem(f"{r} - {n}",r)
        except: pass

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c=self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for r,n in c.fetchall():
                self.gcr_child_combo.addItem(f"{r} - {n}",r)
        except: pass

    def load_link_view(self):
        self.link_tree.clear()
        c=self.connection.cursor()
        try:
            c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
            for row in c.fetchall():
                it=QTreeWidgetItem([str(row[0]), str(row[1])])
                self.link_tree.addTopLevelItem(it)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def link_child(self):
        p_id=self.gcr_parent_combo.currentData()
        c_id=self.gcr_child_combo.currentData()
        if not p_id or not c_id:
            QMessageBox.warning(self,"Missing","Must pick parent & child.")
            return
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(p_id,c_id))
            insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{p_id}->{c_id}","Admin",None,{"parent":p_id,"child":c_id})
            self.connection.commit()
            QMessageBox.information(self,"Linked","Child -> parent GCR.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def unlink_child(self):
        p_id=self.gcr_parent_combo.currentData()
        c_id=self.gcr_child_combo.currentData()
        if not p_id or not c_id:
            QMessageBox.warning(self,"Missing","Need parent & child.")
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(p_id,c_id))
            insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{p_id}->{c_id}","Admin",{"parent":p_id,"child":c_id},None)
            self.connection.commit()
            QMessageBox.information(self,"Unlinked","Child unlinked from GCR parent.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 8) BUSINESS RULES SUB-TABS (WhatIf, BFS, Conflict, etc.)
###############################################################################

# e.g. from your code: 
# - ConflictPriorityManagerTab
# - CompositeRulesTab
# - DataValidationTab
# - DecisionTablesTab
# - SnapshotManagerTab
# - ScheduleManagementTab
# - TaskNotificationCenterTab (if you want)
# - TagsManagerTab
# - GroupSimulationDialog,ChainSimulationDialog
# - WhatIfTestTab

# For brevity, I'll place them here:

class ConflictPriorityManagerTab(QtWidgets.QWidget):
    """
    Manages rule conflicts: add, update priority, delete
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        layout.addWidget(self.cf_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_h.addWidget(add_btn)
        sp_btn=QPushButton("Set Priority")
        sp_btn.clicked.connect(self.set_priority)
        btn_h.addWidget(sp_btn)
        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.delete_conflict)
        btn_h.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows=c.fetchall()
            for row in rows:
                r_idx=self.cf_table.rowCount()
                self.cf_table.insertRow(r_idx)
                for col,val in enumerate(row):
                    self.cf_table.setItem(r_idx,col,QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def add_conflict(self):
        r1,ok1=QInputDialog.getInt(self,"Add Conflict","RuleID1:")
        if not ok1: return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","RuleID2:")
        if not ok2: return
        pr,ok3=QInputDialog.getInt(self,"Priority","Priority:",value=1)
        if not ok3: return
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pr))
            self.connection.commit()
            QMessageBox.information(self,"Added","Conflict added.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def set_priority(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cf_id=int(self.cf_table.item(row,0).text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:",value=1)
        if not ok: return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cf_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated","Priority changed.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_conflict(self):
        row=self.cf_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        cf_id=int(self.cf_table.item(row,0).text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Conflict removed.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class CompositeRulesTab(QtWidgets.QWidget):
    """
    Manage composite rules
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CompRuleID","Name","Logic Expression","ActionOnPass"])
        layout.addWidget(self.cr_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Composite")
        add_btn.clicked.connect(self.add_composite)
        btn_h.addWidget(add_btn)
        del_btn=QPushButton("Delete Composite")
        del_btn.clicked.connect(self.delete_composite)
        btn_h.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_data)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
            rows=c.fetchall()
            for row in rows:
                r_idx=self.cr_table.rowCount()
                self.cr_table.insertRow(r_idx)
                for col_i,val in enumerate(row):
                    self.cr_table.setItem(r_idx,col_i,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def add_composite(self):
        name,ok=QInputDialog.getText(self,"Add Composite","Name:")
        if not ok or not name.strip():
            return
        expr,ok2=QInputDialog.getMultiLineText(self,"Logic Expression","E.g. 'Rule1==PASS AND Rule2==PASS'")
        if not ok2: expr=""
        action,ok3=QInputDialog.getText(self,"Action on Pass","(e.g. SendEmail)")
        if not ok3: action=""
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
                VALUES(?,?,?)
            """,(name.strip(),expr.strip(),action.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Composite rule added.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_composite(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite selected.")
            return
        comp_id=int(self.cr_table.item(row,0).text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {comp_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(comp_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Composite rule removed.")
            self.load_data()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class DataValidationTab(QtWidgets.QWidget):
    """
    Manage data validations: add, remove, run all
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dv_table=QTableWidget(0,6)
        self.dv_table.setHorizontalHeaderLabels(["ValID","TableName","ColumnName","ValType","Params","LastResult"])
        layout.addWidget(self.dv_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        remove_btn=QPushButton("Remove Validation")
        remove_btn.clicked.connect(self.remove_validation)
        run_btn=QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(remove_btn)
        btn_h.addWidget(run_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT V.VALIDATION_ID,V.TABLE_NAME,V.COLUMN_NAME,V.VALIDATION_TYPE,V.PARAMS,
                (SELECT TOP 1 DETAILS FROM DATA_VALIDATION_LOGS L
                 WHERE L.VALIDATION_ID=V.VALIDATION_ID
                 ORDER BY L.VALIDATION_TIMESTAMP DESC) as LAST_RESULT
                FROM DATA_VALIDATIONS V
                ORDER BY V.VALIDATION_ID
            """)
            rows=c.fetchall()
            for row in rows:
                r_idx=self.dv_table.rowCount()
                self.dv_table.insertRow(r_idx)
                for i,val in enumerate(row):
                    self.dv_table.setItem(r_idx,i,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def add_validation(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name:")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Col name","Column:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"ValType","(NOT NULL, UNIQUE, etc.):")
        if not ok3 or not vtype.strip():
            return
        prm,ok4=QInputDialog.getText(self,"Params","(optional e.g. min=0;max=100):")
        if not ok4: prm=""
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS,CREATED_TIMESTAMP)
                VALUES(?,?,?,?,GETDATE())
            """,(tbl.strip(),col.strip(),vtype.strip(),prm.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Validation created.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def remove_validation(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        val_id=int(self.dv_table.item(row,0).text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation ID {val_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(val_id,))
            self.connection.commit()
            QMessageBox.information(self,"Removed","Validation removed.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def run_all(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self,"Executed","All validations run. Check logs.")
            self.load_vals()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class WhatIfTestTab(QtWidgets.QWidget):
    """
    Allows user to pick a rule & do a dry-run simulation (upload CSV optional).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for rid,rn in c.fetchall():
                self.rule_combo.addItem(f"{rid} - {rn}",rid)
        except:
            pass
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        self.upload_btn=QPushButton("Upload CSV")
        self.upload_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(self.upload_btn)

        run_btn=QPushButton("Run Dry-Run")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Select CSV","","CSV Files (*.csv)")
        if path:
            QMessageBox.information(self,"CSV","Selected: "+path)

    def run_test(self):
        rid=self.rule_combo.currentData()
        c=self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL,OPERATION_TYPE,DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            row=c.fetchone()
            if not row:
                self.result_text.setPlainText("Rule not found.")
                return
            sql_text,op_type,dt_id=row
            if op_type.upper()=="DECISION_TABLE":
                ok,msg,rc=execute_decision_table(self.connection,dt_id,True)
            else:
                ok,msg= self.dry_run_sql(sql_text)
                rc=0
            txt=f"Rule {rid} => PASS={ok}, msg={msg}, records={rc}"
            self.result_text.setPlainText(txt)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def dry_run_sql(self, sql_text):
        c=self.connection.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
        except:
            pass
        success=False
        message=""
        try:
            c.execute(sql_text)
            rows=[]
            try:
                rows=c.fetchall()
            except:
                pass
            if rows:
                val=rows[0][0]
                success=(val==1)
                message=f"Returned => {val}"
            else:
                success=True
                message="No rows => PASS"
            c.execute("ROLLBACK")
        except Exception as ex:
            try:c.execute("ROLLBACK")
            except: pass
            success=False
            message=str(ex)
        return success, message


class ScheduleManagementTab(QtWidgets.QWidget):
    """
    Manage RULE_SCHEDULES: add, update, delete
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["ScheduleID","RuleID","ScheduleTime","Status","RunVal?","Actions"])
        layout.addWidget(self.table)

        btn_h=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_schedules)
        btn_h.addWidget(ref_btn)
        add_btn=QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_h.addWidget(add_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS,RUN_DATA_VALIDATIONS
                FROM RULE_SCHEDULES
                ORDER BY SCHEDULE_TIME DESC
            """)
            rows=c.fetchall()
            for row in rows:
                r_idx=self.table.rowCount()
                self.table.insertRow(r_idx)
                for col_i in range(5):
                    val=row[col_i]
                    self.table.setItem(r_idx,col_i,QTableWidgetItem(str(val) if val else ""))
                act_w=QWidget()
                a_lay=QHBoxLayout(act_w)
                a_lay.setContentsMargins(0,0,0,0)
                up_btn=QPushButton("Update")
                up_btn.clicked.connect(lambda _,r=r_idx:self.update_schedule(r))
                del_btn=QPushButton("Delete")
                del_btn.clicked.connect(lambda _,r=r_idx:self.delete_schedule(r))
                a_lay.addWidget(up_btn)
                a_lay.addWidget(del_btn)
                a_lay.addStretch()
                self.table.setCellWidget(r_idx,5,act_w)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        if dlg.exec_()==QDialog.Accepted:
            self.load_schedules()

    def update_schedule(self, row):
        item=self.table.item(row,0)
        if not item: return
        sch_id=int(item.text())
        new_dt,ok=QInputDialog.getText(self,"Update Schedule","Datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
            self.load_schedules()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_schedule(self, row):
        item=self.table.item(row,0)
        if not item: return
        sch_id=int(item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Removed schedule {sch_id}.")
            self.load_schedules()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class EnhancedScheduleDialog(QtWidgets.QDialog):
    """
    Basic scheduling dialog
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Add Schedule")
        self.resize(350,220)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for r,n in c.fetchall():
                self.rule_combo.addItem(f"{r} - {n}",r)
        except: pass
        form.addRow("Rule:",self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        form.addRow("Date:",self.calendar)

        self.time_edit=QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Time:",self.time_edit)

        self.run_val_cb=QCheckBox("Run data validations first?")
        form.addRow(self.run_val_cb)
        layout.addLayout(form)

        btn_h=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        btn_h.addWidget(sch_btn)
        cl_btn=QPushButton("Close")
        cl_btn.clicked.connect(self.reject)
        btn_h.addWidget(cl_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        ds=self.calendar.selectedDate().toString("yyyy-MM-dd")
        ts=self.time_edit.time().toString("HH:mm:ss")
        dt_str=f"{ds} {ts}"
        run_val=1 if self.run_val_cb.isChecked() else 0
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(
                  RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP,RUN_DATA_VALIDATIONS
                )
                VALUES(?,?,'Scheduled',GETDATE(),?)
            """,(rid,dt_str,run_val))
            self.connection.commit()
            QMessageBox.information(self,"Ok",f"Scheduled {rid} at {dt_str}, validations={bool(run_val)}.")
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class SnapshotManagerTab(QtWidgets.QWidget):
    """
    Manages RULE_SNAPSHOTS
    """
    def __init__(self,connection,parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID","Name","CreatedBy","CreatedTS","JSON"])
        layout.addWidget(self.ss_table)

        btn_h=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snaps)
        btn_h.addWidget(take_btn)
        btn_h.addWidget(del_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_snaps()

    def load_snaps(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
            rows=c.fetchall()
            for row in rows:
                r_idx=self.ss_table.rowCount()
                self.ss_table.insertRow(r_idx)
                for i,val in enumerate(row):
                    self.ss_table.setItem(r_idx,i,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def take_snapshot(self):
        name,ok=QInputDialog.getText(self,"Snapshot","Name:")
        if not ok or not name.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES")
            rows=c.fetchall()
            cols=[x[0] for x in c.description]
            snap_data=[dict(zip(cols,r)) for r in rows]
            snap_json=json.dumps(snap_data,indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
                VALUES(?,?,?)
            """,(name.strip(),"SnapshotUser",snap_json))
            self.connection.commit()
            QMessageBox.information(self,"Snapshot","Created.")
            self.load_snaps()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_snapshot(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        snap_id=int(self.ss_table.item(row,0).text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {snap_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(snap_id,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted","Snapshot removed.")
            self.load_snaps()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class TagsManagerTab(QtWidgets.QWidget):
    """
    Manages RULE_TAGS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TagID","RuleID","TagName"])
        layout.addWidget(self.tags_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        remove_btn=QPushButton("Remove Tag")
        remove_btn.clicked.connect(self.remove_tag)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(remove_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        try:
            c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
            rows=c.fetchall()
            for row in rows:
                r_idx=self.tags_table.rowCount()
                self.tags_table.insertRow(r_idx)
                for i,val in enumerate(row):
                    self.tags_table.setItem(r_idx,i,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","RuleID:")
        if not ok:
            return
        tname,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tname.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tname.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Tag assigned.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        tag_id=int(self.tags_table.item(row,0).text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tag_id,))
            self.connection.commit()
            QMessageBox.information(self,"Removed","Tag removed.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class ChainSimulationDialog(QDialog):
    """
    BFS chain simulation from selected parent rule
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Chain Simulation (Dry-run BFS)")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for r,n in c.fetchall():
                self.rule_combo.addItem(f"{r} - {n}",r)
        except: pass
        top_h.addWidget(QLabel("Select Parent Rule:"))
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_h=QHBoxLayout()
        run_btn=QPushButton("Run Chain BFS (Dry-run)")
        run_btn.clicked.connect(self.do_sim)
        btn_h.addWidget(run_btn)
        cls_btn=QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        btn_h.addWidget(cls_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_sim(self):
        pid=self.rule_combo.currentData()
        adjacency,roots,pmap=load_rule_relationships(self.connection)
        all_map=get_all_rules_map(self.connection)
        executed=[]
        skipped=set()
        queue=[pid]
        while queue:
            rid=queue.pop(0)
            if rid in skipped:
                continue
            if rid not in all_map:
                skipped.add(rid)
                continue
            info=all_map[rid]
            op_type=info.get("OPERATION_TYPE","OTHER")
            sql_text=info.get("RULE_SQL","")
            dt_id=info.get("DECISION_TABLE_ID")
            if op_type.upper()=="DECISION_TABLE":
                ok,msg,rc=execute_decision_table(self.connection,dt_id,True)
            else:
                ok,msg=self.dry_run_sql(sql_text)
                rc=0
            if ok:
                executed.append(rid)
                if rid in adjacency:
                    for ch in adjacency[rid]:
                        if ch not in skipped:
                            queue.append(ch)
            else:
                is_crit=(info.get("CRITICAL_RULE",0)==1 or info.get("IS_GLOBAL",0)==1)
                if is_crit and rid in adjacency:
                    skip_all_descendants(rid,adjacency,skipped)
                skipped.add(rid)
        txt=(f"BFS from {pid} =>\nExecuted: {executed}\nSkipped: {list(skipped)}")
        self.result_text.setPlainText(txt)
        QMessageBox.information(self,"Chain BFS",txt)

    def dry_run_sql(self,sql_):
        c=self.connection.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
        except:
            pass
        success=False
        msg=""
        try:
            c.execute(sql_)
            rows=[]
            try: rows=c.fetchall()
            except: pass
            if rows:
                val=rows[0][0]
                success=(val==1)
                msg=f"Returned => {val}"
            else:
                success=True
                msg="No rows => PASS"
            c.execute("ROLLBACK")
        except Exception as ex:
            try:c.execute("ROLLBACK")
            except: pass
            success=False
            msg=str(ex)
        return success,msg


class GroupSimulationDialog(QDialog):
    """
    Dry-run for all rules in a custom group
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Custom Group Simulation")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.group_combo=QComboBox()
        c=connection.cursor()
        try:
            c.execute("SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            for cid,gn in c.fetchall():
                self.group_combo.addItem(f"{cid} - {gn}",cid)
        except:
            pass
        top_h.addWidget(QLabel("Select Custom Group:"))
        top_h.addWidget(self.group_combo)
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_h=QHBoxLayout()
        run_btn=QPushButton("Run Group Simulation (Dry-run)")
        run_btn.clicked.connect(self.do_sim)
        btn_h.addWidget(run_btn)
        cls_btn=QPushButton("Close")
        cls_btn.clicked.connect(self.close)
        btn_h.addWidget(cls_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_sim(self):
        gid=self.group_combo.currentData()
        passed,failed=self.simulate_custom_group(gid)
        txt=(f"GroupSim {gid} =>\nPassed: {passed}\nFailed: {failed}")
        self.result_text.setPlainText(txt)
        QMessageBox.information(self,"GroupSim",txt)

    def simulate_custom_group(self,group_id):
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(group_id,))
        rids=[r[0] for r in c.fetchall()]
        c.execute("SELECT RULE_ID,RULE_SQL,OPERATION_TYPE,DECISION_TABLE_ID FROM BRM_RULES")
        rows=c.fetchall()
        rule_map={}
        for (rid, sql_,op,dtid) in rows:
            rule_map[rid]=(sql_ or "",op.upper(),dtid)
        passed=[]
        failed=[]
        for rid in rids:
            if rid not in rule_map:
                failed.append(rid)
                continue
            sql_,op_type,dtid=rule_map[rid]
            if op_type=="DECISION_TABLE":
                ok,msg,rc=execute_decision_table(self.connection,dtid,True)
            else:
                ok,msg=self.dry_run_sql(sql_)
                rc=0
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
        return passed,failed

    def dry_run_sql(self,sql_):
        c=self.connection.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
        except:
            pass
        success=False
        msg=""
        try:
            c.execute(sql_)
            rows=[]
            try: rows=c.fetchall()
            except: pass
            if rows:
                val=rows[0][0]
                success=(val==1)
                msg=f"Returned => {val}"
            else:
                success=True
                msg="No rows => PASS"
            c.execute("ROLLBACK")
        except Exception as ex:
            try:c.execute("ROLLBACK")
            except: pass
            success=False
            msg=str(ex)
        return success,msg


###############################################################################
# 9) MAIN WINDOW – 2 MAIN TABS: Admin, Business Rules
###############################################################################

class MainWindow(QMainWindow):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.setWindowTitle("BRM MASTER – 2-Tab UI")
        self.resize(1400,900)

        self.tabs=QTabWidget()
        self.setCentralWidget(self.tabs)

        # 1) ADMIN TAB: sub-tabs for user mgmt, group mgmt, ctrl tables, global-critical admin
        self.admin_tab=QTabWidget()
        # each sub-tab
        self.user_mgmt_tab=UserManagementTab(self.connection)
        self.group_mgmt_tab=GroupManagementTab(self.connection)
        self.ctrl_tables_tab=CtrlTablesTab(self.connection,user_group)
        self.gcr_admin_tab=GlobalCriticalAdminTab(self.connection,self.user_group)
        self.admin_tab.addTab(self.user_mgmt_tab,"User Mgmt")
        self.admin_tab.addTab(self.group_mgmt_tab,"Group Mgmt")
        self.admin_tab.addTab(self.ctrl_tables_tab,"Control Tables")
        self.admin_tab.addTab(self.gcr_admin_tab,"Global/Critical Admin")

        # 2) BUSINESS RULES TAB: sub-tabs for BFS, conflict manager, custom groups, what-if, data validations, schedule, snapshots, tags, composite, etc.
        self.br_tab=QTabWidget()
        # sub-tab: conflict manager
        self.conflict_tab=ConflictPriorityManagerTab(self.connection)
        self.br_tab.addTab(self.conflict_tab,"Conflicts")

        # sub-tab: composite rules
        self.composite_tab=CompositeRulesTab(self.connection)
        self.br_tab.addTab(self.composite_tab,"Composite")

        # sub-tab: data validations
        self.data_val_tab=DataValidationTab(self.connection)
        self.br_tab.addTab(self.data_val_tab,"Data Validations")

        # sub-tab: scheduling
        self.schedule_tab=ScheduleManagementTab(self.connection)
        self.br_tab.addTab(self.schedule_tab,"Scheduling")

        # sub-tab: BFS chain & group simulations
        # we'll add 2 buttons or dialogs
        chain_btn=QPushButton("Chain Simulation")
        chain_btn.clicked.connect(self.open_chain_sim)
        group_btn=QPushButton("Group Simulation")
        group_btn.clicked.connect(self.open_group_sim)
        chain_container=QWidget()
        chain_layout=QVBoxLayout(chain_container)
        chain_layout.addWidget(chain_btn)
        chain_layout.addWidget(group_btn)
        chain_layout.addStretch()
        self.br_tab.addTab(chain_container,"BFS Sims")

        # sub-tab: what-if
        self.whatif_tab=WhatIfTestTab(self.connection)
        self.br_tab.addTab(self.whatif_tab,"What-If Testing")

        # sub-tab: snapshots
        self.snap_tab=SnapshotManagerTab(self.connection)
        self.br_tab.addTab(self.snap_tab,"Snapshots")

        # sub-tab: tags
        self.tags_tab=TagsManagerTab(self.connection)
        self.br_tab.addTab(self.tags_tab,"Tags")

        # add the two main tabs to the top-level
        self.tabs.addTab(self.admin_tab,"Administration")
        self.tabs.addTab(self.br_tab,"Business Rules")

        self.setup_menubar()
        self.setStatusBar(QStatusBar(self))
        self.statusBar().showMessage("Ready")

    def setup_menubar(self):
        menubar=self.menuBar()
        file_menu=menubar.addMenu("File")
        exit_action=QAction("Exit",self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        help_menu=menubar.addMenu("Help")
        about_act=QAction("About",self)
        about_act.triggered.connect(self.show_about)
        help_menu.addAction(about_act)

    def show_about(self):
        QMessageBox.information(self,"About","BRM MASTER – 2-tab UI with advanced features.\nAll rights reserved.")

    def open_chain_sim(self):
        dlg=ChainSimulationDialog(self.connection,self)
        dlg.exec_()

    def open_group_sim(self):
        dlg=GroupSimulationDialog(self.connection,self)
        dlg.exec_()


###############################################################################
# 10) main() to tie it all up
###############################################################################

def main():
    app=QApplication(sys.argv)

    # Step1: open DB connection
    db_dlg=DatabaseConnectionDialog()
    if db_dlg.exec_()!=QDialog.Accepted:
        sys.exit(0)
    conn=db_dlg.connection
    if not conn:
        sys.exit(1)

    # Step2: login
    log_dlg=LoginDialog(conn)
    if log_dlg.exec_()!=QDialog.Accepted:
        sys.exit(0)
    user_id=log_dlg.user_id
    user_group=log_dlg.user_group

    # Step3: launch main window
    win=MainWindow(conn,user_id,user_group)
    win.show()
    sys.exit(app.exec_())


if __name__=="__main__":
    main()