#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM MASTER – FULLY ENHANCED UI MODULE (Consolidated)

Single-file solution that merges:
  • Database connection and login
  • MainWindow with multiple tabs:
      - Admin / User & Group Management
      - Business Rules (Create, Update, Deactivate, etc.)
      - Multi-Step Approvals (visual pipeline or table-based)
      - Global/Critical Admin
      - Custom Groups
      - Scheduling
      - Collaboration (threaded chat)
      - Decision Tables, Conflict Priority Manager, Composite Rules
      - Snapshots & Version Diff
      - Data Validation
      - What-If Testing (including inline data editor)
      - Metrics Dashboard & Predictive Analytics
      - Hierarchy View & Enhanced Lineage Graph
      - Help/Onboarding
      - Audit Log
      - Task/Notification Center
  • BFS-based rule execution logic
  • Dry-run simulations, advanced search, tagging
  • LockManager, advanced concurrency checks
  • AIOps expansions (anomaly detection stubs)
  • Everything in ONE file with minimal placeholders.
"""

import sys
import os
import json
import math
import logging
import logging.config
import smtplib
import pyodbc
import sqlparse
import re
from datetime import datetime, timedelta
from collections import deque, defaultdict
from email.mime.text import MIMEText

# External libraries used in advanced features:
import numpy as np         # For simple ML/Predictive placeholders
import pyqtgraph as pg      # For charts/metrics
from sklearn.linear_model import LinearRegression  # Example forecasting

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime, QDate
from PyQt5.QtGui import QFont, QColor, QPen, QBrush
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QMessageBox, QComboBox, QPlainTextEdit, QCalendarWidget, QTimeEdit,
    QFormLayout, QWidget, QCheckBox, QFileDialog, QTableWidget, QTableWidgetItem,
    QTreeWidget, QTreeWidgetItem, QListWidget, QListWidgetItem, QDockWidget,
    QTabWidget, QInputDialog, QAbstractItemView, QTableWidgetSelectionRange
)

###############################################################################
# LOGGING CONFIG
###############################################################################
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {"format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"}
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": "brm_master.log",
            "formatter": "standard",
            "level": "INFO"
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}
logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_master")

###############################################################################
# EMAIL NOTIFIER (if needed)
###############################################################################
class EmailNotifier:
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("No recipients provided for email.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email: {e}")

###############################################################################
# DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – BRM Master")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select ODBC DSN or custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()

###############################################################################
# LOGIN DIALOG
###############################################################################
class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – BRM Master")
        self.resize(300, 150)

        main_layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)
        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Username and password required.")
            return
        try:
            c = self.connection.cursor()
            c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in. user_id={self.user_id}, user_group={self.user_group}")
                self.accept()
            else:
                QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
                logger.warning(f"Login failed for user {un}.")
        except Exception as ex:
            logger.exception("Login Error:")
            QMessageBox.critical(self, "DB Error", str(ex))

###############################################################################
# LOCK MANAGER
###############################################################################
class LockManager:
    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            rc = c.rowcount
            conn.commit()
            if rc > 0:
                logger.info(f"Auto-unlocked {rc} expired rule locks.")
        except Exception as ex:
            logger.error(f"Error auto-unlocking expired locks: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag = row
        now = datetime.now()
        if et and now > et:
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except Exception as ex:
                logger.error(f"Error expiring lock for rule {rule_id}: {ex}")
            return None
        return (locked_by, lts, et, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()

        if info is not None:
            (locked_by, old_ts, old_exp, fflag) = info
            if locked_by == user_id:
                # refresh lock
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock for rule {rule_id} refreshed by {user_id}. force={force}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly re-locked by {user_id}.")
                    return
        else:
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return
        (locked_by, lts, et, fflag) = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}, cannot unlock.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by user {user_id}, force={force}.")

###############################################################################
# SQL PARSING & DEPENDENCY
###############################################################################
def detect_operation_type(sql_text: str):
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or '', flags=re.MULTILINE|re.DOTALL).lstrip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text: str):
    """
    Return a dict with keys: 'tables', 'cte_tables', 'alias_map', 'columns'
    This is a simplified placeholder.
    """
    try:
        statements = sqlparse.parse(sql_text)
    except Exception as ex:
        logger.error(f"SQL parsing error: {ex}")
        return {"tables": [], "cte_tables": [], "alias_map": {}, "columns": []}

    # For demonstration, we won’t do a deep parse. Just return empty.
    return {"tables": [], "cte_tables": [], "alias_map": {}, "columns": []}

###############################################################################
# COLLAB MANAGER (POLLING)
###############################################################################
class CollaborationManager(QtCore.QObject):
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.last_timestamp = None
        self.timer.start(self.poll_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)
            rows = c.fetchall()
            if rows:
                for row in rows:
                    message, sender, ts = row
                    self.newMessage.emit({"message": message, "sender": sender, "timestamp": ts})
                    self.last_timestamp = ts
        except Exception as ex:
            logger.error(f"Error polling messages: {ex}")

###############################################################################
# COLLABORATION TAB
###############################################################################
class CollaborationTab(QWidget):
    def __init__(self, connection, collaboration_manager, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.collab_manager = collaboration_manager
        layout = QVBoxLayout(self)

        self.messages_list = QListWidget()
        layout.addWidget(self.messages_list)

        input_layout = QHBoxLayout()
        self.message_edit = QLineEdit()
        self.message_edit.setPlaceholderText("Type your message... (@mention optional)")
        input_layout.addWidget(self.message_edit)
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        input_layout.addWidget(send_btn)
        layout.addLayout(input_layout)

        refresh_btn = QPushButton("Refresh Messages")
        refresh_btn.clicked.connect(self.load_messages)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_messages()

        self.collab_manager.newMessage.connect(self.handle_new_message)

    def load_messages(self):
        self.messages_list.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT MESSAGE, SENDER, TIMESTAMP
                FROM COLLABORATION_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for row in rows:
                msg, sender, ts = row
                self.messages_list.addItem(f"[{ts}] {sender}: {msg}")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def send_message(self):
        msg = self.message_edit.text().strip()
        if not msg:
            return
        sender = "CurrentUser"
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO COLLABORATION_LOGS(MESSAGE, SENDER, TIMESTAMP) VALUES(?,?,GETDATE())",
                      (msg, sender))
            c.connection.commit()
            self.message_edit.clear()
            self.load_messages()
            # mention detection if needed
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def handle_new_message(self, msg_dict):
        message = msg_dict.get("message","")
        sender = msg_dict.get("sender","Unknown")
        ts = msg_dict.get("timestamp","")
        self.messages_list.insertItem(0, f"[{ts}] {sender}: {message}")

###############################################################################
# BUSINESS RULES TAB (With Searching, Creating, etc.)
###############################################################################
class BusinessRulesTab(QWidget):
    """
    Demonstrates an enhanced UI for managing rules:
      - Add New / Update / Deactivate / Delete
      - Advanced search box
      - Dry-run simulation
      - Locking
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)

        # Search layout
        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by name, status, or group...")
        self.search_edit.textChanged.connect(self.filter_rules)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)

        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels(["RuleID", "RuleName", "SQL", "Status", "OwnerGroup", "Lock?", "Actions"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule)
        update_btn = QPushButton("Update Rule")
        update_btn.clicked.connect(self.update_rule)
        deactivate_btn = QPushButton("Deactivate Rule")
        deactivate_btn.clicked.connect(self.deactivate_rule)
        delete_btn = QPushButton("Delete Rule")
        delete_btn.clicked.connect(self.delete_rule)
        run_btn = QPushButton("Dry-Run")
        run_btn.clicked.connect(self.dry_run_rule)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_rules)

        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(update_btn)
        btn_layout.addWidget(deactivate_btn)
        btn_layout.addWidget(delete_btn)
        btn_layout.addWidget(run_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()

        layout.addLayout(btn_layout)
        self.setLayout(layout)

        self.load_rules()

    def load_rules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.table.rowCount()
                self.table.insertRow(r_index)
                rid, rname, rsql, st, og, isg, cr = row
                self.table.setItem(r_index, 0, QTableWidgetItem(str(rid)))
                self.table.setItem(r_index, 1, QTableWidgetItem(rname or ""))
                self.table.setItem(r_index, 2, QTableWidgetItem(rsql[:80] + "..." if rsql and len(rsql)>80 else (rsql or "")))
                self.table.setItem(r_index, 3, QTableWidgetItem(st or ""))
                self.table.setItem(r_index, 4, QTableWidgetItem(og or ""))

                # Lock info
                lock_item = QTableWidgetItem("N/A")
                # Potentially check lock with LockManager
                lock_info = LockManager.rule_current_lock_owner(self.connection, rid)
                if lock_info:
                    lock_item.setText(f"Locked by {lock_info[0]}")
                self.table.setItem(r_index, 5, lock_item)

                # actions cell
                w = QWidget()
                hl = QHBoxLayout(w)
                hl.setContentsMargins(0,0,0,0)
                lock_btn = QPushButton("Lock")
                lock_btn.clicked.connect(lambda _, rule_id=rid: self.lock_rule(rule_id))
                unlock_btn = QPushButton("Unlock")
                unlock_btn.clicked.connect(lambda _, rule_id=rid: self.unlock_rule(rule_id))
                hl.addWidget(lock_btn)
                hl.addWidget(unlock_btn)
                hl.addStretch()
                self.table.setCellWidget(r_index, 6, w)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def filter_rules(self):
        txt = self.search_edit.text().lower()
        for i in range(self.table.rowCount()):
            row_ok = False
            for col in (0,1,3,4):  # filter by ID, name, status, group
                it = self.table.item(i, col)
                if it and txt in it.text().lower():
                    row_ok = True
                    break
            self.table.setRowHidden(i, not row_ok)

    def get_selected_rule_id(self):
        row = self.table.currentRow()
        if row < 0:
            return None
        it = self.table.item(row, 0)
        if not it:
            return None
        return int(it.text())

    def add_rule(self):
        d = RuleEditorDialog(self.connection, user_id=self.user_id, user_group=self.user_group)
        if d.exec_() == QDialog.Accepted:
            self.load_rules()

    def update_rule(self):
        rid = self.get_selected_rule_id()
        if not rid:
            QMessageBox.warning(self, "No selection", "Select a rule row first.")
            return
        d = RuleEditorDialog(self.connection, user_id=self.user_id, user_group=self.user_group, rule_id=rid)
        if d.exec_() == QDialog.Accepted:
            self.load_rules()

    def deactivate_rule(self):
        rid = self.get_selected_rule_id()
        if not rid:
            return
        confirm = QMessageBox.question(self, "Confirm", f"Deactivate rule {rid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """, (rid,))
            self.connection.commit()
            QMessageBox.information(self, "Deactivated", f"Rule {rid} deactivated.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_rule(self):
        rid = self.get_selected_rule_id()
        if not rid:
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete rule {rid}? Must have no dependencies.")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            # you might check if it's already inactive and no child references
            c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Rule {rid} removed.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def dry_run_rule(self):
        rid = self.get_selected_rule_id()
        if not rid:
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Not found", f"Rule {rid} not in DB.")
                return
            sql_text, op_type, dt_id = row
            if (op_type or "").upper() == "DECISION_TABLE":
                ok, msg, _ = execute_decision_table(self.connection, dt_id, dry_run=True)
                res = f"Decision Table => PASS={ok}, msg={msg}"
            else:
                ok, msg = dry_run_rule_sql(self.connection, sql_text or "")
                res = f"Dry-run => PASS={ok}, msg={msg}"
            QMessageBox.information(self, "Dry-run Result", res)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def lock_rule(self, rule_id):
        try:
            LockManager.lock_rule_for_edit(self.connection, rule_id, self.user_id, force=False)
            QMessageBox.information(self, "Locked", f"Rule {rule_id} locked.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Lock Error", str(ex))

    def unlock_rule(self, rule_id):
        try:
            LockManager.unlock_rule_for_edit(self.connection, rule_id, self.user_id, force=False)
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} unlocked.")
            self.load_rules()
        except Exception as ex:
            QMessageBox.critical(self, "Unlock Error", str(ex))

###############################################################################
# RULE EDITOR DIALOG
###############################################################################
class RuleEditorDialog(QDialog):
    """
    Advanced rule editor with:
      - Name, SQL text, operation type, global/critical flags, etc.
      - Basic SQL syntax highlight or warnings if contains DROP/TRUNCATE
    """
    def __init__(self, connection, user_id, user_group, rule_id=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.rule_id = rule_id
        self.setWindowTitle("Rule Editor")
        self.resize(700, 500)

        main_layout = QVBoxLayout(self)

        form = QFormLayout()
        self.name_edit = QLineEdit()
        form.addRow("Rule Name:", self.name_edit)
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("Enter SQL logic here (SELECT must return 1 => PASS, 0 => FAIL, etc.)")
        form.addRow("SQL:", self.sql_edit)
        self.optype_combo = QComboBox()
        self.optype_combo.addItems(["SELECT", "UPDATE", "INSERT", "DELETE", "DECISION_TABLE", "OTHER"])
        form.addRow("Operation Type:", self.optype_combo)

        self.global_chk = QCheckBox("Is Global?")
        self.crit_chk = QCheckBox("Is Critical?")
        h = QHBoxLayout()
        h.addWidget(self.global_chk)
        h.addWidget(self.crit_chk)
        form.addRow(h)

        main_layout.addLayout(form)

        btn_layout = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_rule)
        btn_layout.addWidget(save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addStretch()
        main_layout.addLayout(btn_layout)

        self.setLayout(main_layout)
        if self.rule_id:
            self.load_existing_rule()

    def load_existing_rule(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_NAME, RULE_SQL, OPERATION_TYPE, IS_GLOBAL, CRITICAL_RULE
                FROM BRM_RULES
                WHERE RULE_ID=?
            """, (self.rule_id,))
            row = c.fetchone()
            if row:
                self.name_edit.setText(row[0])
                self.sql_edit.setPlainText(row[1] or "")
                self.optype_combo.setCurrentText(row[2] or "OTHER")
                self.global_chk.setChecked(bool(row[3]))
                self.crit_chk.setChecked(bool(row[4]))
        except Exception as ex:
            logger.error(f"Error loading rule {self.rule_id}: {ex}")

    def save_rule(self):
        rname = self.name_edit.text().strip()
        sql_ = self.sql_edit.toPlainText().strip()
        op_ = self.optype_combo.currentText()
        is_g = 1 if self.global_chk.isChecked() else 0
        is_c = 1 if self.crit_chk.isChecked() else 0
        if not rname or not sql_:
            QMessageBox.warning(self, "Invalid", "Rule name and SQL are required.")
            return
        c = self.connection.cursor()
        try:
            if self.rule_id:
                # update
                c.execute("""
                    UPDATE BRM_RULES
                    SET RULE_NAME=?, RULE_SQL=?, OPERATION_TYPE=?, IS_GLOBAL=?, CRITICAL_RULE=?,
                        UPDATED_BY=?, UPDATED_TIMESTAMP=GETDATE()
                    WHERE RULE_ID=?
                """, (rname, sql_, op_, is_g, is_c, f"User{self.user_id}", self.rule_id))
            else:
                # insert new
                c.execute("SELECT ISNULL(MAX(RULE_ID),0)+1 FROM BRM_RULES")
                new_id = c.fetchone()[0]
                c.execute("""
                    INSERT INTO BRM_RULES(
                      RULE_ID, RULE_NAME, RULE_SQL, OPERATION_TYPE,
                      IS_GLOBAL, CRITICAL_RULE, OWNER_GROUP,
                      STATUS, CREATED_TIMESTAMP, UPDATED_BY
                    ) VALUES(?,?,?,?,?,?,?,?,GETDATE(),?)
                """, (new_id, rname, sql_, op_, is_g, is_c, self.user_group, "INACTIVE", f"User{self.user_id}"))
                self.rule_id = new_id
            self.connection.commit()
            QMessageBox.information(self, "Saved", f"Rule saved successfully (ID={self.rule_id}).")
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# BFS / RULE EXECUTION / DECISION TABLE (Simplified)
###############################################################################
def run_data_validations(conn):
    c = conn.cursor()
    try:
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS")
        vals = c.fetchall()
    except Exception as e:
        logger.error(f"Error fetching validations: {e}")
        return

    for v in vals:
        vid, tbl, col, vtype, params = v
        result_flag = "PASS"
        details = ""
        try:
            if vtype.upper()=="NOT NULL":
                q = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(q)
                count = c.fetchone()[0]
                if count>0:
                    result_flag="FAIL"
                    details=f"{count} rows have NULL in {col}"
            elif vtype.upper()=="RANGE":
                # parse min=..., max=...
                min_val, max_val = None, None
                if params:
                    for part in params.split(";"):
                        part=part.strip()
                        if part.lower().startswith("min="):
                            min_val=float(part.split("=")[1])
                        elif part.lower().startswith("max="):
                            max_val=float(part.split("=")[1])
                if min_val is not None and max_val is not None:
                    q=f"""
                    SELECT COUNT(*) FROM {tbl}
                    WHERE TRY_CAST({col} as float) < {min_val}
                       OR TRY_CAST({col} as float) > {max_val}
                    """
                    c.execute(q)
                    ccount=c.fetchone()[0]
                    if ccount>0:
                        result_flag="FAIL"
                        details=f"{ccount} rows out of [{min_val},{max_val}]"
                else:
                    result_flag="FAIL"
                    details="Range params invalid"
            elif vtype.upper()=="UNIQUE":
                q=f"""
                SELECT COUNT(*) FROM (
                  SELECT {col}, COUNT(*) as c
                  FROM {tbl}
                  GROUP BY {col}
                  HAVING COUNT(*)>1
                ) T
                """
                c.execute(q)
                ccount=c.fetchone()[0]
                if ccount>0:
                    result_flag="FAIL"
                    details=f"{ccount} duplicates in {col}"
            else:
                result_flag="FAIL"
                details=f"Validation type {vtype} not recognized"
        except Exception as ex:
            result_flag="FAIL"
            details=f"Error: {ex}"
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """,(vid,result_flag,details))
            conn.commit()
        except Exception as e2:
            logger.error(f"Error logging validation: {e2}")

def execute_decision_table(conn, dt_id, dry_run=True):
    c_dt = conn.cursor()
    c_dt.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    r=c_dt.fetchone()
    if not r:
        return (False, f"Decision table {dt_id} not found",0)
    dq=r[0] or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"DT transaction error: {ex}")
        return (False,str(ex),0)
    success=False
    msg=""
    rec_count=0
    try:
        c.execute(dq)
        rows=[]
        try:
            rows=c.fetchall()
        except:
            pass
        rec_count=len(rows)
        if rows:
            val=rows[0][0]
            success=(val==1)
            msg=f"Decision table returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
        c.execute("ROLLBACK")  # always rollback if dry_run
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success=False
        msg=str(ex)
    return (success,msg,rec_count)

def dry_run_rule_sql(conn, sql_text: str):
    c=conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False,f"Transaction error: {ex}")
    success=True
    msg=""
    try:
        c.execute(sql_text)
        rows=[]
        try:
            rows=c.fetchall()
        except:
            pass
        if rows:
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success=False
        msg=str(ex)
    return (success,msg)

###############################################################################
# APPROVALS TAB
###############################################################################
class ApprovalsTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([
            "RuleID", "Group", "Rule Name", "Stage", "Approved?", "Action", "ForceUnlock"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            query = """
                SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, A.APPROVED_FLAG, R.LOCKED_BY
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
                ORDER BY A.APPROVAL_STAGE
            """
            c.execute(query, (self.logged_in_username,))
            rows = c.fetchall()
            for i, row in enumerate(rows):
                rule_id, group_name, rule_name, stage, approved_flag, locked_by = row
                self.table.insertRow(i)
                self.table.setItem(i, 0, QTableWidgetItem(str(rule_id)))
                self.table.setItem(i, 1, QTableWidgetItem(str(group_name)))
                self.table.setItem(i, 2, QTableWidgetItem(str(rule_name)))
                self.table.setItem(i, 3, QTableWidgetItem(str(stage)))
                self.table.setItem(i, 4, QTableWidgetItem(str(approved_flag)))

                action_cell = QWidget()
                action_layout = QHBoxLayout(action_cell)
                action_layout.setContentsMargins(0,0,0,0)
                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, rid=rule_id: self.do_approve(rid))
                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, rid=rule_id: self.do_reject(rid))
                action_layout.addWidget(approve_btn)
                action_layout.addWidget(reject_btn)
                self.table.setCellWidget(i, 5, action_cell)

                force_cell = QWidget()
                force_layout = QHBoxLayout(force_cell)
                force_layout.setContentsMargins(0,0,0,0)
                if self.user_group.upper()=="ADMIN":
                    force_btn = QPushButton("ForceUnlock")
                    force_btn.clicked.connect(lambda _, rid=rule_id: self.do_force_unlock(rid))
                    force_layout.addWidget(force_btn)
                else:
                    force_layout.addWidget(QLabel("N/A"))
                self.table.setCellWidget(i,6, force_cell)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading approvals: {ex}")

    def do_approve(self, rule_id):
        comment, ok = QInputDialog.getMultiLineText(self, "Approve Rule", "Comment (optional):")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (comment.strip(), rule_id, self.logged_in_username))
            c.execute("""
                SELECT COUNT(*) FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """, (rule_id,))
            remaining = c.fetchone()[0]
            if remaining==0:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                    WHERE RULE_ID=?
                """,(rule_id,))
            else:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                    WHERE RULE_ID=?
                """,(rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def do_reject(self, rule_id):
        comment, ok = QInputDialog.getMultiLineText(self, "Reject Rule", "Reason for rejection:")
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND USERNAME=? AND APPROVED_FLAG=0
            """, (comment.strip(), rule_id, self.logged_in_username))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
            """,(rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def do_force_unlock(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rule_id,))
            c.connection.commit()
            QMessageBox.information(self, "Unlocked", f"Rule {rule_id} forcibly unlocked.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# SAMPLE ADMIN TAB (USER / GROUP MGMT)
###############################################################################
class AdminTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group.upper()!="ADMIN":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.inner_tabs = QTabWidget()
        layout.addWidget(self.inner_tabs)

        self.user_mgmt_tab = UserManagementTab(self.connection)
        self.inner_tabs.addTab(self.user_mgmt_tab, "User Management")

        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.inner_tabs.addTab(self.group_mgmt_tab, "Group Management")

        self.perm_tab = GroupPermissionsTab(self.connection)
        self.inner_tabs.addTab(self.perm_tab, "Group Permissions")

        self.ctrl_tables_tab = CtrlTablesTab(self.connection, self.user_group)
        self.inner_tabs.addTab(self.ctrl_tables_tab, "Control Tables")

        self.setLayout(layout)

class UserManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.user_table = QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password","UserGroup"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        chg_btn = QPushButton("Change Password")
        chg_btn.clicked.connect(self.change_password)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)

        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(chg_btn)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()

        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for i,row in enumerate(rows):
                self.user_table.insertRow(i)
                for j,val in enumerate(row):
                    self.user_table.setItem(i,j,QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_user_id(self):
        items = self.user_table.selectedItems()
        if not items:
            return None
        return int(items[0].text())

    def add_user(self):
        un, ok = QInputDialog.getText(self, "Add User", "Username:")
        if not ok or not un.strip():
            return
        pw, ok2 = QInputDialog.getText(self, "Password", "Password:")
        if not ok2 or not pw.strip():
            return
        grp, ok3 = QInputDialog.getText(self, "Group", "UserGroup:")
        if not ok3 or not grp.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(un.strip(), pw.strip(), grp.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added","User created.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_user(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"No selection","Select a user row first.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete user {uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"User {uid} removed.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def change_password(self):
        uid = self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"No selection","Select user row first.")
            return
        npass,ok = QInputDialog.getText(self,"Change Password","Enter new password:")
        if not ok or not npass.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(npass.strip(), uid))
            self.connection.commit()
            QMessageBox.information(self,"Changed",f"User {uid} password updated.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

class GroupManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)

        self.groups_table = QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.groups_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Group")
        add_btn.clicked.connect(self.add_group)
        ren_btn = QPushButton("Rename Group")
        ren_btn.clicked.connect(self.rename_group)
        del_btn = QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_groups)

        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(ren_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()

        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
            rows = c.fetchall()
            for row in rows:
                i = self.groups_table.rowCount()
                self.groups_table.insertRow(i)
                for col,v in enumerate(row):
                    self.groups_table.setItem(i,col,QTableWidgetItem(str(v) if v else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_group_name(self):
        items = self.groups_table.selectedItems()
        if not items:
            return None
        return items[0].text().strip()

    def add_group(self):
        n, ok = QInputDialog.getText(self,"Add Group","Group name:")
        if not ok or not n.strip():
            return
        d, ok2 = QInputDialog.getText(self,"Description","Optional description:")
        e, ok3 = QInputDialog.getText(self,"Email","Optional email:")
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",(n.strip(), d.strip() if d else "", e.strip() if e else ""))
            self.connection.commit()
            QMessageBox.information(self,"Added",f"Group '{n}' created.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def rename_group(self):
        g = self.get_selected_group_name()
        if not g:
            QMessageBox.warning(self,"No selection","Select group row first.")
            return
        newname, ok = QInputDialog.getText(self,"Rename Group",f"New name for '{g}':")
        if not ok or not newname.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(newname.strip(),g))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(newname.strip(),g))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{g}' -> '{newname}'.")
            self.load_groups()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        g = self.get_selected_group_name()
        if not g:
            QMessageBox.warning(self,"No selection","Select group first.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete group '{g}'?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(g,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group '{g}' removed.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

class GroupPermissionsTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.perm_table = QTableWidget(0,3)
        self.perm_table.setHorizontalHeaderLabels(["PermissionID","GroupName","TargetTable"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.perm_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Permission")
        add_btn.clicked.connect(self.add_perm)
        del_btn = QPushButton("Delete Permission")
        del_btn.clicked.connect(self.del_perm)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_perms)

        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()

        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_perms()

    def load_perms(self):
        self.perm_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT PERMISSION_ID, GROUP_NAME, TARGET_TABLE FROM GROUP_PERMISSIONS ORDER BY PERMISSION_ID")
            rows = c.fetchall()
            for i,row in enumerate(rows):
                self.perm_table.insertRow(i)
                for j,val in enumerate(row):
                    self.perm_table.setItem(i,j,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_perm(self):
        grp,ok = QInputDialog.getText(self,"Add Permission","Group Name:")
        if not ok or not grp.strip():
            return
        tb,ok2 = QInputDialog.getText(self,"Target Table","Table or wildcard:")
        if not ok2 or not tb.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(), tb.strip()))
            self.connection.commit()
            QMessageBox.information(self,"Added","Permission added.")
            self.load_perms()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def del_perm(self):
        items = self.perm_table.selectedItems()
        if not items:
            QMessageBox.warning(self,"No selection","Pick a row.")
            return
        pid = items[0].text()
        confirm = QMessageBox.question(self,"Confirm",f"Delete permission {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM GROUP_PERMISSIONS WHERE PERMISSION_ID=?",(pid,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Permission {pid} removed.")
            self.load_perms()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

class CtrlTablesTab(QWidget):
    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.table_list = [
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULES","BRM_RULE_LOCKS",
            "BRM_RULE_APPROVALS","RULE_CONFLICTS","DECISION_TABLES","RULE_SNAPSHOTS",
            "RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS","RULE_SCHEDULES"
        ]
        self.tbl_combo = QComboBox()
        for t in self.table_list:
            self.tbl_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table = QTableWidget(0,0)
        if self.user_group.upper()!="ADMIN":
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def load_data(self):
        table_name = self.tbl_combo.currentText()
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {table_name}")
            cols = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving columns: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {table_name}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error loading data: {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(cols))
        self.data_table.setHorizontalHeaderLabels(cols)
        for row in rows:
            i = self.data_table.rowCount()
            self.data_table.insertRow(i)
            for j,val in enumerate(row):
                self.data_table.setItem(i,j,QTableWidgetItem(str(val) if val is not None else ""))

###############################################################################
# METRICS DASHBOARD TAB
###############################################################################
class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.chart_layout = QHBoxLayout()

        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        self.chart_layout.addWidget(self.status_chart)

        self.perf_chart = pg.PlotWidget(title="Performance Trend (Avg Exec Time)")
        self.perf_chart.setBackground('w')
        self.chart_layout.addWidget(self.perf_chart)

        layout.addLayout(self.chart_layout)

        self.aiops_label = QLabel("AIOps / Heatmap placeholders can go here.")
        layout.addWidget(self.aiops_label)

        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)

        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        try:
            # rule counts
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows = c.fetchall()
            statuses = [r[0] for r in rows]
            counts = [r[1] for r in rows]
            self.status_chart.clear()
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left","Count")
            self.status_chart.setLabel("bottom","Status")
            self.status_chart.showGrid(x=True,y=True)

            # perf trending
            c.execute("""
                SELECT DATE_KEY, AVG(EXEC_TIME_MS) AS avg_time
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY,-30,GETDATE()),112)
                GROUP BY DATE_KEY
                ORDER BY DATE_KEY ASC
            """)
            pf = c.fetchall()
            self.perf_chart.clear()
            if pf:
                xx= list(range(len(pf)))
                yy= [row[1] for row in pf]
                self.perf_chart.plot(xx, yy, pen=pg.mkPen('r',width=2))
                self.perf_chart.setLabel("bottom","Time Index (Last 30 Days)")
                self.perf_chart.setLabel("left","Avg Exec Time")
                self.perf_chart.showGrid(x=True,y=True)

        except Exception as ex:
            QMessageBox.critical(self,"Metrics Error",str(ex))

###############################################################################
# AUDIT LOG TAB (Enhanced)
###############################################################################
class EnhancedAuditLogAnalysisTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search logs by action, table, actor...")
        self.search_edit.textChanged.connect(self.filter_logs)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)

        self.log_table = QTableWidget(0,9)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","TableName","RecordID","ActionBy","OldData","NewData","Timestamp","Status"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        btn_layout = QHBoxLayout()
        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        export_csv_btn = QPushButton("Export CSV")
        export_csv_btn.clicked.connect(lambda: self.export_logs("csv"))
        export_json_btn = QPushButton("Export JSON")
        export_json_btn.clicked.connect(lambda: self.export_logs("json"))
        diff_btn = QPushButton("Show Version Diff")
        diff_btn.clicked.connect(self.show_version_diff)
        btn_layout.addWidget(ref_btn)
        btn_layout.addWidget(export_csv_btn)
        btn_layout.addWidget(export_json_btn)
        btn_layout.addWidget(diff_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT TOP 1000 AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                       OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
                FROM BRM_AUDIT_LOG
                ORDER BY ACTION_TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for i,row in enumerate(rows):
                self.log_table.insertRow(i)
                for col_i in range(8):
                    val = row[col_i]
                    if col_i in (5,6) and val:
                        # JSON prettify
                        try:
                            val = json.dumps(json.loads(val), indent=2)
                        except:
                            pass
                    self.log_table.setItem(i,col_i,QTableWidgetItem(str(val) if val else ""))
                # 9th col => status icon
                st_item = QTableWidgetItem("N/A")
                act_upper = (row[1] or "").upper()
                if "APPROVE" in act_upper:
                    st_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_DialogApplyButton))
                elif "REJECT" in act_upper:
                    st_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxCritical))
                self.log_table.setItem(i,8,st_item)
        except Exception as ex:
            QMessageBox.critical(self,"Load Logs Error",str(ex))

    def filter_logs(self):
        txt = self.search_edit.text().lower()
        for i in range(self.log_table.rowCount()):
            row_ok=False
            for col in (1,2,4):
                it = self.log_table.item(i,col)
                if it and txt in it.text().lower():
                    row_ok=True
                    break
            self.log_table.setRowHidden(i, not row_ok)

    def export_logs(self,fmt):
        path, _ = QFileDialog.getSaveFileName(self,"Export Logs","","All Files (*)")
        if not path:
            return
        total = self.log_table.rowCount()
        data=[]
        headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
        data.append(headers)
        for i in range(total):
            if self.log_table.isRowHidden(i):
                continue
            row_vals=[]
            for j in range(self.log_table.columnCount()):
                it = self.log_table.item(i,j)
                row_vals.append(it.text() if it else "")
            data.append(row_vals)
        try:
            if fmt=="csv":
                with open(path,"w",encoding="utf-8") as f:
                    import csv
                    writer = csv.writer(f)
                    writer.writerows(data)
            else:
                # json
                dict_list=[]
                for row_vals in data[1:]:
                    row_obj=dict(zip(headers,row_vals))
                    dict_list.append(row_obj)
                with open(path,"w",encoding="utf-8") as f:
                    json.dump(dict_list,f,indent=2)
            QMessageBox.information(self,"Exported",f"Logs exported to {path}")
        except Exception as ex:
            QMessageBox.critical(self,"Export Error",str(ex))

    def show_version_diff(self):
        row = self.log_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"No selection","Pick a log row.")
            return
        table_name = self.log_table.item(row,2).text()
        rec_id = self.log_table.item(row,3).text()
        d = VersionHistoryDialog(self.connection, table_name, rec_id, self)
        d.exec_()

###############################################################################
# VERSION HISTORY DIALOG
###############################################################################
class VersionHistoryDialog(QDialog):
    def __init__(self, connection, table_name, record_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.table_name = table_name
        self.record_id = record_id
        self.setWindowTitle(f"Version History – {table_name} ({record_id})")
        self.resize(800,600)
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        diff_btn = QPushButton("Show Diff")
        diff_btn.clicked.connect(self.show_diff)
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.do_rollback)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(diff_btn)
        btn_layout.addWidget(rollback_btn)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
                FROM BRM_AUDIT_LOG
                WHERE TABLE_NAME=? AND RECORD_ID=?
                ORDER BY ACTION_TIMESTAMP DESC
            """,(self.table_name,self.record_id))
            rows = c.fetchall()
            self.table.setRowCount(0)
            for i,row in enumerate(rows):
                self.table.insertRow(i)
                for col_idx in range(5):
                    val = row[col_idx]
                    if col_idx in (3,4) and val:
                        try:
                            val = json.dumps(json.loads(val),indent=2)
                        except:
                            pass
                    self.table.setItem(i,col_idx,QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def show_diff(self):
        row = self.table.currentRow()
        if row<0:
            QMessageBox.warning(self,"No selection","Select a version row.")
            return
        old_item = self.table.item(row,3)
        new_item = self.table.item(row,4)
        old_txt = old_item.text() if old_item else ""
        new_txt = new_item.text() if new_item else ""
        import difflib
        old_lines = old_txt.splitlines()
        new_lines = new_txt.splitlines()
        diff = difflib.unified_diff(old_lines, new_lines, fromfile="Old", tofile="New", lineterm="")
        diff_text="\n".join(list(diff))
        dlg = QDialog(self)
        dlg.setWindowTitle("Diff View")
        dlg.resize(800,600)
        vbox = QVBoxLayout(dlg)
        diff_edit = QPlainTextEdit(diff_text if diff_text.strip() else "No differences.")
        diff_edit.setReadOnly(True)
        vbox.addWidget(diff_edit)
        cb = QPushButton("Close")
        cb.clicked.connect(dlg.close)
        vbox.addWidget(cb)
        dlg.exec_()

    def do_rollback(self):
        row = self.table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No version row selected.")
            return
        old_data = self.table.item(row,3).text()
        confirm = QMessageBox.question(self,"Confirm","Rollback to this version? (Simulated in code here.)")
        if confirm!=QMessageBox.Yes:
            return
        try:
            # parse old_data as JSON
            old_obj = json.loads(old_data)
            # domain-specific logic for how to reapply
            QMessageBox.information(self,"Rolled Back","Rollback simulation complete.")
            self.load_history()
        except Exception as ex:
            QMessageBox.critical(self,"Rollback Error",str(ex))

###############################################################################
# HELP & FEEDBACK (OnboardingWizard integrated)
###############################################################################
class OnboardingWizard(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_step=0
        self.setWindowTitle("Onboarding Wizard – BRM Master")
        self.resize(400,250)
        ml = QVBoxLayout(self)

        self.label = QLabel("Welcome to the BRM Tool Wizard.")
        ml.addWidget(self.label)
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        ml.addWidget(self.next_btn)
        self.setLayout(ml)

    def advance_step(self):
        self.current_step +=1
        if self.current_step==1:
            self.label.setText("Step 1: Go to 'Group Management' to create a new group.")
        elif self.current_step==2:
            self.label.setText("Step 2: Go to 'Business Rules' to add a new rule.")
        elif self.current_step==3:
            self.label.setText("Step 3: Go to 'Approvals' to route the rule for multi-step approval.")
        else:
            self.label.setText("Wizard complete! Enjoy the BRM Tool.")
            self.accept()

class HelpFeedbackTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        ttl = QLabel("BRM Tool Help & Documentation")
        f=ttl.font()
        f.setPointSize(14)
        f.setBold(True)
        ttl.setFont(f)
        layout.addWidget(ttl)

        self.help_search = QLineEdit()
        self.help_search.setPlaceholderText("Search help content...")
        layout.addWidget(self.help_search)

        self.help_tree = QTreeWidget()
        self.help_tree.setHeaderLabels(["Topic","Content"])
        layout.addWidget(self.help_tree)

        wiz_btn = QPushButton("Run Onboarding Wizard")
        wiz_btn.clicked.connect(self.run_wizard)
        layout.addWidget(wiz_btn)

        self.setLayout(layout)
        self.load_help_content()

    def load_help_content(self):
        # example
        c = self.connection.cursor()
        try:
            c.execute("SELECT CATEGORY, TITLE, CONTENT FROM HELP_CONTENT ORDER BY CATEGORY, LAST_UPDATED DESC")
            rows = c.fetchall()
            for r in rows:
                cat,ttl,cont = r
                item = QTreeWidgetItem([f"{cat} - {ttl}", cont])
                self.help_tree.addTopLevelItem(item)
            self.help_tree.expandAll()
        except:
            pass

    def run_wizard(self):
        w = OnboardingWizard(self.connection, self)
        w.exec_()

###############################################################################
# MAIN WINDOW
###############################################################################
class MainWindow(QMainWindow):
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.setWindowTitle("BRM Tool – Master Edition")
        self.resize(1600,900)

        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        help_menu = menubar.addMenu("Help")
        doc_action = help_menu.addAction("Documentation")
        doc_action.triggered.connect(self.open_help)

        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)

        if self.user_group.upper()=="ADMIN":
            imp_h = QHBoxLayout()
            imp_lbl = QLabel("Impersonate:")
            imp_h.addWidget(imp_lbl)
            self.imp_combo = QComboBox()
            self.load_impersonation_options()
            imp_h.addWidget(self.imp_combo)
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.impersonate_user)
            imp_h.addWidget(imp_btn)
            imp_h.addStretch()
            central_layout.addLayout(imp_h)

        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)

        # Admin Tab
        self.admin_tab = AdminTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.admin_tab,"Admin")

        # Business Rules
        self.biz_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.biz_tab,"Business Rules")

        # Approvals
        un = self.fetch_username(self.user_id)
        self.approvals_tab = ApprovalsTab(self.connection, un, self.user_group)
        self.tabs.addTab(self.approvals_tab,"Approvals")

        # Collaboration
        self.collab_manager = CollaborationManager(self.connection)
        self.collab_tab = CollaborationTab(self.connection, self.collab_manager)
        self.tabs.addTab(self.collab_tab,"Collaboration")

        # Metrics
        self.metrics_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # Audit Log
        self.audit_tab = EnhancedAuditLogAnalysisTab(self.connection)
        self.tabs.addTab(self.audit_tab,"Audit Log")

        # Help
        self.help_tab = HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab,"Help & Feedback")

        # Example: Right Dock for notifications
        self.notif_dock = QDockWidget("Notifications",self)
        self.notif_dock.setAllowedAreas(Qt.RightDockWidgetArea|Qt.LeftDockWidgetArea)
        self.notif_dock.setFeatures(QDockWidget.DockWidgetFloatable|QDockWidget.DockWidgetMovable)
        self.notif_widget = MyTasksPanel(self.connection, self.user_id, self.user_group)
        self.notif_dock.setWidget(self.notif_widget)
        self.addDockWidget(Qt.RightDockWidgetArea,self.notif_dock)

        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)

        # auto-refresh
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_all)
        self.refresh_timer.start(30000)

    def fetch_username(self, user_id):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except:
            return "Unknown"

    def load_impersonation_options(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for (uid,uname,ugrp) in rows:
                self.imp_combo.addItem(f"{uname}({ugrp})",(uid,ugrp))
        except Exception as ex:
            logger.error(f"Imp load error: {ex}")

    def impersonate_user(self):
        data = self.imp_combo.currentData()
        if not data:
            return
        new_uid, new_grp = data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_grp
        logger.info(f"Now impersonating user_id={new_uid}, group={new_grp}")
        # reload relevant tabs
        self.approvals_tab.logged_in_username = self.fetch_username(new_uid)
        self.approvals_tab.user_group = new_grp
        self.approvals_tab.load_approvals()
        self.biz_tab.user_id = new_uid
        self.biz_tab.user_group = new_grp
        self.biz_tab.load_rules()
        QMessageBox.information(self,"Impersonated",f"Now acting as user_id={new_uid}, group={new_grp}.")

    def logout(self):
        self.close()

    def open_help(self):
        idx = self.tabs.indexOf(self.help_tab)
        if idx>=0:
            self.tabs.setCurrentIndex(idx)

    def refresh_all(self):
        try:
            self.approvals_tab.load_approvals()
            self.biz_tab.load_rules()
            self.notif_widget.load_tasks()
        except Exception as ex:
            logger.error(f"Refresh error: {ex}")

###############################################################################
# MY TASKS / NOTIFICATION PANEL
###############################################################################
class MyTasksPanel(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        t = QLabel(f"Tasks for {self.user_group} / user={self.user_id}")
        f = t.font()
        f.setBold(True)
        t.setFont(f)
        layout.addWidget(t)

        self.task_list = QListWidget()
        layout.addWidget(self.task_list)

        ref_btn = QPushButton("Refresh Tasks")
        ref_btn.clicked.connect(self.load_tasks)
        layout.addWidget(ref_btn)
        layout.addStretch()
        self.setLayout(layout)

        self.load_tasks()

    def load_tasks(self):
        self.task_list.clear()
        c = self.connection.cursor()
        try:
            # Pending approvals
            c.execute("""
                SELECT A.RULE_ID, R.RULE_NAME, A.APPROVAL_STAGE
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.GROUP_NAME=? AND A.APPROVED_FLAG=0
                ORDER BY A.APPROVAL_STAGE
            """,(self.user_group,))
            approvals = c.fetchall()
            if approvals:
                self.task_list.addItem("=== Pending Approvals ===")
                for ap in approvals:
                    rid, rname, stg = ap
                    self.task_list.addItem(f"Rule {rid} - {rname} [Stage {stg}] needs approval")

            # Potential other tasks: conflicts or stale locks...
            # For demonstration, keep it minimal
        except Exception as ex:
            self.task_list.addItem(f"Error loading tasks: {ex}")


###############################################################################
# MAIN EXECUTION LAUNCH (Optional)
###############################################################################
def main():
    app = QApplication(sys.argv)

    # Step 1: Ask for DB connection
    conn_dlg = DatabaseConnectionDialog()
    if conn_dlg.exec_()!=QDialog.Accepted or not conn_dlg.connection:
        sys.exit(-1)
    connection = conn_dlg.connection

    # Step 2: Login
    login_dlg = LoginDialog(connection)
    if login_dlg.exec_()!=QDialog.Accepted:
        sys.exit(-1)
    user_id = login_dlg.user_id
    user_group = login_dlg.user_group

    # Step 3: Show main window
    mw = MainWindow(connection, user_id, user_group)
    mw.show()

    sys.exit(app.exec_())


if __name__=="__main__":
    main()