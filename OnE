#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 1 (FINAL):
 - All standard imports
 - Logging
 - DatabaseConnectionDialog
 - LoginDialog
 - Basic DB helpers
 - detect_operation_type + parse_sql_dependencies
 - RULE_LIFECYCLE_STATES
 - OnboardingWizard (optional)
"""

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re
import csv
import difflib
import time
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate
from PyQt5.QtGui import QColor, QPainter, QBrush, QPen
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QCalendarWidget, QAbstractItemView, QFileDialog, QInputDialog
)
import pyqtgraph as pg
from sqlparse.sql import Identifier, IdentifierList, Parenthesis
from sqlparse.tokens import Keyword, DML

logging.basicConfig(
    filename='brm_tool_advanced.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger("BRMToolLogger")

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_user",
    "smtp_password": "your_smtp_pass",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email: {ex}")

class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Enhanced")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Pick ODBC DSN or custom connection string:")
        main_layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except:
            pass
        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC string")
        main_layout.addWidget(self.conn_str_edit)

        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string chosen.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

def fetch_all_dict(cursor):
    rows = cursor.fetchall()
    if cursor.description:
        cols = [d[0] for d in cursor.description]
        return [dict(zip(cols,r)) for r in rows]
    return rows

def fetch_one_dict(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [d[0] for d in cursor.description]
        return dict(zip(cols,row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    try:
        c = conn.cursor()
        c.execute("""
        INSERT INTO BRM_AUDIT_LOG(
          ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
          OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        )
        VALUES(?,?,?,?,?,GETDATE())
        """,(
            action,
            table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
    except:
        logger.exception("Failed to insert audit log")

class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login (Enhanced)")
        self.resize(300, 150)

        layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)
        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self,"Error","Enter user/pass.")
            return
        c = self.connection.cursor()
        c.execute("""
          SELECT USER_ID,USER_GROUP
          FROM USERS
          WHERE USERNAME=? AND PASSWORD=?
        """,(un,pw))
        row = fetch_one_dict(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")

def detect_operation_type(sql_text: str)->str:
    if not sql_text or not sql_text.strip():
        return "OTHER"
    txt = sql_text.strip().upper()
    if "##DECISION##" in txt:
        return "DECISION_TABLE"
    if txt.startswith("INSERT"):
        return "INSERT"
    if txt.startswith("UPDATE"):
        return "UPDATE"
    if txt.startswith("DELETE"):
        return "DELETE"
    if txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def parse_sql_dependencies(sql_text: str)->dict:
    out = {"tables":[],"columns":[],"alias_map":{}}
    try:
        stmts = sqlparse.parse(sql_text)
        for stmt in stmts:
            from_seen=False
            for token in stmt.tokens:
                val = (token.value.upper() if token.value else "")
                if token.ttype is Keyword and val in ("FROM","JOIN","LEFT JOIN","RIGHT JOIN","INNER JOIN","FULL JOIN"):
                    from_seen=True
                    continue
                if from_seen:
                    if isinstance(token,IdentifierList):
                        for i_ in token.get_identifiers():
                            out["tables"].append((None, i_.get_real_name()))
                    elif isinstance(token,Identifier):
                        out["tables"].append((None, token.get_real_name()))
                    from_seen=False
    except:
        pass
    return out

RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "IN_APPROVAL_ESCALATION",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]

class OnboardingWizard(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Welcome Wizard - Advanced")
        self.resize(400,200)
        self.layout_ = QVBoxLayout(self)
        self.steps_label = QLabel("Wizard for new users - advanced features.")
        self.layout_.addWidget(self.steps_label)
        self.current_step=0
        self.btn = QPushButton("Next")
        self.btn.clicked.connect(self.advance_step)
        self.layout_.addWidget(self.btn)

    def advance_step(self):
        self.current_step+=1
        if self.current_step==1:
            self.steps_label.setText("1) Manage Groups + Tags + Decision Tables + Composite.")
        elif self.current_step==2:
            self.steps_label.setText("2) Check Conflicts, schedule BFS, run validations.")
        elif self.current_step==3:
            self.steps_label.setText("3) Explore advanced lineage + table/column business names.")
        else:
            self.accept()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 2 (FINAL):
 - BFS execution with conflicts, composites, GCR, decision tables, data validations, tags
 - Lock/unlock + force unlock
 - Multi-step approvals creation
 - Table-level permission checks
 - Advanced CRUD (add/update/deactivate/delete) with line diffs
 - rule_backup / rule_restore
 - BRM_COLUMN_MAPPING auto-handled in add/update
"""

import json
import logging
import difflib
import re
import time
from datetime import datetime
from collections import deque

def lock_rule(conn, rule_id, user_name):
    c=conn.cursor()
    c.execute("SELECT RULE_LOCKED,RULE_LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        raise ValueError(f"Rule {rule_id} not found.")
    locked, locked_by=row
    if locked:
        raise ValueError(f"Rule {rule_id} is already locked by {locked_by}.")
    c.execute("""
      UPDATE BRM_RULES
      SET RULE_LOCKED=1,RULE_LOCKED_BY=?,RULE_LOCKED_TIMESTAMP=GETDATE()
      WHERE RULE_ID=?
    """,(user_name, rule_id))
    conn.commit()
    insert_audit_log(conn,"LOCK","BRM_RULES",rule_id,user_name,{"locked":False},{"locked":True})

def unlock_rule(conn, rule_id, user_name):
    c=conn.cursor()
    c.execute("SELECT RULE_LOCKED,RULE_LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        raise ValueError(f"Rule {rule_id} not found.")
    locked, locked_by=row
    if not locked:
        raise ValueError(f"Rule {rule_id} is not locked.")
    if locked_by!=user_name:
        raise ValueError(f"Rule {rule_id} locked by {locked_by}, not {user_name}.")
    c.execute("""
      UPDATE BRM_RULES
      SET RULE_LOCKED=0,RULE_LOCKED_BY=NULL,RULE_LOCKED_TIMESTAMP=NULL
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
    insert_audit_log(conn,"UNLOCK","BRM_RULES",rule_id,user_name,{"locked":True},{"locked":False})

def force_unlock_rule(conn, rule_id, admin_user):
    c=conn.cursor()
    c.execute("SELECT RULE_LOCKED FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        raise ValueError(f"Rule {rule_id} not found.")
    locked=row[0]
    if not locked:
        raise ValueError(f"Rule {rule_id} is not locked.")
    c.execute("""
      UPDATE BRM_RULES
      SET RULE_LOCKED=0,RULE_LOCKED_BY=NULL,RULE_LOCKED_TIMESTAMP=NULL
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
    insert_audit_log(conn,"FORCE_UNLOCK","BRM_RULES",rule_id,admin_user,{"locked":True},{"locked":False})

def check_table_permissions(conn, user_group, table_list):
    c=conn.cursor()
    denied=[]
    for (dbn,tbl) in table_list:
        if not tbl:
            continue
        if tbl.lower().startswith("(cte)"):
            continue
        c.execute("""
          SELECT 1 FROM GROUP_PERMISSIONS
          WHERE GROUP_NAME=? AND TARGET_TABLE=?
        """,(user_group,tbl))
        if not c.fetchone():
            denied.append(tbl)
    if denied:
        raise ValueError(f"User group {user_group} missing permission for {denied}")

def run_data_validations(conn, rule_info):
    c=conn.cursor()
    rid=rule_info["RULE_ID"]
    c.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    deps=c.fetchall()
    for row in deps:
        tbl=row[0]
        c2=conn.cursor()
        c2.execute("""
          SELECT VALIDATION_ID,COLUMN_NAME,VALIDATION_TYPE,PARAMS
          FROM DATA_VALIDATIONS
          WHERE TABLE_NAME=?
        """,(tbl,))
        for (vid,col,vtyp,pars) in c2.fetchall():
            if vtyp.upper()=="NOT NULL":
                sql_=f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c3=conn.cursor()
                c3.execute(sql_)
                cnt=c3.fetchone()[0]
                if cnt>0:
                    return (False,f"Validation fail: {tbl}.{col} => {cnt} nulls")
            elif vtyp.upper()=="RANGE":
                rmin=0
                rmax=999999
                if pars:
                    for piece in pars.split(";"):
                        if "=" in piece:
                            k,v=piece.split("=")
                            if k.lower().strip()=="min":
                                rmin=float(v)
                            elif k.lower().strip()=="max":
                                rmax=float(v)
                sql2=f"SELECT COUNT(*) FROM {tbl} WHERE {col}<{rmin} OR {col}>{rmax}"
                c4=conn.cursor()
                c4.execute(sql2)
                cc=c4.fetchone()[0]
                if cc>0:
                    return (False,f"Validation fail: {tbl}.{col} => {cc} out of range.")
    return (True,"All validations pass")

def run_tags_if_needed(conn, rule_id):
    return (True,"Tags pass")

def run_decision_table_if_needed(conn, rule_info):
    return (True,"Decision table => pass stub")

def create_multistep_approvals(conn, rule_id):
    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    st=1
    c2=conn.cursor()
    c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME='BG1'")
    for row in c2.fetchall():
        c.execute("""
          INSERT INTO BRM_RULE_APPROVALS(
            RULE_ID,GROUP_NAME,USERNAME,
            APPROVED_FLAG,APPROVAL_STAGE
          )
          VALUES(?,?,?,?,?)
        """,(rule_id,"BG1",row[0],0,st))
    st+=1
    c3=conn.cursor()
    c3.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME='BG2'")
    for row in c3.fetchall():
        c.execute("""
          INSERT INTO BRM_RULE_APPROVALS(
            RULE_ID,GROUP_NAME,USERNAME,
            APPROVED_FLAG,APPROVAL_STAGE
          )
          VALUES(?,?,?,?,?)
        """,(rule_id,"BG2",row[0],0,st))
    st+=1
    c.execute("""
      INSERT INTO BRM_RULE_APPROVALS(
        RULE_ID,GROUP_NAME,USERNAME,
        APPROVED_FLAG,APPROVAL_STAGE
      )
      VALUES(?,?,?,?,?)
    """,(rule_id,"FINAL","final_approver",0,st))
    conn.commit()

def add_rule(conn, rule_data, created_by, user_group):
    c=conn.cursor()
    sql_=rule_data.get("RULE_SQL","").strip()
    op_type=detect_operation_type(sql_)
    deps=parse_sql_dependencies(sql_)
    check_table_permissions(conn, user_group, deps["tables"])
    c.execute("""
      INSERT INTO BRM_RULES(
        GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
        EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,CREATED_BY,
        DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,CREATED_TIMESTAMP,
        OWNER_GROUP,APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,
        CDC_TYPE,LIFECYCLE_STATE,RULE_LOCKED,RULE_LOCKED_BY,RULE_LOCKED_TIMESTAMP
      )
      OUTPUT inserted.RULE_ID
      VALUES(?,?,?,?,?,
             ?,?,'INACTIVE',1,?,
             ?,?,?,GETDATE(),
             ?,'APPROVAL_IN_PROGRESS',?,?,?,
             ?,'DRAFT',0,NULL,NULL)
    """,(
       rule_data.get("GROUP_ID"),
       rule_data.get("PARENT_RULE_ID"),
       rule_data["RULE_TYPE_ID"],
       rule_data["RULE_NAME"].strip(),
       sql_,
       rule_data.get("EFFECTIVE_START_DATE"),
       rule_data.get("EFFECTIVE_END_DATE"),
       created_by,
       rule_data.get("DESCRIPTION",""),
       op_type,
       rule_data.get("BUSINESS_JUSTIFICATION",""),
       rule_data.get("OWNER_GROUP","BG1"),
       rule_data.get("IS_GLOBAL",0),
       rule_data.get("CRITICAL_RULE",0),
       rule_data.get("CRITICAL_SCOPE","NONE"),
       rule_data.get("CDC_TYPE","NONE")
    ))
    new_id=c.fetchone()[0]
    col_op="READ"
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    c2=conn.cursor()
    for (dbn,tbl) in deps["tables"]:
        if tbl and not tbl.lower().startswith("(cte)"):
            c2.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
              )
              VALUES(?,?,?,?,?)
            """,(new_id,dbn,tbl,"AutoCol",col_op))
    # handle column mapping if specified
    if "SOURCE_RULE_ID" in rule_data:
        s_rid=rule_data["SOURCE_RULE_ID"]
        c2.execute("""
          INSERT INTO BRM_COLUMN_MAPPING(SOURCE_RULE_ID,RULE_ID,COMMENTS)
          VALUES(?,?,?)
        """,(s_rid,new_id,"auto from add_rule"))
    if "SOURCE_RULES" in rule_data and isinstance(rule_data["SOURCE_RULES"],(list,tuple)):
        for sr_ in rule_data["SOURCE_RULES"]:
            c2.execute("""
              INSERT INTO BRM_COLUMN_MAPPING(SOURCE_RULE_ID,RULE_ID,COMMENTS)
              VALUES(?,?,?)
            """,(sr_, new_id, "auto from add_rule multi"))
    conn.commit()
    insert_audit_log(conn,"INSERT","BRM_RULES",new_id,created_by,None,rule_data)
    create_multistep_approvals(conn,new_id)
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    rid=rule_data["RULE_ID"]
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    colnames=[desc[0] for desc in c.description]
    old_data=dict(zip(colnames,old))
    if not old_data["RULE_LOCKED"] or old_data["RULE_LOCKED_BY"]!=updated_by:
        raise ValueError("Must lock rule first or mismatch lock owner.")
    new_sql=rule_data.get("RULE_SQL","").strip()
    op_type=detect_operation_type(new_sql)
    deps=parse_sql_dependencies(new_sql)
    check_table_permissions(conn, user_group, deps["tables"])
    c.execute("""
      UPDATE BRM_RULES
      SET GROUP_ID=?,
          PARENT_RULE_ID=?,
          RULE_TYPE_ID=?,
          RULE_NAME=?,
          RULE_SQL=?,
          EFFECTIVE_START_DATE=?,
          EFFECTIVE_END_DATE=?,
          STATUS='INACTIVE',
          VERSION=VERSION+1,
          UPDATED_BY=?,
          DESCRIPTION=?,
          OPERATION_TYPE=?,
          BUSINESS_JUSTIFICATION=?,
          OWNER_GROUP=?,
          APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
          IS_GLOBAL=?,
          CRITICAL_RULE=?,
          CRITICAL_SCOPE=?,
          CDC_TYPE=?,
          LIFECYCLE_STATE='UNDER_APPROVAL'
      WHERE RULE_ID=?
    """,(
       rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
       rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
       rule_data["RULE_TYPE_ID"],
       rule_data["RULE_NAME"].strip(),
       new_sql,
       rule_data.get("EFFECTIVE_START_DATE"),
       rule_data.get("EFFECTIVE_END_DATE"),
       updated_by,
       rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
       op_type,
       rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
       rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
       rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
       rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
       rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
       rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
       rid
    ))
    c2=conn.cursor()
    c2.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    col_op="READ"
    if op_type in ("INSERT","UPDATE","DELETE"):
        col_op="WRITE"
    for (dbn,tbl) in deps["tables"]:
        if tbl and not tbl.lower().startswith("(cte)"):
            c2.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
              )
              VALUES(?,?,?,?,?)
            """,(rid,dbn,tbl,"UpdatedCol",col_op))

    # handle column mapping
    c2.execute("DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
    if "SOURCE_RULE_ID" in rule_data:
        s_rid=rule_data["SOURCE_RULE_ID"]
        c2.execute("""
          INSERT INTO BRM_COLUMN_MAPPING(SOURCE_RULE_ID,RULE_ID,COMMENTS)
          VALUES(?,?,?)
        """,(s_rid,rid,"auto from update_rule single"))
    if "SOURCE_RULES" in rule_data and isinstance(rule_data["SOURCE_RULES"],(list,tuple)):
        for sr_ in rule_data["SOURCE_RULES"]:
            c2.execute("""
              INSERT INTO BRM_COLUMN_MAPPING(SOURCE_RULE_ID,RULE_ID,COMMENTS)
              VALUES(?,?,?)
            """,(sr_,rid,"auto from update_rule multi"))

    conn.commit()
    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["RULE_SQL"]=new_sql
    new_data["VERSION"]=old_data["VERSION"]+1
    if new_sql!=old_data["RULE_SQL"]:
        old_lines=(old_data["RULE_SQL"] or "").splitlines()
        new_lines=(new_sql or "").splitlines()
        diff="\n".join(difflib.unified_diff(old_lines,new_lines,fromfile="old",tofile="new",linenos=True))
        new_data["_sql_diff_"]=diff
    insert_audit_log(conn,"UPDATE","BRM_RULES",rid,updated_by,old_data,new_data)
    create_multistep_approvals(conn,rid)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    colnames=[desc[0] for desc in c.description]
    old_data=dict(zip(colnames,old))
    if not old_data["RULE_LOCKED"] or old_data["RULE_LOCKED_BY"]!=updated_by:
        raise ValueError("Must lock rule or mismatch user to deactivate.")
    c.execute("""
      UPDATE BRM_RULES
      SET STATUS='INACTIVE',VERSION=VERSION+1,LIFECYCLE_STATE='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["LIFECYCLE_STATE"]="INACTIVE"
    insert_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)

def delete_rule(conn, rule_id, action_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    colnames=[desc[0] for desc in c.description]
    old_data=dict(zip(colnames,old))
    if not old_data["RULE_LOCKED"] or old_data["RULE_LOCKED_BY"]!=action_by:
        raise ValueError("Must lock rule or mismatch user to delete.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")
    # also remove from brm_column_mapping
    c.execute("DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID=? OR SOURCE_RULE_ID=?",(rule_id,rule_id))
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    conn.commit()
    insert_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)

def rule_backup(conn, rule_id, backup_by):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row:
        raise ValueError("Rule not found.")
    cols=[desc[0] for desc in c.description]
    data=dict(zip(cols,row))
    snap=json.dumps(data,indent=2)
    c.execute("""
      INSERT INTO RULE_BACKUPS(
        RULE_ID,BACKUP_TIMESTAMP,BACKUP_JSON,CREATED_BY
      )
      OUTPUT inserted.BACKUP_ID
      VALUES(?,GETDATE(),?,?)
    """,(rule_id,snap,backup_by))
    bkid=c.fetchone()[0]
    conn.commit()
    insert_audit_log(conn,"BACKUP_RULE","RULE_BACKUPS",rule_id,backup_by,None,{"backup_id":bkid})
    return bkid

def rule_restore(conn, rule_id, backup_id, restore_by):
    c=conn.cursor()
    c.execute("SELECT BACKUP_JSON FROM RULE_BACKUPS WHERE BACKUP_ID=? AND RULE_ID=?",(backup_id,rule_id))
    row=c.fetchone()
    if not row:
        raise ValueError("Backup not found or mismatch rule.")
    backup_json=row[0]
    snap=json.loads(backup_json)
    c.execute("BEGIN TRAN")
    try:
        c.execute("""
          UPDATE BRM_RULES
          SET RULE_NAME=?,
              RULE_SQL=?,
              OWNER_GROUP=?,
              STATUS='INACTIVE',
              VERSION=VERSION+1,
              APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
              LIFECYCLE_STATE='UNDER_APPROVAL',
              UPDATED_BY=?
          WHERE RULE_ID=?
        """,(
          snap["RULE_NAME"],
          snap["RULE_SQL"],
          snap["OWNER_GROUP"],
          restore_by,
          rule_id
        ))
        c2=conn.cursor()
        c2.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rule_id,))
        deps=parse_sql_dependencies(snap.get("RULE_SQL","") or "")
        op=detect_operation_type(snap.get("RULE_SQL","") or "")
        col_op="READ"
        if op in ("INSERT","UPDATE","DELETE"):
            col_op="WRITE"
        for (dbn,tbl) in deps["tables"]:
            if tbl:
                c2.execute("""
                  INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                    RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                  )
                  VALUES(?,?,?,?,?)
                """,(rule_id,dbn,tbl,"RestoredCol",col_op))
        # We skip restoring BRM_COLUMN_MAPPING here unless you want to store them in backups
        c.execute("COMMIT")
    except Exception as ex:
        c.execute("ROLLBACK")
        raise ex
    insert_audit_log(conn,"RESTORE_RULE","RULE_BACKUPS",rule_id,restore_by,{"backup_id":backup_id},snap)

def evaluate_composite_rule(expr_str, pass_dict):
    pat=re.compile(r"Rule(\d+)\s*==\s*PASS",re.IGNORECASE)
    def replacer(m):
        rid=int(m.group(1))
        return str(pass_dict.get(rid,False))
    replaced=pat.sub(replacer, expr_str)
    replaced=replaced.replace("AND"," and ").replace("OR"," or ").replace("NOT"," not ")
    try:
        val=eval(replaced)
        return bool(val)
    except:
        return False

def advanced_bfs_execute(conn):
    adjacency={}
    in_degree={}
    all_ids=set()

    c=conn.cursor()
    # parent->child
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    for (rid,pid) in c.fetchall():
        all_ids.add(rid)
        in_degree.setdefault(rid,0)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            in_degree[rid]+=1
    # GCR
    c2=conn.cursor()
    c2.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    for row in c2.fetchall():
        adjacency.setdefault(row[0],set()).add(row[1])
        all_ids.add(row[0])
        all_ids.add(row[1])
        in_degree.setdefault(row[0],0)
        in_degree.setdefault(row[1],0)
        in_degree[row[1]]+=1
    # conflicts
    c3=conn.cursor()
    c3.execute("SELECT RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    for (r1,r2,pri) in c3.fetchall():
        adjacency.setdefault(r1,set()).add(r2)
        adjacency.setdefault(r2,set()).add(r1)
        all_ids.add(r1)
        all_ids.add(r2)
        in_degree.setdefault(r1,0)
        in_degree.setdefault(r2,0)
        in_degree[r1]+=1
        in_degree[r2]+=1
    # composites
    c4=conn.cursor()
    c4.execute("SELECT COMPOSITE_RULE_ID,LOGIC_EXPR FROM COMPOSITE_RULES")
    pat=re.compile(r"Rule(\d+)")
    for (crid,expr) in c4.fetchall():
        all_ids.add(crid)
        in_degree.setdefault(crid,0)
        if expr:
            matches=pat.findall(expr)
            for m_ in matches:
                sid=int(m_)
                adjacency.setdefault(sid,set()).add(crid)
                in_degree[crid]+=1
    # column mapping => rule->rule
    c5=conn.cursor()
    c5.execute("SELECT SOURCE_RULE_ID,RULE_ID FROM BRM_COLUMN_MAPPING")
    for (s_rid,t_rid) in c5.fetchall():
        all_ids.add(s_rid)
        all_ids.add(t_rid)
        in_degree.setdefault(s_rid,0)
        in_degree.setdefault(t_rid,0)
        adjacency.setdefault(s_rid,set()).add(t_rid)
        in_degree[t_rid]+=1

    # gather rule info
    rule_info_map={}
    c6=conn.cursor()
    c6.execute("SELECT * FROM BRM_RULES")
    rows=c6.fetchall()
    cols=[desc[0] for desc in c6.description]
    for r_ in rows:
        d=dict(zip(cols,r_))
        rule_info_map[d["RULE_ID"]]=d

    pass_dict={}
    execution_order=[]
    skipped=set()
    from collections import deque
    queue=deque([x for x in all_ids if in_degree[x]==0])

    while queue:
        rid=queue.popleft()
        execution_order.append(rid)
        if rid in rule_info_map:
            # data validations
            okv,msgv=run_data_validations(conn, rule_info_map[rid])
            if not okv:
                pass_dict[rid]=False
                _skip_children(conn, adjacency, rid, skipped, pass_dict)
                _exec_log(conn, rid, False, f"[ValidationFail]{msgv}",0,0)
                continue
            # tags
            okt,msgt=run_tags_if_needed(conn, rid)
            if not okt:
                pass_dict[rid]=False
                _skip_children(conn, adjacency, rid, skipped, pass_dict)
                _exec_log(conn, rid, False, f"[TagFail]{msgt}",0,0)
                continue
            # decision table?
            op=rule_info_map[rid]["OPERATION_TYPE"]
            if op=="DECISION_TABLE":
                okd,msgd=run_decision_table_if_needed(conn, rule_info_map[rid])
                pass_dict[rid]=okd
                _exec_log(conn, rid, okd, msgd,0,0)
                if not okd:
                    _skip_children(conn, adjacency, rid, skipped, pass_dict)
                    continue
            else:
                (oksql,msgsql,rc,dur)=_exec_sql_rule(conn, rule_info_map[rid])
                pass_dict[rid]=oksql
                _exec_log(conn, rid, oksql, msgsql, rc, dur)
                if not oksql:
                    _skip_children(conn, adjacency, rid, skipped, pass_dict)
                    continue
        else:
            # composite
            cinfo=conn.cursor()
            cinfo.execute("SELECT CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(rid,))
            row=cinfo.fetchone()
            if not row:
                pass_dict[rid]=False
                continue
            name,expr,act=row
            c_ok=evaluate_composite_rule(expr, pass_dict)
            pass_dict[rid]=c_ok
            msg=f"Composite {name} => {c_ok}"
            _exec_log(conn, rid, c_ok, msg,0,0)
            if not c_ok:
                _skip_children(conn, adjacency, rid, skipped, pass_dict)
                continue

        if rid in adjacency:
            for nxt in adjacency[rid]:
                if nxt not in skipped:
                    in_degree[nxt]-=1
                    if in_degree[nxt]==0:
                        queue.append(nxt)
    return (execution_order, pass_dict, skipped)

def _skip_children(conn, adjacency, rid, skipped, pass_dict):
    st=list(adjacency.get(rid,[]))
    while st:
        ch=st.pop()
        if ch not in skipped:
            skipped.add(ch)
            pass_dict[ch]=False
            if ch in adjacency:
                st.extend(adjacency[ch])

def _exec_sql_rule(conn, rule_info):
    start=time.time()
    c=conn.cursor()
    c.execute("BEGIN TRAN")
    pass_flag=False
    message=""
    rec_count=0
    try:
        sql_=rule_info.get("RULE_SQL","").strip()
        if sql_:
            c.execute(sql_)
            rows=c.fetchall()
            if rows:
                rec_count=len(rows)
                val=rows[0][0]
                pass_flag=(val==1)
                message=f"Returned: {val}"
            else:
                pass_flag=True
                message="No rows => pass"
        else:
            pass_flag=True
            message="Empty => pass"
        if pass_flag:
            c.execute("COMMIT")
        else:
            c.execute("ROLLBACK")
    except Exception as ex:
        c.execute("ROLLBACK")
        pass_flag=False
        message=str(ex)
    end=time.time()
    dur=(end-start)*1000
    return (pass_flag, message, rec_count, dur)

def _exec_log(conn, rid, pass_flag, message, rec_count, dur):
    c=conn.cursor()
    c.execute("""
      INSERT INTO RULE_EXECUTION_LOGS(
        RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
        MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS
      )
      VALUES(?,GETDATE(),?,?,?,?)
    """,(rid,1 if pass_flag else 0,message,rec_count,dur))
    conn.commit()

def set_rule_approved(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='APPROVED',STATUS='ACTIVE',LIFECYCLE_STATE='ACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_in_progress(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS',STATUS='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_rejected(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='REJECTED',STATUS='INACTIVE',LIFECYCLE_STATE='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_approval_escalation(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='ESCALATION',LIFECYCLE_STATE='IN_APPROVAL_ESCALATION'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 3 (FINAL):
 - dry_run_advanced_bfs for single/chain/group simulations
 - Scheduling (dialog + management tab)
 - sync_metadata_improved capturing data types
 - DataValidationTab
 - WhatIfTestTab
 - BusinessNamingTab
"""

import sys
import os
import json
import csv
import logging
import time
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QPushButton, QPlainTextEdit, QLineEdit, QComboBox,
    QCalendarWidget, QTableWidget, QTableWidgetItem, QListWidget,
    QListWidgetItem, QMessageBox, QInputDialog, QFileDialog, QSplitter, QTextEdit
)
from PyQt5.QtCore import Qt, QDate
import pyqtgraph as pg

def dry_run_advanced_bfs(conn, start_rule_ids=None):
    """
    Non-destructive BFS => always ROLLBACK changes. 
    We'll do a simplified adjacency gather, run validations, skip if fail, etc.
    """
    # build adjacency
    adjacency={}
    in_degree={}
    all_ids=set()
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    for (rid,pid) in c.fetchall():
        all_ids.add(rid)
        in_degree.setdefault(rid,0)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            in_degree[rid]+=1
    # GCR
    c2=conn.cursor()
    c2.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    for (gcr,tgt) in c2.fetchall():
        adjacency.setdefault(gcr,set()).add(tgt)
        all_ids.add(gcr)
        all_ids.add(tgt)
        in_degree.setdefault(gcr,0)
        in_degree.setdefault(tgt,0)
        in_degree[tgt]+=1
    # conflicts => symmetrical
    c3=conn.cursor()
    c3.execute("SELECT RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    for (r1,r2,pri) in c3.fetchall():
        adjacency.setdefault(r1,set()).add(r2)
        adjacency.setdefault(r2,set()).add(r1)
        all_ids.add(r1)
        all_ids.add(r2)
        in_degree.setdefault(r1,0)
        in_degree.setdefault(r2,0)
        in_degree[r1]+=1
        in_degree[r2]+=1
    # composites => skip second pass, do naive
    c4=conn.cursor()
    c4.execute("SELECT COMPOSITE_RULE_ID,LOGIC_EXPR FROM COMPOSITE_RULES")
    comp=c4.fetchall()
    pat=re.compile(r"Rule(\d+)")
    for (crid,expr) in comp:
        all_ids.add(crid)
        in_degree.setdefault(crid,0)
        if expr:
            matches=pat.findall(expr)
            for m_ in matches:
                sid=int(m_)
                adjacency.setdefault(sid,set()).add(crid)
                in_degree[crid]+=1
    # column mapping => rule->rule
    c5=conn.cursor()
    c5.execute("SELECT SOURCE_RULE_ID,RULE_ID FROM BRM_COLUMN_MAPPING")
    for (s_rid,t_rid) in c5.fetchall():
        all_ids.add(s_rid)
        all_ids.add(t_rid)
        in_degree.setdefault(s_rid,0)
        in_degree.setdefault(t_rid,0)
        adjacency.setdefault(s_rid,set()).add(t_rid)
        in_degree[t_rid]+=1

    # gather rule info
    rule_info_map={}
    c6=conn.cursor()
    c6.execute("SELECT * FROM BRM_RULES")
    rr=c6.fetchall()
    cols=[desc[0] for desc in c6.description]
    for row in rr:
        d=dict(zip(cols,row))
        rule_info_map[d["RULE_ID"]]=d

    if not start_rule_ids:
        queue=deque([x for x in all_ids if in_degree[x]==0])
    else:
        queue=deque(start_rule_ids)

    executed=[]
    skipped=set()
    while queue:
        rid=queue.popleft()
        if rid in skipped:
            continue
        if rid not in rule_info_map:
            # possibly composite => pretend pass
            executed.append(rid)
            if rid in adjacency:
                for nxt in adjacency[rid]:
                    if nxt not in skipped:
                        queue.append(nxt)
            continue
        # validations => skip
        # minimal approach
        c=conn.cursor()
        c.execute("BEGIN TRAN")
        pass_flag=True
        try:
            sql_=rule_info_map[rid].get("RULE_SQL","").strip()
            if sql_:
                c.execute(sql_)
                rows=c.fetchall()
                if rows:
                    val=rows[0][0]
                    pass_flag=(val==1)
            c.execute("ROLLBACK")
        except:
            pass_flag=False
            c.execute("ROLLBACK")
        if pass_flag:
            executed.append(rid)
            if rid in adjacency:
                for nxt in adjacency[rid]:
                    if nxt not in skipped:
                        queue.append(nxt)
        else:
            skipped.add(rid)
    return (executed, skipped)

def sync_metadata_improved(conn):
    c=conn.cursor()
    c.execute("""
      SELECT TABLE_SCHEMA,TABLE_NAME,COLUMN_NAME,DATA_TYPE,CHARACTER_MAXIMUM_LENGTH
      FROM INFORMATION_SCHEMA.COLUMNS
    """)
    valid_map={}
    table_set=set()
    for row in c.fetchall():
        sch,tn,cn,dt,ln=row
        key=(sch.lower(),tn.lower(),cn.lower())
        dtype=dt.upper()
        if dt.upper() in ("CHAR","VARCHAR","NVARCHAR") and ln is not None:
            dtype=f"{dt.upper()}({ln})"
        valid_map[key]=dtype
        table_set.add((sch.lower(),tn.lower()))
    c.execute("SELECT DEPENDENCY_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    rows=c.fetchall()
    updated_count=0
    missing_count=0
    for (dep_id,dbn,tn,cn) in rows:
        if not tn: 
            continue
        sch=(dbn.lower() if dbn else "dbo")
        t_low=tn.lower()
        c_low=(cn.lower() if cn else "")
        if (sch,t_low) not in table_set:
            if not t_low.startswith("missing_"):
                c2=conn.cursor()
                c2.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET TABLE_NAME='MISSING_'+TABLE_NAME WHERE DEPENDENCY_ID=?",(dep_id,))
                missing_count+=1
        else:
            key=(sch,t_low,c_low)
            dtp=valid_map.get(key)
            if dtp:
                c2=conn.cursor()
                c2.execute("""
                  UPDATE BRM_RULE_TABLE_DEPENDENCIES
                  SET COLUMN_DATA_TYPE=?
                  WHERE DEPENDENCY_ID=?
                """,(dtp,dep_id))
                updated_count+=1
    conn.commit()
    QMessageBox.information(None,"Metadata Sync",f"Captured data types: {updated_count}, Marked missing: {missing_count}")

class SingleRuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Simulate Single Rule {rule_id}")
        self.resize(500,300)
        layout=QVBoxLayout(self)
        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)
        bh=QHBoxLayout()
        run_btn=QPushButton("Dry-Run BFS")
        run_btn.clicked.connect(self.do_run)
        bh.addWidget(run_btn)
        cl_btn=QPushButton("Close")
        cl_btn.clicked.connect(self.close)
        bh.addWidget(cl_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_run(self):
        ex,sk = dry_run_advanced_bfs(self.connection,[self.rule_id])
        txt=f"Executed => {ex}\nSkipped => {sk}"
        self.output.setPlainText(txt)

class ChainOrGroupSimulationDialog(QDialog):
    def __init__(self, connection, is_group=False, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.is_group=is_group
        title="Group BFS Dry-Run" if is_group else "Chain BFS Dry-Run"
        self.setWindowTitle(title)
        self.resize(600,400)
        layout=QVBoxLayout(self)

        self.combo=QComboBox()
        c=connection.cursor()
        if is_group:
            c.execute("SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            for (gid,gname) in c.fetchall():
                disp=f"{gid} - {gname}"
                self.combo.addItem(disp,gid)
        else:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for (rid,rn) in c.fetchall():
                disp=f"{rid} - {rn}"
                self.combo.addItem(disp,rid)
        layout.addWidget(self.combo)

        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        bh=QHBoxLayout()
        sim_btn=QPushButton("Simulate BFS")
        sim_btn.clicked.connect(self.do_sim)
        bh.addWidget(sim_btn)
        cl_btn=QPushButton("Close")
        cl_btn.clicked.connect(self.close)
        bh.addWidget(cl_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_sim(self):
        val=self.combo.currentData()
        if self.is_group:
            c=self.connection.cursor()
            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(val,))
            rids=[r[0] for r in c.fetchall()]
            ex,sk=dry_run_advanced_bfs(self.connection,rids)
            txt=f"Group {val}: executed={ex}, skipped={sk}"
        else:
            ex,sk=dry_run_advanced_bfs(self.connection,[val])
            txt=f"Chain start {val}: executed={ex}, skipped={sk}"
        self.output.setPlainText(txt)

class EnhancedScheduleDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("New Schedule")
        self.resize(400,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)
        form.addRow("Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        form.addRow("Date:", self.calendar)

        self.time_edit=QLineEdit()
        self.time_edit.setPlaceholderText("HH:MM:SS (e.g. 13:45:00)")
        form.addRow("Time:", self.time_edit)

        layout.addLayout(form)
        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        dt_=self.calendar.selectedDate()
        t_=self.time_edit.text().strip()
        if not t_:
            QMessageBox.warning(self,"Missing","Time is required.")
            return
        full_dt=f"{dt_.toString('yyyy-MM-dd')} {t_}"
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO RULE_SCHEDULES(
            RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP
          )
          VALUES(?,?,?,GETDATE())
        """,(rid,full_dt,"Scheduled"))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} => {full_dt}")
        self.close()

class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["SchedID","RuleID","ScheduleTime","Status","Actions"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn=QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(4):
                it=QTableWidgetItem(str(row[col_i]))
                self.table.setItem(r_i,col_i,it)
            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)
            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _,r=r_i: self.update_schedule(r))
            ah.addWidget(upd_btn)
            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _,r=r_i: self.delete_schedule(r))
            ah.addWidget(del_btn)
            ah.addStretch()
            self.table.setCellWidget(r_i,4,act_w)

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_i):
        it=self.table.item(row_i,0)
        if not it:
            return
        sid=int(it.text())
        new_dt,ok=QInputDialog.getText(self,"Update","Enter new datetime (YYYY-MM-DD HH:MM:SS):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sid))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sid} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, row_i):
        it=self.table.item(row_i,0)
        if not it:
            return
        sid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sid} removed.")
        self.load_schedules()

class DataValidationTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["ValID","TableName","ColumnName","ValType","Params"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Validation")
        addb.clicked.connect(self.add_val)
        bh.addWidget(addb)
        remv=QPushButton("Remove Validation")
        remv.clicked.connect(self.remove_val)
        bh.addWidget(remv)
        runb=QPushButton("Run Validations Now")
        runb.clicked.connect(self.run_validations_now)
        bh.addWidget(runb)
        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_vals)
        bh.addWidget(refb)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
          FROM DATA_VALIDATIONS
          ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table (e.g. 'dbo.MyTable'):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtyp,ok3=QInputDialog.getText(self,"ValType","(NOT NULL / RANGE / etc.):")
        if not ok3 or not vtyp.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(optional, e.g. min=0;max=100):")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO DATA_VALIDATIONS(
            TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
          )
          VALUES(?,?,?,?)
        """,(tbl.strip(),col.strip(),vtyp.strip(),pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Validation created.")
        self.load_vals()

    def remove_val(self):
        row=self.table.currentRow()
        if row<0:
            return
        it=self.table.item(row,0)
        if not it:
            return
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

    def run_validations_now(self):
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_SQL FROM BRM_RULES")
        rows=c.fetchall()
        pass_cnt=0
        fail_cnt=0
        for row in rows:
            rid=row[0]
            rsql=row[1]
            rule_info={"RULE_ID":rid,"RULE_SQL":(rsql or "")}
            ok,msg=run_data_validations(self.connection,rule_info)
            pass_flag=1 if ok else 0
            if ok:
                pass_cnt+=1
            else:
                fail_cnt+=1
            c2=self.connection.cursor()
            c2.execute("""
              INSERT INTO RULE_EXECUTION_LOGS(
                RULE_ID,EXECUTION_TIMESTAMP,PASS_FLAG,MESSAGE,RECORD_COUNT,EXECUTION_TIME_MS
              )
              VALUES(?,GETDATE(),?,?,0,0)
            """,(rid,pass_flag,f"[ValidationRun]{msg}"))
        self.connection.commit()
        QMessageBox.information(self,"Run Complete",f"Validations => pass={pass_cnt}, fail={fail_cnt}")

def load_csv_into_staging(filepath):
    data=[]
    try:
        with open(filepath,"r",newline="",encoding="utf-8") as f:
            rdr=csv.reader(f)
            headers=next(rdr,None)
            if not headers:
                return data
            for row in rdr:
                data.append(row)
    except Exception as ex:
        logging.error(f"Error reading CSV => {ex}")
    return data

class WhatIfTestTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)
        top_h.addWidget(QLabel("Rule:"))
        top_h.addWidget(self.rule_combo)

        self.csv_path=None
        up_btn=QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(up_btn)

        run_btn=QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if not path:
            return
        self.csv_path=path
        QMessageBox.information(self,"Uploaded",f"CSV '{path}' selected for staging on test run.")

    def run_test(self):
        rid=self.rule_combo.currentData()
        rows=[]
        if self.csv_path:
            rows=load_csv_into_staging(self.csv_path)
        ex,sk=dry_run_advanced_bfs(self.connection,[rid])
        msg=f"BFS => executed={ex}, skipped={sk}\nCSV rows loaded => {len(rows)}"
        self.result_text.setPlainText(msg)

class BusinessNamingTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dict_table=QTableWidget(0,5)
        self.dict_table.setHorizontalHeaderLabels(["DB","Table","Column","BusinessName","Description"])
        self.dict_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dict_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Business Name")
        addb.clicked.connect(self.add_entry)
        bh.addWidget(addb)
        remvb=QPushButton("Remove Entry")
        remvb.clicked.connect(self.remove_entry)
        bh.addWidget(remvb)
        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_entries)
        bh.addWidget(refb)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_entries()

    def load_entries(self):
        self.dict_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT DB_NAME,TABLE_NAME,COLUMN_NAME,BUSINESS_NAME,DESCRIPTION
          FROM BUSINESS_DICTIONARY
          ORDER BY DB_NAME,TABLE_NAME,COLUMN_NAME
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.dict_table.rowCount()
            self.dict_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.dict_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_entry(self):
        dbn,ok1=QInputDialog.getText(self,"Add","DB name (e.g. 'dbo'):")
        if not ok1 or not dbn.strip():
            return
        tn,ok2=QInputDialog.getText(self,"Table","Table name:")
        if not ok2 or not tn.strip():
            return
        col,ok3=QInputDialog.getText(self,"Column","Column name (or '*' for entire table):")
        if not ok3 or not col.strip():
            return
        bname,ok4=QInputDialog.getText(self,"Business Name","(friendly name):")
        if not ok4:
            bname=""
        desc,ok5=QInputDialog.getText(self,"Description","Optional:")
        if not ok5:
            desc=""
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BUSINESS_DICTIONARY(
            DB_NAME,TABLE_NAME,COLUMN_NAME,BUSINESS_NAME,DESCRIPTION,UPDATED_TIMESTAMP
          )
          VALUES(?,?,?,?,?,GETDATE())
        """,(dbn.strip(),tn.strip(),col.strip(),bname.strip(),desc.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Business name entry created.")
        self.load_entries()

    def remove_entry(self):
        row=self.dict_table.currentRow()
        if row<0:
            return
        db_item=self.dict_table.item(row,0)
        tbl_item=self.dict_table.item(row,1)
        col_item=self.dict_table.item(row,2)
        if not db_item or not tbl_item or not col_item:
            return
        dbn=db_item.text()
        tn=tbl_item.text()
        cn=col_item.text()
        confirm=QMessageBox.question(self,"Confirm",f"Remove entry {dbn}.{tn}.{cn}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
          DELETE FROM BUSINESS_DICTIONARY
          WHERE DB_NAME=? AND TABLE_NAME=? AND COLUMN_NAME=?
        """,(dbn,tn,cn))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"{dbn}.{tn}.{cn} removed.")
        self.load_entries()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 4 (FINAL):
 - AuditLogViewer
 - RuleSearchDialog
 - VersionHistoryDialog (with color-coded diff)
 - RuleDashboard
 - RuleEditorDialog
"""

import sys
import os
import json
import math
import csv
import logging
import difflib
from datetime import datetime
from collections import defaultdict

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox,
    QWidget, QGroupBox, QAbstractItemView
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor, QTextCharFormat, QSyntaxHighlighter, QTextDocument

import pyqtgraph as pg

class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs (Enhanced)")
        self.resize(900,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Filter by action/table/actionBy..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.log_table=QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)
        csv_btn=QPushButton("Export CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            for col_i in range(8):
                val=row[col_i]
                if col_i in (5,6) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                it=QTableWidgetItem(str(val) if val else "")
                self.log_table.setItem(r_i,col_i,it)

    def perform_search(self, txt):
        low=txt.lower()
        for row_i in range(self.log_table.rowCount()):
            show=False
            for col_i in (1,2,4):
                it=self.log_table.item(row_i,col_i)
                if it and low in it.text().lower():
                    show=True
                    break
            self.log_table.setRowHidden(row_i, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            wr=csv.writer(f)
            headers=[self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            wr.writerow(headers)
            for row_i in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(row_i):
                    continue
                row_data=[]
                for col_i in range(self.log_table.columnCount()):
                    it=self.log_table.item(row_i,col_i)
                    row_data.append(it.text() if it else "")
                wr.writerow(row_data)
        QMessageBox.information(self,"Exported",f"Audit logs => {path}")

class RuleSearchDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules (Enhanced)")
        self.resize(850,600)

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter partial name or snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table=QTableWidget(0,9)
        self.res_table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","Locked?","CreatedBy","OpType","Global/Crit?"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,
                     RULE_LOCKED,CREATED_BY,OPERATION_TYPE,(CASE WHEN IS_GLOBAL=1 OR CRITICAL_RULE=1 THEN 1 ELSE 0 END) as GCR
              FROM BRM_RULES
              WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,
                     RULE_LOCKED,CREATED_BY,OPERATION_TYPE,(CASE WHEN IS_GLOBAL=1 OR CRITICAL_RULE=1 THEN 1 ELSE 0 END) as GCR
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_i=self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.res_table.setItem(r_i,col_i,it)

class VersionDiffHighlighter(QSyntaxHighlighter):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.add_format=QTextCharFormat()
        self.add_format.setForeground(QColor("green"))
        self.remove_format=QTextCharFormat()
        self.remove_format.setForeground(QColor("red"))

    def highlightBlock(self, text):
        if text.startswith("+"):
            self.setFormat(0,len(text),self.add_format)
        elif text.startswith("-"):
            self.setFormat(0,len(text),self.remove_format)

class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History - Rule {rule_id}")
        self.resize(900,500)

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        self.compare_btn=QPushButton("Compare Selected")
        self.compare_btn.clicked.connect(self.do_compare)
        bh.addWidget(self.compare_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID,ACTION,ACTION_TIMESTAMP,OLD_DATA,NEW_DATA
          FROM BRM_AUDIT_LOG
          WHERE TABLE_NAME='BRM_RULES'
            AND RECORD_ID=?
            AND ACTION IN ('INSERT','UPDATE')
          ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                if col_i in (3,4) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def do_compare(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected to compare.")
            return
        row_idx=sel[0].row()
        old_data_item=self.table.item(row_idx,3)
        new_data_item=self.table.item(row_idx,4)
        if not old_data_item or not new_data_item:
            QMessageBox.warning(self,"Missing","No old/new data in that row.")
            return
        old_s=old_data_item.text() or ""
        new_s=new_data_item.text() or ""
        old_lines=old_s.splitlines()
        new_lines=new_s.splitlines()
        diff=difflib.unified_diff(old_lines,new_lines,fromfile="old",tofile="new",lineterm='')

        diff_str="\n".join(diff)
        dlg=QDialog(self)
        dlg.setWindowTitle("Line-by-line Diff")
        dlg.resize(800,600)
        l=QVBoxLayout(dlg)

        txt=QPlainTextEdit()
        doc=QTextDocument(txt)
        txt.setDocument(doc)
        highlighter=VersionDiffHighlighter(doc)
        txt.setPlainText(diff_str)
        txt.setReadOnly(True)

        l.addWidget(txt)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        l.addWidget(cb)
        dlg.exec_()

class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard (Enhanced)", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL..")
        self.search_edit.textChanged.connect(self.load_rules)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)

        perf_btn=QPushButton("Show Performance Chart")
        perf_btn.clicked.connect(self.show_performance_chart)
        top_h.addWidget(perf_btn)

        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,11)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","Locked?","LockedBy",
            "ConfPri?","CreatedTS","ApprovalStatus","Actions"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Prev")
        self.prev_btn.clicked.connect(self.prev_page)
        self.page_label=QLabel("Page 1/1")
        self.next_btn=QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        nav_h.addStretch()
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.load_rules()

    def build_filter_clause(self):
        cond=[]
        pars=[]
        txt=self.search_edit.text().strip()
        if txt:
            cond.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            pars.extend([f"%{txt}%",f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            cond.append("STATUS=?")
            pars.append(st)
        if not cond:
            return ("1=1", [])
        return (" AND ".join(cond),pars)

    def load_rules(self):
        c=self.connection.cursor()
        clause,pars=self.build_filter_clause()
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q,pars)
        total=c.fetchone()[0]
        self.total_pages=max(1,math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page
        data_q=f"""
          SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,RULE_LOCKED,RULE_LOCKED_BY,
                 (SELECT TOP 1 PRIORITY FROM RULE_CONFLICTS WHERE RULE_ID1=BRM_RULES.RULE_ID OR RULE_ID2=BRM_RULES.RULE_ID) as ConfPri,
                 CREATED_TIMESTAMP,APPROVAL_STATUS
          FROM BRM_RULES
          WHERE {clause}
          ORDER BY RULE_ID DESC
          OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q,(*pars,offset,self.records_per_page))
        rows=c.fetchall()
        self.rule_table.setRowCount(0)
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i in range(10):
                val=row[col_i]
                it=QTableWidgetItem(str(val) if val!=None else "")
                if col_i==3: # status
                    if str(val).upper()=="ACTIVE":
                        it.setBackground(QColor("lightgreen"))
                    else:
                        it.setBackground(QColor("lightpink"))
                self.rule_table.setItem(r_i,col_i,it)

            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)

            lock_btn=QPushButton("Lock")
            lock_btn.clicked.connect(lambda _,rid=row[0]: self.do_lock(rid))
            ah.addWidget(lock_btn)

            unl_btn=QPushButton("Unlock")
            unl_btn.clicked.connect(lambda _,rid=row[0]: self.do_unlock(rid))
            ah.addWidget(unl_btn)

            if self.user_group.lower()=="admin":
                forc_btn=QPushButton("ForceUnl")
                forc_btn.clicked.connect(lambda _,rid=row[0]: self.do_force_unlock(rid))
                ah.addWidget(forc_btn)

            ah.addStretch()
            self.rule_table.setCellWidget(r_i,10,act_w)

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

    def do_lock(self, rid):
        try:
            lock_rule(self.connection, rid, f"UserID:{self.user_id}")
            QMessageBox.information(self,"Locked",f"Rule {rid} locked.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_rules()

    def do_unlock(self, rid):
        try:
            unlock_rule(self.connection, rid, f"UserID:{self.user_id}")
            QMessageBox.information(self,"Unlocked",f"Rule {rid} unlocked.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_rules()

    def do_force_unlock(self, rid):
        if self.user_group.lower()!="admin":
            QMessageBox.warning(self,"Denied","Only admin can force unlock.")
            return
        try:
            force_unlock_rule(self.connection, rid, f"Admin:{self.user_id}")
            QMessageBox.information(self,"Force Unlocked",f"Rule {rid} force unlocked.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_rules()

    def show_performance_chart(self):
        sel=self.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        rid=sel[0]
        c=self.connection.cursor()
        c.execute("""
          SELECT EXECUTION_TIMESTAMP,EXECUTION_TIME_MS
          FROM RULE_EXECUTION_LOGS
          WHERE RULE_ID=?
          ORDER BY EXECUTION_TIMESTAMP
        """,(rid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"No data","No logs found.")
            return
        if not pg:
            QMessageBox.information(self,"Missing PyQtGraph","Cannot show chart.")
            return
        dlg=QDialog(self)
        dlg.setWindowTitle(f"Performance Chart - Rule {rid}")
        dlg.resize(800,600)
        l=QVBoxLayout(dlg)
        plot=pg.PlotWidget(title=f"Rule {rid} Performance (ms) Over Time")
        xvals=[]
        yvals=[]
        for row_ in rows:
            ts=row_[0]
            dur=float(row_[1] or 0)
            xvals.append(ts.timestamp())
            yvals.append(dur)
        plot.plot(xvals,yvals,pen='b',symbol='o')
        l.addWidget(plot)
        cl=QPushButton("Close")
        cl.clicked.connect(dlg.close)
        l.addWidget(cl)
        dlg.exec_()

class RuleEditorDialog(QDialog):
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)
        title="Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title+" (Enhanced)")
        self.resize(850,650)

        main_layout=QVBoxLayout(self)
        form_layout=QFormLayout()

        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        for row in c.fetchall():
            disp=f"{row[0]} - {row[1]}"
            self.group_combo.addItem(disp,row[0])
        form_layout.addRow("Group ID:", self.group_combo)

        self.parent_combo=QComboBox()
        self.parent_combo.addItem("(None)",None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            disp2=f"{row[0]} - {row[1]}"
            self.parent_combo.addItem(disp2,row[0])
        form_layout.addRow("Parent Rule:", self.parent_combo)

        self.name_edit=QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo=QComboBox()
        c2=self.connection.cursor()
        c2.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for row in c2.fetchall():
            self.type_combo.addItem(row[1],row[0])
        form_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        self.start_edit=QLineEdit()
        self.start_edit.setPlaceholderText("YYYY-MM-DD HH:MM:SS")
        form_layout.addRow("Effective Start:", self.start_edit)
        self.end_edit=QLineEdit()
        self.end_edit.setPlaceholderText("YYYY-MM-DD HH:MM:SS")
        form_layout.addRow("Effective End:", self.end_edit)

        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_layout.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit=QPlainTextEdit()
        form_layout.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit=QPlainTextEdit()
        form_layout.addRow("Description:", self.desc_edit)

        self.just_edit=QPlainTextEdit()
        form_layout.addRow("Business Justification:", self.just_edit)

        self.global_cb=QComboBox()
        self.global_cb.addItems(["No","Yes"])
        form_layout.addRow("Is Global?:", self.global_cb)

        self.crit_cb=QComboBox()
        self.crit_cb.addItems(["No","Yes"])
        form_layout.addRow("Critical Rule?:", self.crit_cb)

        self.scope_cb=QComboBox()
        self.scope_cb.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_layout.addRow("Critical Scope:", self.scope_cb)

        main_layout.addLayout(form_layout)

        bh=QHBoxLayout()
        self.save_btn=QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        if self.is_update and self.rule_data:
            self.load_existing()

    def load_existing(self):
        rd=self.rule_data
        gid=rd.get("GROUP_ID")
        if gid:
            idx=self.group_combo.findData(gid)
            if idx>=0:
                self.group_combo.setCurrentIndex(idx)
        pid=rd.get("PARENT_RULE_ID")
        if pid:
            idx2=self.parent_combo.findData(pid)
            if idx2>=0:
                self.parent_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            idx3=self.type_combo.findData(rt_id)
            if idx3>=0:
                self.type_combo.setCurrentIndex(idx3)
        st=rd.get("STATUS","INACTIVE")
        i_st=self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)
        if rd.get("EFFECTIVE_START_DATE"):
            self.start_edit.setText(str(rd["EFFECTIVE_START_DATE"]))
        if rd.get("EFFECTIVE_END_DATE"):
            self.end_edit.setText(str(rd["EFFECTIVE_END_DATE"]))
        cdcv=rd.get("CDC_TYPE","NONE")
        i_cdc=self.cdc_combo.findText(cdcv)
        if i_cdc>=0:
            self.cdc_combo.setCurrentIndex(i_cdc)
        if rd["RULE_SQL"]:
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd["DESCRIPTION"]:
            self.desc_edit.setPlainText(rd["DESCRIPTION"])
        if rd["BUSINESS_JUSTIFICATION"]:
            self.just_edit.setPlainText(rd["BUSINESS_JUSTIFICATION"])
        self.global_cb.setCurrentIndex(1 if rd.get("IS_GLOBAL",0)==1 else 0)
        self.crit_cb.setCurrentIndex(1 if rd.get("CRITICAL_RULE",0)==1 else 0)
        scp=rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp=self.scope_cb.findText(scp)
        if i_scp>=0:
            self.scope_cb.setCurrentIndex(i_scp)

    def save_rule(self):
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Missing","Rule name required.")
            return
        group_id=self.group_combo.currentData()
        parent_id=self.parent_combo.currentData()
        rt_id=self.type_combo.currentData()
        st=self.status_combo.currentText()
        sdt=self.start_edit.text().strip() or None
        edt=self.end_edit.text().strip() or None
        cdc_=self.cdc_combo.currentText().strip()
        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()
        is_g=1 if self.global_cb.currentText()=="Yes" else 0
        is_c=1 if self.crit_cb.currentText()=="Yes" else 0
        scp_=self.scope_cb.currentText().upper()
        sql_=self.sql_edit.toPlainText().strip()

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sdt,
            "EFFECTIVE_END_DATE": edt,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": is_g,
            "CRITICAL_RULE": is_c,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdc_
        }

        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            confirm=QMessageBox.question(self,"Confirm","Update rule now?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Updated","Rule updated => re-approval triggered.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            confirm=QMessageBox.question(self,"Confirm","Add new rule now?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id=add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Created",f"Rule (ID={new_id}) => approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 5 (FINAL) with requested “box-like ERwin style” for EnhancedLineageGraphWidget.
 - MultiStepApprovalTab
 - GlobalCriticalAdminTab
 - HierarchyViewTab
 - EnhancedLineageGraphWidget => uses boxes with multiline text
"""

import sys
import json
import math
import logging
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu,
    QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsSimpleTextItem
)
from PyQt5.QtCore import Qt, QRectF, QPointF
from PyQt5.QtGui import QBrush, QColor, QPen, QPainter, QFont

class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.approval_table=QTableWidget(0,8)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","Stage","GroupName","Username","ApprovedFlag","Timestamp","Approve","Reject"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approval_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_approvals)
        bh.addWidget(ref_btn)
        esc_btn=QPushButton("Check Delayed => Escalate")
        esc_btn.clicked.connect(self.check_escalation)
        bh.addWidget(esc_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT A.RULE_ID,A.APPROVAL_STAGE,A.GROUP_NAME,A.USERNAME,
                 A.APPROVED_FLAG,A.APPROVED_TIMESTAMP
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
          ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()
        # only minimal stage
        staging={}
        for row in rows:
            rid=row[0]
            st=row[1]
            staging.setdefault(rid,[]).append(st)
        minimal={}
        for rid, st_list in staging.items():
            minimal[rid]=min(st_list) if st_list else 0
        filtered=[]
        for row_data in rows:
            if row_data[1]==minimal[row_data[0]]:
                filtered.append(row_data)

        for row_data in filtered:
            r_i=self.approval_table.rowCount()
            self.approval_table.insertRow(r_i)
            for col_i in range(6):
                val=row_data[col_i]
                it=QTableWidgetItem(str(val) if val!=None else "")
                self.approval_table.setItem(r_i,col_i,it)
            app_btn=QPushButton("Approve")
            app_btn.clicked.connect(lambda _,r=r_i: self.do_approve(r))
            self.approval_table.setCellWidget(r_i,6,app_btn)
            rej_btn=QPushButton("Reject")
            rej_btn.clicked.connect(lambda _,r=r_i: self.do_reject(r))
            self.approval_table.setCellWidget(r_i,7,rej_btn)

    def do_approve(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        st_item=self.approval_table.item(row_i,1)
        if not rid_item or not st_item:
            return
        rid=int(rid_item.text())
        stage=int(st_item.text())
        c=self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=1,APPROVED_TIMESTAMP=GETDATE()
          WHERE RULE_ID=? AND USERNAME=? AND APPROVAL_STAGE=? AND APPROVED_FLAG=0
        """,(rid,self.logged_in_username,stage))
        c.commit()
        nxt=load_current_stage_for_rule(self.connection,rid)
        if nxt is None:
            set_rule_approved(self.connection,rid)
        else:
            set_rule_in_progress(self.connection,rid)
        insert_audit_log(self.connection,"APPROVE","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"approved":True})
        QMessageBox.information(self,"Approved",f"Rule {rid} => stage {stage} approved.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        st_item=self.approval_table.item(row_i,1)
        if not rid_item or not st_item:
            return
        rid=int(rid_item.text())
        stage=int(st_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=2,APPROVED_TIMESTAMP=GETDATE()
          WHERE RULE_ID=? AND USERNAME=? AND APPROVAL_STAGE=? AND APPROVED_FLAG=0
        """,(rid,self.logged_in_username,stage))
        c.commit()
        set_rule_rejected(self.connection,rid)
        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"rejected":True})
        QMessageBox.information(self,"Rejected",f"Rule {rid} => Rejected.")
        self.load_approvals()

    def check_escalation(self):
        days_th=3
        c=self.connection.cursor()
        c.execute("""
          SELECT A.RULE_ID,MIN(A.APPROVAL_STAGE)
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.APPROVED_FLAG=0
          GROUP BY A.RULE_ID
        """)
        to_esc=[]
        for row in c.fetchall():
            rid=row[0]
            stage=row[1]
            c2=self.connection.cursor()
            c2.execute("""
              SELECT DATEDIFF(DAY,ISNULL(MIN(APPROVED_TIMESTAMP),
                (SELECT CREATED_TIMESTAMP FROM BRM_RULES WHERE RULE_ID=?)),GETDATE())
              FROM BRM_RULE_APPROVALS
              WHERE RULE_ID=? AND APPROVAL_STAGE=?
            """,(rid,rid,stage))
            dd=c2.fetchone()[0]
            if dd>=days_th:
                to_esc.append(rid)
        for rid_ in to_esc:
            set_rule_approval_escalation(self.connection,rid_)
        QMessageBox.information(self,"Escalation",f"Escalated {len(to_esc)} rule(s).")
        self.load_approvals()

def load_current_stage_for_rule(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      SELECT MIN(APPROVAL_STAGE)
      FROM BRM_RULE_APPROVALS
      WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row=c.fetchone()
    if row and row[0]:
        return row[0]
    return None

def set_rule_approved(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='APPROVED',STATUS='ACTIVE',LIFECYCLE_STATE='ACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_in_progress(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS',STATUS='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_rejected(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='REJECTED',STATUS='INACTIVE',LIFECYCLE_STATE='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_approval_escalation(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='ESCALATION',LIFECYCLE_STATE='IN_APPROVAL_ESCALATION'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

class GlobalCriticalAdminTab(QWidget):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if user_group.lower()!="admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.table=QTableWidget(0,8)
        self.table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IsGlobal","CritRule","Scope","Status","Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        top_h=QHBoxLayout()
        self.show_all_cb=QComboBox()
        self.show_all_cb.addItem("Show Only GCR",True)
        self.show_all_cb.addItem("Show All",False)
        top_h.addWidget(self.show_all_cb)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        link_h=QHBoxLayout()
        self.gcr_parent_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_parent_combo)
        self.child_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.child_combo)
        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_h.addWidget(link_btn)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(unlink_btn)
        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["ParentGCR","ChildRule"])
        layout.addWidget(self.link_view)

        ref2=QPushButton("Refresh All")
        ref2.clicked.connect(self.refresh_all)
        layout.addWidget(ref2)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_parent_combo()
        self.populate_child_combo()
        self.load_links()

    def load_rule_list(self):
        self.table.setRowCount(0)
        show_gcr=self.show_all_cb.currentData()
        c=self.connection.cursor()
        if show_gcr:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS
              FROM BRM_RULES
              WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
              ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(7):
                val=row[col_i]
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))
            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)
            setf=QPushButton("SetFlags")
            setf.clicked.connect(lambda _,r=r_i:self.set_flags(r))
            ah.addWidget(setf)
            ah.addStretch()
            self.table.setCellWidget(r_i,7,act_w)

    def get_rule_row_data(self, row_i):
        rid_item=self.table.item(row_i,0)
        if not rid_item:
            return None
        rid=int(rid_item.text())
        isg=self.table.item(row_i,3).text()
        isc=self.table.item(row_i,4).text()
        scp=self.table.item(row_i,5).text()
        return (rid,isg,isc,scp)

    def set_flags(self, row_i):
        info=self.get_rule_row_data(row_i)
        if not info:
            return
        (rid,isg,isc,scp)=info
        new_isg,ok1=QInputDialog
# ... (continuation from your truncated code for PART 5) ...

def set_flags(self, row_i):
    info=self.get_rule_row_data(row_i)
    if not info:
        return
    (rid,isg,isc,scp)=info
    new_isg,ok1=QInputDialog.getItem(self,"is_global",f"Rule {rid} => cur={isg}:",["0","1"],0,False)
    if not ok1:
        return
    new_isc,ok2=QInputDialog.getItem(self,"critical_rule",f"Rule {rid} => cur={isc}:",["0","1"],0,False)
    if not ok2:
        return
    new_scp,ok3=QInputDialog.getItem(self,"critical_scope",f"Rule {rid} => cur={scp}:",["NONE","GROUP","CLUSTER","GLOBAL"],0,False)
    if not ok3:
        return
    c=self.connection.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=c.fetchone()
    if not old:
        QMessageBox.warning(self,"Missing",f"Rule {rid} not found.")
        return
    coln=[desc[0] for desc in c.description]
    old_data=dict(zip(coln,old))
    c.execute("""
      UPDATE BRM_RULES
      SET IS_GLOBAL=?,
          CRITICAL_RULE=?,
          CRITICAL_SCOPE=?
      WHERE RULE_ID=?
    """,(int(new_isg),int(new_isc),new_scp,rid))
    self.connection.commit()
    new_data=dict(old_data)
    new_data["IS_GLOBAL"]=int(new_isg)
    new_data["CRITICAL_RULE"]=int(new_isc)
    new_data["CRITICAL_SCOPE"]=new_scp
    insert_audit_log(self.connection,"FLAG_UPDATE","BRM_RULES",rid,"Admin",old_data,new_data)
    QMessageBox.information(self,"Updated",f"Rule {rid} flags updated.")
    self.load_rule_list()

def load_links(self):
    self.link_view.setRowCount(0)
    c=self.connection.cursor()
    c.execute("""
    SELECT GCR_RULE_ID,TARGET_RULE_ID
    FROM BRM_GLOBAL_CRITICAL_LINKS
    ORDER BY GCR_RULE_ID
    """)
    rows=c.fetchall()
    for row in rows:
        r_i=self.link_view.rowCount()
        self.link_view.insertRow(r_i)
        self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
        self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))

def link_child(self):
    p=self.gcr_parent_combo.currentData()
    ch=self.child_combo.currentData()
    if not p or not ch:
        return
    if p==ch:
        QMessageBox.warning(self,"Invalid","Cannot link rule to itself.")
        return
    c=self.connection.cursor()
    try:
        c.execute("""
          INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID)
          VALUES(?,?)
        """,(p,ch))
        self.connection.commit()
        insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{p}->{ch}","Admin",None,{"p":p,"c":ch})
        QMessageBox.information(self,"Linked",f"Child {ch} => parent {p}")
    except Exception as ex:
        QMessageBox.warning(self,"Error",str(ex))
    self.load_links()

def unlink_child(self):
    p=self.gcr_parent_combo.currentData()
    ch=self.child_combo.currentData()
    if not p or not ch:
        return
    confirm=QMessageBox.question(self,"Confirm",f"Unlink child {ch} from {p}?")
    if confirm!=QMessageBox.Yes:
        return
    c=self.connection.cursor()
    c.execute("""
      DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
      WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
    """,(p,ch))
    self.connection.commit()
    insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{p}->{ch}","Admin",{"p":p,"c":ch},None)
    QMessageBox.information(self,"Unlinked",f"Child {ch} from parent {p}")
    self.load_links()

class HierarchyViewTab(QTreeWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        group_map={}
        for (gid,gname) in c.fetchall():
            top=QTreeWidgetItem([f"{gname} (ID={gid})"])
            top.setData(0, Qt.UserRole, ("group",gid))
            self.addTopLevelItem(top)
            group_map[gid]=top

        c2=self.connection.cursor()
        c2.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rule_map=c2.fetchall()
        for (rid,rn,gid,pid) in rule_map:
            if not pid:
                if gid in group_map:
                    child=QTreeWidgetItem([f"Rule {rid}: {rn}"])
                    child.setData(0, Qt.UserRole, ("rule",rid))
                    group_map[gid].addChild(child)
        self.expandAll()

    def dropEvent(self, event):
        source_item=self.currentItem()
        if not source_item:
            super().dropEvent(event)
            return
        data_role=source_item.data(0, Qt.UserRole)
        if data_role[0]!="rule":
            super().dropEvent(event)
            return

        super().dropEvent(event)
        new_parent=source_item.parent()
        if not new_parent:
            self.load_hierarchy()
            return
        parent_role=new_parent.data(0, Qt.UserRole)
        rule_id=data_role[1]
        if parent_role[0]=="group":
            reparent_rule(self.connection,rule_id,None,parent_role[1],"HierarchyDrag")
        elif parent_role[0]=="rule":
            c=self.connection.cursor()
            c.execute("SELECT GROUP_ID FROM BRM_RULES WHERE RULE_ID=?",(parent_role[1],))
            row=c.fetchone()
            if not row:
                QMessageBox.warning(self,"Invalid","Parent rule group not found => revert.")
                self.load_hierarchy()
                return
            new_gid=row[0]
            reparent_rule(self.connection,rule_id,parent_role[1],new_gid,"HierarchyDrag")
        else:
            QMessageBox.warning(self,"Invalid","Cannot re-parent => revert.")
            self.load_hierarchy()

def reparent_rule(conn, rule_id, new_parent_id, new_group_id, user_name):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError(f"Rule {rule_id} not found.")
    cols=[desc[0] for desc in c.description]
    old_data=dict(zip(cols,old))

    c.execute("""
      UPDATE BRM_RULES
      SET PARENT_RULE_ID=?,
          GROUP_ID=?,
          STATUS='INACTIVE',
          APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
          VERSION=VERSION+1,
          UPDATED_BY=?,
          LIFECYCLE_STATE='UNDER_APPROVAL'
      WHERE RULE_ID=?
    """,(new_parent_id,new_group_id,user_name,rule_id))
    conn.commit()

    new_data=dict(old_data)
    new_data["PARENT_RULE_ID"]=new_parent_id
    new_data["GROUP_ID"]=new_group_id
    new_data["STATUS"]="INACTIVE"
    new_data["APPROVAL_STATUS"]="APPROVAL_IN_PROGRESS"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["UPDATED_BY"]=user_name
    new_data["LIFECYCLE_STATE"]="UNDER_APPROVAL"
    insert_audit_log(conn,"RE_PARENT","BRM_RULES",rule_id,user_name,old_data,new_data)

class EnhancedLineageGraphWidget(QGraphicsView):
    """
    Box-like ERwin style => each rule is a rectangle with multiline text:
      - RuleName
      - Status
      - OperationType
      - (Global or Crit)
    Then lines to tables or child rules or composite IDs.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.node_map={}
        self.load_graph()

    def load_graph(self):
        self.scene.clear()
        self.node_map.clear()

        c=self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME,STATUS,IS_GLOBAL,CRITICAL_RULE,OPERATION_TYPE
          FROM BRM_RULES
        """)
        rules=c.fetchall()

        xoff=50
        yoff=50
        step=120

        font=QFont("Arial",10)

        for r_ in rules:
            rid=r_[0]
            rname=r_[1]
            st=r_[2]
            isg=r_[3]
            isc=r_[4]
            opt=r_[5]

            # We draw a rectangle item
            w=150
            h=70
            rect=QGraphicsRectItem(0,0,w,h)
            # color fill => active=green, else red
            color=QColor("lightgreen") if st.upper()=="ACTIVE" else QColor("lightcoral")
            rect.setBrush(QBrush(color))

            pen=QPen(Qt.black,2)
            if isc:
                pen=QPen(QColor("red"),3)
            if isg:
                pen=QPen(QColor("blue"),3)
            rect.setPen(pen)
            rect.setPos(xoff,yoff)
            self.scene.addItem(rect)

            # multiline text inside
            text=QGraphicsSimpleTextItem(rect)
            detail=f"Rule {rid}\nName: {rname}\nStatus: {st}\nOpType: {opt}"
            if isg:
                detail+=f"\n(Global)"
            if isc:
                detail+=f"\n(Critical)"
            text.setText(detail)
            text.setFont(font)
            # position text inside rect
            text_b=text.boundingRect()
            text.setPos((w-text_b.width())/2, (h-text_b.height())/2)

            self.node_map[("rule",rid)]=rect

            yoff+=step
            if yoff>600:
                xoff+=200
                yoff=50

        # table dependencies => rectangle with different color
        c2=self.connection.cursor()
        c2.execute("""
          SELECT DEPENDENCY_ID,RULE_ID,TABLE_NAME
          FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        table_map={}
        x_table=800
        y_table=50
        step2=100

        for row in c2.fetchall():
            dep_id=row[0]
            rid=row[1]
            tbl=row[2]
            if not tbl:
                continue
            key=("table",tbl)
            if key not in table_map:
                trect=QGraphicsRectItem(0,0,140,60)
                trect.setBrush(QBrush(QColor("lightblue")))
                trect.setPen(QPen(Qt.darkBlue,2))
                self.scene.addItem(trect)
                trect.setPos(x_table,y_table)
                ttext=QGraphicsSimpleTextItem(trect)
                ttext.setFont(font)
                ttext.setText(f"Table:\n{tbl}")
                tb=ttext.boundingRect()
                ttext.setPos((140-tb.width())/2, (60-tb.height())/2)
                table_map[key]=trect
                y_table+=step2
                if y_table>600:
                    x_table+=180
                    y_table=50

            if ("rule",rid) in self.node_map:
                r_item=self.node_map[("rule",rid)]
                t_item=table_map[key]
                self.draw_line(r_item, t_item)

        # column mapping => rule->rule
        c3=self.connection.cursor()
        c3.execute("SELECT COLUMN_MAPPING_ID,SOURCE_RULE_ID,RULE_ID FROM BRM_COLUMN_MAPPING")
        for row in c3.fetchall():
            mid=row[0]
            sr=row[1]
            tr=row[2]
            if ("rule",sr) in self.node_map and ("rule",tr) in self.node_map:
                self.draw_line(self.node_map[("rule",sr)], self.node_map[("rule",tr)], color=Qt.darkGray, thickness=2)

        # composite => we may or may not do separate items if not in RULES
        c4=self.connection.cursor()
        c4.execute("SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR FROM COMPOSITE_RULES")
        comp_map={}
        x_comp=1100
        y_comp=50
        for (cid,cname,expr) in c4.fetchall():
            key=("comp",cid)
            w=150
            h=60
            crect=QGraphicsRectItem(0,0,w,h)
            crect.setBrush(QBrush(QColor("yellow")))
            crect.setPen(QPen(Qt.darkMagenta,2))
            self.scene.addItem(crect)
            crect.setPos(x_comp,y_comp)
            ctext=QGraphicsSimpleTextItem(crect)
            ctext.setFont(font)
            ctext.setText(f"Composite\nID={cid}\n{cname}")
            tb=ctext.boundingRect()
            ctext.setPos((w-tb.width())/2,(h-tb.height())/2)
            comp_map[key]=crect
            y_comp+=step2
            if y_comp>600:
                x_comp+=200
                y_comp=50

            # parse expr => find "RuleN"
            pat=re.compile(r"Rule(\d+)")
            matches=pat.findall(expr or "")
            for m_ in matches:
                srid=int(m_)
                if ("rule",srid) in self.node_map:
                    self.draw_line(self.node_map[("rule",srid)], crect, color=Qt.magenta, thickness=3)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def draw_line(self, item1, item2, color=Qt.darkGray, thickness=2):
        r1=item1.sceneBoundingRect()
        r2=item2.sceneBoundingRect()
        p1=r1.center()
        p2=r2.center()
        line=self.scene.addLine(p1.x(), p1.y(), p2.x(), p2.y(), QPen(color, thickness))
        line.setZValue(-1)

    def resetView(self):
        br=self.scene.itemsBoundingRect()
        if br.isValid():
            self.fitInView(br, Qt.KeepAspectRatio)

    def perform_search(self, text):
        txt=text.lower()
        for item in self.scene.items():
            tip=""
            if isinstance(item, QGraphicsRectItem):
                # see if there's a child QGraphicsSimpleTextItem
                for child in item.childItems():
                    if isinstance(child, QGraphicsSimpleTextItem):
                        tip=(child.text() or "").lower()
                        break
            if txt in tip:
                item.setOpacity(1.0)
            else:
                item.setOpacity(0.2)
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 6 (FINAL):
 - MetricsDashboardTab
 - CtrlTablesTab
 - GroupManagementTab
 - UserManagementTab
"""

import sys
import math
import logging
import json
from datetime import datetime, timedelta
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
import pyodbc
import pyqtgraph as pg

def is_admin_user(user_group:str)->bool:
    return (user_group.strip().lower()=="admin")

def user_has_table_permission(conn, user_group, table_name):
    if is_admin_user(user_group):
        return True
    c=conn.cursor()
    c.execute("""
      SELECT 1
      FROM GROUP_PERMISSIONS
      WHERE GROUP_NAME=? AND TARGET_TABLE=?
    """,(user_group, table_name))
    row=c.fetchone()
    return bool(row)

class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.chart=pg.PlotWidget(title="Rule Counts by Status")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        self.trend_chart=pg.PlotWidget(title="Performance Trend (Optional)")
        self.trend_chart.setBackground('w')
        layout.addWidget(self.trend_chart)

        btn=QPushButton("Refresh Metrics")
        btn.clicked.connect(self.load_metrics)
        layout.addWidget(btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        c.execute("SELECT STATUS,COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        data=c.fetchall()
        statuses=[d[0] for d in data]
        counts=[d[1] for d in data]
        self.chart.clear()
        if statuses:
            xvals=list(range(len(statuses)))
            bar_item=pg.BarGraphItem(x=xvals,height=counts,width=0.6,brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis('bottom').setTicks([list(zip(xvals,statuses))])
            self.chart.setLabel('left','Count')
            self.chart.setLabel('bottom','Status')
            self.chart.showGrid(x=True,y=True)

        self.trend_chart.clear()
        try:
            c.execute("""
              SELECT CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120) as dt,
                     AVG(EXECUTION_TIME_MS) as avg_ms
              FROM RULE_EXECUTION_LOGS
              GROUP BY CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120)
              ORDER BY dt
            """)
            rows=c.fetchall()
            if rows:
                x_labels=[]
                y_vals=[]
                for row_ in rows:
                    x_labels.append(row_[0])
                    y_vals.append(float(row_[1] or 0))
                x_=range(len(x_labels))
                p_data=pg.PlotDataItem(x=list(x_),y=y_vals,pen='r',symbol='o')
                self.trend_chart.addItem(p_data)
                self.trend_chart.getAxis('bottom').setTicks([list(zip(x_,x_labels))])
                self.trend_chart.setLabel('left','Avg Ms')
                self.trend_chart.setLabel('bottom','Date')
                self.trend_chart.showGrid(x=True,y=True)
        except:
            pass

class CtrlTablesTab(QWidget):
    def __init__(self, connection, user_id:str, user_group:str, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES",
            "BRM_AUDIT_LOG","RULE_SCHEDULES","DATA_VALIDATIONS","COMPOSITE_RULES",
            "RULE_CONFLICTS","BRM_GLOBAL_CRITICAL_LINKS","DECISION_TABLES","RULE_BACKUPS",
            "BUSINESS_DICTIONARY","BRM_CUSTOM_RULE_GROUPS","BRM_CUSTOM_GROUP_MEMBERS",
            "BUSINESS_GROUP_APPROVERS","BRM_COLUMN_MAPPING","BRM_CUSTOM_GROUP_BACKUPS"
        ]

        self.tbl_combo=QComboBox()
        for t_ in self.table_list:
            self.tbl_combo.addItem(t_)
        layout.addWidget(QLabel("Pick Admin Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.load_table_data)
        layout.addWidget(load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def load_table_data(self):
        tname=self.tbl_combo.currentText()
        if not user_has_table_permission(self.connection, self.user_group, tname):
            QMessageBox.warning(self,"Denied",f"Group {self.user_group} lacks permission for {tname}.")
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tname}")
            colnames=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Cannot read columns from {tname} => {ex}")
            return
        try:
            c.execute(f"SELECT TOP 500 * FROM {tname}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Cannot read data from {tname} => {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row_ in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for col_i,val in enumerate(row_):
                self.data_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val!=None else ""))

class GroupManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if not is_admin_user(user_group):
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # 1) groups + membership
        gm_tab=QWidget()
        gm_lay=QVBoxLayout(gm_tab)

        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        gm_lay.addWidget(QLabel("Business Groups:"))
        gm_lay.addWidget(self.groups_table)

        bh=QHBoxLayout()
        addg=QPushButton("Add Group")
        addg.clicked.connect(self.add_group)
        bh.addWidget(addg)
        ren=QPushButton("Rename Group")
        ren.clicked.connect(self.rename_group)
        bh.addWidget(ren)
        delg=QPushButton("Delete Group")
        delg.clicked.connect(self.delete_group)
        bh.addWidget(delg)
        bh.addStretch()
        gm_lay.addLayout(bh)

        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        gm_lay.addWidget(QLabel("Users:"))
        gm_lay.addWidget(self.users_table)

        bh2=QHBoxLayout()
        add_usr=QPushButton("Add User => Group")
        add_usr.clicked.connect(self.add_user_to_group)
        bh2.addWidget(add_usr)
        rm_usr=QPushButton("Remove User => BG1")
        rm_usr.clicked.connect(self.remove_user_from_group)
        bh2.addWidget(rm_usr)
        bh2.addStretch()
        gm_lay.addLayout(bh2)

        gm_tab.setLayout(gm_lay)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # 2) perms
        perm_tab=QWidget()
        perm_lay=QVBoxLayout(perm_tab)
        ph=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        ph.addWidget(QLabel("Pick Group:"))
        ph.addWidget(self.perm_group_combo)
        ph.addStretch()
        perm_lay.addLayout(ph)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["TargetTable"])
        perm_lay.addWidget(self.perm_table)

        bh3=QHBoxLayout()
        addp=QPushButton("Add Permission")
        addp.clicked.connect(self.add_permission)
        bh3.addWidget(addp)
        remp=QPushButton("Remove Permission")
        remp.clicked.connect(self.remove_permission)
        bh3.addWidget(remp)
        bh3.addStretch()
        perm_lay.addLayout(bh3)

        perm_tab.setLayout(perm_lay)
        self.tabs.addTab(perm_tab,"Permissions")

        # 3) approvers
        appr_tab=QWidget()
        appr_lay=QVBoxLayout(appr_tab)
        ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(QLabel("Group:"))
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_lay.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        appr_lay.addWidget(self.appr_table)

        abh=QHBoxLayout()
        add_appr=QPushButton("Add Approver")
        add_appr.clicked.connect(self.add_approver)
        abh.addWidget(add_appr)
        del_appr=QPushButton("Remove Approver")
        del_appr.clicked.connect(self.remove_approver)
        abh.addWidget(del_appr)
        abh.addStretch()
        appr_lay.addLayout(abh)

        appr_tab.setLayout(appr_lay)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_all=QPushButton("Refresh All")
        ref_all.clicked.connect(self.load_data)
        layout.addWidget(ref_all)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_group_combo()
        self.load_appr_group_combo()

    # groups
    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT GROUP_NAME,DESCRIPTION,EMAIL
          FROM BUSINESS_GROUPS
          ORDER BY GROUP_NAME
        """)
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for col_i,val in enumerate(r_):
                self.groups_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_groupname(self):
        row=self.groups_table.currentRow()
        if row<0:
            return None
        it=self.groups_table.item(row,0)
        if not it:
            return None
        return it.text().strip()

    def add_group(self):
        gname,ok=QInputDialog.getText(self,"Add Group","Group name:")
        if not ok or not gname.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Dup","Group already exists.")
            return
        c.execute("""
          INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
          VALUES(?,?,?)
        """,(gname.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def rename_group(self):
        gn=self.get_selected_groupname()
        if not gn:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_g,ok=QInputDialog.getText(self,"Rename",f"New name for {gn}:")
        if not ok or not new_g.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_g.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Dup","New group name already used.")
            return
        c.execute("BEGIN TRANSACTION")
        try:
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_g.strip(),gn))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_g.strip(),gn))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RENAME_GROUP","BUSINESS_GROUPS",gn,self.user_id,{"old":gn},{"new":new_g.strip()})
            QMessageBox.information(self,"Renamed",f"{gn} => {new_g}")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def delete_group(self):
        gn=self.get_selected_groupname()
        if not gn:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group {gn}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gn,))
            c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(gn,))
            c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(gn,))
            self.connection.commit()
            insert_audit_log(self.connection,"DELETE_GROUP","BUSINESS_GROUPS",gn,self.user_id,{"group":gn},None)
            QMessageBox.information(self,"Deleted",f"Group {gn} removed.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    # membership
    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.users_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_userid(self):
        row=self.users_table.currentRow()
        if row<0:
            return None
        it=self.users_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user_to_group(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        gn,ok=QInputDialog.getText(self,"Assign Group","Group name:")
        if not ok or not gn.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gn.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Missing",f"Group {gn} not found.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(gn.strip(),uid))
        c.commit()
        insert_audit_log(self.connection,"ADD_USER_TO_GROUP","USERS",uid,self.user_id,None,{"group":gn})
        QMessageBox.information(self,"Assigned",f"User {uid} => group {gn}")
        self.load_data()

    def remove_user_from_group(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove user => group => BG1?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldg=c.fetchone()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        c.commit()
        insert_audit_log(self.connection,"REMOVE_USER_FROM_GROUP","USERS",uid,self.user_id,{"group":oldg},{"group":"BG1"})
        QMessageBox.information(self,"Removed",f"User {uid} => BG1")
        self.load_data()

    # perms
    def load_perm_group_combo(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            self.perm_group_combo.addItem(row[0])
        self.load_permissions()

    def load_permissions(self):
        self.perm_table.setRowCount(0)
        grp=self.perm_group_combo.currentText()
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT TARGET_TABLE
          FROM GROUP_PERMISSIONS
          WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))

    def add_permission(self):
        grp=self.perm_group_combo.currentText()
        if not grp:
            return
        tbl,ok=QInputDialog.getText(self,"Add Permission",f"Table name for group {grp}:")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE)
          VALUES(?,?)
        """,(grp.strip(),tbl.strip()))
        c.commit()
        insert_audit_log(self.connection,"ADD_PERMISSION","GROUP_PERMISSIONS",grp,self.user_id,None,{"table":tbl})
        QMessageBox.information(self,"Added",f"Group {grp} can now see {tbl}.")
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentText()
        row=self.perm_table.currentRow()
        if row<0:
            return
        it=self.perm_table.item(row,0)
        tbl=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove {tbl} from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
          DELETE FROM GROUP_PERMISSIONS
          WHERE GROUP_NAME=? AND TARGET_TABLE=?
        """,(grp,tbl))
        c.commit()
        insert_audit_log(self.connection,"REMOVE_PERMISSION","GROUP_PERMISSIONS",grp,self.user_id,{"table":tbl},None)
        QMessageBox.information(self,"Removed",f"{grp} => no longer sees {tbl}.")
        self.load_permissions()

    # approvers
    def load_appr_group_combo(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            self.appr_group_combo.addItem(row[0])
        self.load_approvers()

    def load_approvers(self):
        grp=self.appr_group_combo.currentText()
        self.appr_table.setRowCount(0)
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT APPROVER_ID,USERNAME
          FROM BUSINESS_GROUP_APPROVERS
          WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.appr_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_approver(self):
        grp=self.appr_group_combo.currentText()
        if not grp:
            return
        usr,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usr.strip():
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME)
          VALUES(?,?)
        """,(grp.strip(),usr.strip()))
        c.commit()
        insert_audit_log(self.connection,"ADD_APPROVER","BUSINESS_GROUP_APPROVERS",grp,self.user_id,None,{"username":usr})
        QMessageBox.information(self,"Added",f"Approver {usr} => {grp}")
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentText()
        row=self.appr_table.currentRow()
        if row<0:
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        appr_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver id={appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        c.commit()
        insert_audit_log(self.connection,"REMOVE_APPROVER","BUSINESS_GROUP_APPROVERS",appr_id,self.user_id,{"approver_id":appr_id},None)
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

class UserManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if not is_admin_user(user_group):
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password(plain)","Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add User")
        addb.clicked.connect(self.add_user)
        bh.addWidget(addb)

        delb=QPushButton("Delete User")
        delb.clicked.connect(self.delete_user)
        bh.addWidget(delb)

        passb=QPushButton("Change Password")
        passb.clicked.connect(self.change_password)
        bh.addWidget(passb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_users)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.user_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_userid(self):
        row=self.user_table.currentRow()
        if row<0:
            return None
        it=self.user_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"Add","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","(plain text):")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","BG1 or Admin etc:")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Dup","Username already exists.")
            return
        c.execute("""
          INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP)
          VALUES(?,?,?)
        """,(uname.strip(),pwd.strip(),grp.strip()))
        c.commit()
        insert_audit_log(self.connection,"ADD_USER","USERS",uname,self.user_id,None,{"username":uname})
        QMessageBox.information(self,"Added","User created.")
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user {uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("SELECT USERNAME,PASSWORD,USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing","User not found, might be removed already.")
            return
        oldd={"username":row[0],"password":row[1],"group":row[2]}
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        c.commit()
        insert_audit_log(self.connection,"DELETE_USER","USERS",uid,self.user_id,oldd,None)
        QMessageBox.information(self,"Deleted",f"User {uid} removed.")
        self.load_users()

    def change_password(self):
        uid=self.get_selected_userid()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pwd,ok=QInputDialog.getText(self,"New Password","(plain text):")
        if not ok or not pwd.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT PASSWORD FROM USERS WHERE USER_ID=?",(uid,))
        oldpw=c.fetchone()
        if not oldpw:
            QMessageBox.warning(self,"Missing","User not found.")
            return
        oldd={"password":oldpw[0]}
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pwd.strip(),uid))
        c.commit()
        insert_audit_log(self.connection,"CHANGE_PWD","USERS",uid,self.user_id,oldd,{"password":pwd.strip()})
        QMessageBox.information(self,"Changed",f"Password for user {uid} updated.")
        self.load_users()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 7 (FINAL):
 - CustomRuleGroupEnhancedTab
 - AlertsAndDashboardsTab
 - ColumnMappingTab (with simulate BFS from source rule)
"""

import sys
import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox,
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QTableWidget,
    QTableWidgetItem
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor

class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("New custom group name")
        top_h.addWidget(self.new_group_edit)
        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)
        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)
        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)
        backup_btn=QPushButton("Backup")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)
        restore_btn=QPushButton("Restore")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        from PyQt5.QtWidgets import QSplitter
        splitter=QSplitter(Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_w=QWidget()
        rw_lay=QVBoxLayout(right_w)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search unassigned rules..")
        self.rule_search.textChanged.connect(self.load_unassigned_rules)
        rw_lay.addWidget(self.rule_search)
        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        rw_lay.addWidget(self.rule_list)
        assign_btn=QPushButton("Assign Selected => Group")
        assign_btn.clicked.connect(self.assign_rules)
        rw_lay.addWidget(assign_btn)
        splitter.addWidget(right_w)

        layout.addWidget(splitter)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_unassigned_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
          SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
          FROM BRM_CUSTOM_RULE_GROUPS
          ORDER BY CUSTOM_GROUP_ID DESC
        """)
        for (cgid,cgname,ownerbg) in c.fetchall():
            disp=f"{cgname} (Owner={ownerbg})"
            pitem=QTreeWidgetItem([disp])
            pitem.setData(0,Qt.UserRole,cgid)
            pitem.setBackground(0,QBrush(QColor("lightgray")))
            self.tree.addTopLevelItem(pitem)

            c2=self.connection.cursor()
            c2.execute("""
              SELECT M.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
              FROM BRM_CUSTOM_GROUP_MEMBERS M
              JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
              WHERE M.CUSTOM_GROUP_ID=?
            """,(cgid,))
            for (rid,rn,isg,isc) in c2.fetchall():
                txt=f"Rule {rid}: {rn}"
                ch=QTreeWidgetItem([txt])
                ch.setData(0,Qt.UserRole,rid)
                if isg:
                    ch.setBackground(0,QBrush(QColor("lightblue")))
                if isc:
                    ch.setBackground(0,QBrush(QColor("tomato")))
                pitem.addChild(ch)
        self.tree.expandAll()

    def load_unassigned_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=[r[0] for r in c.fetchall()]
        if txt:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP
              FROM BRM_RULES
              WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
              ORDER BY RULE_ID DESC
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
            """)
        for (rid,rn,og) in c.fetchall():
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rn} (Owner={og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            from PyQt5.QtWidgets import QMenu
            menu=QMenu()
            rem=menu.addAction("Remove from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem:
                grp_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                  DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                  WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(grp_id,rule_id))
                self.connection.commit()
                insert_audit_log(self.connection,"REMOVE_RULE","BRM_CUSTOM_GROUP_MEMBERS",grp_id,self.user_id,{"rule":rule_id},None)
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group {grp_id}.")
                self.refresh_all()

    def create_group(self):
        nm=self.new_group_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Missing","No name.")
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BRM_CUSTOM_RULE_GROUPS(
            CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP
          )
          VALUES(?,?,?,GETDATE())
        """,(nm,self.user_group,f"User:{self.user_id}"))
        c.commit()
        insert_audit_log(self.connection,"CREATE_CG","BRM_CUSTOM_RULE_GROUPS",nm,self.user_id,None,{"cg_name":nm})
        QMessageBox.information(self,"Created",f"Group '{nm}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        pr=it.parent()
        if pr:
            it=pr
        gid=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (gid,disp)

    def rename_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename",f"New name for group ID={gid}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        old=c.fetchone()
        if not old:
            QMessageBox.warning(self,"Missing","Group not found.")
            return
        coln=[desc[0] for desc in c.description]
        old_data=dict(zip(coln,old))
        c.execute("BEGIN TRANSACTION")
        c.execute("""
          UPDATE BRM_CUSTOM_RULE_GROUPS
          SET CUSTOM_GROUP_NAME=?
          WHERE CUSTOM_GROUP_ID=?
        """,(new_name.strip(),gid))
        c.execute("COMMIT")
        new_data=dict(old_data)
        new_data["CUSTOM_GROUP_NAME"]=new_name.strip()
        insert_audit_log(self.connection,"RENAME_CG","BRM_CUSTOM_RULE_GROUPS",gid,self.user_id,old_data,new_data)
        QMessageBox.information(self,"Renamed",f"Group {gid} => '{new_name}'.")
        self.refresh_all()

    def delete_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group {gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        oldd=None
        c.execute("SELECT * FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if row:
            coln=[desc[0] for desc in c.description]
            oldd=dict(zip(coln,row))
        c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        c.commit()
        insert_audit_log(self.connection,"DELETE_CG","BRM_CUSTOM_RULE_GROUPS",gid,self.user_id,oldd,None)
        QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
        self.refresh_all()

    def backup_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing","Group not found.")
            return
        grp_name=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        members=[x[0] for x in c.fetchall()]
        backup_json=json.dumps({"group_name":grp_name,"members":members})
        c.execute("""
          SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        r_=c.fetchone()
        new_ver=r_[0] if r_ else 1
        c.execute("""
          INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
            CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
          )
          VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,backup_json))
        c.commit()
        insert_audit_log(self.connection,"BACKUP_CG","BRM_CUSTOM_GROUP_BACKUPS",gid,self.user_id,None,{"version":new_ver})
        QMessageBox.information(self,"Backup",f"Group {gid} => ver {new_ver} saved.")
        self.refresh_all()

    def restore_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
          ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        versions=c.fetchall()
        if not versions:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {v[0]} @ {v[1]}" for v in versions]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return
        bkup_vers=None
        bkup_data=None
        for (ver_,ts_,json_) in versions:
            if sel.startswith(f"Version {ver_}"):
                bkup_vers=ver_
                bkup_data=json_
                break
        if not bkup_vers:
            QMessageBox.warning(self,"Missing","Version parse fail.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => ver {bkup_vers}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            data=json.loads(bkup_data)
            name=data["group_name"]
            mems=data["members"]
            c.execute("BEGIN TRANSACTION")
            c.execute("""
              UPDATE BRM_CUSTOM_RULE_GROUPS
              SET CUSTOM_GROUP_NAME=?
              WHERE CUSTOM_GROUP_ID=?
            """,(name,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for m in mems:
                c.execute("""
                  INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(
                    CUSTOM_GROUP_ID,RULE_ID
                  )
                  VALUES(?,?)
                """,(gid,m))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RESTORE_CG","BRM_CUSTOM_GROUP_BACKUPS",gid,self.user_id,{"version":bkup_vers},data)
            QMessageBox.information(self,"Restored",f"Group {gid} => version {bkup_vers} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        top=sel[0]
        pr=top.parent()
        if pr:
            top=pr
        gid=top.data(0,Qt.UserRole)
        if not gid:
            QMessageBox.warning(self,"Error","No valid group ID found.")
            return
        selected_rules=self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self,"None","No rules selected on the right side.")
            return
        c=self.connection.cursor()
        assigned=0
        for it in selected_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                  INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(gid,rid))
                assigned+=1
            except:
                pass
        c.commit()
        insert_audit_log(self.connection,"ASSIGN_RULES","BRM_CUSTOM_GROUP_MEMBERS",gid,self.user_id,None,{"count":assigned})
        QMessageBox.information(self,"Assigned",f"{assigned} rule(s) assigned to group {gid}.")
        self.refresh_all()

class AlertsAndDashboardsTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        perf_box=QWidget()
        perf_layout=QVBoxLayout(perf_box)
        lbl=QLabel("Performance/Usage Stats:")
        lbl.setStyleSheet("font-weight:bold;")
        perf_layout.addWidget(lbl)

        self.perf_table=QTableWidget(0,5)
        self.perf_table.setHorizontalHeaderLabels([
            "RuleID","AvgMs","ExecCount","Success%","LastExec"
        ])
        self.perf_table.horizontalHeader().setStretchLastSection(True)
        perf_layout.addWidget(self.perf_table)

        load_perf_btn=QPushButton("Load Perf Stats")
        load_perf_btn.clicked.connect(self.load_perf_stats)
        perf_layout.addWidget(load_perf_btn)

        layout.addWidget(perf_box)
        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()
        c.execute("""
          SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
                 DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.APPROVED_FLAG=0
            AND A.APPROVAL_STAGE=(
               SELECT MIN(APPROVAL_STAGE)
               FROM BRM_RULE_APPROVALS
               WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
            )
            AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        old_ap=c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for (rid,st,rn,age) in old_ap:
                lines.append(f" - Rule {rid}, stage={st}, age={age}, name={rn}")
        else:
            lines.append("No old approvals >3 days found.")
        lines.append("")

        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
          FROM RULE_SCHEDULES
          WHERE STATUS='Scheduled'
            AND SCHEDULE_TIME>=GETDATE()
            AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
          ORDER BY SCHEDULE_TIME
        """)
        ups=c.fetchall()
        if ups:
            lines.append("Upcoming schedules in <24h:")
            for (sid,rid,ts) in ups:
                lines.append(f" - Sched={sid}, rule={rid}, time={ts}")
        else:
            lines.append("No upcoming schedules next 24h.")
        self.alert_text.setPlainText("\n".join(lines))

    def load_perf_stats(self):
        self.perf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,
                 AVG(EXECUTION_TIME_MS) as avg_ms,
                 COUNT(*) as exec_count,
                 SUM(CASE WHEN PASS_FLAG=1 THEN 1 ELSE 0 END)*100.0/COUNT(*) as success_pct,
                 MAX(EXECUTION_TIMESTAMP) as last_exec
          FROM RULE_EXECUTION_LOGS
          GROUP BY RULE_ID
          ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.perf_table.rowCount()
            self.perf_table.insertRow(r_i)
            for col_i in range(5):
                val=row[col_i]
                it=QTableWidgetItem(str(val) if val!=None else "")
                self.perf_table.setItem(r_i,col_i,it)

class ColumnMappingTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.map_table=QTableWidget(0,4)
        self.map_table.setHorizontalHeaderLabels(["MappingID","SourceRuleID","TargetRuleID","Comments"])
        self.map_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.map_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Mapping")
        addb.clicked.connect(self.add_mapping)
        bh.addWidget(addb)
        delb=QPushButton("Remove Mapping")
        delb.clicked.connect(self.remove_mapping)
        bh.addWidget(delb)
        sim_btn=QPushButton("Simulate BFS from Source")
        sim_btn.clicked.connect(self.simulate_bfs)
        bh.addWidget(sim_btn)
        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_mappings)
        bh.addWidget(refb)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_mappings()

    def load_mappings(self):
        self.map_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT COLUMN_MAPPING_ID,SOURCE_RULE_ID,RULE_ID,COMMENTS
          FROM BRM_COLUMN_MAPPING
          ORDER BY COLUMN_MAPPING_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.map_table.rowCount()
            self.map_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.map_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_mapping(self):
        s_rid,ok=QInputDialog.getInt(self,"Add Mapping","Source Rule ID:")
        if not ok:
            return
        t_rid,ok2=QInputDialog.getInt(self,"Add Mapping","Target Rule ID:")
        if not ok2:
            return
        cmt,ok3=QInputDialog.getText(self,"Comments","(optional):")
        if not ok3:
            cmt=""
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BRM_COLUMN_MAPPING(SOURCE_RULE_ID,RULE_ID,COMMENTS)
          VALUES(?,?,?)
        """,(s_rid,t_rid,cmt.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Mapping created.")
        self.load_mappings()

    def remove_mapping(self):
        row=self.map_table.currentRow()
        if row<0:
            return
        it=self.map_table.item(row,0)
        if not it:
            return
        mid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete mapping id={mid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_COLUMN_MAPPING WHERE COLUMN_MAPPING_ID=?",(mid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Mapping {mid} removed.")
        self.load_mappings()

    def simulate_bfs(self):
        row=self.map_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No row selected.")
            return
        s_item=self.map_table.item(row,1)
        if not s_item:
            return
        s_rid=int(s_item.text())
        ex,sk=dry_run_advanced_bfs(self.connection,[s_rid])
        QMessageBox.information(self,"Sim BFS",f"Source {s_rid} => executed={ex}, skipped={sk}")
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 8 (FINAL):
  QMainWindow bridging all parts:
    - DB connection + login (Part1)
    - BFS + CRUD logic (Part2)
    - Simulations, scheduling, metadata sync, validations, what-if (Part3)
    - Audit logs, rule search, version history, dashboard, editor (Part4)
    - Approvals, GCR admin, hierarchy, EnhancedLineageGraphWidget box style (Part5)
    - Metrics, ctrl tables, group mgmt, user mgmt (Part6)
    - Custom groups, alerts, column mapping (Part7)
"""

import sys
from PyQt5.QtWidgets import (
    QMainWindow, QApplication, QWidget, QVBoxLayout,
    QMenuBar, QAction, QMessageBox, QDialog, QHBoxLayout, QLineEdit, QPushButton, QTabWidget, QLabel
)
from PyQt5.QtCore import QTimer
from datetime import datetime

def main():
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool - Part 8 (Final Enhanced)")
        self.resize(1400,900)

        # 1) Database + login from Part1
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection=dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="Unknown"

        # optional wizard
        # wiz=OnboardingWizard(self.connection)
        # wiz.exec_()

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        syncAct=QAction("Sync Metadata",self)
        syncAct.triggered.connect(self.sync_metadata_action)
        fileMenu.addAction(syncAct)

        metricsAct=QAction("View Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        schedAct=QAction("New Schedule (Dialog)",self)
        schedAct.triggered.connect(self.new_schedule_dialog)
        fileMenu.addAction(schedAct)

        chainAct=QAction("Simulate Rule Chain",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        grpAct=QAction("Simulate Custom Group",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        helpMenu=menubar.addMenu("Help")
        usageAct=QAction("Show Tips",self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        toolsMenu=menubar.addMenu("Tools")
        alAct=QAction("View Audit Logs",self)
        alAct.triggered.connect(self.launch_audit_viewer)
        toolsMenu.addAction(alAct)

        srAct=QAction("Search Rules",self)
        srAct.triggered.connect(self.launch_rule_search)
        toolsMenu.addAction(srAct)

        verAct=QAction("Version History (Diff)",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        cw=QWidget()
        main_layout=QVBoxLayout(cw)

        self.tabs=QTabWidget()
        main_layout.addWidget(self.tabs)

        # Part4 => rule dashboard
        brw=QWidget()
        br_lay=QVBoxLayout(brw)
        top_h=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule_handler)
        top_h.addWidget(add_btn)
        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.update_rule_handler)
        top_h.addWidget(upd_btn)
        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.deactivate_rule_handler)
        top_h.addWidget(deact_btn)
        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.delete_rule_handler)
        top_h.addWidget(del_btn)
        bfs_btn=QPushButton("Run Full BFS")
        bfs_btn.clicked.connect(self.run_full_bfs)
        top_h.addWidget(bfs_btn)
        sim1_btn=QPushButton("Sim Single Rule")
        sim1_btn.clicked.connect(self.simulate_single_rule)
        top_h.addWidget(sim1_btn)
        top_h.addStretch()
        br_lay.addLayout(top_h)
        self.brm_dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_lay.addWidget(self.brm_dashboard)
        brw.setLayout(br_lay)
        self.tabs.addTab(brw,"Business Rules")

        # Part5 => approvals
        self.approv_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # GCR admin if admin
        if self.user_group.lower()=="admin":
            self.gcr_tab=GlobalCriticalAdminTab(self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # hierarchy
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # lineage
        lw=QWidget()
        lw_lay=QVBoxLayout(lw)
        lineage_h=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search lineage..")
        srch_btn=QPushButton("Search")
        srch_btn.clicked.connect(self.do_lineage_search)
        lineage_h.addWidget(self.lineage_search)
        lineage_h.addWidget(srch_btn)
        rst_btn=QPushButton("Reset View")
        rst_btn.clicked.connect(self.reset_lineage_view)
        lineage_h.addWidget(rst_btn)
        ref_lin_btn=QPushButton("Refresh Graph")
        ref_lin_btn.clicked.connect(self.refresh_lineage_graph)
        lineage_h.addWidget(ref_lin_btn)
        lineage_h.addStretch()
        lw_lay.addLayout(lineage_h)
        self.lineage_view=EnhancedLineageGraphWidget(self.connection)
        lw_lay.addWidget(self.lineage_view)
        lw.setLayout(lw_lay)
        self.tabs.addTab(lw,"Lineage")

        # part7 => custom groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # part3 => scheduling
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # part6 => ctrl tables
        self.ctrl_tab=CtrlTablesTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # part6 => metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # part7 => alerts
        self.alert_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Perf")

        # group mgmt
        self.grp_mgmt_tab=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # user mgmt
        if self.user_group.lower()=="admin":
            self.user_mgmt_tab=UserManagementTab(self.connection,self.user_id,self.user_group)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        # part7 => column mapping
        self.col_map_tab=ColumnMappingTab(self.connection)
        self.tabs.addTab(self.col_map_tab,"Column Mappings")

        cw.setLayout(main_layout)
        self.setCentralWidget(cw)

        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules_due)
        self.schedule_timer.start(60000)

        self.show()

    def sync_metadata_action(self):
        sync_metadata_improved(self.connection)

    def show_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(900,600)
        l=QVBoxLayout(dlg)
        met=MetricsDashboardTab(self.connection)
        l.addWidget(met)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        l.addWidget(cb)
        dlg.exec_()

    def new_schedule_dialog(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()

    def launch_chain_sim(self):
        dlg=ChainOrGroupSimulationDialog(self.connection,is_group=False,parent=self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=ChainOrGroupSimulationDialog(self.connection,is_group=True,parent=self)
        dlg.exec_()

    def show_help(self):
        QMessageBox.information(self,"Help","BRM Tool => BFS, approvals, lineage, scheduling, etc.")

    def launch_audit_viewer(self):
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_rule_search(self):
        dlg=RuleSearchDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Version History","Rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection,rid,self)
        dlg.exec_()

    def add_rule_handler(self):
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def update_rule_handler(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if len(sel)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=sel[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error",f"No rule with ID={rid}")
            return
        coln=[desc[0] for desc in c.description]
        data=dict(zip(coln,row))
        dlg=RuleEditorDialog(self.connection,self.user_group,data,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def deactivate_rule_handler(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                deactivate_rule(self.connection,rid,self.logged_in_username,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivated => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def delete_rule_handler(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(sel)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                delete_rule(self.connection,rid,self.logged_in_username,self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Delete => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_full_bfs(self):
        ex, passdict, sk=advanced_bfs_execute(self.connection)
        msg=f"ETL BFS => executed={ex}, skipped={list(sk)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def simulate_single_rule(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if len(sel)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule for single simulation.")
            return
        rid=sel[0]
        dlg=SingleRuleSimulationDialog(self.connection,rid,self)
        dlg.exec_()

    def do_lineage_search(self):
        txt=self.lineage_search.text().strip()
        self.lineage_view.perform_search(txt)

    def reset_lineage_view(self):
        self.lineage_view.resetView()

    def refresh_lineage_graph(self):
        self.lineage_view.load_graph()

    def check_schedules_due(self):
        nowstr=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
          FROM RULE_SCHEDULES
          WHERE STATUS='Scheduled'
            AND SCHEDULE_TIME<=?
        """,(nowstr,))
        due=c.fetchall()
        for (sid,rid,ts) in due:
            c2=self.connection.cursor()
            c2.execute("UPDATE RULE_SCHEDULES SET STATUS='InProgress' WHERE SCHEDULE_ID=?",(sid,))
            self.connection.commit()
            ex, passdict, sk=advanced_bfs_execute(self.connection)
            pf=passdict.get(rid,False)
            new_status="Executed" if pf else "Failed"
            c2.execute("UPDATE RULE_SCHEDULES SET STATUS=? WHERE SCHEDULE_ID=?",(new_status,sid))
            self.connection.commit()
        self.sch_tab.load_schedules()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()
if __name__=="__main__":
    main()