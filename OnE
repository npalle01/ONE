
from datetime import datetime
dt = datetime.now()
formatted = dt.strftime('%Y-%m-%d %H:%M:%S')

import sys
import os
import json
import logging
import logging.config
import smtplib
import pyodbc
import sqlparse
import re
from datetime import datetime, timedelta
import re
import logging

from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout,
    QMessageBox, QComboBox, QPlainTextEdit, QCalendarWidget, QTimeEdit,
    QFormLayout, QWidget, QCheckBox, QButtonGroup
)

###############################################################################
# 1) LOGGING CONFIG
###############################################################################
LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_core.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")
logger = logging.getLogger("brm_core_foundation")
logger.setLevel(logging.DEBUG)

###############################################################################
# 2) EMAIL NOTIFIER
###############################################################################
class EmailNotifier:
    """
    Sends emails via SMTP, reading credentials from environment variables
    or falling back to placeholder defaults.
    Enhanced: Provides detailed logging and error reporting.
    Example usage:
        notifier = EmailNotifier()
        notifier.send_email("Test subject", "Hello world", ["someone@example.com"])
    """
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("No recipients provided for email.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email to {recipients}: {e}")
            raise

###############################################################################
# 3) DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):

    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()
        else:
            # Remain in the dialog for user correction
            pass

###############################################################################
# 4) BASIC DB HELPERS
###############################################################################
def fetch_all_dict(cursor):
    """
    Fetch all rows into a list of dicts if description is present, else raw rows.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        out = []
        for r_ in rows:
            out.append(dict(zip(colnames, r_)))
        return out
    else:
        return rows


def fetch_one_dict(cursor):
    """
    Fetch the next row as dict (if present) or None.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None


def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert an audit record into BRM_AUDIT_LOG with optional old/new data as JSON.
    Enhanced: Incorporates robust error handling.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action, table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"Audit log inserted => action={action}, table={table_name}, record_id={record_id}, actor={actor}")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")


class CollaborationManager(QtCore.QObject):
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.last_timestamp = None
        self.timer.start(self.poll_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE, SENDER, TIMESTAMP 
                    FROM COLLABORATION_LOGS 
                    WHERE TIMESTAMP > ? 
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("SELECT MESSAGE, SENDER, TIMESTAMP FROM COLLABORATION_LOGS ORDER BY TIMESTAMP ASC")
            rows = c.fetchall()
            if rows:
                for row in rows:
                    message, sender, ts = row
                    self.newMessage.emit({"message": message, "sender": sender, "timestamp": ts})
                    self.last_timestamp = ts
        except Exception as ex:
            # For production, consider logging this error
            print(f"Error polling collaboration messages: {ex}")
def run_chain_bfs_from_rule(conn, parent_rule_id):


    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_lookup = get_all_rules_map(conn)

    executed = []
    skipped = set()


    visited = set()
    in_stack = set()
    queue = [parent_rule_id]

    while queue:
        rid = queue.pop(0)
        # If we've visited or skipped rid, continue
        if rid in visited or rid in skipped:
            continue

        # Check for cycle
        if rid in in_stack:
            logger.error(f"[BFS] Cycle detected involving rule {rid}. Skipping its branch.")
            skipped.add(rid)
            continue

        # Mark this node in the "currently exploring" set
        in_stack.add(rid)

        if rid not in rule_lookup:
            logger.warning(f"Rule {rid} not found in the lookup. Skipping.")
            skipped.add(rid)
            in_stack.remove(rid)
            continue

        info = rule_lookup[rid]
        # Execute the rule
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=False)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            visited.add(rid)
            # Remove from the exploring set
            in_stack.remove(rid)
            if rid in adjacency:
                for child in adjacency[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            # For critical or global rules, skip all descendants
            if info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1:
                if rid in adjacency:
                    for ch in adjacency[rid]:
                        skip_all_descendants(ch, adjacency, skipped)
            # Also skip direct children in BFS
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
            in_stack.remove(rid)

    return (executed, list(skipped))

def run_bfs(self):
    selected_items = self.rule_table.selectedItems()
    if not selected_items:
        QMessageBox.warning(self, "No Rule Selected", "Please select a rule to run BFS from.")
        return
    # Assuming the rule ID is in the first column:
    rule_id = int(self.rule_table.item(selected_items[0].row(), 0).text())
    executed, skipped = run_chain_bfs_from_rule(self.connection, rule_id)
    msg = f"BFS Execution starting from rule {rule_id}:\nExecuted: {executed}\nSkipped: {skipped}"
    QMessageBox.information(self, "BFS Execution Result", msg)
    self.load_rules()  # Refresh the table if needed.


###############################################################################
# 5) LOCK MANAGER (UNIFIED APPROACH)
###############################################################################
class LockManager:
    """
    A consolidated approach storing locks in BRM_RULE_LOCKS with expiry.
    Provides:
      • auto_unlock_expired_locks: Frees stale locks automatically
      • rule_current_lock_owner: Returns active lock info for a rule
      • lock_rule_for_edit: Locks or refreshes a rule for editing
      • unlock_rule_for_edit: Unlocks a rule, optionally forcing it

    Enhanced:
      - Includes comprehensive error handling, detailed logging,
      - Adds an optional scheduling mechanism for lock expiry checks.
    The BRM_RULE_LOCKS table structure is assumed to include:
       RULE_ID INT,
       LOCKED_BY VARCHAR(100),
       LOCK_TIMESTAMP DATETIME,
       EXPIRY_TIMESTAMP DATETIME,
       FORCE_LOCK BIT,
       ACTIVE_LOCK BIT
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            rc = c.rowcount
            conn.commit()
            if rc > 0:
                logger.info(f"Auto-unlocked {rc} expired rule locks.")
        except Exception as ex:
            logger.error(f"Error auto-unlocking expired locks: {ex}")

    @staticmethod
    def schedule_expiry_checks(app, conn, interval_ms=60000):
        """
        ---- Enhanced / Optional ----
        If you're using PyQt, you can periodically call 'auto_unlock_expired_locks'
        using a QTimer. Add this method to schedule repeated lock expiry checks
        every 'interval_ms' milliseconds (default 60s).
        """
        from PyQt5.QtCore import QTimer
        timer = QTimer(app)
        timer.setInterval(interval_ms)
        timer.timeout.connect(lambda: LockManager.auto_unlock_expired_locks(conn))
        timer.start()
        logger.debug("Scheduled lock expiry checks every %d ms", interval_ms)

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        LockManager.auto_unlock_expired_locks(conn)
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag = row
        now = datetime.now()
        if et and now > et:
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
                logger.info(f"Lock on rule {rule_id} has expired.")
            except Exception as ex:
                logger.error(f"Error expiring lock for rule {rule_id}: {ex}")
            return None
        return (locked_by, lts, et, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if info is not None:
            locked_by, old_ts, old_exp, fflag = info
            if locked_by == user_id:
                # Refresh the existing lock
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock for rule {rule_id} refreshed by {user_id}. Force={force}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly re-locked by {user_id}.")
                    return
        else:
            # No current lock, create a new one
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            logger.debug(f"No active lock found for rule {rule_id} when attempting to unlock.")
            return  # not locked or already expired
        locked_by, lts, et, fflag = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}, cannot unlock.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by user {user_id}, force={force}.")

###############################################################################
# 6) ADVANCED SQL PARSER
###############################################################################
def detect_operation_type(sql_text: str) -> str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, MERGE, WITH, or OTHER.
    Enhanced to detect top-level MERGE statements, or top-level WITH hints
    that might contain merges/queries. (We treat top-level "WITH" as "OTHER" or
    do a quick next token check).

    Strips leading comments and whitespace before determining operation.
    """
    # Remove inline and block comments
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text, flags=re.MULTILINE | re.DOTALL).strip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("MERGE"):
        return "MERGE"
    elif up.startswith("SELECT"):
        return "SELECT"
    elif up.startswith("WITH"):
        # "WITH" might lead to a CTE used for an INSERT, SELECT, MERGE, etc.
        # We'll parse for the next real token, but for simplicity let's call it "WITH"
        return "WITH"
    else:
        return "OTHER"


def parse_sql_dependencies(sql_text: str):
    try:
        statements = sqlparse.parse(sql_text)
    except Exception as ex:
        logger.error(f"SQL parsing error: {ex}")
        return {"tables": [], "cte_tables": [], "alias_map": {}, "columns": []}

    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []

    for stmt in statements:
        ctes = _extract_with_clauses(stmt)
        for cName, cRefs in ctes.items():
            cte_info.append((cName, cRefs))

        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)

    unique_tables = list({x for x in all_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }


def _extract_with_clauses(statement):
    tokens = list(statement.tokens)
    i = 0
    cte_map = {}
    from sqlparse.tokens import Keyword

    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map


def _parse_cte_block(tokens, i, cte_map):
    from sqlparse.sql import Identifier, Parenthesis
    from sqlparse.tokens import Keyword

    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT", "INSERT", "UPDATE", "DELETE"):
            return i
        else:
            i += 1
    return i


def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    from sqlparse.sql import Parenthesis
    while i < len(tokens):
        tk = tokens[i]
        if tk.value.upper() == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i


def _extract_subselect_tokens(tokens):
    from sqlparse.sql import IdentifierList, Identifier
    from sqlparse.tokens import Keyword
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if hasattr(tk, "is_group") and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, set())
                    st = (st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st = _parse_identifier(tk, set())
                st = (st[0], st[1], st[2], True)
                results.append(st)
        i += 1
    return results


def _is_subselect(token):
    from sqlparse.tokens import DML
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper() == "SELECT":
            return True
    return False


def _extract_main_from(tokenlist, known_cte_names):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import IdentifierList, Identifier
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if hasattr(tk, "is_group") and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM", "JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, known_cte_names)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]] = (st[0], st[1])
            elif isinstance(tk, Identifier):
                st = _parse_identifier(tk, known_cte_names)
                results.append(st)
                if st[2]:
                    alias_map[st[2]] = (st[0], st[1])
        i += 1
    return (results, alias_map)


def _parse_identifier(ident, known_cte_names):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema = ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema, real_name, alias, False)


def _extract_columns(statement):
    from sqlparse.tokens import DML, Keyword
    from sqlparse.sql import IdentifierList, Identifier, Parenthesis
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is DML:
            upv = tk.value.upper()
            if upv == "SELECT":
                results.extend(_parse_select_list(tokens, i + 1))
            elif upv in ("INSERT", "UPDATE"):
                results.extend(_parse_dml_columns(tokens, i, upv))
        i += 1
    return results


def _parse_select_list(tokens, start_idx):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import IdentifierList, Identifier
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM", "JOIN", "WHERE", "GROUP", "ORDER", "UNION", "INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                nm = ident.get_name()
                if nm and nm.upper() not in ("DISTINCT", "TOP", "ALL"):
                    columns.append(nm)
        elif isinstance(tk, Identifier):
            nm = tk.get_name()
            if nm and nm.upper() not in ("DISTINCT", "TOP", "ALL"):
                columns.append(nm)
        i += 1
    return columns


def _parse_dml_columns(tokens, start_idx, dml_word):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import Parenthesis, IdentifierList, Identifier
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                for sub in tk.tokens:
                    if isinstance(sub, IdentifierList):
                        for ident in sub.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(sub, Identifier):
                        columns.append(sub.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return columns


def _parse_update_set_list(tokens, start_i):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import Identifier
    cols = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE", "FROM"):
            break
        if isinstance(tk, Identifier):
            cols.append(tk.get_name())
        i += 1
    return cols

###############################################################################
# 7) LOGIN DIALOG (PLAIN TEXT PASSWORD COMPARISON)
###############################################################################
# !/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QMessageBox

logger = logging.getLogger("brm_core_foundation")


class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password dialog that checks the USERS table.
    Uses plain-text password comparison.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – Part 1 (Enhanced)")
        self.resize(300, 150)

        main_layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_layout.addWidget(QLabel("Username:"))
        main_layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(QLabel("Password:"))
        main_layout.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_layout.addWidget(login_btn)

        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()

        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password are required.")
            return

        try:
            logger.debug(f"Attempting login for user: {un}")
            c = self.connection.cursor()
            c.execute("""
                SELECT USER_ID, USER_GROUP 
                FROM USERS
                WHERE USERNAME = ? AND PASSWORD = ?
            """, (un, pw))
            row = c.fetchone()
            if row:
                self.user_id = row[0]
                self.user_group = row[1]
                logger.info(f"User {un} logged in successfully. user_id={self.user_id}, user_group={self.user_group}")
                self.accept()
            else:
                logger.warning(f"Login failed for user: {un} - Invalid credentials.")
                QMessageBox.warning(self, "Login Failed", "Invalid credentials.")
        except Exception as ex:
            logger.exception("Error during login:")
            QMessageBox.critical(self, "Database Error", f"An error occurred during login:\n{ex}")


###############################################################################
# 8) ONBOARDING WIZARD (FULLY IMPLEMENTED)
###############################################################################
class OnboardingWizard(QDialog):
    """
    A multi-step wizard for brand-new users:
      Step 1) create a group
      Step 2) create a rule
      Step 3) schedule it
    Then done. This wizard provides explicit guidance with no placeholders.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_step = 0
        self.setWindowTitle("Onboarding Wizard – Part 1")
        self.resize(400, 250)
        main_l = QVBoxLayout(self)

        self.label = QLabel("Welcome to the BRM Tool! This wizard helps new users complete initial setup.")
        main_l.addWidget(self.label)

        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        main_l.addWidget(self.next_btn)

        self.setLayout(main_l)

    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Navigate to 'Group Management' to create a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Navigate to 'Business Rules' to add a new rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Navigate to 'Scheduling' to schedule your new rule.")
        else:
            self.label.setText("Setup complete! Enjoy using the BRM Tool.")
            self.accept()

###############################################################################
# UTILITY: SYNC METADATA (IMPROVED)
###############################################################################
def sync_metadata_improved(conn):
    """
    Synchronizes metadata by comparing real tables (from sys.tables) with BRM_RULE_TABLE_DEPENDENCIES.
    Marks missing table references with a 'MISSING_' prefix.
    Enhanced: Provides comprehensive error handling and logging.
    """
    try:
        c = conn.cursor()
        c.execute("""
            SELECT s.name AS schema_name, t.name AS table_name
            FROM sys.tables t
            JOIN sys.schemas s ON t.schema_id=s.schema_id
            ORDER BY s.name, t.name
        """)
        actual_tables = set()
        for row in c.fetchall():
            full_n = (f"{row[0]}.{row[1]}").lower()
            actual_tables.add(full_n)

        c.execute("""
            SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps = c.fetchall()
        missing_count = 0
        for (dep_id, dbn, tbl) in deps:
            if not tbl:
                continue
            low_tbl = tbl.lower().strip()
            if "." not in low_tbl:
                low_tbl = f"dbo.{low_tbl}"
            if low_tbl not in actual_tables:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_TABLE_DEPENDENCIES
                    SET TABLE_NAME = 'MISSING_' + TABLE_NAME
                    WHERE DEPENDENCY_ID=?
                """, (dep_id,))
                missing_count += 1

        conn.commit()
        msg = (f"Metadata sync complete. Found {len(actual_tables)} real DB tables.\n"
               f"Scanned {len(deps)} dependencies.\n"
               f"Marked {missing_count} references as 'MISSING_'.")
        logger.info(msg)
        return msg
    except Exception as ex:
        logger.error(f"Sync metadata error: {ex}")
        return f"Sync error: {ex}"
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 2 
Advanced functionality includes:
  • BFS-based rule execution (unified approach) with robust error handling.
  • Construction of adjacency for child rules, conflicts, global-critical links, and composite references.
  • Fully implemented multi-step approvals, dynamically determining impacted business groups.
  • Advanced CRUD operations (add, update, deactivate, delete) with lock management and dependency re-parsing.
  • Data validation execution logic integrated with detailed logging.
  • Decision table execution: fetches and runs the decision query from DECISION_TABLES.
  • Dry-run simulation of rule execution (both chain and custom group rules) without placeholders.
"""


def run_data_validations(conn):
    """
    Executes all data validations defined in the DATA_VALIDATIONS table.
    For each validation, it runs a query based on the validation type:
      - For "NOT NULL": checks that the specified column contains no NULL values.
      - For "RANGE": expects parameters like "min=0;max=100" and checks that numeric values in the column fall within this range.
      - For "UNIQUE": checks that the specified column does not contain duplicate values.
    The results are logged into the DATA_VALIDATION_LOGS table.
    """
    cursor = conn.cursor()

    try:
        cursor.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        validations = cursor.fetchall()
    except Exception as e:
        logger.error("Error fetching validations: %s", e)
        return

    for val in validations:
        validation_id, table_name, column_name, validation_type, params = val
        result_flag = "PASS"
        details = ""
        try:
            if validation_type.upper() == "NOT NULL":
                # Check that the specified column contains no NULL values.
                query = f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL"
                cursor.execute(query)
                count = cursor.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} rows have NULL in column '{column_name}'."
                else:
                    details = f"All rows have non-NULL values in column '{column_name}'."
            elif validation_type.upper() == "RANGE":
                # Expecting parameters in the format: "min=0;max=100"
                min_val = None
                max_val = None
                if params:
                    for part in params.split(";"):
                        part = part.strip()
                        if part.lower().startswith("min="):
                            min_val = float(part.split("=")[1])
                        elif part.lower().startswith("max="):
                            max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid parameters for RANGE validation."
                else:
                    # Check that all numeric values in the column are within the given range.
                    query = f"""
                        SELECT COUNT(*) FROM {table_name}
                        WHERE TRY_CAST({column_name} AS FLOAT) IS NOT NULL 
                          AND (TRY_CAST({column_name} AS FLOAT) < {min_val} OR TRY_CAST({column_name} AS FLOAT) > {max_val})
                    """
                    cursor.execute(query)
                    count = cursor.fetchone()[0]
                    if count > 0:
                        result_flag = "FAIL"
                        details = f"{count} rows have values outside the range [{min_val}, {max_val}]."
                    else:
                        details = f"All rows have values within the range [{min_val}, {max_val}]."
            elif validation_type.upper() == "UNIQUE":
                # Check that the column values are unique.
                query = f"""
                    SELECT COUNT(*) FROM (
                        SELECT {column_name}, COUNT(*) AS cnt
                        FROM {table_name}
                        GROUP BY {column_name}
                        HAVING COUNT(*) > 1
                    ) AS duplicates
                """
                cursor.execute(query)
                count = cursor.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} duplicate value(s) found in column '{column_name}'."
                else:
                    details = f"All values in column '{column_name}' are unique."
            else:
                result_flag = "FAIL"
                details = f"Validation type '{validation_type}' not implemented."
        except Exception as ex:
            result_flag = "FAIL"
            details = f"Error during validation: {ex}"

        # Log the result in DATA_VALIDATION_LOGS.
        try:
            cursor.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP)
                VALUES(?, ?, ?, GETDATE())
            """, (validation_id, result_flag, details))
            conn.commit()
        except Exception as log_ex:
            logger.error(f"Error logging validation {validation_id}: {log_ex}")


###############################################################################
# 1) BFS RULE EXECUTION (UNIFIED)
###############################################################################
def execute_rules_unified_bfs(conn, dry_run=False):
    """
    Executes rules using a unified BFS approach.
    Runs data validations first, then processes each rule in BFS order.
    Logs execution outcomes into RULE_EXECUTION_LOGS.
    Returns two lists: executed and skipped rule IDs.
    """
    run_data_validations(conn)
    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_lookup = get_all_rules_map(conn)
    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info = rule_lookup[rid]
        # Run the rule in a transaction
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # For critical or global rules, skip all descendants
            is_crit = (info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1)
            if is_crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))


###############################################################################
# 2) LOAD RULE RELATIONSHIPS & SUPPORT FUNCTIONS
###############################################################################
def load_rule_relationships(conn):
    """
    Constructs an adjacency list for:
      - Child rules (via PARENT_RULE_ID)
      - Conflict links (from RULE_CONFLICTS, two-way)
      - Global-critical links (from BRM_GLOBAL_CRITICAL_LINKS, one-way)
      - Composite references (from COMPOSITE_RULES, sub-rule -> composite rule)
    Returns a tuple: (adjacency_dict, list_of_root_rule_ids, parent_map).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid

    # Add conflict links (bidirectional)
    c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
    conflicts = c.fetchall()
    for (r1, r2) in conflicts:
        adjacency.setdefault(r1, set()).add(r2)
        adjacency.setdefault(r2, set()).add(r1)

    # Add global-critical links (one directional: parent->child)
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcrs = c.fetchall()
    for (gcr, tgt) in gcrs:
        adjacency.setdefault(gcr, set()).add(tgt)

    # Add composite links (sub-rule -> composite rule)
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp_rows = c.fetchall()
    pat = re.compile(r"Rule(\d+)")
    for (comp_id, expr) in comp_rows:
        if expr:
            matches = pat.findall(expr)
            for m in matches:
                try:
                    sub_id = int(m)
                    adjacency.setdefault(sub_id, set()).add(comp_id)
                except Exception as ex:
                    logger.error(f"Error parsing composite rule expression: {ex}")
                    continue

    child_ids = set(parent_map.keys())
    roots = [rid for rid in all_ids if rid not in child_ids]
    return (adjacency, roots, parent_map)


def skip_all_descendants(start_id, adjacency, skipped):
    """
    Recursively marks all descendants reachable from start_id as skipped.
    Uses a stack-based approach. If a cycle is encountered, we also skip that node.
    """
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for child in adjacency[cur]:
                if child not in skipped:
                    stack.append(child)

def get_all_rules_map(conn):
    """
    Returns a dictionary mapping RULE_ID to the complete rule row (as a dict) from BRM_RULES.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    rule_map = {}
    for row in rows:
        d = dict(zip(colnames, row))
        rule_map[d["RULE_ID"]] = d
    return rule_map

###############################################################################
# 3) RUN SINGLE RULE IN TRANSACTION
###############################################################################
def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    Executes a single rule within a transaction.
    If the rule's operation type is "DECISION_TABLE", it executes the decision table logic.
    Otherwise, it executes the SQL contained in RULE_SQL and checks for a PASS (1) result.
    Returns a tuple: (success_flag, message, record_count).
    Enhanced: Fully implemented with robust error/transaction management.
    """
    op_type = rule_info.get("OPERATION_TYPE", "OTHER")
    if op_type.upper() == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False, "No DECISION_TABLE_ID provided", 0)
        # Execute the decision table logic
        ok, msg, rec_count = execute_decision_table(conn, dt_id, dry_run=True)
        return (ok, msg, rec_count)

    sql_ = rule_info.get("RULE_SQL") or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Error beginning transaction for rule {rule_info.get('RULE_ID')}: {ex}")
        return (False, str(ex), 0)
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        try:
            rows = c.fetchall()
        except Exception:
            rows = []
        if rows:
            rec_count = len(rows)
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows returned => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except Exception:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

###############################################################################
# 4) INSERT RULE EXECUTION LOG
###############################################################################
def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Inserts an execution log record into RULE_EXECUTION_LOGS.
    Enhanced: Fully implemented with error handling.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
              CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting rule execution log for rule {rule_id}: {ex}")

###############################################################################
# 5) DECISION TABLE EXECUTION
###############################################################################
def execute_decision_table(conn, dt_id, dry_run=True):
    """
    Executes a decision table:
      - Fetches the DECISION_QUERY from DECISION_TABLES.
      - Executes the query in a transaction.
      - If the first column of the first row equals 1, it is considered a PASS.
      - Always rollbacks if dry_run is True.
    Returns a tuple: (success_flag, message, record_count).
    Enhanced: Fully implemented without placeholders.
    """
    c_dt = conn.cursor()
    c_dt.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c_dt.fetchone()
    if not row:
        return (False, f"Decision table {dt_id} not found.", 0)
    decision_query = row[0] or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        logger.error(f"Error starting transaction for decision table {dt_id}: {ex}")
        return (False, str(ex), 0)
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(decision_query)
        try:
            rows = c.fetchall()
        except Exception:
            rows = []
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Decision table returned: {val}"
        else:
            success = True
            msg = "No rows returned => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except Exception:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rec_count)

###############################################################################
# 6) DECISION TABLE EXECUTION LOGGING
###############################################################################
def insert_decision_table_log(conn, dt_id, pass_flag, message, record_count):
    """
    Inserts a decision table execution log into DECISION_TABLE_EXEC_LOGS.
    Enhanced: Fully implemented.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO DECISION_TABLE_EXEC_LOGS(
              DECISION_TABLE_ID, EXEC_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT
            )
            VALUES(?, GETDATE(), ?, ?, ?)
        """, (dt_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"Error inserting decision table log for DT {dt_id}: {ex}")

###############################################################################
# 7) DRY-RUN SIMULATIONS (CHAIN & GROUP)
###############################################################################
def dry_run_rule_sql(conn, sql_text):
    """
    Executes the given SQL in a transaction, evaluates the result (first column equals 1 => PASS),
    and always rollbacks.
    Returns (success_flag, message).
    Enhanced: Fully implemented with robust transaction management.
    """
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False, f"Error starting transaction: {ex}")
    success = True
    message = ""
    try:
        c.execute(sql_text)
        try:
            rows = c.fetchall()
        except Exception:
            rows = []
        if rows:
            val = rows[0][0]
            success = (val == 1)
            message = f"Returned: {val}"
        else:
            success = True
            message = "No rows returned => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        message = str(ex)
    return (success, message)


def simulate_chain_bfs(conn, parent_rule_id):
    """
    Simulates rule execution in a BFS chain starting from parent_rule_id.
    For DECISION_TABLE rules, executes the decision table query.
    For others, uses dry_run_rule_sql.
    Returns two lists: executed and skipped rule IDs.
    Enhanced: Fully implemented without placeholders.
    """
    adjacency, roots, parent_map = load_rule_relationships(conn)
    c = conn.cursor()
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_type, dt_id) in rows:
        rule_map[rid] = (sql_ or "", op_type or "OTHER", dt_id)
    executed = []
    skipped = set()
    queue = [parent_rule_id]

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_text)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # For critical rules, skip all descendants
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))


def simulate_custom_group_rules(conn, custom_group_id):
    """
    Simulates rule execution for all rules assigned to a custom group.
    Each rule is executed individually using dry_run_rule_sql or decision table execution.
    Returns two lists: passed and failed rule IDs.
    Enhanced: Fully implemented.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rule_ids = [r[0] for r in c.fetchall()]
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    all_rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_type, dt_id) in all_rows:
        rule_map[rid] = (sql_ or "", op_type or "OTHER", dt_id)
    passed = []
    failed = []
    for rid in rule_ids:
        if rid not in rule_map:
            failed.append(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_text)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
    return (passed, failed)

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 3 of 8 (FINAL, REVISED + FULLY ENHANCED)
Focuses on:
 • Advanced scheduling UI (EnhancedScheduleDialog and ScheduleManagementTab)
 • Fully implemented chain and custom group simulation dialogs (ChainSimulationDialog and GroupSimulationDialog)
 • Fully functional feature tabs:
     - DecisionTablesTab: Execute decision table queries (integrated with execute_decision_table)
     - ConflictPriorityManagerTab: Manage conflicts with add, update, delete operations
     - CompositeRulesTab: Create, list, and delete composite rules using logical expressions
     - SnapshotManagerTab: Take snapshots of BRM_RULES (as JSON) and delete them
     - TagsManagerTab: Assign and remove textual tags to rules
     - DataValidationTab: Manage data validations and execute them with detailed results
     - WhatIfTestTab: Allow rule dry-run testing (with CSV upload support)
 • sync_metadata_improved is re-used here (in sync with Part 1)
No placeholders or minimal implementations remain.
All advanced BFS, concurrency, logging, and database operations from Parts 1–2 are assumed to be accessible.
"""

import sys
import os
import logging
import re
import csv
import math
import time
import pyodbc
import sqlparse
from datetime import datetime, timedelta
from collections import deque

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDate, QTime, QDateTime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox,
    QMessageBox, QLineEdit, QDialog, QTableWidget, QTableWidgetItem,
    QCalendarWidget, QCheckBox, QInputDialog, QPlainTextEdit, QFileDialog, QRadioButton, QGroupBox
)

# Assumed imports from Part 1 and Part 2:
# - logger, insert_audit_log, fetch_all_dict, fetch_one_dict, LockManager,
# - detect_operation_type, parse_sql_dependencies, skip_all_descendants,
# - run_data_validations, execute_decision_table (from PART 2), etc.

###############################################################################
# SYNC METADATA (IMPROVED)
###############################################################################
def sync_metadata_improved(conn):
    """
    Marks missing table references in BRM_RULE_TABLE_DEPENDENCIES by prefixing 'MISSING_'.
    Fully enhanced with robust error handling.
    """
    try:
        c = conn.cursor()
        c.execute("""
            SELECT s.name AS schema_name, t.name AS table_name
            FROM sys.tables t
            JOIN sys.schemas s ON t.schema_id=s.schema_id
            ORDER BY s.name, t.name
        """)
        actual_tables = set()
        for row in c.fetchall():
            full_n = (f"{row[0]}.{row[1]}").lower()
            actual_tables.add(full_n)

        c.execute("""
            SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps = c.fetchall()
        missing_count = 0
        for (dep_id, dbn, tbl) in deps:
            if not tbl:
                continue
            low_tbl = tbl.lower().strip()
            if "." not in low_tbl:
                low_tbl = f"dbo.{low_tbl}"
            if low_tbl not in actual_tables:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_TABLE_DEPENDENCIES
                    SET TABLE_NAME='MISSING_' + TABLE_NAME
                    WHERE DEPENDENCY_ID=?
                """, (dep_id,))
                missing_count += 1

        conn.commit()
        msg = (f"Metadata sync complete. Found {len(actual_tables)} real DB tables.\n"
               f"Scanned {len(deps)} dependencies.\n"
               f"Marked {missing_count} references as 'MISSING_'.")
        logger.info(msg)
        return msg
    except Exception as ex:
        logger.error(f"Sync metadata error: {ex}")
        return f"Sync error: {ex}"

###############################################################################
# DRY-RUN SIMULATIONS (CHAIN and CUSTOM GROUP)
###############################################################################
def dry_run_rule_sql(conn, sql_text):
    """
    Executes the given SQL in a transaction and evaluates its result:
      - If the first column of the first row equals 1, it is considered PASS.
      - Always rollbacks the transaction.
    Returns (success_flag, message).
    """
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except Exception as ex:
        return (False, f"Transaction start error: {ex}")
    try:
        c.execute(sql_text)
        try:
            rows = c.fetchall()
        except Exception:
            rows = []
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows returned => PASS"
        c.execute("ROLLBACK")
        return (success, msg)
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except Exception:
            pass
        return (False, str(ex))


def simulate_chain_bfs(conn, parent_rule_id):
    """
    Simulates a BFS chain dry-run starting from parent_rule_id.
    For DECISION_TABLE rules, executes the decision table query.
    Returns two lists: executed and skipped rule IDs.
    Fully implemented with robust error handling.
    """
    adjacency, roots, parent_map = load_rule_relationships(conn)
    c = conn.cursor()
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    rows = c.fetchall()
    rule_map = {}
    for (rid, sql_text, op_type, dt_id) in rows:
        rule_map[rid] = (sql_text or "", op_type or "OTHER", dt_id)
    executed = []
    skipped = set()
    queue = [parent_rule_id]

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_text)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child in adjacency[rid]:
                    if child not in skipped:
                        queue.append(child)
        else:
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)
    return (executed, list(skipped))


def simulate_custom_group_rules(conn, custom_group_id):
    """
    Simulates a dry-run for each rule assigned to a custom group.
    Executes each rule individually (using decision table logic if needed).
    Returns two lists: passed and failed rule IDs.
    Fully implemented.
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rule_ids = [r[0] for r in c.fetchall()]
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    all_rows = c.fetchall()
    rule_map = {}
    for (rid, sql_text, op_type, dt_id) in all_rows:
        rule_map[rid] = (sql_text or "", op_type or "OTHER", dt_id)
    passed = []
    failed = []
    for rid in rule_ids:
        if rid not in rule_map:
            failed.append(rid)
            continue
        sql_text, op_type, dt_id = rule_map[rid]
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, _ = execute_decision_table(conn, dt_id, dry_run=True)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_text)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
    return (passed, failed)

###############################################################################
# ADVANCED SCHEDULING
###############################################################################
class EnhancedScheduleDialog(QtWidgets.QDialog):
    """
    A fully functional scheduling dialog that allows the user to:
      - Select a rule
      - Pick a date and time (with calendar and time edit widgets)
      - Optionally select to run data validations before rule execution
      - Insert the schedule into RULE_SCHEDULES with robust error handling.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling – Part 3")
        self.resize(400, 300)
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setSelectedDate(QtCore.QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        self.run_val_checkbox = QCheckBox("Run Data Validations Before Rule?")
        self.run_val_checkbox.setChecked(False)
        form.addRow(self.run_val_checkbox)

        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        btn_layout.addWidget(sch_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_str = self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str = self.time_edit.time().toString("HH:mm:ss")
        dt_str = f"{date_str} {time_str}"
        run_val_flag = 1 if self.run_val_checkbox.isChecked() else 0
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(
                  RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, RUN_DATA_VALIDATIONS
                )
                VALUES(?, ?, 'Scheduled', GETDATE(), ?)
            """, (rid, dt_str, run_val_flag))
            self.connection.commit()
            QMessageBox.information(self, "Scheduled",
                                    f"Rule {rid} scheduled at {dt_str}, validations={bool(run_val_flag)}.")
            self.close()
        except Exception as ex:
            QMessageBox.critical(self, "Schedule Error", str(ex))

###############################################################################
# SCHEDULE MANAGEMENT TAB
###############################################################################
class ScheduleManagementTab(QtWidgets.QWidget):
    """
    Displays the RULE_SCHEDULES table with functionality to refresh,
    add new schedules, update, and delete schedules.
    Fully implemented with robust error handling.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID", "RuleID", "ScheduleTime", "Status", "RunVal?", "Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(refresh_btn)
        # Assuming button_layout is where your Refresh button is added:
        btn_layout = QHBoxLayout()
        run_bfs_button = QPushButton("Execute Rule")
        run_bfs_button.clicked.connect(self.run_bfs)
        btn_layout.addWidget(run_bfs_button)

        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_layout.addWidget(add_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS
                FROM RULE_SCHEDULES
                ORDER BY SCHEDULE_TIME DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                for col_index in range(5):
                    self.table.setItem(row_index, col_index, QTableWidgetItem(str(row[col_index])))
                # Action cell: Update and Delete buttons
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                action_layout.setContentsMargins(0, 0, 0, 0)
                update_btn = QPushButton("Update")
                update_btn.clicked.connect(lambda _, idx=row_index: self.update_schedule(idx))
                delete_btn = QPushButton("Delete")
                delete_btn.clicked.connect(lambda _, idx=row_index: self.delete_schedule(idx))
                action_layout.addWidget(update_btn)
                action_layout.addWidget(delete_btn)
                action_layout.addStretch()
                self.table.setCellWidget(row_index, 5, action_widget)
            self.table.resizeColumnsToContents()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_index):
        sched_item = self.table.item(row_index, 0)
        if not sched_item:
            return
        schedule_id = int(sched_item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE RULE_SCHEDULES
                SET SCHEDULE_TIME=?
                WHERE SCHEDULE_ID=?
            """, (new_dt.strip(), schedule_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {schedule_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Update Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, row_index):
        sched_item = self.table.item(row_index, 0)
        if not sched_item:
            return
        schedule_id = int(sched_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {schedule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (schedule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Schedule {schedule_id} removed.")
        except Exception as ex:
            QMessageBox.critical(self, "Delete Error", str(ex))
        self.load_schedules()

###############################################################################
# CHAIN/GROUP SIMULATION DIALOGS (BFS DRY-RUN)
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    Dialog to simulate rule execution via BFS chain starting from a selected parent rule.
    Shows executed and skipped rule IDs.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation – Part 3")
        self.resize(550, 400)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        top_layout.addWidget(QLabel("Select Parent Rule:"))
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_layout.addWidget(self.rule_combo)
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Run Chain BFS (Dry-run)")
        run_btn.clicked.connect(self.do_simulation)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_simulation(self):
        parent_rule_id = self.rule_combo.currentData()
        executed, skipped = simulate_chain_bfs(self.connection, parent_rule_id)
        msg = (f"Chain BFS starting from {parent_rule_id}:\n"
               f"Executed: {executed}\n"
               f"Skipped: {skipped}")
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Chain Simulation Result", msg)


class GroupSimulationDialog(QDialog):
    """
    Dialog to simulate dry-run for all rules assigned to a custom group.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation – Part 3")
        self.resize(600, 450)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        top_layout.addWidget(QLabel("Select Custom Group:"))
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for (cid, gn) in c.fetchall():
            disp = f"{cid} - {gn}"
            self.group_combo.addItem(disp, cid)
        top_layout.addWidget(self.group_combo)
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_layout = QHBoxLayout()
        run_btn = QPushButton("Run Group Simulation (Dry-run)")
        run_btn.clicked.connect(self.do_simulation)
        btn_layout.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def do_simulation(self):
        group_id = self.group_combo.currentData()
        passed, failed = simulate_custom_group_rules(self.connection, group_id)
        msg = (f"Custom Group Simulation for group {group_id}:\n"
               f"Passed: {passed}\n"
               f"Failed: {failed}")
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Group Simulation Result", msg)

###############################################################################
# DECISION TABLES TAB
###############################################################################
class DecisionTablesTab(QtWidgets.QWidget):
    """
    Manages decision tables: listing, adding, deleting, and executing decision table queries.
    Fully implemented to run the decision table execution and log the results.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID", "Name", "Description"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete DT")
        del_btn.clicked.connect(self.delete_dt)
        btn_layout.addWidget(del_btn)
        run_btn = QPushButton("Execute DT")
        run_btn.clicked.connect(self.run_dt)
        btn_layout.addWidget(run_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        btn_layout.addWidget(ref_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.dt_table.rowCount()
                self.dt_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.dt_table.setItem(r_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional:")
        if not ok2:
            desc = ""
        query_text, ok3 = QInputDialog.getMultiLineText(self, "Decision Query",
                                                        "Enter SQL query that returns 1 (PASS) or 0 (FAIL):")
        if not ok3 or not query_text.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION, DECISION_QUERY, CREATED_TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """, (name.strip(), desc.strip(), query_text.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision Table created.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No Decision Table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete Decision Table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision Table removed.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No Decision Table selected.")
            return
        dt_id = int(self.dt_table.item(row, 0).text())
        # Execute decision table with dry-run execution
        ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        # Log execution
        insert_decision_table_log(self.connection, dt_id, ok, msg, rec_count)
        result_text = f"Decision Table {dt_id} executed: PASS={ok}, Message='{msg}', Records={rec_count}"
        QMessageBox.information(self, "Execution Result", result_text)

###############################################################################
# CONFLICT PRIORITY MANAGER TAB
###############################################################################
class ConflictPriorityManagerTab(QtWidgets.QWidget):
    """
    Manages RULE_CONFLICTS: allows adding a conflict, setting priority, and deleting a conflict.
    Fully implemented with error handling.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        btn_layout.addWidget(set_btn)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY
                FROM RULE_CONFLICTS
                ORDER BY CONFLICT_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.cf_table.rowCount()
                self.cf_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.cf_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:", value=1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_priority, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No conflict selected.")
            return
        cf_id = int(self.cf_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Conflict deleted.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# COMPOSITE RULES TAB
###############################################################################
class CompositeRulesTab(QtWidgets.QWidget):
    """
    Manages composite rules: add new composite rules and delete existing ones.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["CompRuleID", "Name", "Logic Expression", "ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_composite)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.delete_composite)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_composites)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
                FROM COMPOSITE_RULES
                ORDER BY COMPOSITE_RULE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.cr_table.rowCount()
                self.cr_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.cr_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_composite(self):
        name, ok = QInputDialog.getText(self, "Add Composite Rule", "Name:")
        if not ok or not name.strip():
            return
        expr, ok2 = QInputDialog.getMultiLineText(self, "Logic Expression",
                                                  "Enter logic expression (e.g., 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr = ""
        action, ok3 = QInputDialog.getText(self, "Action on Pass", "Enter action (e.g., 'SendEmail') (Optional):")
        if not ok3:
            action = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
                VALUES(?,?,?)
            """, (name.strip(), expr.strip(), action.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Composite rule added successfully.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_composite(self):
        row = self.cr_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No composite rule selected.")
            return
        comp_id = int(self.cr_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {comp_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (comp_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Composite rule deleted.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# SNAPSHOT MANAGER TAB
###############################################################################
class SnapshotManagerTab(QtWidgets.QWidget):
    """
    Displays snapshots of BRM_RULES stored as JSON.
    Allows taking a snapshot and deleting existing snapshots.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID", "Name", "CreatedBy", "CreatedTS", "JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        btn_layout = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_layout.addWidget(take_btn)
        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_snapshots)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.ss_table.rowCount()
                self.ss_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.ss_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Enter snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            snapshot_data = [dict(zip(colnames, r)) for r in rows]
            snapshot_json = json.dumps(snapshot_data, indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
                VALUES(?, ?, ?)
            """, (name.strip(), "SnapshotUser", snapshot_json))
            self.connection.commit()
            QMessageBox.information(self, "Snapshot", "Snapshot created successfully.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        snap_id = int(self.ss_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {snap_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Snapshot deleted.")
            self.load_snapshots()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# TAGS MANAGER TAB
###############################################################################
class TagsManagerTab(QtWidgets.QWidget):
    """
    Manages rule tags: allows adding and removing tags assigned to rules.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        btn_layout.addWidget(add_btn)
        remove_btn = QPushButton("Remove Tag")
        remove_btn.clicked.connect(self.remove_tag)
        btn_layout.addWidget(remove_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_tags)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT TAG_ID, RULE_ID, TAG_NAME
                FROM RULE_TAGS
                ORDER BY TAG_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.tags_table.rowCount()
                self.tags_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.tags_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "Enter RuleID:")
        if not ok:
            return
        tag_name, ok2 = QInputDialog.getText(self, "Tag", "Enter tag name:")
        if not ok2 or not tag_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?, ?)", (rule_id, tag_name.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Tag assigned successfully.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        tag_id = int(self.tags_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Tag removed successfully.")
            self.load_tags()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# DATA VALIDATION TAB
###############################################################################
class DataValidationTab(QtWidgets.QWidget):
    """
    Manages data validations: allows adding and removing validations,
    and executing all validations with pass/fail results.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dv_table = QTableWidget(0, 6)
        self.dv_table.setHorizontalHeaderLabels([
            "ValID", "TableName", "ColumnName", "ValType", "Params", "LastResult"
        ])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_layout.addWidget(add_btn)
        remove_btn = QPushButton("Remove Validation")
        remove_btn.clicked.connect(self.remove_validation)
        btn_layout.addWidget(remove_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        btn_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT V.VALIDATION_ID, V.TABLE_NAME, V.COLUMN_NAME, V.VALIDATION_TYPE,
                       V.PARAMS,
                       (SELECT TOP 1 DETAILS FROM DATA_VALIDATION_LOGS L
                        WHERE L.VALIDATION_ID=V.VALIDATION_ID
                        ORDER BY L.VALIDATION_TIMESTAMP DESC
                       ) AS LAST_RESULT
                FROM DATA_VALIDATIONS V
                ORDER BY V.VALIDATION_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_index = self.dv_table.rowCount()
                self.dv_table.insertRow(r_index)
                for col, val in enumerate(row):
                    self.dv_table.setItem(r_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Enter table name (e.g., dbo.Customers):")
        if not ok or not table_name.strip():
            return
        column_name, ok2 = QInputDialog.getText(self, "Column", "Enter column name:")
        if not ok2 or not column_name.strip():
            return
        val_type, ok3 = QInputDialog.getText(self, "Validation Type", "Enter validation type (e.g., NOT NULL, RANGE):")
        if not ok3 or not val_type.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Parameters", "Optional parameters (e.g., min=0;max=100):")
        if not ok4:
            params = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP)
                VALUES(?,?,?,?,GETDATE())
            """, (table_name.strip(), column_name.strip(), val_type.strip(), params.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Data validation added successfully.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        val_id = int(self.dv_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation ID {val_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (val_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Validation removed.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_all_validations(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Validations Run", "All validations executed. Check results.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_validations()

###############################################################################
# WHAT-IF TEST TAB
###############################################################################
class WhatIfTestTab(QtWidgets.QWidget):
    """
    Lets the user pick a rule and optionally upload a CSV file.
    Executes a dry-run of the rule (or its BFS chain) and displays the pass/fail result.
    Fully implemented.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.csv_path = None

        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_layout.addWidget(QLabel("Select Rule:"))
        top_layout.addWidget(self.rule_combo)

        upload_btn = QPushButton("Upload CSV")
        upload_btn.clicked.connect(self.upload_csv)
        top_layout.addWidget(upload_btn)

        run_btn = QPushButton("Run Dry-Run")
        run_btn.clicked.connect(self.run_test)
        top_layout.addWidget(run_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)
        self.setLayout(layout)

    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if path:
            self.csv_path = path
            QMessageBox.information(self, "CSV Uploaded", f"CSV file '{path}' selected.")

    def run_test(self):
        rid = self.rule_combo.currentData()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rid,))
            row = c.fetchone()
            if not row:
                self.result_text.setPlainText("Rule not found.")
                return
            sql_text, op_type, dt_id = row
            if op_type.upper() == "DECISION_TABLE":
                ok, msg, _ = execute_decision_table(self.connection, dt_id, dry_run=True)
                result = f"Rule {rid} (DECISION_TABLE): PASS={ok}, Message='{msg}'"
            else:
                ok, msg = dry_run_rule_sql(self.connection, sql_text)
                result = f"Rule {rid}: PASS={ok}, Message='{msg}'"
            self.result_text.setPlainText(result)
            QMessageBox.information(self, "Test Result", result)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# End of PART 3
###############################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 4 of 8 (FINAL, REVISED + FULLY ENHANCED)
Focuses on:
 • AuditLogViewer: Display audit logs with text filtering and CSV export.
 • RuleSearchDialog: Real‑time search by rule name or SQL snippet.
 • VersionHistoryDialog: Shows audit log history (INSERT/UPDATE) for a rule,
   provides line‑by‑line diff, and supports rollback to a previous version.
 • RuleDashboard: Paginated dashboard with advanced filtering and search.
 • RuleEditorDialog: Advanced rule editor for adding/updating rules with full
   validations, dependency re‑parsing, and integration with multi‑step approvals.
Integration with multi-level approvals and data validations is assumed.
"""

import sys
import json
import csv
import math
import difflib
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox, QCheckBox,
    QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox
)
from PyQt5.QtCore import Qt, QDateTime, QTimer
from PyQt5.QtGui import QColor

# Assumed to be imported from Parts 1 & 2:
# insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data)
# detect_operation_type(sql_text: str) -> str
# parse_sql_dependencies(sql_text: str) -> dict
# LockManager with lock_rule_for_edit/unlock_rule_for_edit
# run_data_validations(conn)
# create_multistep_approvals(conn, rule_id, initiated_by)
# load_rule_relationships(conn), get_all_rules_map(conn), skip_all_descendants(start_id, adjacency, skipped)

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Displays BRM_AUDIT_LOG with a text search filter and CSV export functionality.
    Fully implemented.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs – Part 4")
        self.resize(900, 600)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        layout.addLayout(top_layout)

        self.log_table = QTableWidget(0, 8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID", "Action", "Table", "RecordID", "ActionBy", "OldData", "NewData", "Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_layout.addWidget(refresh_btn)
        export_btn = QPushButton("Export to CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addWidget(export_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
                FROM BRM_AUDIT_LOG
                ORDER BY ACTION_TIMESTAMP DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.log_table.rowCount()
                self.log_table.insertRow(row_index)
                for col in range(8):
                    val = row[col]
                    if col in (5, 6) and val:
                        try:
                            parsed = json.loads(val)
                            val = json.dumps(parsed, indent=2)
                        except Exception:
                            pass
                    self.log_table.setItem(row_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def perform_search(self, text):
        search_text = text.lower()
        for row_index in range(self.log_table.rowCount()):
            visible = False
            for col in (1, 2, 4):
                item = self.log_table.item(row_index, col)
                if item and search_text in item.text().lower():
                    visible = True
                    break
            self.log_table.setRowHidden(row_index, not visible)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
                writer.writerow(headers)
                for row_index in range(self.log_table.rowCount()):
                    if self.log_table.isRowHidden(row_index):
                        continue
                    row_data = []
                    for col in range(self.log_table.columnCount()):
                        item = self.log_table.item(row_index, col)
                        row_data.append(item.text() if item else "")
                    writer.writerow(row_data)
            QMessageBox.information(self, "Exported", f"Audit logs exported to {path}.")
        except Exception as ex:
            QMessageBox.critical(self, "Export Error", str(ex))

###############################################################################
# RULE SEARCH DIALOG
###############################################################################
class RuleSearchDialog(QDialog):
    """
    Provides real-time filtering of rules based on name or SQL snippet.
    Fully implemented.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules – Part 4")
        self.resize(800, 500)
        layout = QVBoxLayout(self)

        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter rule name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        layout.addLayout(top_layout)

        self.res_table = QTableWidget(0, 6)
        self.res_table.setHorizontalHeaderLabels(["RuleID", "RuleName", "RULE_SQL", "STATUS", "VERSION", "CREATED_BY"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_results)
        layout.addWidget(refresh_btn)
        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        search_term = self.search_edit.text().strip()
        c = self.connection.cursor()
        try:
            if search_term:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                    FROM BRM_RULES
                    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """, (f"%{search_term}%", f"%{search_term}%"))
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                    OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
                """)
            rows = c.fetchall()
            self.res_table.setRowCount(0)
            for row in rows:
                row_index = self.res_table.rowCount()
                self.res_table.insertRow(row_index)
                for col in range(6):
                    self.res_table.setItem(row_index, col, QTableWidgetItem(str(row[col]) if row[col] is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# VERSION HISTORY DIALOG
###############################################################################
class VersionHistoryDialog(QDialog):
    """
    Shows the version history (audit logs for INSERT/UPDATE actions) for a specific rule.
    Provides a detailed line-by-line diff and rollback functionality.
    Fully implemented.
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(900, 500)
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["AuditID", "Action", "Timestamp", "OldData", "NewData", "Diff"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        rollback_btn = QPushButton("Rollback Selected")
        rollback_btn.clicked.connect(self.do_rollback)
        btn_layout.addWidget(rollback_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_layout.addWidget(close_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
                FROM BRM_AUDIT_LOG
                WHERE TABLE_NAME='BRM_RULES'
                  AND RECORD_ID=?
                  AND ACTION IN ('INSERT','UPDATE')
                ORDER BY ACTION_TIMESTAMP DESC
            """, (self.rule_id,))
            rows = c.fetchall()
            self.table.setRowCount(0)
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                self.table.setItem(row_index, 0, QTableWidgetItem(str(row[0])))
                self.table.setItem(row_index, 1, QTableWidgetItem(str(row[1])))
                self.table.setItem(row_index, 2, QTableWidgetItem(str(row[2])))
                old_data = row[3] or ""
                new_data = row[4] or ""
                try:
                    old_data = json.dumps(json.loads(old_data), indent=2)
                except Exception:
                    pass
                try:
                    new_data = json.dumps(json.loads(new_data), indent=2)
                except Exception:
                    pass
                self.table.setItem(row_index, 3, QTableWidgetItem(old_data))
                self.table.setItem(row_index, 4, QTableWidgetItem(new_data))
                diff_btn = QPushButton("Show Diff")
                diff_btn.clicked.connect(lambda _, idx=row_index: self.show_diff(idx))
                self.table.setCellWidget(row_index, 5, diff_btn)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def show_diff(self, row_index):
        old_item = self.table.item(row_index, 3)
        new_item = self.table.item(row_index, 4)
        if not old_item or not new_item:
            QMessageBox.warning(self, "No Data", "Missing data for diff.")
            return
        old_lines = old_item.text().splitlines()
        new_lines = new_item.text().splitlines()
        diff = difflib.unified_diff(old_lines, new_lines, fromfile="Old", tofile="New", lineterm="")
        diff_text = "\n".join(list(diff))
        diff_dialog = QDialog(self)
        diff_dialog.setWindowTitle("Line-by-Line Diff")
        diff_dialog.resize(800, 600)
        layout = QVBoxLayout(diff_dialog)
        diff_edit = QPlainTextEdit()
        diff_edit.setReadOnly(True)
        diff_edit.setPlainText(diff_text if diff_text.strip() else "No differences.")
        layout.addWidget(diff_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(diff_dialog.close)
        layout.addWidget(close_btn)
        diff_dialog.exec_()

    def do_rollback(self):
        selected_items = self.table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Select a version to rollback.")
            return
        row_index = selected_items[0].row()
        old_item = self.table.item(row_index, 3)
        if not old_item or not old_item.text().strip():
            QMessageBox.warning(self, "Empty Data", "Selected version has no rollback data.")
            return
        confirm = QMessageBox.question(self, "Confirm Rollback", "Rollback to this version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_item.text())
        except Exception as ex:
            QMessageBox.critical(self, "JSON Error", str(ex))
            return
        self.apply_rollback(old_data)
        QMessageBox.information(self, "Rolled Back", "Rollback applied successfully.")
        self.load_history()

    def apply_rollback(self, old_data):
        rule_id = old_data["RULE_ID"]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        current = c.fetchone()
        if not current:
            raise ValueError("Rule not found; cannot rollback.")
        new_sql = old_data.get("RULE_SQL", "")
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("""
                UPDATE BRM_RULES
                SET RULE_NAME=?,
                    RULE_SQL=?,
                    OWNER_GROUP=?,
                    STATUS='INACTIVE',
                    VERSION=VERSION+1,
                    UPDATED_BY='Rollback',
                    APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
                WHERE RULE_ID=?
            """, (old_data["RULE_NAME"], new_sql, old_data["OWNER_GROUP"], rule_id))
            c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
            parse_info = parse_sql_dependencies(new_sql)
            col_op = "WRITE" if detect_operation_type(new_sql).upper() in ("INSERT", "UPDATE", "DELETE") else "READ"
            for (sch, tb, alias, is_sub) in parse_info["tables"]:
                if tb and not tb.startswith("(CTE)"):
                    c.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                          RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                        )
                        VALUES(?,?,?,?,?)
                    """, (rule_id, sch if sch else "N/A", tb, "RolledBackCol", col_op))
            c.execute("COMMIT")
        except Exception as ex:
            c.execute("ROLLBACK")
            raise ex

###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    """
    A dashboard that displays rules in a paginated table with filtering by status and
    an advanced search box.
    Fully implemented with dynamic pagination.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL...")
        self.search_edit.textChanged.connect(self.load_rules)
        top_layout.addWidget(QLabel("Search:"))
        top_layout.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_layout.addWidget(QLabel("Status:"))
        top_layout.addWidget(self.status_filter)
        main_layout.addLayout(top_layout)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "Name", "SQL", "Status", "Version", "OwnerGroup",
            "CreatedTS", "ApprovalStatus", "Encrypted?"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_layout = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        self.page_label = QLabel("Page 1/1")
        nav_layout.addWidget(self.prev_btn)
        nav_layout.addWidget(self.page_label)
        nav_layout.addWidget(self.next_btn)
        nav_layout.addStretch()
        main_layout.addLayout(nav_layout)
        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.load_rules()

    def build_filter_clause(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        clause = " AND ".join(filters) if filters else "1=1"
        return clause, params

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_clause()
        try:
            c.execute(f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}", params)
            total = c.fetchone()[0]
            self.total_pages = max(1, math.ceil(total / self.records_per_page))
            if self.current_page > self.total_pages:
                self.current_page = self.total_pages
            self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
            offset = (self.current_page - 1) * self.records_per_page
            c.execute(f"""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
                       CREATED_TIMESTAMP, APPROVAL_STATUS, ENCRYPTED_FLAG
                FROM BRM_RULES
                WHERE {clause}
                ORDER BY RULE_ID DESC
                OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
            """, (*params, offset, self.records_per_page))
            rows = c.fetchall()
            self.rule_table.setRowCount(0)
            for row in rows:
                row_index = self.rule_table.rowCount()
                self.rule_table.insertRow(row_index)
                for col, val in enumerate(row):
                    item = QTableWidgetItem(str(val) if val is not None else "")
                    if col == 3:
                        if str(val).upper() == "ACTIVE":
                            item.setBackground(QColor(144, 238, 144))
                        else:
                            item.setBackground(QColor(255, 182, 193))
                    self.rule_table.setItem(row_index, col, item)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def update_selected_rule_id(self):
        selected = self.rule_table.selectedItems()
        if not selected:
            self.selected_rule_id = None
            return
        row = selected[0].row()
        item = self.rule_table.item(row, 0)
        self.selected_rule_id = int(item.text()) if item else None

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

###############################################################################
# RULE EDITOR DIALOG
###############################################################################
class RuleEditorDialog(QDialog):
    """
    Provides an advanced interface to add or update a rule.
    Features include real-time SQL validation, dependency re-parsing, and integration with multi-step approvals.
    Fully implemented without placeholders.
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = (rule_data is not None)
        title = "Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title + " – Part 4")
        self.resize(800, 600)
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.grp_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        for (gid, gname) in c.fetchall():
            self.grp_combo.addItem(f"{gname} (ID={gid})", gid)
        form_layout.addRow("Group:", self.grp_combo)

        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            self.parent_combo.addItem(f"{rn} (ID={rid})", rid)
        form_layout.addRow("Parent Rule:", self.parent_combo)

        self.name_edit = QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo = QComboBox()
        c.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for (tid, tnm) in c.fetchall():
            self.type_combo.addItem(tnm, tid)
        form_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE", "ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_layout.addRow("Effective Start:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_layout.addRow("Effective End:", self.end_dt)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "UPSERT", "INSERT_ONLY"])
        form_layout.addRow("CDC Type:", self.cdc_combo)

        self.encrypted_check = QCheckBox("Encrypt SQL?")
        form_layout.addRow(self.encrypted_check)

        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("Enter SQL (returning 1 for PASS, 0 for FAIL).")
        self.sql_edit.textChanged.connect(self.live_validate_sql)
        form_layout.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit = QTextEdit()
        form_layout.addRow("Description:", self.desc_edit)
        self.just_edit = QTextEdit()
        form_layout.addRow("Justification:", self.just_edit)

        if self.user_group == "Admin":
            self.global_cb = QCheckBox("Global")
            form_layout.addRow("Global (Admin Only):", self.global_cb)
        else:
            self.global_cb = None

        self.crit_cb = QCheckBox("Critical Rule")
        form_layout.addRow("Critical Rule:", self.crit_cb)
        self.crit_scope_combo = QComboBox()
        self.crit_scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        form_layout.addRow("Critical Scope:", self.crit_scope_combo)

        main_layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.save_btn = QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        btn_layout.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addStretch()
        main_layout.addLayout(btn_layout)
        self.setLayout(main_layout)

        if self.is_update and self.rule_data:
            self.load_existing()

    def load_existing(self):
        rd = self.rule_data
        gid = rd.get("GROUP_ID")
        if gid:
            index = self.grp_combo.findData(gid)
            if index >= 0:
                self.grp_combo.setCurrentIndex(index)
        pid = rd.get("PARENT_RULE_ID")
        if pid:
            index = self.parent_combo.findData(pid)
            if index >= 0:
                self.parent_combo.setCurrentIndex(index)
        self.name_edit.setText(rd.get("RULE_NAME", ""))
        rt_id = rd.get("RULE_TYPE_ID")
        if rt_id:
            index = self.type_combo.findData(rt_id)
            if index >= 0:
                self.type_combo.setCurrentIndex(index)
        status = rd.get("STATUS", "INACTIVE")
        idx_status = self.status_combo.findText(status)
        if idx_status >= 0:
            self.status_combo.setCurrentIndex(idx_status)
        start = rd.get("EFFECTIVE_START_DATE")
        if start:
            self.start_dt.setDateTime(QDateTime.fromString(start, "yyyy-MM-dd HH:mm:ss"))
        end = rd.get("EFFECTIVE_END_DATE")
        if end:
            self.end_dt.setDateTime(QDateTime.fromString(end, "yyyy-MM-dd HH:mm:ss"))
        cdc_val = rd.get("CDC_TYPE", "NONE").upper()
        idx_cdc = self.cdc_combo.findText(cdc_val)
        if idx_cdc >= 0:
            self.cdc_combo.setCurrentIndex(idx_cdc)
        self.encrypted_check.setChecked(bool(rd.get("ENCRYPTED_FLAG", 0)))
        self.sql_edit.setPlainText(rd.get("RULE_SQL", ""))
        self.desc_edit.setPlainText(rd.get("DESCRIPTION", ""))
        self.just_edit.setPlainText(rd.get("BUSINESS_JUSTIFICATION", ""))
        if self.user_group == "Admin" and self.global_cb:
            self.global_cb.setChecked(rd.get("IS_GLOBAL", 0) == 1)
        self.crit_cb.setChecked(rd.get("CRITICAL_RULE", 0) == 1)
        scope = rd.get("CRITICAL_SCOPE", "NONE").upper()
        idx_scope = self.crit_scope_combo.findText(scope)
        if idx_scope >= 0:
            self.crit_scope_combo.setCurrentIndex(idx_scope)

    def live_validate_sql(self):
        sql_text = self.sql_edit.toPlainText()
        op_type = detect_operation_type(sql_text)
        if not sql_text.strip():
            self.sql_edit.setStyleSheet("background-color: #FFC0CB;")
        elif op_type == "OTHER":
            self.sql_edit.setStyleSheet("background-color: #FFFACD;")
        else:
            self.sql_edit.setStyleSheet("background-color: #CCFFCC;")

    def save_rule(self):
        rule_name = self.name_edit.text().strip()
        if not rule_name:
            QMessageBox.warning(self, "Error", "Rule name is required.")
            return
        sql_text = self.sql_edit.toPlainText().strip()
        group_id = self.grp_combo.currentData()
        parent_id = self.parent_combo.currentData() if self.parent_combo.currentData() else None
        rule_type_id = self.type_combo.currentData()
        status = self.status_combo.currentText()
        start_date = self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_date = self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdc_type = self.cdc_combo.currentText().upper()
        description = self.desc_edit.toPlainText().strip()
        justification = self.just_edit.toPlainText().strip()
        is_global = 1 if (self.user_group == "Admin" and self.global_cb and self.global_cb.isChecked()) else 0
        is_critical = 1 if self.crit_cb.isChecked() else 0
        critical_scope = self.crit_scope_combo.currentText().upper()
        encrypted_flag = 1 if self.encrypted_check.isChecked() else 0

        op_type = detect_operation_type(sql_text)
        if not sql_text and self.rule_data and self.rule_data.get("DECISION_TABLE_ID"):
            op_type = "DECISION_TABLE"

        rule_data = {
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rule_type_id,
            "RULE_NAME": rule_name,
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": start_date,
            "EFFECTIVE_END_DATE": end_date,
            "STATUS": status,
            "VERSION": self.rule_data["VERSION"] + 1 if self.is_update and self.rule_data.get("VERSION") else 1,
            "CREATED_BY": "CurrentUser",
            "DESCRIPTION": description,
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": justification,
            "OWNER_GROUP": self.grp_combo.currentText(),
            "CLUSTER_NAME": "",
            "APPROVAL_STATUS": "APPROVAL_IN_PROGRESS",
            "IS_GLOBAL": is_global,
            "CRITICAL_RULE": is_critical,
            "CRITICAL_SCOPE": critical_scope,
            "CDC_TYPE": cdc_type,
            "LIFECYCLE_STATE": "DRAFT" if not self.is_update else "UNDER_APPROVAL",
            "DECISION_TABLE_ID": self.rule_data.get("DECISION_TABLE_ID") if self.is_update else None,
        }

        try:
            c = self.connection.cursor()
            if self.is_update:
                rule_data["RULE_ID"] = self.rule_data["RULE_ID"]
                confirm = QMessageBox.question(self, "Confirm Update", "Update rule and restart approval?")
                if confirm != QMessageBox.Yes:
                    return
                c.execute("""
                    UPDATE BRM_RULES
                    SET GROUP_ID=?,
                        PARENT_RULE_ID=?,
                        RULE_TYPE_ID=?,
                        RULE_NAME=?,
                        RULE_SQL=?,
                        EFFECTIVE_START_DATE=?,
                        EFFECTIVE_END_DATE=?,
                        STATUS='INACTIVE',
                        VERSION=VERSION+1,
                        UPDATED_BY=?,
                        DESCRIPTION=?,
                        OPERATION_TYPE=?,
                        BUSINESS_JUSTIFICATION=?,
                        OWNER_GROUP=?,
                        CLUSTER_NAME=?,
                        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                        IS_GLOBAL=?,
                        CRITICAL_RULE=?,
                        CRITICAL_SCOPE=?,
                        CDC_TYPE=?,
                        LIFECYCLE_STATE='UNDER_APPROVAL',
                        DECISION_TABLE_ID=?
                    WHERE RULE_ID=?
                """, (
                    rule_data["GROUP_ID"],
                    rule_data["PARENT_RULE_ID"],
                    rule_data["RULE_TYPE_ID"],
                    rule_data["RULE_NAME"],
                    rule_data["RULE_SQL"],
                    rule_data["EFFECTIVE_START_DATE"],
                    rule_data["EFFECTIVE_END_DATE"],
                    "CurrentUser",
                    rule_data["DESCRIPTION"],
                    rule_data["OPERATION_TYPE"],
                    rule_data["BUSINESS_JUSTIFICATION"],
                    rule_data["OWNER_GROUP"],
                    rule_data["CLUSTER_NAME"],
                    rule_data["IS_GLOBAL"],
                    rule_data["CRITICAL_RULE"],
                    rule_data["CRITICAL_SCOPE"],
                    rule_data["CDC_TYPE"],
                    rule_data["LIFECYCLE_STATE"],
                    rule_data["DECISION_TABLE_ID"],
                    rule_data["RULE_ID"]
                ))
                c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
                if rule_data["RULE_SQL"]:
                    parse_info = parse_sql_dependencies(rule_data["RULE_SQL"])
                    col_op = "WRITE" if rule_data["OPERATION_TYPE"].upper() in ("INSERT", "UPDATE", "DELETE") else "READ"
                    for (sch, tb, alias, is_sub) in parse_info["tables"]:
                        if tb and not tb.startswith("(CTE)"):
                            c.execute("""
                                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                                  RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                                )
                                VALUES(?,?,?,?,?)
                            """, (rule_data["RULE_ID"], sch if sch else "N/A", tb, "AutoCol", col_op))
            else:
                c.execute("""
                    SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?
                """, (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
                if c.fetchone():
                    raise ValueError("Duplicate rule name in that group.")
                c.execute("""
                    INSERT INTO BRM_RULES(
                      GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
                      EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
                      CREATED_BY, DESCRIPTION, OPERATION_TYPE,
                      BUSINESS_JUSTIFICATION, CREATED_TIMESTAMP,
                      UPDATED_BY, OWNER_GROUP, CLUSTER_NAME,
                      APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE,
                      CRITICAL_SCOPE, CDC_TYPE, LIFECYCLE_STATE,
                      DECISION_TABLE_ID, ENCRYPTED_FLAG
                    )
                    OUTPUT inserted.RULE_ID
                    VALUES(?,?,?,?,?,
                           ?,?,
                           ?,?,
                           ?,?,?,?,?,?,
                           ?,?,?,?,
                           ?,?,?,?,?,
                           ?)
                """, (
                    rule_data["GROUP_ID"],
                    rule_data["PARENT_RULE_ID"],
                    rule_data["RULE_TYPE_ID"],
                    rule_data["RULE_NAME"].strip(),
                    rule_data["RULE_SQL"],
                    rule_data["EFFECTIVE_START_DATE"],
                    rule_data["EFFECTIVE_END_DATE"],
                    rule_data.get("STATUS", "INACTIVE"),
                    rule_data["VERSION"],
                    "CurrentUser",
                    rule_data["DESCRIPTION"],
                    rule_data["OPERATION_TYPE"],
                    rule_data["BUSINESS_JUSTIFICATION"],
                    datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    None,
                    rule_data["OWNER_GROUP"],
                    rule_data["CLUSTER_NAME"],
                    rule_data["APPROVAL_STATUS"],
                    rule_data["IS_GLOBAL"],
                    rule_data["CRITICAL_RULE"],
                    rule_data["CRITICAL_SCOPE"],
                    rule_data["CDC_TYPE"],
                    rule_data["LIFECYCLE_STATE"],
                    rule_data["DECISION_TABLE_ID"],
                    encrypted_flag
                )).fetchone()
            insert_audit_log(self.connection, "UPDATE" if self.is_update else "INSERT",
                               "BRM_RULES", rule_data.get("RULE_ID"), "CurrentUser", None, rule_data)
            self.connection.commit()
            create_multistep_approvals(self.connection, rule_data.get("RULE_ID"), "CurrentUser")
            QMessageBox.information(self, "Success", "Rule processed and approval process initiated.")
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


def create_multistep_approvals(conn, rule_id, initiated_by):
    """
    Create multi‑step approval process records for a rule in the BRM_RULE_APPROVALS table.

    This function determines the impacted business groups and inserts approval records for each stage.
    In this example, it creates two stages:
      • Stage 1: The rule owner's business group must approve.
      • Stage 2: A global approval from the 'GlobalApprovers' group.

    All approval records are inserted with APPROVED_FLAG = 0 (pending).

    Parameters:
      conn          : Database connection object.
      rule_id       : The ID of the rule that requires approval.
      initiated_by  : The username of the user who initiated the rule creation/update.

    Returns:
      None
    """
    c = conn.cursor()
    try:
        # Fetch rule details to determine the owner group.
        c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        if not row:
            raise ValueError("Rule not found for approvals")
        owner_group = row[0]

        # Insert Stage 1 approval record for the owner's business group.
        c.execute("""
            INSERT INTO BRM_RULE_APPROVALS 
            (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
            VALUES (?, ?, ?, 0, 1)
        """, (rule_id, owner_group, initiated_by))

        # Insert Stage 2 approval record for a global approver group.
        c.execute("""
            INSERT INTO BRM_RULE_APPROVALS 
            (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
            VALUES (?, ?, ?, 0, 2)
        """, (rule_id, "GlobalApprovers", initiated_by))

        conn.commit()
        logger.info(f"Multi‑step approvals created for rule {rule_id} by {initiated_by}")
    except Exception as ex:
        conn.rollback()
        logger.error(f"Error creating multi‑step approvals for rule {rule_id}: {ex}")
        raise

from PyQt5.QtCore import Qt, QPointF, QTimer
from PyQt5.QtGui import QPen, QBrush, QColor, QFont
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QCheckBox, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu, QInputDialog,
    QGraphicsView, QGraphicsScene, QGraphicsEllipseItem, QGraphicsLineItem, QGraphicsItem, QGraphicsTextItem
)

###############################################################################
# GLOBAL CRITICAL ADMIN TAB
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only"))
            self.setLayout(layout)
            return

        top_layout = QHBoxLayout()
        self.show_only_gcr = QCheckBox("Show only Global/Critical rules")
        self.show_only_gcr.setChecked(True)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_rule_list)
        top_layout.addWidget(self.show_only_gcr)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID", "RuleName", "OwnerGroup", "IS_GLOBAL", "CRITICAL_RULE",
            "CRITICAL_SCOPE", "Status", "UpdatedBy", "Force Act/Deact"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        link_layout = QHBoxLayout()
        self.gcr_parent_combo = QComboBox()
        link_layout.addWidget(QLabel("Parent GCR Rule:"))
        link_layout.addWidget(self.gcr_parent_combo)
        self.gcr_child_combo = QComboBox()
        link_layout.addWidget(QLabel("Child Rule:"))
        link_layout.addWidget(self.gcr_child_combo)
        link_btn = QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        unlink_btn = QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_layout.addWidget(link_btn)
        link_layout.addWidget(unlink_btn)
        link_layout.addStretch()
        layout.addLayout(link_layout)

        self.link_view = QTableWidget(0, 2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR Rule", "Child Rule"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        refresh_all_btn = QPushButton("Refresh All")
        refresh_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(refresh_all_btn)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.load_link_view()
        self.populate_gcr_combo()
        self.populate_child_combo()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            if self.show_only_gcr.isChecked():
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                           CRITICAL_SCOPE, STATUS, UPDATED_BY
                    FROM BRM_RULES
                    WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                    ORDER BY RULE_ID DESC
                """)
            else:
                c.execute("""
                    SELECT RULE_ID, RULE_NAME, OWNER_GROUP, IS_GLOBAL, CRITICAL_RULE,
                           CRITICAL_SCOPE, STATUS, UPDATED_BY
                    FROM BRM_RULES
                    ORDER BY RULE_ID DESC
                """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.rule_table.rowCount()
                self.rule_table.insertRow(row_index)
                for col, val in enumerate(row):
                    self.rule_table.setItem(row_index, col, QTableWidgetItem(str(val) if val is not None else ""))
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                action_layout.setContentsMargins(0, 0, 0, 0)
                force_act_btn = QPushButton("ForceActivate")
                force_act_btn.clicked.connect(lambda _, rid=row[0]: self.force_activate(rid))
                force_deact_btn = QPushButton("ForceDeactivate")
                force_deact_btn.clicked.connect(lambda _, rid=row[0]: self.force_deactivate(rid))
                action_layout.addWidget(force_act_btn)
                action_layout.addWidget(force_deact_btn)
                action_layout.addStretch()
                self.rule_table.setCellWidget(row_index, 8, action_widget)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
            rows = c.fetchall()
            for row in rows:
                row_index = self.link_view.rowCount()
                self.link_view.insertRow(row_index)
                self.link_view.setItem(row_index, 0, QTableWidgetItem(str(row[0])))
                self.link_view.setItem(row_index, 1, QTableWidgetItem(str(row[1])))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, RULE_NAME
                FROM BRM_RULES
                WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
                ORDER BY RULE_ID
            """)
            for (rid, rn) in c.fetchall():
                self.gcr_parent_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for (rid, rn) in c.fetchall():
                self.gcr_child_combo.addItem(f"{rid} - {rn}", rid)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def link_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Both parent and child must be selected.")
            return
        confirm = QMessageBox.question(self, "Link", f"Link child {child_id} to parent {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID, TARGET_RULE_ID) VALUES(?,?)", (parent_id, child_id))
            insert_audit_log(self.connection, "LINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_id}->{child_id}", "Admin", None, {"parent": parent_id, "child": child_id})
            self.connection.commit()
            QMessageBox.information(self, "Linked", f"Child {child_id} linked to parent {parent_id}.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def unlink_child(self):
        parent_id = self.gcr_parent_combo.currentData()
        child_id = self.gcr_child_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self, "Missing", "Both parent and child must be selected.")
            return
        confirm = QMessageBox.question(self, "Unlink", f"Unlink child {child_id} from parent {parent_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?", (parent_id, child_id))
            insert_audit_log(self.connection, "UNLINK_GCR", "BRM_GLOBAL_CRITICAL_LINKS", f"{parent_id}->{child_id}", "Admin", {"parent": parent_id, "child": child_id}, None)
            self.connection.commit()
            QMessageBox.information(self, "Unlinked", f"Child {child_id} unlinked from parent {parent_id}.")
            self.load_link_view()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def force_activate(self, rule_id):
        confirm = QMessageBox.question(self, "Force Activate", f"Force activate rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT STATUS FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if row and row[0].upper() == "ACTIVE":
                QMessageBox.information(self, "Already Active", "Rule is already active.")
                return
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE', APPROVAL_STATUS='FORCE_ACTIVATED'
                WHERE RULE_ID=?
            """, (rule_id,))
            insert_audit_log(self.connection, "FORCE_ACTIVATE", "BRM_RULES", rule_id, "Admin", {"old_status": row[0] if row else None}, {"new_status": "ACTIVE"})
            self.connection.commit()
            QMessageBox.information(self, "Activated", f"Rule {rule_id} force-activated.")
            self.load_rule_list()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def force_deactivate(self, rule_id):
        confirm = QMessageBox.question(self, "Force Deactivate", f"Force deactivate rule {rule_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
            children = c.fetchall()
            if children:
                confirm_children = QMessageBox.question(self, "Active Children", "Active child rules exist. Deactivate them as well?")
                if confirm_children != QMessageBox.Yes:
                    return
                descendants = self.get_all_descendants(rule_id)
                for child_id in descendants:
                    c.execute("""
                        UPDATE BRM_RULES
                        SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
                        WHERE RULE_ID=?
                    """, (child_id,))
                    insert_audit_log(self.connection, "FORCE_DEACTIVATE", "BRM_RULES", child_id, "Admin", None, {"status": "INACTIVE"})
            c.execute("SELECT STATUS FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            old_status = row[0] if row else None
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE', APPROVAL_STATUS='FORCE_DEACTIVATED'
                WHERE RULE_ID=?
            """, (rule_id,))
            insert_audit_log(self.connection, "FORCE_DEACTIVATE", "BRM_RULES", rule_id, "Admin", {"old_status": old_status}, {"new_status": "INACTIVE"})
            self.connection.commit()
            QMessageBox.information(self, "Deactivated", f"Rule {rule_id} force-deactivated.")
            self.load_rule_list()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_all_descendants(self, start_id):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
        rows = c.fetchall()
        children_map = defaultdict(list)
        for rid, pid in rows:
            if pid:
                children_map[pid].append(rid)
        visited = set()
        queue = [start_id]
        descendants = []
        while queue:
            current = queue.pop(0)
            if current in visited:
                continue
            visited.add(current)
            for child in children_map.get(current, []):
                descendants.append(child)
                queue.append(child)
        return descendants

###############################################################################
# HIERARCHY VIEW TAB
###############################################################################
class HierarchyViewTab(QTreeWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setHeaderLabels(["Group / Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QTreeWidget.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        self.group_map = {}
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
            for gid, gname in c.fetchall():
                item = QTreeWidgetItem([f"{gname} (ID={gid})"])
                item.setData(0, Qt.UserRole, ("group", gid))
                self.addTopLevelItem(item)
                self.group_map[gid] = item
            c.execute("SELECT RULE_ID, RULE_NAME, GROUP_ID, PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
            rule_data = {}
            for rid, rn, group_id, parent_id in c.fetchall():
                rule_data[rid] = {"name": rn, "group_id": group_id, "parent_id": parent_id}
            self.rule_items = {}
            for rid, data in rule_data.items():
                if not data["parent_id"]:
                    if data["group_id"] in self.group_map:
                        item = QTreeWidgetItem([f"Rule {rid}: {data['name']}"])
                        item.setData(0, Qt.UserRole, ("rule", rid))
                        self.group_map[data["group_id"]].addChild(item)
                        self.rule_items[rid] = item
            for rid, data in rule_data.items():
                if data["parent_id"]:
                    parent_item = self.rule_items.get(data["parent_id"])
                    if parent_item:
                        item = QTreeWidgetItem([f"Rule {rid}: {data['name']}"])
                        item.setData(0, Qt.UserRole, ("rule", rid))
                        parent_item.addChild(item)
                        self.rule_items[rid] = item
            self.expandAll()
        except Exception as ex:
            QMessageBox.critical(self, "Hierarchy Load Error", str(ex))

    def dropEvent(self, event):
        super().dropEvent(event)
        self.update_database_reparenting()
        self.load_hierarchy()

    def update_database_reparenting(self):
        c = self.connection.cursor()
        top_count = self.topLevelItemCount()
        for i in range(top_count):
            group_item = self.topLevelItem(i)
            group_data = group_item.data(0, Qt.UserRole)
            if group_data and group_data[0] == "group":
                group_id = group_data[1]
                for j in range(group_item.childCount()):
                    child_item = group_item.child(j)
                    self.recursive_update(child_item, None, group_id, c)
        c.commit()

    def recursive_update(self, item, parent_rule_id, group_id, cursor):
        data = item.data(0, Qt.UserRole)
        if data and data[0] == "rule":
            rule_id = data[1]
            try:
                cursor.execute("""
                    UPDATE BRM_RULES
                    SET PARENT_RULE_ID=?, GROUP_ID=?, STATUS='INACTIVE', APPROVAL_STATUS='APPROVAL_IN_PROGRESS', UPDATED_BY='HierarchyDragDrop', VERSION=VERSION+1
                    WHERE RULE_ID=?
                """, (parent_rule_id, group_id, rule_id))
            except Exception as ex:
                logging.error(f"Error updating rule {rule_id} during reparenting: {ex}")
            for i in range(item.childCount()):
                child = item.child(i)
                self.recursive_update(child, rule_id, group_id, cursor)

###############################################################################
# ENHANCED LINEAGE GRAPH WIDGET (Force-Directed, MANTA-Like)
###############################################################################
class EnhancedLineageGraphWidget(QGraphicsView):
    """
    force-directed layout algorithm, supports zooming, panning,
    and node dragging.

    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QGraphicsScene()
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.zoom_factor = 1.15
        self.nodes = {}  # rule_id -> NodeItem
        self.edges = []  # list of EdgeItem
        self.load_data()
        self.setup_force_directed()
        self.setMinimumSize(600, 400)

    def load_data(self):
        """
        Loads rule lineage from BRM_RULE_LINEAGE and rule statuses from BRM_RULES.
        Builds a graph structure.
        """
        self.rule_info = {}  # rule_id -> dict with 'name' and 'status'
        self.adjacency = {}  # rule_id -> list of child rule_ids
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME, STATUS FROM BRM_RULES")
            for rid, name, status in c.fetchall():
                self.rule_info[rid] = {"name": name, "status": status}
            c.execute("SELECT RULE_ID, PARENT_ID FROM BRM_RULE_LINEAGE")
            for rid, parent_id in c.fetchall():
                pid = parent_id if parent_id is not None else 0
                self.adjacency.setdefault(pid, []).append(rid)
        except Exception as ex:
            QMessageBox.critical(self, "Lineage Load Error", str(ex))
            return

    def setup_force_directed(self):
        """
        Creates graphical nodes and edges, applies an initial random layout,
        and starts a timer for force-directed layout adjustments.
        """
        self.scene.clear()
        self.nodes.clear()
        self.edges.clear()
        # Create nodes for each rule
        for rid, info in self.rule_info.items():
            node = NodeItem(rid, info["name"], info["status"])
            node.setPos(50 + (rid % 10) * 80, 50 + (rid // 10) * 80)
            self.scene.addItem(node)
            self.nodes[rid] = node
        # Create edges based on lineage adjacency
        for parent, children in self.adjacency.items():
            if parent == 0:
                continue
            for child in children:
                if parent in self.nodes and child in self.nodes:
                    edge = EdgeItem(self.nodes[parent], self.nodes[child])
                    self.scene.addItem(edge)
                    self.edges.append(edge)
        # Start timer to update layout
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_forces)
        self.timer.start(30)

    def update_forces(self):
        """
        Simple force-directed layout algorithm:
         - Nodes repel each other.
         - Edges act as springs pulling connected nodes together.
         - Updates positions gradually.
        """
        # Parameters for forces
        repulsion = 5000.0
        spring_length = 150.0
        spring_strength = 0.1
        damping = 0.85

        # Reset forces
        for node in self.nodes.values():
            node.force = QtCore.QPointF(0, 0)

        # Repulsive forces between all pairs of nodes
        node_list = list(self.nodes.values())
        for i in range(len(node_list)):
            for j in range(i+1, len(node_list)):
                node_a = node_list[i]
                node_b = node_list[j]
                delta = node_a.pos() - node_b.pos()
                distance = max(1.0, math.hypot(delta.x(), delta.y()))
                force_magnitude = repulsion / (distance * distance)
                force = delta / distance * force_magnitude
                node_a.force += force
                node_b.force -= force

        # Attractive (spring) forces along edges
        for edge in self.edges:
            delta = edge.source.pos() - edge.dest.pos()
            distance = max(1.0, math.hypot(delta.x(), delta.y()))
            displacement = distance - spring_length
            force = (delta / distance) * (spring_strength * displacement)
            edge.source.force -= force
            edge.dest.force += force

        # Update node positions based on forces
        for node in self.nodes.values():
            velocity = node.velocity + node.force * 0.1
            velocity *= damping
            node.velocity = velocity
            new_pos = node.pos() + velocity
            node.setPos(new_pos)
        # Update edges
        for edge in self.edges:
            edge.updatePosition()

    def wheelEvent(self, event):
        """
        Implements zoom in/out with mouse wheel.
        """
        if event.angleDelta().y() > 0:
            factor = self.zoom_factor
        else:
            factor = 1.0 / self.zoom_factor
        self.scale(factor, factor)

class NodeItem(QGraphicsEllipseItem):
    """
    Represents a rule as a node in the lineage graph.
    Supports dragging and displays rule name.
    """
    def __init__(self, rule_id, name, status, radius=30):
        super().__init__(-radius, -radius, radius*2, radius*2)
        self.rule_id = rule_id
        self.name = name
        self.status = status.upper()
        self.radius = radius
        self.setFlags(QGraphicsItem.ItemIsMovable | QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemSendsGeometryChanges)
        self.setBrush(self.get_brush())
        self.setPen(QPen(Qt.black))
        self.force = QtCore.QPointF(0, 0)
        self.velocity = QtCore.QPointF(0, 0)
        self.text_item = QGraphicsTextItem(self.name, self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setPos(-radius, -radius - 20)

    def get_brush(self):
        if self.status == "ACTIVE":
            return QBrush(QColor(144, 238, 144))
        elif self.status == "INACTIVE":
            return QBrush(QColor(255, 182, 193))
        else:
            return QBrush(QColor(255, 255, 153))

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange:
            # When node moves, update connected edges automatically
            for edge in self.scene().items():
                if isinstance(edge, EdgeItem):
                    if edge.source == self or edge.dest == self:
                        edge.updatePosition()
        return super().itemChange(change, value)

class EdgeItem(QGraphicsLineItem):
    """
    Represents an edge (line) between two NodeItems.
    """
    def __init__(self, source, dest):
        super().__init__()
        self.source = source
        self.dest = dest
        self.setPen(QPen(Qt.gray, 2))

    def updatePosition(self):
        line = QtCore.QLineF(self.source.pos(), self.dest.pos())
        self.setLine(line)

###############################################################################
# End of PART 5
###############################################################################
# !/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 6 of 8 (FINAL, REVISED + FULLY ENHANCED)
Focuses on:
 • MetricsDashboardTab – displays performance and usage metrics with advanced charts using pyqtgraph.
 • CtrlTablesTab – robust viewing of control/reference tables.
 • GroupManagementTab – extended group management enforcing permissions and multi-step logic.
 • UserManagementTab – advanced user management with add, delete, and change password functionalities.
 • Integration of performance monitoring & trending based on RULE_EXECUTION_LOGS and RULE_PERF_STATS.
All code is fully implemented with robust error handling and no placeholders.
"""

import sys
import math
import logging
import csv
import pyodbc
import pyqtgraph as pg
from datetime import datetime, timedelta

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog
)


# Assumed to be available from previous parts:
# - insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data)
# - (Other helper functions: detect_operation_type, parse_sql_dependencies, etc.)

###############################################################################
# METRICS DASHBOARD TAB
###############################################################################
class MetricsDashboardTab(QWidget):
    """
    Displays performance metrics using pyqtgraph:
      - Bar chart for rule counts by STATUS.
      - Line chart for performance trending (average execution time and usage count over the last 30 days).
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        # Create two chart areas side-by-side
        self.chart_layout = QHBoxLayout()

        # Bar chart for rule counts by status
        self.status_chart = pg.PlotWidget(title="Rule Counts by Status")
        self.status_chart.setBackground('w')
        self.chart_layout.addWidget(self.status_chart)

        # Line chart for performance trend
        self.perf_chart = pg.PlotWidget(title="Performance Trend (Avg Exec Time & Usage)")
        self.perf_chart.setBackground('w')
        self.chart_layout.addWidget(self.perf_chart)

        layout.addLayout(self.chart_layout)

        refresh_btn = QPushButton("Refresh Metrics")
        refresh_btn.clicked.connect(self.load_metrics)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c = self.connection.cursor()
        try:
            # Bar Chart: Rule counts by STATUS from BRM_RULES
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows = c.fetchall()
            statuses = [row[0] for row in rows]
            counts = [row[1] for row in rows]
            self.status_chart.clear()
            x_vals = list(range(len(statuses)))
            bar_item = pg.BarGraphItem(x=x_vals, height=counts, width=0.6, brush="skyblue")
            self.status_chart.addItem(bar_item)
            self.status_chart.getAxis("bottom").setTicks([list(zip(x_vals, statuses))])
            self.status_chart.setLabel("left", "Count")
            self.status_chart.setLabel("bottom", "Status")
            self.status_chart.showGrid(x=True, y=True)

            # Line Chart: Performance trending from RULE_PERF_STATS (last 30 days)
            c.execute("""
                SELECT DATE_KEY, AVG(EXEC_TIME_MS) AS avg_time, SUM(USAGE_COUNT) AS total_usage
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY,-30,GETDATE()),112)
                GROUP BY DATE_KEY
                ORDER BY DATE_KEY ASC
            """)
            perf_rows = c.fetchall()
            self.perf_chart.clear()
            if perf_rows:
                x_vals = list(range(len(perf_rows)))
                avg_times = [row[1] for row in perf_rows]
                usage_counts = [row[2] for row in perf_rows]
                self.perf_chart.plot(x_vals, avg_times, pen=pg.mkPen('r', width=2), name="Avg Exec Time (ms)")
                self.perf_chart.plot(x_vals, usage_counts, pen=pg.mkPen('b', width=2), name="Total Usage")
                self.perf_chart.setLabel("bottom", "Time Index (Last 30 Days)")
                self.perf_chart.setLabel("left", "Value")
                self.perf_chart.showGrid(x=True, y=True)
        except Exception as ex:
            QMessageBox.critical(self, "Metrics Error", str(ex))


###############################################################################
# CONTROL TABLES TAB
###############################################################################
class CtrlTablesTab(QWidget):
    """
    Allows users (or admin) to view control/reference tables.
    Loads up to 1000 rows with robust error handling.
    """

    def __init__(self, connection, user_group="BG1", parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)
        self.table_list = [
            "USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES", "BRM_RULE_GROUPS",
            "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG", "BRM_RULE_LINEAGE",
            "BRM_COLUMN_MAPPING", "BRM_CUSTOM_GROUP_MEMBERS", "BRM_GLOBAL_CRITICAL_LINKS", "RULE_SCHEDULES",
            "BRM_RULE_COMMENTS", "DECISION_TABLES", "RULE_CONFLICTS", "COMPOSITE_RULES",
            "RULE_SNAPSHOTS", "RULE_TAGS", "DATA_VALIDATIONS", "RULE_EXECUTION_LOGS", "RULE_PERF_STATS"
        ]

        self.tbl_combo = QComboBox()
        for t in self.table_list:
            self.tbl_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn = QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table = QTableWidget(0, 0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        if self.user_group != "Admin":
            self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        else:
            self.data_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def load_data(self):
        table_name = self.tbl_combo.currentText()
        if not table_name:
            return
        c = self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {table_name}")
            colnames = [desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error retrieving columns from {table_name}: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {table_name}")
            rows = c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading data from {table_name}: {ex}")
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            row_index = self.data_table.rowCount()
            self.data_table.insertRow(row_index)
            for i, val in enumerate(row):
                self.data_table.setItem(row_index, i, QTableWidgetItem(str(val) if val is not None else ""))


###############################################################################
# GROUP MANAGEMENT TAB
###############################################################################
class GroupManagementTab(QWidget):
    """
    Provides full management of business groups:
      - Create new groups, rename, and delete groups.
      - Enforces permissions by verifying group existence and updating dependent tables.
    Fully implemented.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs = QtWidgets.QTabWidget()
        layout.addWidget(self.tabs)

        # Groups & Membership
        groups_tab = QWidget()
        groups_layout = QVBoxLayout(groups_tab)
        self.groups_table = QTableWidget(0, 3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName", "Description", "Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        groups_layout.addWidget(self.groups_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Group")
        add_btn.clicked.connect(self.add_group)
        btn_layout.addWidget(add_btn)
        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        btn_layout.addWidget(rename_btn)
        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        btn_layout.addWidget(delete_btn)
        btn_layout.addStretch()
        groups_layout.addLayout(btn_layout)
        groups_tab.setLayout(groups_layout)
        self.tabs.addTab(groups_tab, "Groups & Membership")

        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_NAME, DESCRIPTION, EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
            rows = c.fetchall()
            for row in rows:
                row_index = self.groups_table.rowCount()
                self.groups_table.insertRow(row_index)
                for col, val in enumerate(row):
                    self.groups_table.setItem(row_index, col, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_group(self):
        row = self.groups_table.currentRow()
        if row < 0:
            return None
        item = self.groups_table.item(row, 0)
        return item.text().strip() if item else None

    def add_group(self):
        group_name, ok = QInputDialog.getText(self, "Add Group", "Enter group name:")
        if not ok or not group_name.strip():
            return
        description, ok2 = QInputDialog.getText(self, "Description", "Enter group description (optional):")
        email, ok3 = QInputDialog.getText(self, "Email", "Enter group email (optional):")
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (group_name.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "Group already exists.")
                return
            c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)",
                      (group_name.strip(), description.strip() if description else "", email.strip() if email else ""))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Group created successfully.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def rename_group(self):
        group_name = self.get_selected_group()
        if not group_name:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"Enter new name for '{group_name}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (new_name.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "New group name already exists.")
                return
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?", (new_name.strip(), group_name))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?", (new_name.strip(), group_name))
            c.execute("COMMIT")
            QMessageBox.information(self, "Renamed", f"Group '{group_name}' renamed to '{new_name}'.")
            self.load_groups()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Error", str(ex))

    def delete_group(self):
        group_name = self.get_selected_group()
        if not group_name:
            QMessageBox.warning(self, "None", "No group selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete group '{group_name}'?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?", (group_name,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Group '{group_name}' deleted.")
            self.load_groups()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


###############################################################################
# USER MANAGEMENT TAB
###############################################################################
class UserManagementTab(QWidget):
    """
    Provides complete user management:
      - Add new users (with basic validation)
      - Delete users
      - Change passwords with improved checks
    Fully implemented.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["UserID", "Username", "Password", "Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_layout.addWidget(add_btn)
        del_btn = QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        btn_layout.addWidget(del_btn)
        change_btn = QPushButton("Change Password")
        change_btn.clicked.connect(self.change_password)
        btn_layout.addWidget(change_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_users)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for row in rows:
                row_index = self.user_table.rowCount()
                self.user_table.insertRow(row_index)
                for col, val in enumerate(row):
                    self.user_table.setItem(row_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def get_selected_user_id(self):
        row = self.user_table.currentRow()
        if row < 0:
            return None
        item = self.user_table.item(row, 0)
        return int(item.text()) if item else None

    def add_user(self):
        username, ok = QInputDialog.getText(self, "Add User", "Enter username:")
        if not ok or not username.strip():
            return
        password, ok2 = QInputDialog.getText(self, "Add User", "Enter password:")
        if not ok2 or not password.strip():
            return
        group, ok3 = QInputDialog.getText(self, "Add User", "Enter group (e.g., BG1, Admin):")
        if not ok3 or not group.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM USERS WHERE USERNAME=?", (username.strip(),))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "Username already exists.")
                return
            c.execute("INSERT INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?,?,?)",
                      (username.strip(), password.strip(), group.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "User added successfully.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_user(self):
        user_id = self.get_selected_user_id()
        if user_id is None:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete user ID {user_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?", (user_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"User {user_id} deleted.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def change_password(self):
        user_id = self.get_selected_user_id()
        if user_id is None:
            QMessageBox.warning(self, "None", "No user selected.")
            return
        new_password, ok = QInputDialog.getText(self, "Change Password", "Enter new password:")
        if not ok or not new_password.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?", (new_password.strip(), user_id))
            self.connection.commit()
            QMessageBox.information(self, "Changed", "Password updated successfully.")
            self.load_users()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

###############################################################################
# End of PART 6
###############################################################################
# !/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 7 of 8 (FINAL, REVISED + FULLY ENHANCED)
Focuses on:
 • CustomRuleGroupEnhancedTab:
    - Fully manages custom groups (create/rename/delete)
    - Backup and restore group versions (storing members as JSON)
    - Assign and remove rules with full lock checking and BFS integration
    - Forces unlock of locked rules when necessary (admin only)
 • AlertsAndDashboardsTab:
    - Displays alerts for approvals older than a threshold (e.g., >3 days)
    - Shows upcoming schedules within the next 24 hours
    - Reports performance alerts from RULE_PERF_STATS (thresholds for exec time and memory)
    - Detects stale locks (active locks past expiry)
All features are fully implemented with robust error handling.
"""

import sys
import json
import math
import logging
from datetime import datetime, timedelta
from collections import defaultdict

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QListWidget, QListWidgetItem,
    QPlainTextEdit, QPushButton, QMessageBox, QInputDialog, QLineEdit, QLabel, QDialog, QSplitter
)


# Assumed helper functions (imported from previous parts):
#   - insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data)
#   - LockManager with lock_rule_for_edit and unlock_rule_for_edit
#   - run_data_validations(conn)
#   - detect_operation_type(sql_text), parse_sql_dependencies(sql_text)
#   - skip_all_descendants(start_id, adjacency, skipped)
#   - (Other necessary functions from PARTs 1–6)

###############################################################################
# CUSTOM RULE GROUP ENHANCED TAB
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Fully manages custom rule groups:
      - Create, rename, and delete custom groups.
      - Backup and restore group versions.
      - Assign and remove rules to/from groups.
      - Checks for rule locks and forces unlock if admin.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        main_layout = QVBoxLayout(self)

        # Top controls: new group, create, rename, delete, backup, restore.
        top_layout = QHBoxLayout()
        self.new_group_edit = QLineEdit()
        self.new_group_edit.setPlaceholderText("Enter new custom group name")
        top_layout.addWidget(self.new_group_edit)

        create_btn = QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_layout.addWidget(create_btn)

        rename_btn = QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_layout.addWidget(rename_btn)

        delete_btn = QPushButton("Delete Group")
        delete_btn.clicked.connect(self.delete_group)
        top_layout.addWidget(delete_btn)

        backup_btn = QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_layout.addWidget(backup_btn)

        restore_btn = QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_layout.addWidget(restore_btn)

        top_layout.addStretch()
        main_layout.addLayout(top_layout)

        # Splitter with left tree (group and assigned rules) and right list (available rules).
        splitter = QSplitter(Qt.Horizontal)

        # Left side: Group tree.
        self.group_tree = QTreeWidget()
        self.group_tree.setHeaderLabels(["Custom Group / Assigned Rules"])
        self.group_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.group_tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.group_tree)

        # Right side: Available rules.
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.rule_search = QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules...")
        self.rule_search.textChanged.connect(self.load_available_rules)
        right_layout.addWidget(self.rule_search)
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_layout.addWidget(self.rule_list)
        assign_btn = QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_layout.addWidget(assign_btn)
        right_widget.setLayout(right_layout)
        splitter.addWidget(right_widget)

        main_layout.addWidget(splitter)
        self.setLayout(main_layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.group_tree.clear()
        c = self.connection.cursor()
        try:
            c.execute(
                "SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID DESC")
            groups = c.fetchall()
            for group in groups:
                group_id, group_name, owner = group
                display_text = f"{group_name} (Owner: {owner})"
                group_item = QTreeWidgetItem([display_text])
                group_item.setData(0, Qt.UserRole, group_id)
                self.group_tree.addTopLevelItem(group_item)
                # Load assigned rules for this group.
                c2 = self.connection.cursor()
                c2.execute("""
                    SELECT M.RULE_ID, R.RULE_NAME, R.IS_GLOBAL, R.CRITICAL_RULE, R.OPERATION_TYPE, R.LOCKED_BY
                    FROM BRM_CUSTOM_GROUP_MEMBERS M
                    JOIN BRM_RULES R ON M.RULE_ID = R.RULE_ID
                    WHERE M.CUSTOM_GROUP_ID=?
                """, (group_id,))
                assigned = c2.fetchall()
                for rule in assigned:
                    rule_id, rule_name, is_global, critical, op_type, locked_by = rule
                    rule_text = f"Rule {rule_id}: {rule_name}"
                    rule_item = QTreeWidgetItem([rule_text])
                    rule_item.setData(0, Qt.UserRole, rule_id)
                    if is_global == 1:
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#D5EEFF")))
                    if critical == 1:
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#FFD1D1")))
                    if op_type.upper() == "DECISION_TABLE":
                        rule_item.setBackground(0, QtGui.QBrush(QtGui.QColor("#FFFFCC")))
                    if locked_by:
                        rule_item.setToolTip(0, f"Locked by {locked_by}")
                    group_item.addChild(rule_item)
            self.group_tree.expandAll()
        except Exception as ex:
            QMessageBox.critical(self, "Group Tree Error", str(ex))

    def load_available_rules(self):
        self.rule_list.clear()
        search_term = self.rule_search.text().strip()
        c = self.connection.cursor()
        try:
            if search_term:
                c.execute(
                    "SELECT RULE_ID, RULE_NAME, OWNER_GROUP FROM BRM_RULES WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ? ORDER BY RULE_ID DESC",
                    (f"%{search_term}%", f"%{search_term}%"))
            else:
                c.execute("SELECT RULE_ID, RULE_NAME, OWNER_GROUP FROM BRM_RULES ORDER BY RULE_ID DESC")
            rows = c.fetchall()
            c2 = self.connection.cursor()
            c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
            assigned = set(r[0] for r in c2.fetchall())
            for row in rows:
                rule_id, rule_name, owner = row
                if rule_id in assigned:
                    continue
                display_text = f"Rule {rule_id}: {rule_name} (Owner: {owner})"
                list_item = QListWidgetItem(display_text)
                list_item.setData(Qt.UserRole, rule_id)
                self.rule_list.addItem(list_item)
        except Exception as ex:
            QMessageBox.critical(self, "Available Rules Error", str(ex))

    def on_tree_context(self, pos):
        item = self.group_tree.itemAt(pos)
        if not item:
            return
        parent = item.parent()
        if parent is None:
            return  # No context menu for group header
        menu = QMenu()
        remove_action = menu.addAction("Remove Rule from Group")
        action = menu.exec_(self.group_tree.viewport().mapToGlobal(pos))
        if action == remove_action:
            group_id = parent.data(0, Qt.UserRole)
            rule_id = item.data(0, Qt.UserRole)
            self.remove_rule_from_group(group_id, rule_id)

    def remove_rule_from_group(self, group_id, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if row and row[0]:
                if self.user_group != "Admin":
                    QMessageBox.warning(self, "Locked",
                                        f"Rule {rule_id} is locked by {row[0]}. Only admin can force unlock.")
                    return
                else:
                    c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?", (group_id, rule_id))
            self.connection.commit()
            QMessageBox.information(self, "Removed", f"Rule {rule_id} removed from group {group_id}.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def create_group(self):
        group_name = self.new_group_edit.text().strip()
        if not group_name:
            QMessageBox.warning(self, "Error", "Group name cannot be empty.")
            return
        c = self.connection.cursor()
        try:
            c.execute("SELECT 1 FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_NAME=?", (group_name,))
            if c.fetchone():
                QMessageBox.warning(self, "Error", "Custom group already exists.")
                return
            c.execute("""
                INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP)
                VALUES(?, ?, ?, GETDATE())
            """, (group_name, self.user_group, f"User:{self.user_id}"))
            self.connection.commit()
            QMessageBox.information(self, "Created", f"Custom group '{group_name}' created successfully.")
            self.new_group_edit.clear()
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def rename_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        current_name = group_item.text(0).split(" (Owner:")[0]
        new_name, ok = QInputDialog.getText(self, "Rename Group", f"Enter new name for '{current_name}':")
        if not ok or not new_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",
                      (new_name.strip(), group_id))
            self.connection.commit()
            QMessageBox.information(self, "Renamed", f"Group renamed to '{new_name}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete custom group {group_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Custom group {group_id} deleted.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def backup_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Error", "Custom group not found.")
                return
            group_name = row[0]
            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            members = [r[0] for r in c.fetchall()]
            backup_data = {"group_name": group_name, "members": members}
            c.execute("SELECT ISNULL(MAX(BACKUP_VERSION),0)+1 FROM BRM_CUSTOM_GROUP_BACKUPS WHERE CUSTOM_GROUP_ID=?",
                      (group_id,))
            new_version = c.fetchone()[0]
            c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID, BACKUP_TIMESTAMP, BACKUP_VERSION, BACKUP_JSON)
                VALUES(?, GETDATE(), ?, ?)
            """, (group_id, new_version, json.dumps(backup_data)))
            self.connection.commit()
            QMessageBox.information(self, "Backup", f"Backup version {new_version} for group {group_id} created.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self, "Backup Error", str(ex))

    def restore_group(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "No custom group selected.")
            return
        group_item = selected_items[0]
        group_id = group_item.data(0, Qt.UserRole)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT BACKUP_VERSION, BACKUP_TIMESTAMP, BACKUP_JSON
                FROM BRM_CUSTOM_GROUP_BACKUPS
                WHERE CUSTOM_GROUP_ID=?
                ORDER BY BACKUP_VERSION DESC
            """, (group_id,))
            backups = c.fetchall()
            if not backups:
                QMessageBox.information(self, "No Backups", "No backups found for this group.")
                return
            items = [f"Version {b[0]} (TS: {b[1]})" for b in backups]
            selected_str, ok = QInputDialog.getItem(self, "Restore Backup", "Select backup version:", items, 0, False)
            if not ok or not selected_str:
                return
            import re
            version = int(re.search(r"Version\s+(\d+)", selected_str).group(1))
            backup_json = None
            for b in backups:
                if b[0] == version:
                    backup_json = b[2]
                    break
            if not backup_json:
                QMessageBox.warning(self, "Error", "Backup not found.")
                return
            confirm = QMessageBox.question(self, "Confirm Restore", f"Restore group {group_id} to version {version}?")
            if confirm != QMessageBox.Yes:
                return
            data = json.loads(backup_json)
            new_group_name = data.get("group_name", "RestoredGroup")
            members = data.get("members", [])
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",
                      (new_group_name, group_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (group_id,))
            for rule_id in members:
                if self.rule_locked(rule_id):
                    if self.user_group == "Admin":
                        self.force_unlock_rule(rule_id)
                    else:
                        continue
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?, ?)",
                          (group_id, rule_id))
            c.execute("COMMIT")
            QMessageBox.information(self, "Restored", f"Custom group {group_id} restored to version {version}.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self, "Restore Error", str(ex))

    def rule_locked(self, rule_id):
        c = self.connection.cursor()
        c.execute("SELECT LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        row = c.fetchone()
        return bool(row and row[0])

    def force_unlock_rule(self, rule_id):
        c = self.connection.cursor()
        c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        self.connection.commit()
        insert_audit_log(self.connection, "FORCE_UNLOCK", "BRM_RULES", rule_id, "Admin", None, {"forced": True})

    def assign_rules(self):
        selected_items = self.group_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "None", "Select a custom group from the tree.")
            return
        group_item = selected_items[0]
        if group_item.parent():
            group_item = group_item.parent()
        group_id = group_item.data(0, Qt.UserRole)
        selected_rules = self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self, "None", "Select one or more available rules to assign.")
            return
        c = self.connection.cursor()
        count = 0
        for item in selected_rules:
            rule_id = item.data(Qt.UserRole)
            if self.rule_locked(rule_id):
                if self.user_group == "Admin":
                    self.force_unlock_rule(rule_id)
                else:
                    continue
            try:
                c.execute("INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID, RULE_ID) VALUES(?, ?)",
                          (group_id, rule_id))
                count += 1
            except Exception as ex:
                logging.error(f"Error assigning rule {rule_id} to group {group_id}: {ex}")
        self.connection.commit()
        QMessageBox.information(self, "Assigned", f"{count} rule(s) assigned to group {group_id}.")
        self.refresh_all()


###############################################################################
# ALERTS AND DASHBOARDS TAB
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    """
    Displays alerts based on:
      - Approvals older than 3 days.
      - Upcoming schedules within the next 24 hours.
      - Performance alerts (e.g., avg exec time > 2000 ms or memory > 50000 KB in last 7 days).
      - Stale locks (active locks with expiry past the current time).
    Fully implemented.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)
        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)
        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()
        try:
            # Approvals older than 3 days
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                       DATEDIFF(DAY, COALESCE(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) AS Age
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.APPROVED_FLAG=0
                  AND DATEDIFF(DAY, COALESCE(A.APPROVED_TIMESTAMP, R.CREATED_TIMESTAMP), GETDATE()) > 3
            """)
            approvals = c.fetchall()
            if approvals:
                lines.append("Approvals older than 3 days:")
                for rid, stage, name, age in approvals:
                    lines.append(f" - Rule {rid} ({name}), Stage: {stage}, Age: {age} days")
            else:
                lines.append("No approvals older than 3 days.")
        except Exception as ex:
            lines.append(f"Error checking approvals: {ex}")

        lines.append("")
        try:
            # Upcoming schedules within next 24h
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled'
                  AND SCHEDULE_TIME BETWEEN GETDATE() AND DATEADD(HOUR, 24, GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules = c.fetchall()
            if schedules:
                lines.append("Upcoming schedules (next 24h):")
                for sid, rid, sched_time in schedules:
                    lines.append(f" - Schedule {sid}: Rule {rid} at {sched_time}")
            else:
                lines.append("No upcoming schedules within 24h.")
        except Exception as ex:
            lines.append(f"Error checking schedules: {ex}")

        lines.append("")
        try:
            # Performance alerts: avg exec time > 2000 ms or memory > 50000 KB in last 7 days
            c.execute("""
                SELECT RULE_ID, AVG(EXEC_TIME_MS) AS AvgTime, AVG(MEM_USAGE) AS AvgMem
                FROM RULE_PERF_STATS
                WHERE DATE_KEY >= CONVERT(varchar(8), DATEADD(DAY, -7, GETDATE()), 112)
                GROUP BY RULE_ID
                HAVING AVG(EXEC_TIME_MS) > 2000 OR AVG(MEM_USAGE) > 50000
            """)
            perf_alerts = c.fetchall()
            if perf_alerts:
                lines.append("Performance alerts (last 7 days):")
                for rid, avg_time, avg_mem in perf_alerts:
                    lines.append(f" - Rule {rid}: Avg Exec Time = {avg_time:.1f} ms, Avg Memory = {avg_mem:.1f} KB")
            else:
                lines.append("No performance alerts in the last 7 days.")
        except Exception as ex:
            lines.append(f"Error checking performance: {ex}")

        lines.append("")
        try:
            # Stale locks: active locks where expiry time has passed
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < GETDATE()
            """)
            stale_locks = c.fetchall()
            if stale_locks:
                lines.append("Stale locks detected:")
                for rid, locked_by, lock_ts, expiry_ts in stale_locks:
                    lines.append(f" - Rule {rid}: Locked by {locked_by}, expired at {expiry_ts}")
            else:
                lines.append("No stale locks detected.")
        except Exception as ex:
            lines.append(f"Error checking stale locks: {ex}")

        self.alert_text.setPlainText("\n".join(lines))
        logging.info("Alerts updated.")


from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton,
    QTableWidget, QTableWidgetItem, QAbstractItemView, QMessageBox, QInputDialog
)
from PyQt5.QtCore import Qt

# It is assumed that these helper functions are defined and imported from your integrated code:
# - execute_decision_table(connection, dt_id, dry_run=True)
# - dry_run_rule_sql(connection, sql_text)
# - simulate_custom_group_rules(connection, group_id)



class ApprovalsTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "RuleID", "Group", "Rule Name", "Stage", "Action", "Force Unlock"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        refresh_btn = QPushButton("Refresh Approvals")
        refresh_btn.clicked.connect(self.load_approvals)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            query = """
                SELECT A.RULE_ID, A.GROUP_NAME, R.RULE_NAME, A.APPROVAL_STAGE, R.LOCKED_BY
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID = R.RULE_ID
                WHERE A.USERNAME = ? AND A.APPROVED_FLAG = 0
                ORDER BY A.APPROVAL_STAGE
            """
            c.execute(query, (self.logged_in_username,))
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                rule_id, group_name, rule_name, stage, locked_by = row
                self.table.setItem(row_index, 0, QTableWidgetItem(str(rule_id)))
                self.table.setItem(row_index, 1, QTableWidgetItem(group_name))
                self.table.setItem(row_index, 2, QTableWidgetItem(rule_name))
                self.table.setItem(row_index, 3, QTableWidgetItem(str(stage)))

                # Action cell with Approve and Reject buttons
                action_widget = QWidget()
                action_layout = QHBoxLayout(action_widget)
                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, rid=rule_id: self.approve_rule(rid))
                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, rid=rule_id: self.reject_rule(rid))
                action_layout.addWidget(approve_btn)
                action_layout.addWidget(reject_btn)
                action_layout.setContentsMargins(0, 0, 0, 0)
                self.table.setCellWidget(row_index, 4, action_widget)

                # Force Unlock column for Admins
                if self.user_group == "Admin":
                    force_btn = QPushButton("Force Unlock")
                    force_btn.clicked.connect(lambda _, rid=rule_id: self.force_unlock(rid))
                    self.table.setCellWidget(row_index, 5, force_btn)
                else:
                    self.table.setItem(row_index, 5, QTableWidgetItem("N/A"))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading approvals: {ex}")

    def approve_rule(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG = 1, APPROVED_TIMESTAMP = GETDATE()
                WHERE RULE_ID = ? AND USERNAME = ?
            """, (rule_id, self.logged_in_username))
            # Check if all approvals are complete for this rule
            c.execute("SELECT COUNT(*) FROM BRM_RULE_APPROVALS WHERE RULE_ID = ? AND APPROVED_FLAG = 0", (rule_id,))
            remaining = c.fetchone()[0]
            if remaining == 0:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS = 'APPROVED', STATUS = 'ACTIVE', LIFECYCLE_STATE = 'ACTIVE'
                    WHERE RULE_ID = ?
                """, (rule_id,))
            insert_audit_log(self.connection, "APPROVE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None,
                             {"approved": True})
            self.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error approving rule: {ex}")

    def reject_rule(self, rule_id):
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG = 2, APPROVED_TIMESTAMP = GETDATE()
                WHERE RULE_ID = ? AND USERNAME = ?
            """, (rule_id, self.logged_in_username))
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS = 'REJECTED', STATUS = 'INACTIVE', LIFECYCLE_STATE = 'INACTIVE'
                WHERE RULE_ID = ?
            """, (rule_id,))
            insert_audit_log(self.connection, "REJECT", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username, None,
                             {"rejected": True})
            self.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} rejected.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error rejecting rule: {ex}")

    def force_unlock(self, rule_id):
        if self.user_group != "Admin":
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_RULE_LOCKS WHERE RULE_ID = ? AND ACTIVE_LOCK = 1", (rule_id,))
            insert_audit_log(self.connection, "FORCE_UNLOCK", "BRM_RULE_LOCKS", rule_id, "Admin", None,
                             {"forced": True})
            self.connection.commit()
            QMessageBox.information(self, "Force Unlocked", f"Rule {rule_id} force-unlocked.")
            self.load_approvals()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error forcing unlock: {ex}")


class SchedulingTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        add_btn = QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        layout.addWidget(add_btn)

        self.table = QTableWidget(0, 5)
        self.table.setHorizontalHeaderLabels(["ScheduleID", "RuleID", "ScheduleTime", "Status", "Run Validations"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        update_btn = QPushButton("Update Selected Schedule")
        update_btn.clicked.connect(self.update_schedule)
        btn_layout.addWidget(update_btn)
        delete_btn = QPushButton("Delete Selected Schedule")
        delete_btn.clicked.connect(self.delete_schedule)
        btn_layout.addWidget(delete_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS
                FROM RULE_SCHEDULES
                ORDER BY SCHEDULE_TIME DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                for col in range(5):
                    self.table.setItem(row_index, col, QTableWidgetItem(str(row[col])))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading schedules: {ex}")

    def add_schedule(self):
        try:
            from EnhancedScheduleDialog import EnhancedScheduleDialog
        except ImportError:
            QMessageBox.critical(self, "Error", "EnhancedScheduleDialog module not found.")
            return
        dlg = EnhancedScheduleDialog(self.connection)
        if dlg.exec_() == QDialog.Accepted:
            self.load_schedules()

    def update_schedule(self):
        selected_items = self.table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Select a schedule to update.")
            return
        row = selected_items[0].row()
        schedule_id = int(self.table.item(row, 0).text())
        new_time, ok = QInputDialog.getText(self, "Update Schedule", "Enter new schedule time (YYYY-MM-DD HH:MM:SS):")
        if not ok or not new_time.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME = ? WHERE SCHEDULE_ID = ?",
                      (new_time.strip(), schedule_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {schedule_id} updated.")
            self.load_schedules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error updating schedule: {ex}")

    def delete_schedule(self):
        selected_items = self.table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Select a schedule to delete.")
            return
        row = selected_items[0].row()
        schedule_id = int(self.table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm Delete",
                                       f"Are you sure you want to delete schedule {schedule_id}?",
                                       QMessageBox.Yes | QMessageBox.No)
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID = ?", (schedule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Schedule {schedule_id} deleted.")
            self.load_schedules()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error deleting schedule: {ex}")


class DefectManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels(
            ["DefectID", "RuleID", "Description", "Severity", "Reporter", "Status", "Timestamp"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Log New Defect")
        add_btn.clicked.connect(self.add_defect)
        btn_layout.addWidget(add_btn)
        update_btn = QPushButton("Update Defect")
        update_btn.clicked.connect(self.update_defect)
        btn_layout.addWidget(update_btn)
        delete_btn = QPushButton("Delete Defect")
        delete_btn.clicked.connect(self.delete_defect)
        btn_layout.addWidget(delete_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_defects)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_defects()

    def load_defects(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DEFECT_ID, RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, TIMESTAMP
                FROM BRM_DEFECT_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                for col in range(7):
                    self.table.setItem(row_index, col, QTableWidgetItem(str(row[col]) if row[col] is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading defects: {ex}")

    def add_defect(self):
        rule_id, ok = QInputDialog.getInt(self, "Log Defect", "Enter Rule ID:")
        if not ok:
            return
        description, ok = QInputDialog.getMultiLineText(self, "Log Defect", "Enter defect description:")
        if not ok or not description.strip():
            return
        severity, ok = QInputDialog.getText(self, "Log Defect", "Enter severity (e.g., Low, Medium, High):")
        if not ok or not severity.strip():
            return
        reporter, ok = QInputDialog.getText(self, "Log Defect", "Enter reporter name:")
        if not ok or not reporter.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO BRM_DEFECT_LOGS(RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, TIMESTAMP)
                VALUES(?, ?, ?, ?, 'Open', GETDATE())
            """, (rule_id, description.strip(), severity.strip(), reporter.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Logged", "Defect logged successfully.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error logging defect: {ex}")

    def update_defect(self):
        selected_items = self.table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Select a defect to update.")
            return
        row = selected_items[0].row()
        defect_id = int(self.table.item(row, 0).text())
        new_status, ok = QInputDialog.getText(self, "Update Defect", "Enter new status:")
        if not ok or not new_status.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE BRM_DEFECT_LOGS SET STATUS=? WHERE DEFECT_ID=?", (new_status.strip(), defect_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Defect updated successfully.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error updating defect: {ex}")

    def delete_defect(self):
        selected_items = self.table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Select a defect to delete.")
            return
        row = selected_items[0].row()
        defect_id = int(self.table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete defect {defect_id}?",
                                       QMessageBox.Yes | QMessageBox.No)
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?", (defect_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Defect deleted successfully.")
            self.load_defects()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error deleting defect: {ex}")


class ConflictPriorityTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 4)
        self.table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        btn_layout.addWidget(add_btn)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        btn_layout.addWidget(set_btn)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        btn_layout.addWidget(del_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_conflicts)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows = c.fetchall()
            for row in rows:
                row_index = self.table.rowCount()
                self.table.insertRow(row_index)
                for col, val in enumerate(row):
                    self.table.setItem(row_index, col, QTableWidgetItem(str(val) if val is not None else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading conflicts: {ex}")

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "Enter RuleID2:")
        if not ok2:
            return
        priority, ok3 = QInputDialog.getInt(self, "Set Priority", "Enter priority:", value=1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1, r2, priority))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error adding conflict: {ex}")

    def set_priority(self):
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "No Selection", "Select a conflict to set priority.")
            return
        cf_id = int(self.table.item(row, 0).text())
        new_priority, ok = QInputDialog.getInt(self, "Set Priority", f"Enter new priority for conflict {cf_id}:",
                                               value=1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_priority, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority updated.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error setting priority: {ex}")

    def delete_conflict(self):
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "No Selection", "Select a conflict to delete.")
            return
        cf_id = int(self.table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete conflict {cf_id}?",
                                       QMessageBox.Yes | QMessageBox.No)
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Conflict deleted successfully.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error deleting conflict: {ex}")


class CollaborationTab(QWidget):
    def __init__(self, connection, collaboration_manager, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.collaboration_manager = collaboration_manager
        layout = QVBoxLayout(self)

        self.messages_list = QListWidget()
        layout.addWidget(self.messages_list)

        input_layout = QHBoxLayout()
        self.message_edit = QLineEdit()
        self.message_edit.setPlaceholderText("Type your message here...")
        input_layout.addWidget(self.message_edit)
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        input_layout.addWidget(send_btn)
        layout.addLayout(input_layout)

        refresh_btn = QPushButton("Refresh Messages")
        refresh_btn.clicked.connect(self.load_messages)
        layout.addWidget(refresh_btn)

        self.setLayout(layout)
        self.load_messages()

        # Connect the collaboration manager's signal to auto-update messages
        self.collaboration_manager.newMessage.connect(self.handle_new_message)

    def load_messages(self):
        self.messages_list.clear()
        c = self.connection.cursor()
        try:
            c.execute("SELECT MESSAGE, SENDER, TIMESTAMP FROM COLLABORATION_LOGS ORDER BY TIMESTAMP DESC")
            rows = c.fetchall()
            for row in rows:
                message, sender, ts = row
                item_text = f"[{ts}] {sender}: {message}"
                self.messages_list.addItem(item_text)
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading collaboration messages: {ex}")

    def send_message(self):
        message = self.message_edit.text().strip()
        if not message:
            return
        sender = "CurrentUser"  # Replace with actual username retrieval if needed.
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO COLLABORATION_LOGS(MESSAGE, SENDER, TIMESTAMP) VALUES(?, ?, GETDATE())",
                      (message, sender))
            self.connection.commit()
            self.message_edit.clear()
            self.load_messages()
        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error sending message: {ex}")

    def handle_new_message(self, msg_dict):
        # Append new message to the list when received via signal.
        message = msg_dict.get("message", "")
        sender = msg_dict.get("sender", "Unknown")
        ts = msg_dict.get("timestamp", "")
        item_text = f"[{ts}] {sender}: {message}"
        self.messages_list.insertItem(0, item_text)


###############################################################################
# End of PART 7
###############################################################################
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# !/usr/bin/env python
# -*- coding: utf-8 -*-
# !/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 8 – Integrated and Advanced UI/UX for BRM Tool
Fully implemented with advanced features:
  - Business Rules Tab with top-row actions and a sub‑tab widget for Custom Groups, What‑If Test, Conflict Priority, Scheduling, Composite Rules, and Hierarchy.
  - Approvals Tab with approve/reject actions that capture a comment.
  - Enhanced Lineage Tab with a button to view an end‑to‑end textual lineage.
  - Admin Tab (first main tab) now includes a new Group Permissions sub‑tab.
  - Data Validation Tab with full functionality.

Assumes all helper functions (insert_audit_log, LockManager, detect_operation_type, parse_sql_dependencies,
run_data_validations, create_multistep_approvals, load_rule_relationships, etc.) are defined below.

For demonstration purposes, each component is implemented within this file.
"""

import sys, os, json, csv, math, logging
from datetime import datetime, timedelta
import difflib

import pyqtgraph as pg
import numpy as np
from sklearn.linear_model import LinearRegression

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDateTime, QPointF
from PyQt5.QtGui import QIcon, QPen, QBrush, QColor, QFont, QPalette
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QDialog, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QLabel, QPushButton, QDockWidget, QLineEdit, QMessageBox, QComboBox, QTableWidget,
    QTableWidgetItem, QPlainTextEdit, QInputDialog, QFileDialog, QTreeWidget, QTreeWidgetItem,
    QGraphicsView, QGraphicsScene, QGraphicsEllipseItem, QGraphicsLineItem, QProgressDialog,
    QSplitter, QMenu, QCalendarWidget, QTimeEdit, QFormLayout, QGroupBox, QCheckBox
)

# ---------------------- Logging and Helper Functions -------------------------
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
logger = logging.getLogger("BRM_TOOL")


def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP)
            VALUES (?, ?, ?, ?, ?, ?, GETDATE())
        """, (action, table_name, str(record_id) if record_id else None, actor,
              json.dumps(old_data) if old_data else None, json.dumps(new_data) if new_data else None))
        conn.commit()
        logger.debug(f"Audit log inserted: {action} on {table_name} (Record: {record_id})")
    except Exception as e:
        logger.error(f"Error inserting audit log: {e}")


class LockManager:
    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < ?", (now,))
            conn.commit()
            logger.info("Expired locks auto-unlocked.")
        except Exception as e:
            logger.error(f"Error auto unlocking locks: {e}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("SELECT LOCKED_BY, EXPIRY_TIMESTAMP FROM BRM_RULE_LOCKS WHERE RULE_ID=? AND ACTIVE_LOCK=1",
                  (rule_id,))
        row = c.fetchone()
        if row:
            if datetime.now() > row[1]:
                c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
                conn.commit()
                return None
            return row[0]
        return None

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        LockManager.auto_unlock_expired_locks(conn)
        owner = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()
        if owner and owner != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {owner}.")
        elif owner and owner != user_id and force:
            c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS (RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
            VALUES (?, ?, ?, ?, ?, 1)
        """, (rule_id, user_id, now, expiry, 1 if force else 0))
        conn.commit()
        logger.info(f"Rule {rule_id} locked by {user_id} (force={force}).")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        current_owner = LockManager.rule_current_lock_owner(conn, rule_id)
        if current_owner and current_owner != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {current_owner}. Cannot unlock.")
        c = conn.cursor()
        c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1", (rule_id,))
        conn.commit()
        logger.info(f"Rule {rule_id} unlocked by {user_id} (force={force}).")


def detect_operation_type(sql_text: str) -> str:
    cleaned = (sql_text or "").strip()
    # Remove comments and leading whitespace
    import re
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', cleaned, flags=re.MULTILINE | re.DOTALL).lstrip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"


def parse_sql_dependencies(sql_text: str):
    # Use sqlparse to extract table names (this is a simplified example)
    try:
        import sqlparse
        statements = sqlparse.parse(sql_text)
        tables = []
        for stmt in statements:
            for token in stmt.tokens:
                if token.ttype is None and token.is_group:
                    for subtoken in token.tokens:
                        if subtoken.ttype is None and subtoken.is_group:
                            continue
                        if subtoken.ttype is sqlparse.tokens.Name:
                            tables.append(subtoken.value)
        return {"tables": list(set(tables))}
    except Exception as e:
        logger.error(f"Error parsing SQL dependencies: {e}")
        return {"tables": []}


def run_data_validations(conn):
    """
    Executes all data validations defined in the DATA_VALIDATIONS table.
    For each validation, it runs a query based on the validation type:
      - NOT NULL
      - RANGE (expects params: "min=X;max=Y")
      - UNIQUE
      - REGEX (new example)
      - FOREIGN_KEY (new example)

    Logs results into DATA_VALIDATION_LOGS.
    """
    cursor = conn.cursor()
    try:
        cursor.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        validations = cursor.fetchall()
    except Exception as e:
        logger.error("Error fetching validations: %s", e)
        return

    for val in validations:
        validation_id, table_name, column_name, validation_type, params = val
        result_flag = "PASS"
        details = ""

        try:
            if validation_type.upper() == "NOT NULL":
                query = f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL"
                cursor.execute(query)
                count = cursor.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} rows have NULL in column '{column_name}'."
                else:
                    details = f"All rows have non-NULL values in column '{column_name}'."

            elif validation_type.upper() == "RANGE":
                min_val, max_val = None, None
                if params:
                    for part in params.split(";"):
                        part = part.strip().lower()
                        if part.startswith("min="):
                            min_val = float(part.split("=")[1])
                        elif part.startswith("max="):
                            max_val = float(part.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid parameters for RANGE validation."
                else:
                    query = f"""
                        SELECT COUNT(*) FROM {table_name}
                        WHERE TRY_CAST({column_name} AS FLOAT) IS NOT NULL
                          AND (TRY_CAST({column_name} AS FLOAT) < {min_val}
                               OR TRY_CAST({column_name} AS FLOAT) > {max_val})
                    """
                    cursor.execute(query)
                    count = cursor.fetchone()[0]
                    if count > 0:
                        result_flag = "FAIL"
                        details = (f"{count} rows have values outside "
                                   f"the range [{min_val}, {max_val}].")
                    else:
                        details = (f"All rows have values within "
                                   f"the range [{min_val}, {max_val}].")

            elif validation_type.upper() == "UNIQUE":
                query = f"""
                    SELECT COUNT(*) FROM (
                        SELECT {column_name}, COUNT(*) AS cnt
                        FROM {table_name}
                        GROUP BY {column_name}
                        HAVING COUNT(*) > 1
                    ) AS duplicates
                """
                cursor.execute(query)
                count = cursor.fetchone()[0]
                if count > 0:
                    result_flag = "FAIL"
                    details = f"{count} duplicate value(s) found in column '{column_name}'."
                else:
                    details = f"All values in column '{column_name}' are unique."

            elif validation_type.upper() == "REGEX":
                # ---- New Example Validation Type ----
                # Expects `params` like "pattern=^[A-Z]{3}\d{2}"
                pattern = None
                if params and "pattern=" in params.lower():
                    pattern = params.split("=", 1)[1].strip()
                if not pattern:
                    result_flag = "FAIL"
                    details = "No valid regex pattern provided."
                else:
                    # We can do a rough check by using T-SQL's LIKE or CLR.
                    # Or fetch data in Python and validate row by row.
                    # Below is a Python approach (may be slow for large tables):
                    test_query = f"SELECT [{column_name}] FROM {table_name}"
                    cursor.execute(test_query)
                    fail_count = 0
                    import re
                    compiled_pat = re.compile(pattern)
                    for row_ in cursor.fetchall():
                        val_ = str(row_[0]) if row_[0] is not None else ""
                        if not compiled_pat.match(val_):
                            fail_count += 1
                    if fail_count > 0:
                        result_flag = "FAIL"
                        details = f"{fail_count} rows failed the REGEX pattern {pattern}."
                    else:
                        details = f"All rows matched the REGEX pattern {pattern}."

            elif validation_type.upper() == "FOREIGN_KEY":
                # ---- New Example Validation Type ----
                # Example 'params': "ref_table=OtherTable;ref_col=ID"
                ref_table, ref_col = None, None
                if params:
                    for part in params.split(";"):
                        keyval = part.strip().split("=")
                        if len(keyval) == 2:
                            if keyval[0].lower() == "ref_table":
                                ref_table = keyval[1]
                            elif keyval[0].lower() == "ref_col":
                                ref_col = keyval[1]
                if not ref_table or not ref_col:
                    result_flag = "FAIL"
                    details = "Invalid FOREIGN_KEY parameters (need ref_table, ref_col)."
                else:
                    query = f"""
                        SELECT COUNT(*)
                        FROM {table_name} t
                        LEFT JOIN {ref_table} r
                          ON t.{column_name} = r.{ref_col}
                        WHERE r.{ref_col} IS NULL
                          AND t.{column_name} IS NOT NULL
                    """
                    cursor.execute(query)
                    count = cursor.fetchone()[0]
                    if count > 0:
                        result_flag = "FAIL"
                        details = f"{count} row(s) in {table_name} have no matching ref in {ref_table}.{ref_col}."
                    else:
                        details = "All rows in foreign key column have matching references."

            else:
                # Unknown or not implemented
                result_flag = "FAIL"
                details = f"Validation type '{validation_type}' is not implemented."

        except Exception as ex:
            result_flag = "FAIL"
            details = f"Error during validation: {ex}"

        # Log the result
        try:
            cursor.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(
                    VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP
                )
                VALUES(?, ?, ?, GETDATE())
            """, (validation_id, result_flag, details))
            conn.commit()
        except Exception as log_ex:
            logger.error(f"Error logging validation {validation_id}: {log_ex}")


def create_multistep_approvals(conn, rule_id, initiated_by):
    # Create dummy multi-step approval records
    c = conn.cursor()
    try:
        steps = [1, 2]  # For example, 2-stage approval
        for step in steps:
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS (RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
                VALUES (?, ?, ?, 0, ?)
            """, (rule_id, "BusinessGroup", initiated_by, step))
        conn.commit()
        logger.info(f"Multi-step approvals created for rule {rule_id}.")
    except Exception as e:
        logger.error(f"Error creating multi-step approvals: {e}")


def load_rule_relationships(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    adjacency = {}
    parent_map = {}
    all_ids = set()
    for rid, pid in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid
    # For simplicity, ignoring conflict, global-critical and composite links in this demo.
    child_ids = set(parent_map.keys())
    roots = [rid for rid in all_ids if rid not in child_ids]
    return (adjacency, roots, parent_map)


from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton,
    QTableWidget, QTableWidgetItem, QMessageBox, QAbstractItemView
)
from PyQt5.QtGui import QColor
from PyQt5.QtCore import Qt
import datetime

class BusinessRulesTab(QWidget):
    """
    Enhanced version of the Business Rules Tab that displays:
      - Multi-step approval chain in a new column (color-coded).
      - Adds a multi-stage chain text like BG1(approved)->BG2(pending)->BG3(approved)->FINAL.
      - "Worst" status sets the entire cell color (rejected=red, delayed=purple, pending=orange, else green).
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None

        main_layout = QVBoxLayout(self)

        # Top toolbar row: search + basic actions
        toolbar_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search rules...")
        self.search_edit.textChanged.connect(self.load_rules)
        toolbar_layout.addWidget(self.search_edit)

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule)
        toolbar_layout.addWidget(add_btn)

        edit_btn = QPushButton("Edit Rule")
        edit_btn.clicked.connect(self.edit_rule)
        toolbar_layout.addWidget(edit_btn)

        delete_btn = QPushButton("Delete Rule")
        delete_btn.clicked.connect(self.delete_rule)
        toolbar_layout.addWidget(delete_btn)

        deactivate_btn = QPushButton("Deactivate Rule")
        deactivate_btn.clicked.connect(self.deactivate_rule)
        toolbar_layout.addWidget(deactivate_btn)

        # --- New: Radio Buttons for Execution Mode ---
        self.dryrun_radio = QRadioButton("Dry‑Run")
        self.real_run_radio = QRadioButton("Real Run")
        # Set default selection
        self.dryrun_radio.setChecked(True)
        # Group the radio buttons so that only one can be selected
        self.exec_mode_group = QButtonGroup(self)
        self.exec_mode_group.addButton(self.dryrun_radio)
        self.exec_mode_group.addButton(self.real_run_radio)
        toolbar_layout.addWidget(self.dryrun_radio)
        toolbar_layout.addWidget(self.real_run_radio)
        # ------------------------------------------------

        execute_rule_btn = QPushButton("Execute Rule")
        execute_rule_btn.clicked.connect(self.run_selected_rule)
        toolbar_layout.addWidget(execute_rule_btn)

        group_run_btn = QPushButton("Run (Group)")
        group_run_btn.clicked.connect(self.dryrun_group)
        toolbar_layout.addWidget(group_run_btn)

        toolbar_layout.addStretch()
        main_layout.addLayout(toolbar_layout)

        single_dryrun_btn = QPushButton("Dry‑Run (Single)")
        single_dryrun_btn.clicked.connect(self.dryrun_single)
        toolbar_layout.addWidget(single_dryrun_btn)

        group_dryrun_btn = QPushButton("Dry‑Run (Group)")
        group_dryrun_btn.clicked.connect(self.dryrun_group)
        toolbar_layout.addWidget(group_dryrun_btn)

        toolbar_layout.addStretch()
        main_layout.addLayout(toolbar_layout)

        # Table with an extra column "Approval Chain"
        self.rules_table = QTableWidget(0, 8)
        self.rules_table.setHorizontalHeaderLabels([
            "RuleID",
            "Name",
            "Status",
            "Version",
            "Owner Group",
            "Created Timestamp",
            "Approval Chain",  # new column
            "Action"
        ])
        self.rules_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rules_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rules_table.itemSelectionChanged.connect(self.on_rule_selection)
        main_layout.addWidget(self.rules_table)

        self.setLayout(main_layout)
        self.load_rules()
    def run_selected_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "Run Rule", "No rule selected.")
            return

        # Check the selected execution mode from radio buttons
        if self.dryrun_radio.isChecked():
            # Call the dry-run function
            self.show_dryrun_result(self.selected_rule_id)
        else:
            # Call the actual execution function (you'd have to implement this)
            self.execute_rule(self.selected_rule_id)

    def execute_rule(self, rule_id):
        # Example placeholder for actual rule execution logic.
        try:
            c = self.connection.cursor()
            c.execute("SELECT RULE_SQL, OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Run Rule", "Rule not found.")
                return
            sql_text, op_type = row
            # Implement real execution logic here...
            QMessageBox.information(self, "Run Rule", f"Real execution for Rule {rule_id} invoked.")
        except Exception as e:
            QMessageBox.critical(self, "Execution Error", str(e))

    def load_rules(self):
        """Loads rules from BRM_RULES plus the new multi-step approval column."""
        self.rules_table.setRowCount(0)
        search_term = self.search_edit.text().strip()
        c = self.connection.cursor()
        try:
            if search_term:
                query = (
                    "SELECT RULE_ID, RULE_NAME, STATUS, VERSION, OWNER_GROUP, "
                    "CONVERT(VARCHAR, CREATED_TIMESTAMP, 120) "
                    "FROM BRM_RULES "
                    "WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?"
                )
                c.execute(query, (f"%{search_term}%", f"%{search_term}%"))
            else:
                c.execute(
                    "SELECT RULE_ID, RULE_NAME, STATUS, VERSION, OWNER_GROUP, "
                    "CONVERT(VARCHAR, CREATED_TIMESTAMP, 120) FROM BRM_RULES"
                )
            rows = c.fetchall()

            for i, row in enumerate(rows):
                self.rules_table.insertRow(i)
                # Fill the first 6 columns (RuleID..CreatedTimestamp)
                for col_idx in range(6):
                    self.rules_table.setItem(i, col_idx, QTableWidgetItem(str(row[col_idx])))

                rule_id = row[0]
                # Build & insert the Approval Chain cell
                approval_item = self.build_approval_chain_item(rule_id)
                self.rules_table.setItem(i, 6, approval_item)

                # Action column: add a "Dry‑Run" button
                action_btn = QPushButton("Dry‑Run")
                action_btn.clicked.connect(lambda _, rid=rule_id: self.show_dryrun_result(rid))
                self.rules_table.setCellWidget(i, 7, action_btn)

        except Exception as e:
            QMessageBox.critical(self, "Load Rules Error", str(e))

    def build_approval_chain_item(self, rule_id):
        """
        Fetch multi-step approvals (BRM_RULE_APPROVALS), build text like
          BG1(approved)->BG2(pending)->BG3(approved)->FINAL
        Color code the entire cell by worst status:
          - Rejected => Red
          - Delayed (>24h) => Purple
          - Pending => Orange
          - Otherwise => Green
        """
        c = self.connection.cursor()
        try:
            c.execute(
                """
                SELECT GROUP_NAME,
                       APPROVAL_STAGE,
                       APPROVED_FLAG,
                       COALESCE(APPROVED_TIMESTAMP, REQUESTED_TIMESTAMP) AS STAGE_TS
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=?
                ORDER BY APPROVAL_STAGE
                """,
                (rule_id,)
            )
            approvals = c.fetchall()
        except Exception as ex:
            return QTableWidgetItem("(No data)")

        if not approvals:
            return QTableWidgetItem("(No approvals)")

        chain_segments = []
        # worst status logic
        # priority: rejected > delayed > pending > approved
        overall_status = "approved"

        for (group_name, stage, flag, stage_ts) in approvals:
            # default to green/approved
            color = "#008000"
            label = "(approved)"

            if flag == 0:
                # pending
                label = "(pending)"
                color = "#FFA500"  # orange
                # check if delayed
                if stage_ts:
                    diff = datetime.datetime.now() - stage_ts
                    if diff.total_seconds() > 86400:
                        # delayed
                        label = "(delayed)"
                        color = "#800080"  # purple
                        overall_status = self.pick_worst_status(overall_status, "delayed")
                    else:
                        overall_status = self.pick_worst_status(overall_status, "pending")
                else:
                    overall_status = self.pick_worst_status(overall_status, "pending")

            elif flag == 2:
                # rejected
                label = "(rejected)"
                color = "#FF0000"
                overall_status = self.pick_worst_status(overall_status, "rejected")

            # if flag == 1 => approved => keep default
            chain_segments.append(f"{group_name}{label}")

        chain_str = " -> ".join(chain_segments)
        item = QTableWidgetItem(chain_str)

        # now set the background color by worst status
        if overall_status == "rejected":
            item.setBackground(QColor("#FFC0C0"))  # light red
        elif overall_status == "delayed":
            item.setBackground(QColor("#E0B0FF"))  # light purple
        elif overall_status == "pending":
            item.setBackground(QColor("#FFFACD"))  # light yellow
        else:
            # approved
            item.setBackground(QColor("#CCFFCC"))  # light green

        return item

    def pick_worst_status(self, current, candidate):
        """
        Ranks statuses: rejected > delayed > pending > approved
        to determine the "worst" overall.
        """
        order = {"approved": 0, "pending": 1, "delayed": 2, "rejected": 3}
        return max(current, candidate, key=lambda s: order[s])

    def on_rule_selection(self):
        items = self.rules_table.selectedItems()
        if items:
            try:
                self.selected_rule_id = int(items[0].text())
            except:
                self.selected_rule_id = None
        else:
            self.selected_rule_id = None

    def add_rule(self):

        editor = RuleEditorDialog(self.connection, self.user_group, rule_data=None)
        if editor.exec_() == QDialog.Accepted:

            self.load_rules()

    def edit_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "Edit Rule", "No rule selected.")
            return

        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (self.selected_rule_id,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self, "Edit Rule", "Selected rule not found in the database.")
            return
        # Build a dictionary mapping column names to values
        colnames = [desc[0] for desc in c.description]
        rule_data = dict(zip(colnames, row))

        # Open the rule editor dialog pre-populated with the existing data
        editor = RuleEditorDialog(self.connection, self.user_group, rule_data)
        if editor.exec_() == QDialog.Accepted:
            # After a successful edit, refresh the rules list
            self.load_rules()

    def delete_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "Delete Rule", "No rule selected.")
            return
        confirm = QMessageBox.question(
            self, "Delete Rule",
            f"Are you sure you want to delete Rule {self.selected_rule_id}?",
            QMessageBox.Yes | QMessageBox.No
        )
        if confirm == QMessageBox.Yes:
            try:
                c = self.connection.cursor()
                c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (self.selected_rule_id,))
                self.connection.commit()
                # e.g., insert_audit_log(...)
                self.load_rules()
            except Exception as e:
                QMessageBox.critical(self, "Delete Error", str(e))

    def deactivate_rule(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "Deactivate Rule", "No rule selected.")
            return
        try:
            c = self.connection.cursor()
            c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE' WHERE RULE_ID=?", (self.selected_rule_id,))
            self.connection.commit()
            # e.g., insert_audit_log(...)
            self.load_rules()
        except Exception as e:
            QMessageBox.critical(self, "Deactivate Error", str(e))

    def dryrun_single(self):
        if not self.selected_rule_id:
            QMessageBox.warning(self, "Dry‑Run", "No rule selected.")
            return
        self.show_dryrun_result(self.selected_rule_id)

    def show_dryrun_result(self, rule_id):
        """Show a dialog with the results of a single-rule dry run."""
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Error", "Rule not found.")
                return
            sql_text, op_type, dt_id = row
            if op_type and op_type.upper() == "DECISION_TABLE":
                # call your function: e.g. execute_decision_table(conn, dt_id, dry_run=True)
                ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
            else:
                # call your function: e.g. dry_run_rule_sql(conn, sql_text)
                ok, msg = dry_run_rule_sql(self.connection, sql_text)
                rec_count = 0

            result = (
                f"Dry‑Run Result for Rule {rule_id}:\n"
                f"PASS={ok}\n"
                f"Message: {msg}\n"
                f"Records Impacted: {rec_count}"
            )
            QMessageBox.information(self, "Dry‑Run Result", result)

        except Exception as e:
            QMessageBox.critical(self, "Dry‑Run Error", str(e))

    def dryrun_group(self):
        group_id, ok = QInputDialog.getInt(self, "Group Dry‑Run", "Enter Custom Group ID:")
        if not ok:
            return
        try:
            passed, failed = simulate_custom_group_rules(self.connection, group_id)
            msg = (
                f"Group Dry‑Run for group {group_id}:\n"
                f"Passed: {passed}\n"
                f"Failed: {failed}"
            )
            QMessageBox.information(self, "Group Dry‑Run Result", msg)
        except Exception as e:
            QMessageBox.critical(self, "Group Dry‑Run Error", str(e))

# ---------------------- Scheduling Tab ----------------------
class SchedulingTab(QWidget):

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        top_layout.addWidget(add_btn)
        update_btn = QPushButton("Update Schedule")
        update_btn.clicked.connect(self.update_schedule)
        top_layout.addWidget(update_btn)
        delete_btn = QPushButton("Delete Schedule")
        delete_btn.clicked.connect(self.delete_schedule)
        top_layout.addWidget(delete_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.schedule_table = QTableWidget(0, 5)
        self.schedule_table.setHorizontalHeaderLabels(["ScheduleID", "RuleID", "Time", "Status", "RunValidations"])
        self.schedule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.schedule_table)
        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.schedule_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute(
                "SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS FROM RULE_SCHEDULES ORDER BY SCHEDULE_TIME DESC")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.schedule_table.insertRow(i)
                for j, value in enumerate(row):
                    self.schedule_table.setItem(i, j, QTableWidgetItem(str(value)))
        except Exception as e:
            QMessageBox.critical(self, "Load Schedules Error", str(e))

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection)
        if dlg.exec_() == QDialog.Accepted:
            self.load_schedules()

    def update_schedule(self):
        selected = self.schedule_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a schedule to update.")
            return
        sched_id = int(selected[0].text())
        new_time, ok = QInputDialog.getText(self, "Update Schedule", "Enter new time (YYYY-MM-DD HH:MM:SS):")
        if not ok or not new_time.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?", (new_time.strip(), sched_id))
            self.connection.commit()
            self.load_schedules()
        except Exception as e:
            QMessageBox.critical(self, "Update Schedule Error", str(e))

    def delete_schedule(self):
        selected = self.schedule_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a schedule to delete.")
            return
        sched_id = int(selected[0].text())
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete schedule {sched_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sched_id,))
            self.connection.commit()
            self.load_schedules()
        except Exception as e:
            QMessageBox.critical(self, "Delete Schedule Error", str(e))


# ---------------------- Composite Rules Tab (Wizard-based) ----------------------
class CompositeRulesTab(QWidget):
    """
    Provides a wizard-based approach to create a composite rule.
    Users can search and select multiple rules and define a logical expression with an action.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        wizard_btn = QPushButton("Create Composite Rule (Wizard)")
        wizard_btn.clicked.connect(self.open_wizard)
        layout.addWidget(wizard_btn)
        self.setLayout(layout)

    def open_wizard(self):
        dlg = CompositeRuleWizard(self.connection)
        dlg.exec_()


class CompositeRuleWizard(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Composite Rule Wizard")
        self.resize(600, 400)
        self.selected_rules = []
        self.init_ui()

    def init_ui(self):
        vbox = QVBoxLayout(self)
        self.rule_list = QListWidget()
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for rid, name in c.fetchall():
            item = QListWidgetItem(f"{rid} - {name}")
            item.setData(Qt.UserRole, rid)
            self.rule_list.addItem(item)
        self.rule_list.setSelectionMode(QListWidget.MultiSelection)
        vbox.addWidget(QLabel("Select rules for composite logic:"))
        vbox.addWidget(self.rule_list)
        self.expr_edit = QLineEdit()
        self.expr_edit.setPlaceholderText("Enter logical expression (e.g., 'Rule10 AND Rule20')")
        vbox.addWidget(QLabel("Logical Expression:"))
        vbox.addWidget(self.expr_edit)
        self.action_edit = QLineEdit()
        self.action_edit.setPlaceholderText("Enter action on pass (e.g., SendEmail)")
        vbox.addWidget(QLabel("Action on Pass:"))
        vbox.addWidget(self.action_edit)
        btn_layout = QHBoxLayout()
        finish_btn = QPushButton("Finish")
        finish_btn.clicked.connect(self.finish_wizard)
        btn_layout.addWidget(finish_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addStretch()
        vbox.addLayout(btn_layout)
        self.setLayout(vbox)

    def finish_wizard(self):
        selected = self.rule_list.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select at least one rule.")
            return
        self.selected_rules = [item.data(Qt.UserRole) for item in selected]
        expr = self.expr_edit.text().strip()
        action = self.action_edit.text().strip()
        if not expr:
            QMessageBox.warning(self, "Missing Expression", "Enter a logical expression.")
            return
        try:
            c = self.connection.cursor()
            c.execute("INSERT INTO COMPOSITE_RULES (CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS) VALUES (?, ?, ?)",
                      ("CompositeRule", expr, action))
            self.connection.commit()
            insert_audit_log(self.connection, "INSERT", "COMPOSITE_RULES", None, "CurrentUser", None,
                             {"rules": self.selected_rules, "expression": expr})
            QMessageBox.information(self, "Success", "Composite rule created successfully.")
            self.accept()
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))


# ---------------------- Data Validation Tab ----------------------
class DataValidationTab(QWidget):
    """
    Provides full data validation management:
      - Add, Remove, Run All, and Refresh validations.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        top_layout.addWidget(add_btn)
        remove_btn = QPushButton("Remove Validation")
        remove_btn.clicked.connect(self.remove_validation)
        top_layout.addWidget(remove_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all_validations)
        top_layout.addWidget(run_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_validations)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.dv_table = QTableWidget(0, 6)
        self.dv_table.setHorizontalHeaderLabels(["ValidationID", "Table", "Column", "Type", "Params", "LastResult"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)
        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute(
                "SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.dv_table.insertRow(i)
                for j, val in enumerate(row):
                    self.dv_table.setItem(i, j, QTableWidgetItem(str(val)))
        except Exception as e:
            QMessageBox.critical(self, "Load Validations Error", str(e))

    def add_validation(self):
        table_name, ok = QInputDialog.getText(self, "Add Validation", "Enter table name:")
        if not ok or not table_name.strip():
            return
        column_name, ok = QInputDialog.getText(self, "Add Validation", "Enter column name:")
        if not ok or not column_name.strip():
            return
        vtype, ok = QInputDialog.getText(self, "Add Validation", "Enter validation type (e.g., NOT NULL, RANGE):")
        if not ok or not vtype.strip():
            return
        params, ok = QInputDialog.getText(self, "Add Validation", "Enter parameters (if any):")
        c = self.connection.cursor()
        try:
            c.execute(
                "INSERT INTO DATA_VALIDATIONS (TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP) VALUES (?, ?, ?, ?, GETDATE())",
                (table_name.strip(), column_name.strip(), vtype.strip(), params.strip() if params else ""))
            self.connection.commit()
            insert_audit_log(self.connection, "INSERT", "DATA_VALIDATIONS", None, "CurrentUser", None,
                             {"table": table_name, "column": column_name})
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Add Validation Error", str(e))

    def remove_validation(self):
        selected = self.dv_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a validation to remove.")
            return
        vid = int(selected[0].text())
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "DATA_VALIDATIONS", vid, "CurrentUser")
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Remove Validation Error", str(e))

    def run_all_validations(self):
        try:
            run_data_validations(self.connection)
            QMessageBox.information(self, "Validations Run", "Data validations executed successfully.")
            self.load_validations()
        except Exception as e:
            QMessageBox.critical(self, "Run Validations Error", str(e))


# ---------------------- Main BRM Details Widget ----------------------
class BRDetailsWidget(QWidget):
    """
    Contains sub-tabs under the Business Rules Tab: Custom Groups, What-If Test, Conflict Priority,
    Scheduling, Composite Rules, and Hierarchy.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.sub_tabs = QTabWidget()
        self.custom_groups_tab = CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.sub_tabs.addTab(self.custom_groups_tab, "Custom Groups")
        self.whatif_tab = WhatIfTestTab(self.connection)
        self.sub_tabs.addTab(self.whatif_tab, "What-If Test")
        self.conflict_tab = ConflictPriorityTab(self.connection)
        self.sub_tabs.addTab(self.conflict_tab, "Conflict Priority")
        self.scheduling_tab = SchedulingTab(self.connection)
        self.sub_tabs.addTab(self.scheduling_tab, "Scheduling")
        self.composite_tab = CompositeRulesTab(self.connection)
        self.sub_tabs.addTab(self.composite_tab, "Composite Rules")
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.sub_tabs.addTab(self.hierarchy_tab, "Hierarchy")
        layout.addWidget(self.sub_tabs)
        self.setLayout(layout)


# ---------------------- Admin Tab with Group Permissions ----------------------
class AdminTab(QWidget):
    """
    Contains admin functionalities including User Management, Group Management, Group Permissions, and Control Tables.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        self.inner_tabs = QTabWidget()
        layout.addWidget(self.inner_tabs)
        self.user_mgmt_tab = UserManagementTab(self.connection)
        self.inner_tabs.addTab(self.user_mgmt_tab, "User Management")
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.inner_tabs.addTab(self.group_mgmt_tab, "Group Management")
        self.group_perm_tab = GroupPermissionsTab(self.connection)
        self.inner_tabs.addTab(self.group_perm_tab, "Group Permissions")
        self.ctrl_tables_tab = CtrlTablesTab(self.connection, self.user_group)
        self.inner_tabs.addTab(self.ctrl_tables_tab, "Control Tables")
        self.setLayout(layout)


class GroupPermissionsTab(QWidget):
    """
    Allows admin to add, delete, and refresh group permissions.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        top_layout = QHBoxLayout()
        add_btn = QPushButton("Add Permission")
        add_btn.clicked.connect(self.add_permission)
        top_layout.addWidget(add_btn)
        delete_btn = QPushButton("Delete Permission")
        delete_btn.clicked.connect(self.delete_permission)
        top_layout.addWidget(delete_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_permissions)
        top_layout.addWidget(refresh_btn)
        top_layout.addStretch()
        layout.addLayout(top_layout)
        self.perm_table = QTableWidget(0, 3)
        self.perm_table.setHorizontalHeaderLabels(["PermissionID", "GroupName", "TargetTable"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.perm_table)
        self.setLayout(layout)
        self.load_permissions()

    def load_permissions(self):
        self.perm_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT PERMISSION_ID, GROUP_NAME, TARGET_TABLE FROM GROUP_PERMISSIONS ORDER BY PERMISSION_ID")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.perm_table.insertRow(i)
                for j, val in enumerate(row):
                    self.perm_table.setItem(i, j, QTableWidgetItem(str(val)))
        except Exception as e:
            QMessageBox.critical(self, "Load Permissions Error", str(e))

    def add_permission(self):
        group_name, ok = QInputDialog.getText(self, "Add Permission", "Enter group name:")
        if not ok or not group_name.strip():
            return
        target_table, ok = QInputDialog.getText(self, "Add Permission", "Enter target table:")
        if not ok or not target_table.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO GROUP_PERMISSIONS (GROUP_NAME, TARGET_TABLE) VALUES (?, ?)",
                      (group_name.strip(), target_table.strip()))
            self.connection.commit()
            insert_audit_log(self.connection, "INSERT", "GROUP_PERMISSIONS", None, "Admin", None,
                             {"group": group_name, "table": target_table})
            self.load_permissions()
        except Exception as e:
            QMessageBox.critical(self, "Add Permission Error", str(e))

    def delete_permission(self):
        selected = self.perm_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a permission to delete.")
            return
        row = selected[0].row()
        perm_id = int(self.perm_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete permission {perm_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM GROUP_PERMISSIONS WHERE PERMISSION_ID=?", (perm_id,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "GROUP_PERMISSIONS", perm_id, "Admin")
            self.load_permissions()
        except Exception as e:
            QMessageBox.critical(self, "Delete Permission Error", str(e))


# ---------------------- User Management Tab ----------------------
class UserManagementTab(QWidget):
    """
    Provides complete user management: Add, Delete, Change Password.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.user_table = QTableWidget(0, 4)
        self.user_table.setHorizontalHeaderLabels(["UserID", "Username", "Password", "User Group"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        btn_layout.addWidget(add_btn)
        delete_btn = QPushButton("Delete User")
        delete_btn.clicked.connect(self.delete_user)
        btn_layout.addWidget(delete_btn)
        change_btn = QPushButton("Change Password")
        change_btn.clicked.connect(self.change_password)
        btn_layout.addWidget(change_btn)
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_users)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, PASSWORD, USER_GROUP FROM USERS ORDER BY USER_ID")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.user_table.insertRow(i)
                for j, val in enumerate(row):
                    self.user_table.setItem(i, j, QTableWidgetItem(str(val)))
        except Exception as e:
            QMessageBox.critical(self, "Load Users Error", str(e))

    def add_user(self):
        username, ok = QInputDialog.getText(self, "Add User", "Enter username:")
        if not ok or not username.strip():
            return
        password, ok = QInputDialog.getText(self, "Add User", "Enter password:")
        if not ok or not password.strip():
            return
        group, ok = QInputDialog.getText(self, "Add User", "Enter user group:")
        if not ok or not group.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO USERS (USERNAME, PASSWORD, USER_GROUP) VALUES (?, ?, ?)",
                      (username.strip(), password.strip(), group.strip()))
            self.connection.commit()
            insert_audit_log(self.connection, "INSERT", "USERS", None, "Admin", None, {"username": username})
            self.load_users()
        except Exception as e:
            QMessageBox.critical(self, "Add User Error", str(e))

    def delete_user(self):
        selected = self.user_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a user to delete.")
            return
        uid = int(selected[0].text())
        confirm = QMessageBox.question(self, "Confirm Delete", f"Delete user {uid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM USERS WHERE USER_ID=?", (uid,))
            self.connection.commit()
            insert_audit_log(self.connection, "DELETE", "USERS", uid, "Admin")
            self.load_users()
        except Exception as e:
            QMessageBox.critical(self, "Delete User Error", str(e))

    def change_password(self):
        selected = self.user_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a user to change password.")
            return
        uid = int(selected[0].text())
        new_pass, ok = QInputDialog.getText(self, "Change Password", "Enter new password:")
        if not ok or not new_pass.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?", (new_pass.strip(), uid))
            self.connection.commit()
            insert_audit_log(self.connection, "UPDATE", "USERS", uid, "Admin", None, {"password": "changed"})
            self.load_users()
        except Exception as e:
            QMessageBox.critical(self, "Change Password Error", str(e))


# ---------------------- Enhanced Audit Log Analysis Tab ----------------------
class EnhancedAuditLogAnalysisTab(QWidget):
    """
    Displays audit logs with full-text search, export options, and a trend chart.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        search_layout = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search audit logs...")
        self.search_edit.textChanged.connect(self.filter_logs)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.search_edit)
        layout.addLayout(search_layout)
        self.audit_table = QTableWidget(0, 9)
        self.audit_table.setHorizontalHeaderLabels(
            ["AuditID", "Action", "Table", "RecordID", "ActionBy", "OldData", "NewData", "Timestamp", "Status"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.audit_table)
        btn_layout = QHBoxLayout()
        refresh_btn = QPushButton("Refresh Logs")
        refresh_btn.clicked.connect(self.load_logs)
        btn_layout.addWidget(refresh_btn)
        export_csv_btn = QPushButton("Export CSV")
        export_csv_btn.clicked.connect(lambda: self.export_logs("csv"))
        btn_layout.addWidget(export_csv_btn)
        export_json_btn = QPushButton("Export JSON")
        export_json_btn.clicked.connect(lambda: self.export_logs("json"))
        btn_layout.addWidget(export_json_btn)
        export_excel_btn = QPushButton("Export Excel")
        export_excel_btn.clicked.connect(lambda: self.export_logs("excel"))
        btn_layout.addWidget(export_excel_btn)
        diff_btn = QPushButton("View Version Diff")
        diff_btn.clicked.connect(self.open_version_history)
        btn_layout.addWidget(diff_btn)
        btn_layout.addStretch()
        layout.addLayout(btn_layout)
        self.trend_chart = pg.PlotWidget(title="Audit Log Trend (Last 30 Days)")
        self.trend_chart.setBackground('w')
        layout.addWidget(self.trend_chart)
        self.setLayout(layout)
        self.load_logs()
        self.load_trend_chart()

    def load_logs(self):
        self.audit_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute(
                "SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP FROM BRM_AUDIT_LOG ORDER BY ACTION_TIMESTAMP DESC OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY")
            rows = c.fetchall()
            for i, row in enumerate(rows):
                self.audit_table.insertRow(i)
                for j in range(8):
                    val = row[j]
                    if j in (5, 6) and val:
                        try:
                            val = json.dumps(json.loads(val), indent=2)
                        except:
                            pass
                    self.audit_table.setItem(i, j, QTableWidgetItem(str(val)))
                # Set status icon based on action
                status_item = QTableWidgetItem()
                action = (row[1] or "").upper()
                if "APPROVE" in action:
                    status_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_DialogApplyButton))
                elif "REJECT" in action:
                    status_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxCritical))
                else:
                    status_item.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_FileDialogDetailedView))
                self.audit_table.setItem(i, 8, status_item)
        except Exception as e:
            QMessageBox.critical(self, "Load Logs Error", str(e))

    def filter_logs(self):
        text = self.search_edit.text().lower()
        for i in range(self.audit_table.rowCount()):
            visible = any(
                text in (self.audit_table.item(i, col).text().lower() if self.audit_table.item(i, col) else "") for col
                in (1, 2, 4))
            self.audit_table.setRowHidden(i, not visible)

    def export_logs(self, fmt):
        path, _ = QFileDialog.getSaveFileName(self, "Export Logs", "", "All Files (*)")
        if not path:
            return
        progress = QProgressDialog("Exporting logs...", "Cancel", 0, 100, self)
        progress.setWindowModality(Qt.WindowModal)
        progress.setValue(0)
        try:
            data = []
            headers = [self.audit_table.horizontalHeaderItem(i).text() for i in range(self.audit_table.columnCount())]
            data.append(headers)
            total = self.audit_table.rowCount()
            for i in range(total):
                if self.audit_table.isRowHidden(i):
                    continue
                row_data = [self.audit_table.item(i, j).text() if self.audit_table.item(i, j) else "" for j in
                            range(self.audit_table.columnCount())]
                data.append(row_data)
                progress.setValue(int((i / total) * 100))
                QApplication.processEvents()
                if progress.wasCanceled():
                    QMessageBox.information(self, "Cancelled", "Export cancelled.")
                    return
            if fmt in ("csv", "excel"):
                with open(path, "w", newline="", encoding="utf-8") as f:
                    writer = csv.writer(f)
                    writer.writerows(data)
            elif fmt == "json":
                dict_list = [dict(zip(headers, row)) for row in data[1:]]
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(dict_list, f, indent=2)
            progress.setValue(100)
            QMessageBox.information(self, "Exported", f"Logs exported as {fmt.upper()} to {path}.")
        except Exception as e:
            QMessageBox.critical(self, "Export Error", str(e))

    def open_version_history(self):
        selected = self.audit_table.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Select a log entry for version diff.")
            return
        try:
            rule_id = int(self.audit_table.item(selected[0].row(), 0).text())
        except:
            QMessageBox.warning(self, "Selection Error", "Invalid selection.")
            return
        dlg = VersionHistoryDialog(self.connection, rule_id)
        dlg.exec_()

    def load_trend_chart(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(date, ACTION_TIMESTAMP) as LogDate, COUNT(*)
                FROM BRM_AUDIT_LOG
                WHERE ACTION_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
                GROUP BY CONVERT(date, ACTION_TIMESTAMP)
                ORDER BY LogDate
            """)
            rows = c.fetchall()
            if rows:
                dates = [row[0] for row in rows]
                counts = [row[1] for row in rows]
                x_vals = list(range(len(dates)))
                self.trend_chart.clear()
                self.trend_chart.plot(x_vals, counts, pen=pg.mkPen('g', width=2), symbol='o')
                labels = [(x, d.strftime("%m-%d")) for x, d in zip(x_vals, dates)]
                self.trend_chart.getAxis("bottom").setTicks([labels])
        except Exception as e:
            QMessageBox.critical(self, "Trend Chart Error", str(e))


# ---------------------- Predictive Analytics Tab ----------------------
class PredictiveAnalyticsTab(QWidget):
    """
    Provides rule performance forecasting and anomaly detection with advanced filtering.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        filter_layout = QHBoxLayout()
        self.rule_filter_edit = QLineEdit()
        self.rule_filter_edit.setPlaceholderText("Filter by rule name...")
        filter_layout.addWidget(QLabel("Rule:"))
        filter_layout.addWidget(self.rule_filter_edit)
        self.table_filter_edit = QLineEdit()
        self.table_filter_edit.setPlaceholderText("Filter by table...")
        filter_layout.addWidget(QLabel("Table:"))
        filter_layout.addWidget(self.table_filter_edit)
        self.column_filter_edit = QLineEdit()
        self.column_filter_edit.setPlaceholderText("Filter by column...")
        filter_layout.addWidget(QLabel("Column:"))
        filter_layout.addWidget(self.column_filter_edit)
        self.database_filter_edit = QLineEdit()
        self.database_filter_edit.setPlaceholderText("Filter by database...")
        filter_layout.addWidget(QLabel("Database:"))
        filter_layout.addWidget(self.database_filter_edit)
        self.ug_filter_edit = QLineEdit()
        self.ug_filter_edit.setPlaceholderText("Filter by user group...")
        filter_layout.addWidget(QLabel("User Group:"))
        filter_layout.addWidget(self.ug_filter_edit)
        layout.addLayout(filter_layout)
        self.chart = pg.PlotWidget(title="Forecast: Average Execution Time")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)
        forecast_btn = QPushButton("Run Forecast")
        forecast_btn.clicked.connect(self.run_forecast)
        layout.addWidget(forecast_btn)
        self.result_label = QLabel("")
        layout.addWidget(self.result_label)
        self.setLayout(layout)

    def run_forecast(self):
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT CONVERT(date, ACTION_TIMESTAMP) as LogDate, AVG(EXEC_TIME_MS) as AvgTime
                FROM RULE_PERF_STATS
                WHERE ACTION_TIMESTAMP >= DATEADD(DAY, -30, GETDATE())
                GROUP BY CONVERT(date, ACTION_TIMESTAMP)
                ORDER BY LogDate
            """)
            rows = c.fetchall()
            if not rows:
                self.result_label.setText("Insufficient data.")
                return
            dates = [row[0] for row in rows]
            avg_times = [row[1] for row in rows]
            X = np.array([[i] for i in range(len(avg_times))])
            y = np.array(avg_times)
            model = LinearRegression()
            model.fit(X, y)
            forecast_index = len(avg_times)
            forecast = model.predict(np.array([[forecast_index]]))[0]
            anomaly = forecast > 2000
            self.chart.clear()
            x_vals = list(range(len(avg_times)))
            self.chart.plot(x_vals, avg_times, pen=pg.mkPen('b', width=2), symbol='o')
            self.chart.plot([forecast_index], [forecast], pen=pg.mkPen('r', width=2), symbol='x', symbolSize=14)
            self.chart.getAxis("bottom").setLabel("Day Index (Last 30 Days)")
            self.chart.getAxis("left").setLabel("Avg Exec Time (ms)")
            if anomaly:
                self.result_label.setText(f"Anomaly: Forecast avg time {forecast:.1f} ms exceeds threshold.")
            else:
                self.result_label.setText(f"Forecast: Avg time = {forecast:.1f} ms.")
        except Exception as e:
            QMessageBox.critical(self, "Forecast Error", str(e))


# ---------------------- Enhanced Lineage Analysis Tab ----------------------
class EnhancedLineageAnalysisTab(QWidget):
    """
    Provides an interactive lineage view with a button to view a textual representation.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        filter_layout = QHBoxLayout()
        self.rule_name_filter = QLineEdit()
        self.rule_name_filter.setPlaceholderText("Enter rule name filter...")
        filter_layout.addWidget(QLabel("Filter:"))
        filter_layout.addWidget(self.rule_name_filter)
        view_btn = QPushButton("View Textual Lineage")
        view_btn.clicked.connect(self.view_textual_lineage)
        filter_layout.addWidget(view_btn)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)
        # For demonstration, we use a plain text area to represent the graph
        self.graph_widget = EnhancedLineageGraphWidget(self.connection)
        layout.addWidget(self.graph_widget)

        self.setLayout(layout)

    def view_textual_lineage(self):
        filter_text = self.rule_name_filter.text().strip()
        # Simulate fetching a textual representation based on the filter
        text = f"End-to-End Lineage for rules matching '{filter_text}':\n\n"
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID FROM BRM_RULES WHERE RULE_NAME LIKE ?",
                  (f"%{filter_text}%",))
        rows = c.fetchall()
        for rid, name, parent in rows:
            text += f"Rule {rid}: {name} (Parent: {parent})\n"
        dlg = QDialog(self)
        dlg.setWindowTitle("Textual Lineage View")
        dlg.resize(800, 600)
        vbox = QVBoxLayout(dlg)
        text_edit = QPlainTextEdit(text)
        text_edit.setReadOnly(True)
        vbox.addWidget(text_edit)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.accept)
        vbox.addWidget(close_btn)
        dlg.exec_()


# ---------------------- Admin Tab ----------------------
class AdminTab(QWidget):
    """
    Aggregates admin functionalities: User Management, Group Management, Group Permissions, and Control Tables.
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        if self.user_group != "Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        self.inner_tabs = QTabWidget()
        layout.addWidget(self.inner_tabs)
        self.user_mgmt_tab = UserManagementTab(self.connection)
        self.inner_tabs.addTab(self.user_mgmt_tab, "User Management")
        self.group_mgmt_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.inner_tabs.addTab(self.group_mgmt_tab, "Group Management")
        self.group_perm_tab = GroupPermissionsTab(self.connection)
        self.inner_tabs.addTab(self.group_perm_tab, "Group Permissions")
        self.ctrl_tables_tab = CtrlTablesTab(self.connection, self.user_group)
        self.inner_tabs.addTab(self.ctrl_tables_tab, "Control Tables")
        self.setLayout(layout)


# ---------------------- Main Window ----------------------
class MainWindow(QMainWindow):
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.setWindowTitle("BRM Tool – Ultimate Production Ready Edition")
        self.resize(2200, 1300)
        self.setStyleSheet("""
            QWidget { font-family: 'Segoe UI'; font-size: 13px; }
            QTabWidget::pane { border: 0; }
            QHeaderView::section { background-color: #E8E8E8; padding: 6px; border: 1px solid #C0C0C0; }
            QTableWidget { background-color: #FFFFFF; alternate-background-color: #F5F5F5; }
            QPushButton { background-color: #0078D7; color: white; border: none; padding: 6px; }
            QPushButton:hover { background-color: #005A9E; }
            QPushButton:pressed { background-color: #004578; }
            QLineEdit, QPlainTextEdit { border: 1px solid #C0C0C0; padding: 4px; }
        """)
        self.create_menu_bar()
        self.create_tool_bar()
        self.create_status_bar()
        central_widget = QWidget()
        central_layout = QVBoxLayout(central_widget)
        if self.user_group == "Admin":
            imp_layout = QHBoxLayout()
            imp_label = QLabel("Impersonate:")
            imp_label.setStyleSheet("font-weight: bold;")
            self.impersonation_combo = QComboBox()
            self.load_impersonation_options()
            imp_btn = QPushButton("Switch User")
            imp_btn.clicked.connect(self.switch_user)
            imp_layout.addWidget(imp_label)
            imp_layout.addWidget(self.impersonation_combo)
            imp_layout.addWidget(imp_btn)
            imp_layout.addStretch()
            central_layout.addLayout(imp_layout)
        self.tabs = QTabWidget()
        central_layout.addWidget(self.tabs)
        self.admin_tab = AdminTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.admin_tab, QIcon(), "Admin")
        self.dashboard_tab = MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.dashboard_tab, QIcon(), "Dashboard")
        self.biz_rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        biz_container = QWidget()
        biz_layout = QVBoxLayout(biz_container)
        biz_layout.addWidget(self.biz_rules_tab)
        self.br_details = BRDetailsWidget(self.connection, self.user_id, self.user_group)
        biz_layout.addWidget(self.br_details)
        biz_container.setLayout(biz_layout)
        self.tabs.addTab(biz_container, QIcon(), "Business Rules")
        self.approvals_tab = ApprovalsTab(self.connection, self.get_username(), self.user_group)
        self.tabs.addTab(self.approvals_tab, QIcon(), "Approvals")
        self.defects_tab = DefectManagementTab(self.connection)
        self.tabs.addTab(self.defects_tab, QIcon(), "Defects")
        self.collaboration_tab = CollaborationTab(self.connection, self.create_collaboration_manager())
        self.tabs.addTab(self.collaboration_tab, QIcon(), "Collaboration")
        self.audit_log_tab = EnhancedAuditLogAnalysisTab(self.connection)
        self.tabs.addTab(self.audit_log_tab, QIcon(), "Audit Log Analysis")
        self.predictive_tab = PredictiveAnalyticsTab(self.connection)
        self.tabs.addTab(self.predictive_tab, QIcon(), "Predictive Analytics")
        self.lineage_tab = EnhancedLineageAnalysisTab(self.connection)
        self.tabs.addTab(self.lineage_tab, QIcon(), "Enhanced Lineage")
        self.help_tab = HelpFeedbackTab(self.connection)
        self.tabs.addTab(self.help_tab, QIcon(), "Help & Feedback")
        central_widget.setLayout(central_layout)
        self.setCentralWidget(central_widget)
        self.notifications_dock = QDockWidget("Real-Time Notifications", self)
        self.notifications_widget = AlertsAndDashboardsTab(self.connection)
        self.notifications_dock.setWidget(self.notifications_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, self.notifications_dock)
        self.refresh_timer = QTimer(self)
        self.refresh_timer.timeout.connect(self.refresh_tabs)
        self.refresh_timer.start(30000)

    def create_menu_bar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        logout_action = file_menu.addAction("Log Out")
        logout_action.triggered.connect(self.logout)
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        help_menu = menubar.addMenu("Help")
        doc_action = help_menu.addAction("Documentation")
        doc_action.triggered.connect(self.open_help)

    def create_tool_bar(self):
        toolbar = self.addToolBar("Main Toolbar")
        refresh_action = toolbar.addAction(QIcon.fromTheme("view-refresh"), "Refresh")
        refresh_action.triggered.connect(self.refresh_tabs)

    def create_status_bar(self):
        status = self.statusBar()
        status.showMessage(f"Connected | User: {self.get_username()} | Group: {self.user_group}")

    def logout(self):
        self.close()

    def open_help(self):
        index = self.tabs.indexOf(self.help_tab)
        if index != -1:
            self.tabs.setCurrentIndex(index)

    def get_username(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = c.fetchone()
            return row[0] if row else "Unknown"
        except Exception:
            return "Unknown"

    def load_impersonation_options(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for uid, uname, ugroup in c.fetchall():
                self.impersonation_combo.addItem(f"{uname} ({ugroup})", (uid, ugroup))
        except Exception as ex:
            QMessageBox.critical(self, "Impersonation Error", str(ex))

    def switch_user(self):
        data = self.impersonation_combo.currentData()
        if not data:
            return
        new_uid, new_group = data
        if new_uid == self.user_id and new_group == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_group
        QMessageBox.information(self, "Switched", f"Now impersonating {self.get_username()} ({self.user_group}).")
        self.approvals_tab.logged_in_username = self.get_username()
        self.approvals_tab.user_group = self.user_group
        self.approvals_tab.load_approvals()
        self.biz_rules_tab.user_id = self.user_id
        self.biz_rules_tab.user_group = self.user_group
        self.biz_rules_tab.load_rules()
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i) == "Admin":
                self.tabs.setTabVisible(i, self.user_group == "Admin")
                break
        self.create_status_bar()

    def create_collaboration_manager(self):
         # Ensure CollaborationManager is fully implemented.
        return CollaborationManager(self.connection, poll_ms=5000)

    def refresh_tabs(self):
        try:
            self.approvals_tab.load_approvals()
            self.biz_rules_tab.load_rules()
            self.notifications_widget.check_alerts()
            self.statusBar().showMessage(f"Refreshed at {datetime.now().strftime('%H:%M:%S')}")
        except Exception as ex:
            logging.error(f"Error refreshing tabs: {ex}")


# ---------------------- Help & Feedback Tab ----------------------
class HelpFeedbackTab(QWidget):
    """
    Displays dynamic help content fetched from the HELP_CONTENT table.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        title = QLabel("BRM Tool Help & Documentation")
        title.setStyleSheet("font-size: 16px; font-weight: bold;")
        layout.addWidget(title)
        search_layout = QHBoxLayout()
        self.help_search = QLineEdit()
        self.help_search.setPlaceholderText("Search help topics...")
        self.help_search.textChanged.connect(self.filter_help)
        search_layout.addWidget(QLabel("Search:"))
        search_layout.addWidget(self.help_search)
        layout.addLayout(search_layout)
        self.help_tabs = QTabWidget()
        self.faq_widget = QTreeWidget()
        self.faq_widget.setHeaderLabels(["FAQ", "Answer"])
        self.guides_widget = QTreeWidget()
        self.guides_widget.setHeaderLabels(["Guide Title", "Content"])
        self.help_tabs.addTab(self.faq_widget, "FAQs")
        self.help_tabs.addTab(self.guides_widget, "Guides")
        layout.addWidget(self.help_tabs)
        self.setLayout(layout)
        self.populate_help_content()

    def populate_help_content(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT CATEGORY, TITLE, CONTENT FROM HELP_CONTENT ORDER BY CATEGORY, LAST_UPDATED DESC")
            rows = c.fetchall()
            self.faq_widget.clear()
            self.guides_widget.clear()
            for category, title, content in rows:
                item = QTreeWidgetItem([title, content])
                if category.upper() == "FAQ":
                    self.faq_widget.addTopLevelItem(item)
                else:
                    self.guides_widget.addTopLevelItem(item)
        except Exception as e:
            QMessageBox.critical(self, "Help Content Error", str(e))

    def filter_help(self):
        text = self.help_search.text().lower()
        for tree in [self.faq_widget, self.guides_widget]:
            for i in range(tree.topLevelItemCount()):
                item = tree.topLevelItem(i)
                visible = text in item.text(0).lower() or text in item.text(1).lower()
                item.setHidden(not visible)


# ---------------------- Alerts & Dashboards Tab ----------------------
class AlertsAndDashboardsTab(QWidget):
    """
    Displays real-time alerts including approvals older than 3 days, upcoming schedules,
    performance alerts, and stale locks.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.alert_text = QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)
        check_btn = QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)
        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines = []
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, APPROVAL_STAGE, GETDATE() - COALESCE(APPROVED_TIMESTAMP, CREATED_TIMESTAMP) AS Age
                FROM BRM_RULE_APPROVALS
                WHERE APPROVED_FLAG=0 AND DATEDIFF(DAY, COALESCE(APPROVED_TIMESTAMP, GETDATE()), GETDATE()) > 3
            """)
            approvals = c.fetchall()
            if approvals:
                lines.append("Approvals older than 3 days:")
                for rule_id, stage, age in approvals:
                    lines.append(f" - Rule {rule_id}, Stage {stage}, Age: {age} days")
            else:
                lines.append("No approvals older than 3 days.")
        except Exception as e:
            lines.append(f"Approval check error: {e}")
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled' AND SCHEDULE_TIME BETWEEN GETDATE() AND DATEADD(HOUR, 24, GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            schedules = c.fetchall()
            if schedules:
                lines.append("\nUpcoming schedules (next 24h):")
                for sid, rid, stime in schedules:
                    lines.append(f" - Schedule {sid}: Rule {rid} at {stime}")
            else:
                lines.append("\nNo upcoming schedules within 24h.")
        except Exception as e:
            lines.append(f"Schedule check error: {e}")
        try:
            c.execute("""
                SELECT RULE_ID, AVG(EXEC_TIME_MS), AVG(MEM_USAGE)
                FROM RULE_PERF_STATS
                WHERE ACTION_TIMESTAMP >= DATEADD(DAY, -7, GETDATE())
                GROUP BY RULE_ID
                HAVING AVG(EXEC_TIME_MS) > 2000 OR AVG(MEM_USAGE) > 50000
            """)
            perf = c.fetchall()
            if perf:
                lines.append("\nPerformance alerts (last 7 days):")
                for rid, avg_time, avg_mem in perf:
                    lines.append(f" - Rule {rid}: Avg Exec Time: {avg_time:.1f} ms, Avg Memory: {avg_mem:.1f} KB")
            else:
                lines.append("\nNo performance alerts in last 7 days.")
        except Exception as e:
            lines.append(f"Performance check error: {e}")
        try:
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, EXPIRY_TIMESTAMP
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < GETDATE()
            """)
            stale = c.fetchall()
            if stale:
                lines.append("\nStale locks detected:")
                for rid, owner, expiry in stale:
                    lines.append(f" - Rule {rid}: Locked by {owner}, expired at {expiry}")
            else:
                lines.append("\nNo stale locks detected.")
        except Exception as e:
            lines.append(f"Stale lock check error: {e}")
        self.alert_text.setPlainText("\n".join(lines))


# ---------------------- Main Application Launcher ----------------------
def main():
    app = QApplication(sys.argv)


    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    conn = db_dialog.connection
    if not conn:
        sys.exit(1)

    login_dialog = LoginDialog(conn)
    if login_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dialog.user_id
    user_group = login_dialog.user_group
    main_window = MainWindow(conn, user_id, user_group)
    main_window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

