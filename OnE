#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 1:
 - Consolidated imports
 - Logging
 - Email config + sender
 - Database connection dialog
 - Basic DB helpers
 - Login dialog
 - detect_operation_type
 - parse_sql_dependencies (with sqlparse or naive fallback)
 - Lifecycle states
 - OnboardingWizard (optional)
 
Plus minimal references to the new lock columns in BRM_RULES.
"""

import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import re
import csv
import difflib
import time
from datetime import datetime, date, time as pytime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer, QDate, QMimeData
from PyQt5.QtGui import QColor, QPainter, QBrush, QPen, QDrag
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog,
    QCalendarWidget, QAbstractItemView
)
import pyqtgraph as pg
from sqlparse.sql import Identifier, IdentifierList, Parenthesis
from sqlparse.tokens import Keyword, DML

logging.basicConfig(
    filename='brm_tool.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_user",
    "smtp_password": "your_smtp_pass",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)
        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email: {ex}")

class DatabaseConnectionDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Pick ODBC DSN or a custom connection string:")
        main_layout.addWidget(lbl)

        self.conn_type_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except:
            pass
        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string")
        main_layout.addWidget(self.conn_str_edit)

        bh = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

    def get_connection(self):
        override = self.conn_str_edit.text().strip()
        if override:
            conn_str = override
        else:
            choice = self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self, "Error", "No DSN or connection string.")
                return None
            conn_str = f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

def fetch_all_dict(cursor):
    rows = cursor.fetchall()
    if cursor.description:
        cols = [d[0] for d in cursor.description]
        return [dict(zip(cols,r)) for r in rows]
    return rows

def fetch_one_dict(cursor):
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [d[0] for d in cursor.description]
        return dict(zip(cols,row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    try:
        c = conn.cursor()
        c.execute("""
        INSERT INTO BRM_AUDIT_LOG(
          ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
          OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
        )
        VALUES(?,?,?,?,?,GETDATE())
        """,(
            action,
            table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
    except:
        pass

class LoginDialog(QtWidgets.QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.resize(300, 150)

        layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)
        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self,"Error","Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(un,pw))
        row = fetch_one_dict(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self,"Failed","Invalid credentials.")

def detect_operation_type(sql_text: str)->str:
    if not sql_text or not sql_text.strip():
        return "OTHER"
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    if txt.startswith("UPDATE"):
        return "UPDATE"
    if txt.startswith("DELETE"):
        return "DELETE"
    if txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

def parse_sql_dependencies(sql_text: str)->dict:
    # Either use sqlparse or naive approach
    out = {"tables":[],"columns":[],"alias_map":{}}
    try:
        stmts = sqlparse.parse(sql_text)
        for stmt in stmts:
            # from detection
            from_seen = False
            for token in stmt.tokens:
                val = token.value.upper() if token.value else ""
                if token.ttype is Keyword and val in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                    from_seen = True
                    continue
                if from_seen:
                    if isinstance(token,IdentifierList):
                        for ident in token.get_identifiers():
                            out["tables"].append((None, ident.get_real_name()))
                    elif isinstance(token,Identifier):
                        out["tables"].append((None, token.get_real_name()))
                    from_seen=False
    except:
        pass
    return out

RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]

class OnboardingWizard(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Welcome Wizard")
        self.resize(400,200)
        self.layout_ = QVBoxLayout(self)
        self.steps_label = QLabel("Wizard for new users.")
        self.layout_.addWidget(self.steps_label)
        self.current_step=0
        self.btn = QPushButton("Next")
        self.btn.clicked.connect(self.advance_step)
        self.layout_.addWidget(self.btn)

    def advance_step(self):
        self.current_step+=1
        if self.current_step==1:
            self.steps_label.setText("1) Manage Group.")
        elif self.current_step==2:
            self.steps_label.setText("2) Add Rule.")
        elif self.current_step==3:
            self.steps_label.setText("3) Scheduling.")
        else:
            self.accept()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 2:
 - BFS execution with advanced adjacency:
     * parent->child
     * global-critical => skip children on fail
     * conflicts => skip lower priority if fail
     * composites => skip composite if sub-rules fail
 - Multi-step approvals with color-coded pipeline checks
 - Lock/unlock + force unlock (admin only)
 - Table-level permission checks
 - Advanced CRUD: add, update, deactivate, delete (with version diffs)
 - Data validations integrated in BFS
"""

import json
import logging
import difflib
import time
from datetime import datetime
from collections import deque

# Reuse from Part 1:
#   fetch_one_dict, fetch_all_dict, insert_audit_log, detect_operation_type, parse_sql_dependencies
#   RULE_LIFECYCLE_STATES, etc.

def lock_rule(conn, rule_id, user_name):
    c = conn.cursor()
    c.execute("SELECT RULE_LOCKED, RULE_LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if not row:
        raise ValueError(f"Rule {rule_id} not found.")
    locked = row[0]
    if locked:
        raise ValueError(f"Rule {rule_id} is already locked by {row[1]}.")
    c.execute("""
      UPDATE BRM_RULES
      SET RULE_LOCKED=1, RULE_LOCKED_BY=?, RULE_LOCKED_TIMESTAMP=GETDATE()
      WHERE RULE_ID=?
    """,(user_name, rule_id))
    conn.commit()
    insert_audit_log(conn,"LOCK","BRM_RULES",rule_id,user_name,{"locked":False},{"locked":True})

def unlock_rule(conn, rule_id, user_name):
    c = conn.cursor()
    c.execute("SELECT RULE_LOCKED, RULE_LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if not row:
        raise ValueError(f"Rule {rule_id} not found.")
    locked, locked_by = row
    if not locked:
        raise ValueError(f"Rule {rule_id} is not locked.")
    if locked_by!=user_name:
        raise ValueError(f"Rule {rule_id} locked by {locked_by}, not current user {user_name}.")
    c.execute("""
      UPDATE BRM_RULES
      SET RULE_LOCKED=0, RULE_LOCKED_BY=NULL, RULE_LOCKED_TIMESTAMP=NULL
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
    insert_audit_log(conn,"UNLOCK","BRM_RULES",rule_id,user_name,{"locked":True},{"locked":False})

def force_unlock_rule(conn, rule_id, admin_user):
    # Admin only
    c = conn.cursor()
    c.execute("SELECT RULE_LOCKED FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if not row:
        raise ValueError(f"Rule {rule_id} not found.")
    locked = row[0]
    if not locked:
        raise ValueError(f"Rule {rule_id} is not locked, nothing to force unlock.")
    c.execute("""
      UPDATE BRM_RULES
      SET RULE_LOCKED=0, RULE_LOCKED_BY=NULL, RULE_LOCKED_TIMESTAMP=NULL
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
    insert_audit_log(conn,"FORCE_UNLOCK","BRM_RULES",rule_id,admin_user,{"locked":True},{"locked":False})

def check_table_permissions(conn, user_group, table_list):
    c = conn.cursor()
    denied = []
    for tbl in table_list:
        # unify name
        realtbl = tbl[1] if isinstance(tbl, tuple) else tbl
        if realtbl and realtbl.lower().startswith("(cte)"):
            continue
        c.execute("""
          SELECT 1
          FROM GROUP_PERMISSIONS
          WHERE GROUP_NAME=? AND TARGET_TABLE=?
        """,(user_group, realtbl))
        if not c.fetchone():
            denied.append(realtbl)
    if denied:
        raise ValueError(f"Missing permission on {denied}")

def run_data_validations(conn, rule_info):
    """
    For this rule’s table dependencies, fetch validations from DATA_VALIDATIONS
    and run them (naive approach => check row count returned).
    If a validation fails => return (False, message).
    """
    c = conn.cursor()
    rid = rule_info["RULE_ID"]
    # gather tables from BRM_RULE_TABLE_DEPENDENCIES
    c.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    deps = c.fetchall()
    tables = [r[0] for r in deps]
    for tbl in tables:
        c2 = conn.cursor()
        c2.execute("""
          SELECT VALIDATION_ID, COLUMN_NAME, VALIDATION_TYPE, PARAMS
          FROM DATA_VALIDATIONS
          WHERE TABLE_NAME=?
        """,(tbl,))
        validations = c2.fetchall()
        for (vid, col, vtype, pars) in validations:
            # minimal example => "NOT NULL" => check if we have any null
            if vtype.upper()=="NOT NULL":
                sql_ = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c3 = conn.cursor()
                c3.execute(sql_)
                cnt = c3.fetchone()[0]
                if cnt>0:
                    return (False, f"Validation fail: {tbl}.{col} has {cnt} NULLs.")
            elif vtype.upper()=="RANGE":
                # parse params => "min=0;max=100"
                # naive approach
                range_min = 0
                range_max = 9999999
                if pars:
                    for pair in pars.split(";"):
                        if pair.strip():
                            key,val = pair.strip().split("=")
                            key=key.strip().lower()
                            val=val.strip()
                            if key=="min":
                                range_min=float(val)
                            elif key=="max":
                                range_max=float(val)
                sql_ = f"SELECT COUNT(*) FROM {tbl} WHERE {col} < {range_min} OR {col} > {range_max}"
                c3 = conn.cursor()
                c3.execute(sql_)
                cnt = c3.fetchone()[0]
                if cnt>0:
                    return (False, f"Validation fail: {tbl}.{col} out-of-range count={cnt}.")
            # you can add more checks
    return (True, "All validations pass")

def create_multistep_approvals(conn, rule_id):
    """
    This sets up the pipeline: BG1->BG2->FINAL, or more advanced if needed.
    Color-coded approach can happen in the UI. We just store the rows.
    """
    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    # minimal example
    # 1) BG1
    c2=conn.cursor()
    c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME='BG1'")
    stage=1
    for row in c2.fetchall():
        un=row[0]
        c.execute("""
          INSERT INTO BRM_RULE_APPROVALS(
            RULE_ID, GROUP_NAME, USERNAME,
            APPROVED_FLAG, APPROVAL_STAGE
          )
          VALUES(?,?,?,?,?)
        """,(rule_id,"BG1",un,0,stage))
    stage+=1
    # 2) BG2
    c3=conn.cursor()
    c3.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME='BG2'")
    for row in c3.fetchall():
        un=row[0]
        c.execute("""
          INSERT INTO BRM_RULE_APPROVALS(
            RULE_ID, GROUP_NAME, USERNAME,
            APPROVED_FLAG, APPROVAL_STAGE
          )
          VALUES(?,?,?,?,?)
        """,(rule_id,"BG2",un,0,stage))
    stage+=1
    # 3) FINAL single user
    c.execute("""
      INSERT INTO BRM_RULE_APPROVALS(
        RULE_ID, GROUP_NAME, USERNAME,
        APPROVED_FLAG, APPROVAL_STAGE
      )
      VALUES(?,?,?,?,?)
    """,(rule_id,"FINAL","final_approver",0,stage))
    conn.commit()

def add_rule(conn, rule_data, created_by, user_group):
    c=conn.cursor()
    # check lock => not relevant on new rule
    # parse
    sql_ = rule_data.get("RULE_SQL","")
    op_type = detect_operation_type(sql_)
    deps = parse_sql_dependencies(sql_)
    table_list = deps["tables"]
    check_table_permissions(conn,user_group,table_list)
    # insert
    c.execute("""
      INSERT INTO BRM_RULES(
        GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,
        RULE_NAME,RULE_SQL,EFFECTIVE_START_DATE,
        EFFECTIVE_END_DATE,STATUS,VERSION,CREATED_BY,
        DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
        CREATED_TIMESTAMP,OWNER_GROUP,APPROVAL_STATUS,
        IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE,
        LIFECYCLE_STATE,RULE_LOCKED,RULE_LOCKED_BY,
        RULE_LOCKED_TIMESTAMP,CLUSTER_NAME
      )
      OUTPUT inserted.RULE_ID
      VALUES(?,?,?,?,?,
             ?,?,
             ?,?,
             ?,
             ?,?,?,GETDATE(),?,
             'APPROVAL_IN_PROGRESS',?,?,?,?,?,'DRAFT',0,NULL,NULL,'')
    """,(
      rule_data.get("GROUP_ID"),
      rule_data.get("PARENT_RULE_ID"),
      rule_data.get("RULE_TYPE_ID"),
      rule_data["RULE_NAME"].strip(),
      sql_.strip(),
      rule_data.get("EFFECTIVE_START_DATE"),
      rule_data.get("EFFECTIVE_END_DATE"),
      "INACTIVE",
      1,
      created_by,
      rule_data.get("DESCRIPTION",""),
      op_type,
      rule_data.get("BUSINESS_JUSTIFICATION",""),
      rule_data.get("OWNER_GROUP","BG1"),
      rule_data.get("IS_GLOBAL",0),
      rule_data.get("CRITICAL_RULE",0),
      rule_data.get("CRITICAL_SCOPE","NONE"),
      rule_data.get("CDC_TYPE","NONE"),
    ))
    new_id = c.fetchone()[0]
    # deps
    c2 = conn.cursor()
    col_op = "READ" if op_type=="SELECT" else "WRITE"
    for t_ in table_list:
        if t_[1] and not t_[1].lower().startswith("(cte)"):
            c2.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
              )
              VALUES(?,?,?,?,?)
            """,(new_id, t_[0], t_[1], "AutoCol", col_op))
    conn.commit()
    insert_audit_log(conn,"INSERT","BRM_RULES",new_id,created_by,None,rule_data)
    create_multistep_approvals(conn, new_id)
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    rid = rule_data["RULE_ID"]
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
    old=c.fetchone()
    if not old:
        raise ValueError(f"Rule {rid} not found.")
    colnames = [desc[0] for desc in c.description]
    old_data = dict(zip(colnames, old))
    # check lock
    if not old_data["RULE_LOCKED"] or old_data["RULE_LOCKED_BY"]!=updated_by:
        raise ValueError(f"Rule {rid} must be locked by you before update.")
    # parse
    new_sql = rule_data.get("RULE_SQL","").strip()
    op_type = detect_operation_type(new_sql)
    deps = parse_sql_dependencies(new_sql)
    check_table_permissions(conn,user_group,deps["tables"])
    # version+1
    c.execute("""
      UPDATE BRM_RULES
      SET GROUP_ID=?,
          PARENT_RULE_ID=?,
          RULE_TYPE_ID=?,
          RULE_NAME=?,
          RULE_SQL=?,
          EFFECTIVE_START_DATE=?,
          EFFECTIVE_END_DATE=?,
          STATUS='INACTIVE',
          VERSION=VERSION+1,
          UPDATED_BY=?,
          DESCRIPTION=?,
          OPERATION_TYPE=?,
          BUSINESS_JUSTIFICATION=?,
          OWNER_GROUP=?,
          APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
          IS_GLOBAL=?,
          CRITICAL_RULE=?,
          CRITICAL_SCOPE=?,
          CDC_TYPE=?,
          LIFECYCLE_STATE='UNDER_APPROVAL'
      WHERE RULE_ID=?
    """,(
      rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
      rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"].strip(),
      new_sql,
      rule_data.get("EFFECTIVE_START_DATE"),
      rule_data.get("EFFECTIVE_END_DATE"),
      updated_by,
      rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
      op_type,
      rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
      rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
      rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
      rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
      rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
      rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
      rid
    ))
    # rebuild deps
    c2=conn.cursor()
    c2.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
    col_op="READ" if op_type=="SELECT" else "WRITE"
    for t_ in deps["tables"]:
        if t_[1] and not t_[1].lower().startswith("(cte)"):
            c2.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
              )
              VALUES(?,?,?,?,?)
            """,(rid,t_[0],t_[1],"UpdatedCol",col_op))
    conn.commit()
    new_data = dict(old_data)
    for k,v in rule_data.items():
        new_data[k] = v
    new_data["RULE_SQL"] = new_sql
    new_data["VERSION"] = old_data["VERSION"]+1
    # diff
    if new_sql!=old_data["RULE_SQL"]:
        old_lines = (old_data["RULE_SQL"] or "").splitlines()
        new_lines = (new_sql or "").splitlines()
        diff_ = difflib.unified_diff(old_lines,new_lines,fromfile="old",tofile="new",linenos=True)
        new_data["_sql_diff_"] = "\n".join(diff_)
    insert_audit_log(conn,"UPDATE","BRM_RULES",rid,updated_by,old_data,new_data)
    create_multistep_approvals(conn, rid)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError(f"Rule {rule_id} not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old))
    # check lock
    if not old_data["RULE_LOCKED"] or old_data["RULE_LOCKED_BY"]!=updated_by:
        raise ValueError(f"Rule {rule_id} must be locked by you before deactivation.")
    c.execute("""
      UPDATE BRM_RULES
      SET STATUS='INACTIVE', VERSION=VERSION+1, LIFECYCLE_STATE='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()
    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["LIFECYCLE_STATE"]="INACTIVE"
    insert_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)

def delete_rule(conn, rule_id, action_by, user_group):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError(f"Rule {rule_id} not found.")
    cols=[d[0] for d in c.description]
    old_data=dict(zip(cols,old))
    # check lock
    if not old_data["RULE_LOCKED"] or old_data["RULE_LOCKED_BY"]!=action_by:
        raise ValueError(f"Rule {rule_id} must be locked by you before deleting.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE before deletion.")
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    conn.commit()
    insert_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)

def load_rule_relationships(conn):
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows=c.fetchall()
    adjacency={}
    all_ids=set()
    parent_map={}
    for (rid,pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid,set()).add(rid)
            parent_map[rid]=pid
    # global-critical
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcr = c.fetchall()
    for (gcrid, childid) in gcr:
        adjacency.setdefault(gcrid,set()).add(childid)
    # conflicts
    c.execute("SELECT RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    confs = c.fetchall()
    for (r1,r2,pri) in confs:
        adjacency.setdefault(r1,set()).add(r2)
        adjacency.setdefault(r2,set()).add(r1)
    # composites
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp = c.fetchall()
    pat = re.compile(r"Rule(\d+)")
    for (crid, expr) in comp:
        if not expr: continue
        matches = pat.findall(expr)
        for m_ in matches:
            sub_id = int(m_)
            adjacency.setdefault(sub_id,set()).add(crid)
    # find roots
    child_ids = set(parent_map.keys())
    roots = [r for r in all_ids if r not in child_ids]
    return adjacency, roots

def get_rule_map(conn):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows=c.fetchall()
    cols=[desc[0] for desc in c.description]
    out={}
    for row in rows:
        d=dict(zip(cols,row))
        out[d["RULE_ID"]]=d
    return out

def execute_rules_dag_bfs(conn):
    adjacency, roots = load_rule_relationships(conn)
    rule_map = get_rule_map(conn)
    executed=[]
    skipped=set()
    queue = list(roots)
    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        rule_info = rule_map[rid]
        # run data validations first
        okval, msgval = run_data_validations(conn, rule_info)
        if not okval:
            skipped.add(rid)
            # skip adjacency
            if rid in adjacency:
                stck = list(adjacency[rid])
                while stck:
                    ch = stck.pop()
                    if ch not in skipped:
                        skipped.add(ch)
                        if ch in adjacency:
                            stck.extend(adjacency[ch])
            continue
        # then run the rule SQL
        start=time.time()
        c=conn.cursor()
        c.execute("BEGIN TRAN")
        pass_flag=False
        message=""
        rec_count=0
        try:
            sql_ = rule_info.get("RULE_SQL","").strip()
            if sql_:
                c.execute(sql_)
                rows_=c.fetchall()
                if rows_:
                    rec_count=len(rows_)
                    val=rows_[0][0]
                    pass_flag=(val==1)
                    message=f"Returned: {val}"
                else:
                    pass_flag=True
                    message="No rows => pass"
            else:
                pass_flag=True
                message="Empty SQL => pass"
            if pass_flag:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
        except Exception as ex:
            c.execute("ROLLBACK")
            pass_flag=False
            message=str(ex)
        end=time.time()
        dur=end-start
        # log
        c.execute("""
          INSERT INTO RULE_EXECUTION_LOGS(
            RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
            MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS
          )
          VALUES(?,GETDATE(),?,?,?,?)
        """,(rid, 1 if pass_flag else 0, message, rec_count, dur*1000))
        conn.commit()
        if pass_flag:
            executed.append(rid)
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip adjacency
            if rid in adjacency:
                stck = list(adjacency[rid])
                while stck:
                    ch = stck.pop()
                    if ch not in skipped:
                        skipped.add(ch)
                        if ch in adjacency:
                            stck.extend(adjacency[ch])
    return (executed, skipped)

def load_current_stage_for_rule(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      SELECT MIN(APPROVAL_STAGE)
      FROM BRM_RULE_APPROVALS
      WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row=c.fetchone()
    if row and row[0]:
        return row[0]
    return None

def set_rule_approved(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='APPROVED',STATUS='ACTIVE',LIFECYCLE_STATE='ACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_in_progress(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

def set_rule_rejected(conn, rule_id):
    c=conn.cursor()
    c.execute("""
      UPDATE BRM_RULES
      SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
      WHERE RULE_ID=?
    """,(rule_id,))
    conn.commit()

⸻



#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 3:
 - Single/chain/group simulations (dry-run BFS) => no commits.
 - Scheduling dialogs + management tab.
 - Sync metadata that also captures data types for each column.
 - DataValidationTab: run validations and store results.
 
We assume we have references from Part 1 & Part 2:
   - fetch_one_dict, fetch_all_dict, insert_audit_log
   - advanced BFS logic
   - check_table_permissions, run_data_validations
"""

import sys
import json
import csv
import logging
import time
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QPushButton, QPlainTextEdit, QLineEdit, QComboBox,
    QCalendarWidget, QTableWidget, QTableWidgetItem, QListWidget, QListWidgetItem,
    QMessageBox, QInputDialog, QFileDialog
)
from PyQt5.QtCore import Qt, QDate

import pyodbc
import pyqtgraph as pg

# Reuse from Part 1 & 2:
#   parse_sql_dependencies, detect_operation_type, insert_audit_log, fetch_all_dict

def dry_run_bfs(conn, start_rule_ids=None):
    """
    Non-destructive BFS => always ROLLBACK changes. Also calls run_data_validations but does not commit.
    Returns (executed, skipped).
    """
    from Part2File import load_rule_relationships, get_rule_map  # adapt to your structure if single file

    adjacency, roots = load_rule_relationships(conn)
    rule_map = get_rule_map(conn)
    executed=[]
    skipped=set()
    queue = list(start_rule_ids) if start_rule_ids else roots
    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        rule_info = rule_map[rid]
        # run validations
        okv, msgv = run_data_validations(conn, rule_info)
        if not okv:
            skipped.add(rid)
            continue
        c=conn.cursor()
        c.execute("BEGIN TRAN")
        pass_flag=True
        msg=""
        rec_count=0
        try:
            sql_=rule_info.get("RULE_SQL","").strip()
            if sql_:
                c.execute(sql_)
                rows=c.fetchall()
                if rows:
                    rec_count=len(rows)
                    val=rows[0][0]
                    pass_flag=(val==1)
                    msg=f"Returned: {val}"
                else:
                    msg="No rows => pass"
            else:
                msg="Empty => pass"
        except Exception as ex:
            pass_flag=False
            msg=str(ex)
        finally:
            c.execute("ROLLBACK")
        if pass_flag:
            executed.append(rid)
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip adjacency
            if rid in adjacency:
                stck = list(adjacency[rid])
                while stck:
                    x_ = stck.pop()
                    if x_ not in skipped:
                        skipped.add(x_)
                        if x_ in adjacency:
                            stck.extend(adjacency[x_])
    return (executed, skipped)

class SingleRuleSimulationDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Simulate Single Rule {rule_id} - Dry Run")
        self.resize(500,300)
        layout=QVBoxLayout(self)

        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        bh=QHBoxLayout()
        run_btn=QPushButton("Dry-Run BFS")
        run_btn.clicked.connect(self.do_run)
        bh.addWidget(run_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

    def do_run(self):
        ex, sk = dry_run_bfs(self.connection, [self.rule_id])
        txt=f"Executed => {ex}\nSkipped => {sk}"
        self.output.setPlainText(txt)

class ChainOrGroupSimulationDialog(QDialog):
    def __init__(self, connection, is_group=False, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.is_group=is_group
        self.setWindowTitle("Simulate (Chain or Group) Dry-Run")
        self.resize(600,400)
        layout=QVBoxLayout(self)

        self.combo=QComboBox()
        c=connection.cursor()
        if is_group:
            c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            rows=c.fetchall()
            for (cid,name) in rows:
                disp=f"{cid} - {name}"
                self.combo.addItem(disp, cid)
        else:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            rows=c.fetchall()
            for (rid,rn) in rows:
                disp=f"{rid} - {rn}"
                self.combo.addItem(disp, rid)
        layout.addWidget(self.combo)

        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        bh=QHBoxLayout()
        run_btn=QPushButton("Simulate BFS")
        run_btn.clicked.connect(self.simulate)
        bh.addWidget(run_btn)
        cls=QPushButton("Close")
        cls.clicked.connect(self.close)
        bh.addWidget(cls)
        layout.addLayout(bh)
        self.setLayout(layout)

    def simulate(self):
        val=self.combo.currentData()
        if self.is_group:
            # gather rules in group
            c=self.connection.cursor()
            c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(val,))
            rids=[r[0] for r in c.fetchall()]
            ex,sk = dry_run_bfs(self.connection, rids)
            txt=f"Group {val}\nExecuted=>{ex}\nSkipped=>{sk}"
        else:
            ex,sk = dry_run_bfs(self.connection, [val])
            txt=f"Chain start {val}\nExecuted=>{ex}\nSkipped=>{sk}"
        self.output.setPlainText(txt)

def sync_metadata_improved(conn):
    """
    Enhanced to capture data types. We'll look up columns in INFORMATION_SCHEMA.COLUMNS
    and see if we need to mark them in BRM_RULE_TABLE_DEPENDENCIES => storing in COLUMN_DATA_TYPE.
    For missing tables => prefix "MISSING_".
    """
    c=conn.cursor()
    c.execute("""
      SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH
      FROM INFORMATION_SCHEMA.COLUMNS
    """)
    valid_map = {}  # (schema.lower(), table.lower(), col.lower()) => type
    table_set = set()
    for row in c.fetchall():
        sch,tn,cn,dt,l_ = row
        key=(sch.lower(), tn.lower(), cn.lower())
        dtype=dt.upper()
        if dt.upper() in ("CHAR","VARCHAR","NVARCHAR"):
            if l_:
                dtype=f"{dt.upper()}({l_})"
        valid_map[key]=dtype
        table_set.add((sch.lower(), tn.lower()))

    c.execute("SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    rows=c.fetchall()
    updated_count=0
    missing_count=0
    for (dep_id,dbn,tn,cn) in rows:
        if not tn: continue
        t_low=tn.lower()
        # assume dbn might be "dbo" or similar
        sch = dbn.lower() if dbn else "dbo"
        c_low=cn.lower() if cn else ""
        if (sch, t_low) not in table_set:
            # prefix missing
            if not t_low.startswith("missing_"):
                c2=conn.cursor()
                c2.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET TABLE_NAME='MISSING_'+TABLE_NAME WHERE DEPENDENCY_ID=?",(dep_id,))
                missing_count+=1
        else:
            # try to set data type if found
            key=(sch, t_low, c_low)
            dtp = valid_map.get(key)
            if dtp:
                c2=conn.cursor()
                c2.execute("UPDATE BRM_RULE_TABLE_DEPENDENCIES SET COLUMN_DATA_TYPE=? WHERE DEPENDENCY_ID=?", (dtp,dep_id))
                updated_count+=1
    conn.commit()
    QMessageBox.information(None, "Metadata Sync", f"Updated data types: {updated_count}, Marked missing: {missing_count}")

class EnhancedScheduleDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Add New Schedule")
        self.resize(400,300)
        layout=QVBoxLayout(self)

        form=QFormLayout()
        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            disp=f"{row[0]} - {row[1]}"
            self.rule_combo.addItem(disp,row[0])
        form.addRow("Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        form.addRow("Date:", self.calendar)

        self.time_edit=QLineEdit()
        self.time_edit.setPlaceholderText("HH:MM:SS")
        form.addRow("Time:", self.time_edit)

        layout.addLayout(form)
        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)
        cl_btn=QPushButton("Close")
        cl_btn.clicked.connect(self.close)
        bh.addWidget(cl_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        dt_ = self.calendar.selectedDate()
        t_ = self.time_edit.text().strip()
        if not t_:
            QMessageBox.warning(self,"Missing","Enter time.")
            return
        full_dt=f"{dt_.toString('yyyy-MM-dd')} {t_}"
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO RULE_SCHEDULES(
            RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP
          )
          VALUES(?,?,?,GETDATE())
        """,(rid,full_dt,"Scheduled"))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} => {full_dt}.")
        self.close()

class ScheduleManagementTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["SchedID","RuleID","Time","Status","Actions"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)

        add_btn=QPushButton("New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
          FROM RULE_SCHEDULES
          ORDER BY SCHEDULE_TIME DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(4):
                it=QTableWidgetItem(str(row[col_i]))
                self.table.setItem(r_i,col_i,it)
            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)
            upd=QPushButton("Update")
            upd.clicked.connect(lambda _,r=r_i:self.update_schedule(r))
            ah.addWidget(upd)
            dlt=QPushButton("Delete")
            dlt.clicked.connect(lambda _,r=r_i:self.delete_schedule(r))
            ah.addWidget(dlt)
            ah.addStretch()
            self.table.setCellWidget(r_i,4,act_w)
        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self,row_idx):
        sched_id_item=self.table.item(row_idx,0)
        if not sched_id_item:
            return
        sid=int(sched_id_item.text())
        new_dt,ok=QInputDialog.getText(self,"Update","New datetime (YYYY-MM-DD HH:MM:SS):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(new_dt.strip(),sid))
            self.connection.commit()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self,row_idx):
        sid_item=self.table.item(row_idx,0)
        if not sid_item:
            return
        sid=int(sid_item.text())
        if QMessageBox.question(self,"Confirm",f"Delete schedule {sid}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sid} removed.")
        self.load_schedules()

class DataValidationTab(QWidget):
    """
    Now includes a "Run Validation" button that triggers run_data_validations for all rules or a specific rule,
    then stores results in a dedicated table (or in RULE_EXECUTION_LOGS as a special entry).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.val_table=QTableWidget(0,5)
        self.val_table.setHorizontalHeaderLabels(["ValID","Table","Column","Type","Params"])
        self.val_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.val_table)

        bh=QHBoxLayout()
        addb=QPushButton("Add Validation")
        addb.clicked.connect(self.add_val)
        bh.addWidget(addb)
        delb=QPushButton("Remove Validation")
        delb.clicked.connect(self.remove_val)
        bh.addWidget(delb)

        runb=QPushButton("Run Validations Now")
        runb.clicked.connect(self.run_validations_now)
        bh.addWidget(runb)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_vals)
        bh.addWidget(refb)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.val_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
          FROM DATA_VALIDATIONS
          ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.val_table.rowCount()
            self.val_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.val_table.setItem(r_i,col_i,it)

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","TableName (e.g. dbo.Customers):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column:")
        if not ok2 or not col.strip():
            return
        vtyp,ok3=QInputDialog.getText(self,"ValType","(e.g. NOT NULL,RANGE):")
        if not ok3 or not vtyp.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","(e.g. min=0;max=100) optional:")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO DATA_VALIDATIONS(
            TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
          )
          VALUES(?,?,?,?)
        """,(tbl.strip(), col.strip(), vtyp.strip(), pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Validation created.")
        self.load_vals()

    def remove_val(self):
        row=self.val_table.currentRow()
        if row<0:
            return
        vid_item=self.val_table.item(row,0)
        if not vid_item:
            return
        vid=int(vid_item.text())
        if QMessageBox.question(self,"Confirm",f"Remove validation {vid}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

    def run_validations_now(self):
        """
        For demonstration, we run validations for each rule in BRM_RULES and collect fail messages
        or pass. Then store in RULE_EXECUTION_LOGS as a 'validation-run'.
        """
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_SQL FROM BRM_RULES")
        all_rules=c.fetchall()
        fail_count=0
        pass_count=0
        for (rid,rsql) in all_rules:
            # pretend we have a rule_info
            rule_info={"RULE_ID":rid,"RULE_SQL":rsql}
            ok,msg=run_data_validations(self.connection, rule_info)
            pass_flag=1 if ok else 0
            if ok:
                pass_count+=1
            else:
                fail_count+=1
            c2=self.connection.cursor()
            c2.execute("""
              INSERT INTO RULE_EXECUTION_LOGS(
                RULE_ID,EXECUTION_TIMESTAMP,PASS_FLAG,MESSAGE,RECORD_COUNT,EXECUTION_TIME_MS
              )
              VALUES(?,GETDATE(),?,?,?,0)
            """,(rid,pass_flag,f"[Validation] {msg}",0))
        self.connection.commit()
        QMessageBox.information(self,"Done",f"Validations => pass={pass_count}, fail={fail_count}")
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 4:
 - AuditLogViewer
 - RuleSearchDialog
 - VersionHistoryDialog (with line-by-line diff)
 - RuleDashboard (pagination, filters, lock/unlock, performance chart)
 - RuleEditorDialog (with lock requirement)
"""

import sys
import os
import json
import math
import csv
import logging
import difflib
from datetime import datetime
from collections import defaultdict

from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox,
    QWidget, QAbstractItemView
)
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtGui import QColor

import pyqtgraph as pg

# We use code from Part 1 & 2:
#   insert_audit_log, fetch_one_dict, fetch_all_dict
#   lock_rule, unlock_rule, force_unlock_rule
#   add_rule, update_rule, deactivate_rule, delete_rule
#   detect_operation_type, parse_sql_dependencies
#   set_rule_approved, set_rule_in_progress, set_rule_rejected
#   check_table_permissions

class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs")
        self.resize(900,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search action/table/action_by..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.table=QTableWidget(0,8)
        self.table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        csv_btn=QPushButton("Export CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)

        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,
                 OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
          FROM BRM_AUDIT_LOG
          ORDER BY ACTION_TIMESTAMP DESC
          OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(8):
                val=row[col_i]
                if col_i in (5,6) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def perform_search(self, txt):
        txt=txt.lower()
        for row_i in range(self.table.rowCount()):
            show=False
            for col_i in (1,2,4):  # action, table_name, action_by
                it=self.table.item(row_i,col_i)
                if it and txt in it.text().lower():
                    show=True
                    break
            self.table.setRowHidden(row_i, not show)

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            wr=csv.writer(f)
            headers=[self.table.horizontalHeaderItem(i).text() for i in range(self.table.columnCount())]
            wr.writerow(headers)
            for row_i in range(self.table.rowCount()):
                if self.table.isRowHidden(row_i):
                    continue
                row_data=[]
                for col_i in range(self.table.columnCount()):
                    it=self.table.item(row_i,col_i)
                    row_data.append(it.text() if it else "")
                wr.writerow(row_data)
        QMessageBox.information(self,"Exported",f"Audit logs => {path}.")

class RuleSearchDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Search Rules")
        self.resize(850,600)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Enter partial rule name or snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.table=QTableWidget(0,7)
        self.table.setHorizontalHeaderLabels(["RuleID","Name","SQL","Status","Version","CreatedBy","Locked?"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        ref=QPushButton("Refresh")
        ref.clicked.connect(self.load_results)
        layout.addWidget(ref)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY,RULE_LOCKED
              FROM BRM_RULES
              WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY,RULE_LOCKED
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)

class VersionHistoryDialog(QDialog):
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History for Rule {rule_id}")
        self.resize(900,500)
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        self.compare_btn=QPushButton("Compare Selected")
        self.compare_btn.clicked.connect(self.do_compare)
        bh.addWidget(self.compare_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
          FROM BRM_AUDIT_LOG
          WHERE TABLE_NAME='BRM_RULES'
            AND RECORD_ID=?
            AND ACTION IN ('INSERT','UPDATE')
          ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                if col_i in (3,4) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def do_compare(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected.")
            return
        row_idx=sel[0].row()
        old_data_item=self.table.item(row_idx,3)
        new_data_item=self.table.item(row_idx,4)
        if not old_data_item or not new_data_item:
            QMessageBox.warning(self,"Missing","No old/new data to compare.")
            return
        old_s=old_data_item.text() or ""
        new_s=new_data_item.text() or ""
        old_lines=old_s.splitlines()
        new_lines=new_s.splitlines()
        diff=difflib.unified_diff(old_lines,new_lines,fromfile="old",tofile="new",lineterm='')
        diff_str="\n".join(diff)
        dlg=QDialog(self)
        dlg.setWindowTitle("Line-by-line Diff")
        dlg.resize(800,600)
        l=QVBoxLayout(dlg)
        txt=QPlainTextEdit()
        txt.setReadOnly(True)
        txt.setPlainText(diff_str)
        l.addWidget(txt)
        cl=QPushButton("Close")
        cl.clicked.connect(dlg.close)
        l.addWidget(cl)
        dlg.exec_()

class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Business Rules Dashboard", parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL..")
        self.search_edit.textChanged.connect(self.load_rules)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)

        perf_btn=QPushButton("Show Performance Chart")
        perf_btn.clicked.connect(self.show_performance_chart)
        top_h.addWidget(perf_btn)

        main_layout.addLayout(top_h)

        self.table=QTableWidget(0,10)
        self.table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","Locked?","LockedBy",
            "CreatedTS","ApprovalStatus","Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.page_label=QLabel("Page 1/1")
        self.next_btn=QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        nav_h.addStretch()
        main_layout.addLayout(nav_h)
        self.setLayout(main_layout)
        self.selected_rule_id=None
        self.load_rules()

    def build_filter_clause(self):
        cond=[]
        pars=[]
        txt=self.search_edit.text().strip()
        if txt:
            cond.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            pars.extend([f"%{txt}%",f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            cond.append("STATUS=?")
            pars.append(st)
        if not cond:
            clause="1=1"
        else:
            clause=" AND ".join(cond)
        return clause, pars

    def load_rules(self):
        c=self.connection.cursor()
        clause,pars=self.build_filter_clause()
        count_q=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(count_q,pars)
        total=c.fetchone()[0]
        self.total_pages= max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset=(self.current_page-1)*self.records_per_page
        data_q=f"""
          SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,RULE_LOCKED,RULE_LOCKED_BY,
                 CREATED_TIMESTAMP,APPROVAL_STATUS
          FROM BRM_RULES
          WHERE {clause}
          ORDER BY RULE_ID DESC
          OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*pars,offset,self.records_per_page))
        rows=c.fetchall()

        self.table.setRowCount(0)
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(9):
                val=row[col_i]
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)
            # last col => actions
            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)

            lock_btn=QPushButton("Lock")
            lock_btn.clicked.connect(lambda _,rid=row[0]: self.lock_this_rule(rid))
            ah.addWidget(lock_btn)

            unl_btn=QPushButton("Unlock")
            unl_btn.clicked.connect(lambda _,rid=row[0]: self.unlock_this_rule(rid))
            ah.addWidget(unl_btn)

            if self.user_group.lower()=="admin":
                force_btn=QPushButton("ForceUnlock")
                force_btn.clicked.connect(lambda _,rid=row[0]: self.force_unlock_this_rule(rid))
                ah.addWidget(force_btn)

            ah.addStretch()
            self.table.setCellWidget(r_i,9,act_w)

    def get_selected_rule_ids(self):
        sel=self.table.selectionModel().selectedRows()
        out=[]
        for i_ in sel:
            row=i_.row()
            rid_item=self.table.item(row,0)
            if rid_item:
                out.append(int(rid_item.text()))
        return out

    def update_selected_rule_id(self):
        sel=self.table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row=sel[0].row()
        it=self.table.item(row,0)
        if it:
            self.selected_rule_id=int(it.text())
        else:
            self.selected_rule_id=None

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

    def lock_this_rule(self, rid):
        if not rid:
            return
        from Part2File import lock_rule  # adapt to your actual structure
        try:
            lock_rule(self.connection, rid, f"UserID:{self.user_id}")
            QMessageBox.information(self,"Locked",f"Rule {rid} locked by you.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_rules()

    def unlock_this_rule(self, rid):
        if not rid:
            return
        from Part2File import unlock_rule
        try:
            unlock_rule(self.connection, rid, f"UserID:{self.user_id}")
            QMessageBox.information(self,"Unlocked",f"Rule {rid} unlocked by you.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_rules()

    def force_unlock_this_rule(self, rid):
        if not rid:
            return
        from Part2File import force_unlock_rule
        if self.user_group.lower()!="admin":
            QMessageBox.warning(self,"Denied","Only admin can force unlock.")
            return
        try:
            force_unlock_rule(self.connection, rid, f"Admin:{self.user_id}")
            QMessageBox.information(self,"Force Unlocked",f"Rule {rid} forcibly unlocked.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_rules()

    def show_performance_chart(self):
        sel=self.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        rid=sel[0]
        c=self.connection.cursor()
        c.execute("""
          SELECT EXECUTION_TIMESTAMP, EXECUTION_TIME_MS
          FROM RULE_EXECUTION_LOGS
          WHERE RULE_ID=?
          ORDER BY EXECUTION_TIMESTAMP
        """,(rid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"Empty","No logs to show.")
            return
        if not pg:
            QMessageBox.information(self,"PyQtGraph missing","Cannot show chart.")
            return
        dlg=QDialog(self)
        dlg.setWindowTitle(f"Performance Chart - Rule {rid}")
        dlg.resize(800,600)
        l=QVBoxLayout(dlg)
        plot=pg.PlotWidget(title=f"Rule {rid} Perf (ms) vs Time")
        xvals=[]
        yvals=[]
        for row_ in rows:
            ts=row_[0]
            ms=row_[1]
            xvals.append(ts.timestamp())
            yvals.append(ms or 0)
        plot.plot(xvals,yvals,pen='b',symbol='o')
        l.addWidget(plot)
        cl=QPushButton("Close")
        cl.clicked.connect(dlg.close)
        l.addWidget(cl)
        dlg.exec_()

class RuleEditorDialog(QDialog):
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)
        title="Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title)
        self.resize(850,600)

        main_layout=QVBoxLayout(self)
        form_layout=QFormLayout()

        # group id
        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        for row in c.fetchall():
            disp=f"{row[0]} - {row[1]}"
            self.group_combo.addItem(disp,row[0])
        form_layout.addRow("Group ID:", self.group_combo)

        # parent
        self.parent_combo=QComboBox()
        self.parent_combo.addItem("(None)",None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            disp2=f"{row[0]} - {row[1]}"
            self.parent_combo.addItem(disp2,row[0])
        form_layout.addRow("Parent Rule:", self.parent_combo)

        # name
        self.name_edit=QLineEdit()
        form_layout.addRow("Rule Name:", self.name_edit)
        # type
        self.type_combo=QComboBox()
        c.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for row in c.fetchall():
            self.type_combo.addItem(row[1],row[0])
        form_layout.addRow("Rule Type:", self.type_combo)

        # status
        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_layout.addRow("Status:", self.status_combo)

        # dates
        self.start_edit=QLineEdit()
        self.start_edit.setPlaceholderText("YYYY-MM-DD HH:MM:SS or blank")
        form_layout.addRow("Effective Start:", self.start_edit)

        self.end_edit=QLineEdit()
        self.end_edit.setPlaceholderText("YYYY-MM-DD HH:MM:SS or blank")
        form_layout.addRow("Effective End:", self.end_edit)

        # cdc
        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_layout.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit=QPlainTextEdit()
        form_layout.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit=QPlainTextEdit()
        form_layout.addRow("Description:", self.desc_edit)

        self.just_edit=QPlainTextEdit()
        form_layout.addRow("Business Justification:", self.just_edit)

        self.global_cb=QComboBox()
        self.global_cb.addItems(["No","Yes"])
        form_layout.addRow("Is Global?:", self.global_cb)

        self.crit_cb=QComboBox()
        self.crit_cb.addItems(["No","Yes"])
        form_layout.addRow("Critical Rule?:", self.crit_cb)

        self.scope_cb=QComboBox()
        self.scope_cb.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_layout.addRow("Critical Scope:", self.scope_cb)

        main_layout.addLayout(form_layout)

        bh=QHBoxLayout()
        self.save_btn=QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)

        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

        if self.is_update:
            self.load_existing()

    def load_existing(self):
        rd=self.rule_data
        # group
        if rd["GROUP_ID"]:
            idx=self.group_combo.findData(rd["GROUP_ID"])
            if idx>=0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2=self.parent_combo.findData(rd["PARENT_RULE_ID"])
            if idx2>=0:
                self.parent_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"] or "")
        # type
        if rd["RULE_TYPE_ID"]:
            i3=self.type_combo.findData(rd["RULE_TYPE_ID"])
            if i3>=0:
                self.type_combo.setCurrentIndex(i3)
        st=rd.get("STATUS","INACTIVE")
        i4=self.status_combo.findText(st)
        if i4>=0:
            self.status_combo.setCurrentIndex(i4)
        if rd["EFFECTIVE_START_DATE"]:
            self.start_edit.setText(str(rd["EFFECTIVE_START_DATE"]))
        if rd["EFFECTIVE_END_DATE"]:
            self.end_edit.setText(str(rd["EFFECTIVE_END_DATE"]))
        self.cdc_combo.setCurrentText(rd.get("CDC_TYPE","NONE"))
        if rd["RULE_SQL"]:
            self.sql_edit.setPlainText(rd["RULE_SQL"])
        if rd["DESCRIPTION"]:
            self.desc_edit.setPlainText(rd["DESCRIPTION"])
        if rd["BUSINESS_JUSTIFICATION"]:
            self.just_edit.setPlainText(rd["BUSINESS_JUSTIFICATION"])
        self.global_cb.setCurrentText("Yes" if rd["IS_GLOBAL"] else "No")
        self.crit_cb.setCurrentText("Yes" if rd["CRITICAL_RULE"] else "No")
        self.scope_cb.setCurrentText(rd.get("CRITICAL_SCOPE","NONE"))

    def save_rule(self):
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Missing","Rule name is required.")
            return
        group_id=self.group_combo.currentData()
        parent_id=self.parent_combo.currentData()
        rtype_id=self.type_combo.currentData()
        st=self.status_combo.currentText()
        sdt=self.start_edit.text().strip() or None
        edt=self.end_edit.text().strip() or None
        cdcv=self.cdc_combo.currentText().strip()
        sql_=self.sql_edit.toPlainText().strip()
        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()
        isg=1 if self.global_cb.currentText()=="Yes" else 0
        isc=1 if self.crit_cb.currentText()=="Yes" else 0
        scopev=self.scope_cb.currentText().strip()

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rtype_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sdt,
            "EFFECTIVE_END_DATE": edt,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scopev,
            "CDC_TYPE": cdcv
        }
        if self.is_update:
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            from Part2File import update_rule
            try:
                update_rule(self.connection, rule_dict, f"UserID:{self.parent().user_id}", self.user_group)
                QMessageBox.information(self,"Updated","Rule updated => re-approval triggered.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            from Part2File import add_rule
            try:
                new_id=add_rule(self.connection, rule_dict, f"UserID:{self.parent().user_id}", self.user_group)
                QMessageBox.information(self,"Created",f"New rule (ID={new_id}) => approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 5:
 - MultiStepApprovalTab (color-coded pipeline)
 - GlobalCriticalAdminTab
 - HierarchyViewTab (drag-drop)
 - EnhancedLineageGraphWidget (ER-style with search & highlighting)
 
We assume usage of prior parts (1-4) for BFS adjacency, approvals,
and references to lock/unlock, plus set_rule_approved, set_rule_in_progress, set_rule_rejected.
"""

import sys
import json
import math
import logging
import re
from datetime import datetime
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton,
    QAbstractItemView, QMessageBox, QComboBox, QLabel, QLineEdit,
    QDialog, QHBoxLayout, QTreeWidget, QTreeWidgetItem, QMenu,
    QInputDialog, QGraphicsView, QGraphicsScene, QGraphicsItem, QGraphicsEllipseItem,
    QGraphicsRectItem
)
from PyQt5.QtCore import Qt, QRectF
from PyQt5.QtGui import QBrush, QColor, QPen

# Reuse from prior:
#   load_current_stage_for_rule, set_rule_approved, set_rule_in_progress, set_rule_rejected
#   lock_rule, unlock_rule, force_unlock_rule
#   insert_audit_log, fetch_all_dict, fetch_one_dict
#   reparent_rule() => we define below or in part2 or 6
#   parse_sql_dependencies, run_data_validations, etc.

def reparent_rule(conn, rule_id, new_parent_id, new_group_id, user="HierarchyDrag"):
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old=c.fetchone()
    if not old:
        raise ValueError(f"Rule {rule_id} not found.")
    cols=[desc[0] for desc in c.description]
    old_data=dict(zip(cols,old))

    # in real usage, also check if the rule is locked or user has permission
    c.execute("""
      UPDATE BRM_RULES
      SET PARENT_RULE_ID=?,
          GROUP_ID=?,
          STATUS='INACTIVE',
          APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
          VERSION=VERSION+1,
          UPDATED_BY=?,
          LIFECYCLE_STATE='UNDER_APPROVAL'
      WHERE RULE_ID=?
    """,(new_parent_id,new_group_id,user,rule_id))
    conn.commit()
    new_data=dict(old_data)
    new_data["PARENT_RULE_ID"]=new_parent_id
    new_data["GROUP_ID"]=new_group_id
    new_data["STATUS"]="INACTIVE"
    new_data["APPROVAL_STATUS"]="APPROVAL_IN_PROGRESS"
    new_data["VERSION"]=old_data["VERSION"]+1
    new_data["UPDATED_BY"]=user
    new_data["LIFECYCLE_STATE"]="UNDER_APPROVAL"
    insert_audit_log(conn,"RE_PARENT","BRM_RULES",rule_id,user,old_data,new_data)

class MultiStepApprovalTab(QWidget):
    """
    Displays pending approvals for the current user => color-coded to indicate
    pipeline stage, partial approvals, etc.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,8)
        self.table.setHorizontalHeaderLabels([
            "RuleID","Stage","Group","User","ApprovedFlag","Timestamp","Approve","Reject"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT A.RULE_ID,A.APPROVAL_STAGE,A.GROUP_NAME,A.USERNAME,
                 A.APPROVED_FLAG,A.APPROVED_TIMESTAMP
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.USERNAME=? AND A.APPROVED_FLAG IN (0)
          ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()
        # we only show if A.APPROVAL_STAGE == minimal among unapproved for that rule
        # so gather minimal
        staging={}
        for row in rows:
            rid=row[0]
            st=row[1]
            staging.setdefault(rid,[]).append(st)
        minimal_stage={}
        for rid, st_list in staging.items():
            minimal_stage[rid]=min(st_list) if st_list else 0
        filtered=[]
        for row in rows:
            rid=row[0]
            st=row[1]
            if st==minimal_stage[rid]:
                filtered.append(row)

        for row_data in filtered:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(6):
                val=row_data[col_i]
                it=QTableWidgetItem(str(val) if val else "")
                # color code stage or approved flag
                if col_i==4: # approved_flag
                    if val==0:
                        it.setBackground(QColor("tomato"))
                    elif val==1:
                        it.setBackground(QColor("lightgreen"))
                self.table.setItem(r_i,col_i,it)

            appr_btn=QPushButton("Approve")
            appr_btn.clicked.connect(lambda _,r=r_i: self.do_approve(r))
            self.table.setCellWidget(r_i,6,appr_btn)

            rej_btn=QPushButton("Reject")
            rej_btn.clicked.connect(lambda _,r=r_i: self.do_reject(r))
            self.table.setCellWidget(r_i,7,rej_btn)

    def do_approve(self, row_idx):
        rid_item=self.table.item(row_idx,0)
        stage_item=self.table.item(row_idx,1)
        if not rid_item or not stage_item:
            return
        rid=int(rid_item.text())
        stage=int(stage_item.text())
        c=self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
          WHERE RULE_ID=? AND USERNAME=? AND APPROVAL_STAGE=? AND APPROVED_FLAG=0
        """,(rid,self.logged_in_username,stage))
        self.connection.commit()
        # check if more approvals needed
        nxt=load_current_stage_for_rule(self.connection, rid)
        if nxt is None:
            set_rule_approved(self.connection, rid)
        else:
            set_rule_in_progress(self.connection, rid)
        insert_audit_log(self.connection,"APPROVE","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"approved":True})
        QMessageBox.information(self,"Approved",f"Rule {rid} => stage {stage} approved.")
        self.load_approvals()

    def do_reject(self, row_idx):
        rid_item=self.table.item(row_idx,0)
        stage_item=self.table.item(row_idx,1)
        if not rid_item or not stage_item:
            return
        rid=int(rid_item.text())
        stage=int(stage_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
          WHERE RULE_ID=? AND USERNAME=? AND APPROVAL_STAGE=? AND APPROVED_FLAG=0
        """,(rid,self.logged_in_username,stage))
        self.connection.commit()
        set_rule_rejected(self.connection, rid)
        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"rejected":True})
        QMessageBox.information(self,"Rejected",f"Rule {rid} => Rejected.")
        self.load_approvals()

class GlobalCriticalAdminTab(QWidget):
    """
    Admin can set/unset IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE, and manage GCR links.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if user_group.lower()!="admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.table=QTableWidget(0,9)
        self.table.setHorizontalHeaderLabels([
            "RuleID","Name","OwnerGroup","IS_GLOBAL","CRITICAL_RULE","CRITICAL_SCOPE","Locked?","Status","Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        top_h=QHBoxLayout()
        self.show_all_chk=QComboBox()
        self.show_all_chk.addItem("Show Only GCR rules",True)
        self.show_all_chk.addItem("Show All",False)
        self.show_all_chk.currentIndexChanged.connect(self.load_rule_list)
        top_h.addWidget(self.show_all_chk)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        # GCR linking
        link_h=QHBoxLayout()
        self.parent_gcr_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.parent_gcr_combo)

        self.child_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.child_combo)

        linkb=QPushButton("Link Child")
        linkb.clicked.connect(self.link_child)
        link_h.addWidget(linkb)

        unlinkb=QPushButton("Unlink Child")
        unlinkb.clicked.connect(self.unlink_child)
        link_h.addWidget(unlinkb)
        link_h.addStretch()

        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["ParentGCR","ChildRule"])
        layout.addWidget(self.link_view)

        ref2=QPushButton("Refresh All")
        ref2.clicked.connect(self.refresh_all)
        layout.addWidget(ref2)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_parent_combo()
        self.populate_child_combo()
        self.load_links()

    def load_rule_list(self):
        self.table.setRowCount(0)
        show_gcr=self.show_all_chk.currentData()
        c=self.connection.cursor()
        if show_gcr:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,RULE_LOCKED,STATUS
              FROM BRM_RULES
              WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
              ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,RULE_LOCKED,STATUS
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(8):
                val=row[col_i]
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)
            # actions
            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)
            setf=QPushButton("Set Flags")
            setf.clicked.connect(lambda _,r=r_i: self.set_flags(r))
            ah.addWidget(setf)
            ah.addStretch()
            self.table.setCellWidget(r_i,8,act_w)

    def get_selected_rule_row_data(self, row_idx):
        rid_item=self.table.item(row_idx,0)
        if not rid_item:
            return None
        rid=int(rid_item.text())
        isg=self.table.item(row_idx,3).text()
        isc=self.table.item(row_idx,4).text()
        scp=self.table.item(row_idx,5).text()
        return (rid, isg, isc, scp)

    def set_flags(self, row_idx):
        info=self.get_selected_rule_row_data(row_idx)
        if not info:
            return
        (rid, isg, isc, scp)=info
        new_isg,ok1=QInputDialog.getItem(self,"is_global",f"Rule {rid} => current={isg}:",["0","1"],0,False)
        if not ok1:
            return
        new_isc,ok2=QInputDialog.getItem(self,"critical_rule",f"Rule {rid} => current={isc}:",["0","1"],0,False)
        if not ok2:
            return
        new_scp,ok3=QInputDialog.getItem(self,"critical_scope",f"Rule {rid} => current={scp}:",["NONE","GROUP","CLUSTER","GLOBAL"],0,False)
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        old=c.fetchone()
        if not old:
            QMessageBox.warning(self,"Missing","Rule not found.")
            return
        cols=[desc[0] for desc in c.description]
        old_data=dict(zip(cols,old))
        c.execute("""
          UPDATE BRM_RULES
          SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
          WHERE RULE_ID=?
        """,(int(new_isg),int(new_isc),new_scp,rid))
        self.connection.commit()
        new_data=dict(old_data)
        new_data["IS_GLOBAL"]=int(new_isg)
        new_data["CRITICAL_RULE"]=int(new_isc)
        new_data["CRITICAL_SCOPE"]=new_scp
        insert_audit_log(self.connection,"FLAG_UPDATE","BRM_RULES",rid,"Admin",old_data,new_data)
        QMessageBox.information(self,"Updated",f"Rule {rid} flags updated.")
        self.load_rule_list()

    def populate_parent_combo(self):
        self.parent_gcr_combo.clear()
        c=self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME FROM BRM_RULES
          WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
          ORDER BY RULE_ID
        """)
        for row in c.fetchall():
            disp=f"{row[0]} - {row[1]}"
            self.parent_gcr_combo.addItem(disp, row[0])

    def populate_child_combo(self):
        self.child_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            disp=f"{row[0]} - {row[1]}"
            self.child_combo.addItem(disp, row[0])

    def load_links(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def link_child(self):
        p=self.parent_gcr_combo.currentData()
        ch=self.child_combo.currentData()
        if not p or not ch:
            return
        if p==ch:
            QMessageBox.warning(self,"Invalid","Cannot link rule to itself.")
            return
        c=self.connection.cursor()
        try:
            c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(p,ch))
            self.connection.commit()
            insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{p}->{ch}","Admin",None,{"p":p,"c":ch})
            QMessageBox.information(self,"Linked",f"{ch} => parent {p}.")
        except Exception as ex:
            QMessageBox.warning(self,"Error",str(ex))
        self.load_links()

    def unlink_child(self):
        p=self.parent_gcr_combo.currentData()
        ch=self.child_combo.currentData()
        if not p or not ch:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(p,ch))
        self.connection.commit()
        insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{p}->{ch}","Admin",{"p":p,"c":ch},None)
        QMessageBox.information(self,"Unlinked",f"{ch} from parent {p}.")
        self.load_links()

class HierarchyViewTab(QTreeWidget):
    """
    Show group -> rules, allow drag to re-parent. 
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group/Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        group_map={}
        for row in c.fetchall():
            gid=row[0]
            gname=row[1]
            top=QTreeWidgetItem([f"{gname} (ID={gid})"])
            top.setData(0, Qt.UserRole, ("group",gid))
            self.addTopLevelItem(top)
            group_map[gid]=top
        # rules
        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        all_rule_info=[]
        for (rid,rn,gid,pid) in rows:
            if pid is None:
                if gid in group_map:
                    child=QTreeWidgetItem([f"Rule {rid}: {rn}"])
                    child.setData(0, Qt.UserRole, ("rule",rid))
                    group_map[gid].addChild(child)
            all_rule_info.append((rid,rn,gid,pid))
        # deeper levels => BFS approach if you want. 
        # We keep it to 2-level for brevity
        self.expandAll()

    def dropEvent(self, event):
        source_item=self.currentItem()
        if not source_item:
            super().dropEvent(event)
            return
        data_role=source_item.data(0, Qt.UserRole)
        if data_role[0]!="rule":
            super().dropEvent(event)
            return
        super().dropEvent(event)
        # find new parent
        new_parent=source_item.parent()
        if not new_parent:
            self.load_hierarchy()
            return
        parent_data=new_parent.data(0, Qt.UserRole)
        rule_id=data_role[1]
        if parent_data[0]=="group":
            reparent_rule(self.connection, rule_id, None, parent_data[1], "HierarchyView")
        elif parent_data[0]=="rule":
            # find parent's group from DB
            c=self.connection.cursor()
            c.execute("SELECT GROUP_ID FROM BRM_RULES WHERE RULE_ID=?",(parent_data[1],))
            row=c.fetchone()
            if not row:
                QMessageBox.warning(self,"Invalid","Parent rule group not found => revert.")
                self.load_hierarchy()
                return
            new_group_id=row[0]
            reparent_rule(self.connection, rule_id, parent_data[1], new_group_id, "HierarchyView")
        else:
            QMessageBox.warning(self,"Invalid","Cannot re-parent to unknown item => revert.")
            self.load_hierarchy()

class EnhancedLineageGraphWidget(QGraphicsView):
    """
    Professional “ER diagram” style. We show:
      - Rectangles for tables
      - Ellipses for rules
      - Arrows for adjacency
      - We store data types in tooltips if we want
      - Searching => highlight matches or dim others
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.node_map={}
        self.load_graph()

    def load_graph(self):
        self.scene.clear()
        self.node_map.clear()
        c=self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME,STATUS,IS_GLOBAL,CRITICAL_RULE
          FROM BRM_RULES
        """)
        rules=c.fetchall()
        # place them in a row
        xoff=50
        yoff=50
        for row in rules:
            rid=row[0]
            rname=row[1]
            st=row[2]
            isg=row[3]
            isc=row[4]
            node=QGraphicsEllipseItem(0,0,100,50)
            color=QColor("lightgreen") if st.upper()=="ACTIVE" else QColor("lightgray")
            if isc:
                node.setPen(QPen(QColor("red"),3))
            if isg:
                node.setPen(QPen(QColor("blue"),3))
            node.setBrush(QBrush(color))
            node.setToolTip(f"Rule {rid}: {rname}\nStatus={st}")
            node.setPos(xoff,yoff)
            self.scene.addItem(node)
            self.node_map[("rule",rid)]=node
            yoff+=80
            if yoff>600:
                xoff+=200
                yoff=50
        # table dependencies => we show them as rectangles
        c.execute("""
          SELECT DEPENDENCY_ID,RULE_ID,TABLE_NAME,COLUMN_NAME,COLUMN_DATA_TYPE
          FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        table_map={}
        x_table=700
        y_table=50
        for row in c.fetchall():
            dep_id=row[0]
            rid=row[1]
            tbl=row[2]
            col=row[3]
            dtp=row[4] if row[4] else "?"
            if not tbl:
                continue
            tkey=("table",tbl)
            if tkey not in table_map:
                rect=QGraphicsRectItem(0,0,120,60)
                rect.setBrush(QBrush(QColor("lightblue")))
                rect.setToolTip(f"Table: {tbl}")
                rect.setPos(x_table,y_table)
                self.scene.addItem(rect)
                table_map[tkey]=rect
                y_table+=100
                if y_table>600:
                    x_table+=220
                    y_table=50
            # link rule->table
            if ("rule",rid) in self.node_map:
                rule_item=self.node_map[("rule",rid)]
                table_item=table_map[tkey]
                self.draw_arrow(rule_item, table_item, col, dtp)
        self.scene.setSceneRect(self.scene.itemsBoundingRect())

    def draw_arrow(self, item1, item2, col_name, data_type):
        p1=item1.sceneBoundingRect().center()
        p2=item2.sceneBoundingRect().center()
        # you can draw a line or arrow
        line=self.scene.addLine(p1.x(),p1.y(),p2.x(),p2.y(),QPen(Qt.darkGray,2))
        # if col_name => maybe a tooltip for the line
        line.setToolTip(f"Uses column={col_name}\nType={data_type}")

    def perform_search(self, text):
        txt=text.lower()
        for item in self.scene.items():
            if isinstance(item,(QGraphicsRectItem,QGraphicsEllipseItem)):
                tip=(item.toolTip() or "").lower()
                if txt in tip:
                    item.setOpacity(1.0)
                else:
                    item.setOpacity(0.2)

    def reset_view(self):
        for item in self.scene.items():
            item.setOpacity(1.0)
        self.fitInView(self.scene.sceneRect(),Qt.KeepAspectRatio)
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 6:
 - MetricsDashboardTab (bar chart of statuses, optional line chart of performance)
 - CtrlTablesTab (manage any 'admin' tables, with permission checks)
 - GroupManagementTab (manage business groups, group membership, table perms, group approvers)
 - UserManagementTab (admin user CRUD, no encryption)
"""

import sys
import math
import logging
import json
from datetime import datetime, timedelta
from collections import defaultdict

import pyodbc
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem,
    QHBoxLayout, QLineEdit, QMessageBox, QComboBox, QGroupBox, QAbstractItemView,
    QInputDialog, QTabWidget
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
import pyqtgraph as pg

# Reuse from prior parts:
#   fetch_all_dict, fetch_one_dict, insert_audit_log
#   user_has_table_permission => define a small function below
#   is_admin => define or just do user_group.lower()=="admin"

def is_admin_user(user_group:str)->bool:
    return user_group.strip().lower()=="admin"

def user_has_table_permission(conn, user_group, table_name):
    if is_admin_user(user_group):
        return True
    c=conn.cursor()
    c.execute("""
      SELECT 1 
      FROM GROUP_PERMISSIONS
      WHERE GROUP_NAME=? AND TARGET_TABLE=?
    """,(user_group, table_name))
    row=c.fetchone()
    return bool(row)

class MetricsDashboardTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.chart=pg.PlotWidget(title="Rule Status Distribution")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        self.trend_chart=pg.PlotWidget(title="Execution Performance Trend (Avg MS by Day)")
        self.trend_chart.setBackground('w')
        layout.addWidget(self.trend_chart)

        btn=QPushButton("Refresh Metrics")
        btn.clicked.connect(self.load_metrics)
        layout.addWidget(btn)
        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        # status distribution
        c.execute("SELECT STATUS,COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()
        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]
        self.chart.clear()
        if statuses:
            xvals=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(xvals), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(xvals, statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True,y=True)

        # performance trend
        self.trend_chart.clear()
        try:
            c.execute("""
              SELECT CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120) as dt,
                     AVG(EXECUTION_TIME_MS) as avg_ms
              FROM RULE_EXECUTION_LOGS
              GROUP BY CONVERT(VARCHAR(10),EXECUTION_TIMESTAMP,120)
              ORDER BY dt
            """)
            trend=c.fetchall()
            if trend:
                x_lbl=[]
                y_vals=[]
                for row_ in trend:
                    x_lbl.append(row_[0])
                    y_vals.append(float(row_[1]) if row_[1] else 0)
                x_idx=range(len(x_lbl))
                line=pg.PlotDataItem(x=list(x_idx), y=y_vals, pen='r', symbol='o')
                self.trend_chart.addItem(line)
                self.trend_chart.getAxis('bottom').setTicks([list(zip(x_idx,x_lbl))])
                self.trend_chart.setLabel('left','Avg Ms')
                self.trend_chart.setLabel('bottom','Date')
                self.trend_chart.showGrid(x=True,y=True)
        except:
            pass

class CtrlTablesTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_APPROVALS","BRM_GLOBAL_CRITICAL_LINKS","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SCHEDULES","DECISION_TABLES","DATA_VALIDATIONS","RULE_TAGS","RULE_SNAPSHOTS",
            "BRM_CUSTOM_RULE_GROUPS","BRM_CUSTOM_GROUP_MEMBERS","BRM_CUSTOM_GROUP_BACKUPS",
            "RULE_EXECUTION_LOGS"
        ]

        self.combo=QComboBox()
        for t_ in self.table_list:
            self.combo.addItem(t_)
        layout.addWidget(QLabel("Select Admin Table:"))
        layout.addWidget(self.combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)
        self.setLayout(layout)

    def load_data(self):
        tbl=self.combo.currentText()
        if not user_has_table_permission(self.connection, self.user_group, tbl):
            QMessageBox.warning(self,"No Permission",f"{self.user_group} cannot read {tbl}")
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[desc[0] for desc in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
            return
        try:
            c.execute(f"SELECT TOP 500 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val!=None else "")
                self.data_table.setItem(r_i,col_i,it)

class GroupManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)
        if not is_admin_user(user_group):
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return
        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)
        # 1) Groups & membership
        gm_widget=QWidget()
        gm_layout=QVBoxLayout(gm_widget)

        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        gm_layout.addWidget(self.groups_table)

        grp_btns=QHBoxLayout()
        add_grp=QPushButton("Add Group")
        add_grp.clicked.connect(self.add_group)
        grp_btns.addWidget(add_grp)
        rename_grp=QPushButton("Rename Group")
        rename_grp.clicked.connect(self.rename_group)
        grp_btns.addWidget(rename_grp)
        del_grp=QPushButton("Delete Group")
        del_grp.clicked.connect(self.delete_group)
        grp_btns.addWidget(del_grp)
        grp_btns.addStretch()
        gm_layout.addLayout(grp_btns)

        # membership
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        gm_layout.addWidget(self.users_table)

        memb_btns=QHBoxLayout()
        add_usr=QPushButton("Add User to Group")
        add_usr.clicked.connect(self.add_user_to_group)
        memb_btns.addWidget(add_usr)
        rm_usr=QPushButton("Remove User from Group")
        rm_usr.clicked.connect(self.remove_user_from_group)
        memb_btns.addWidget(rm_usr)
        memb_btns.addStretch()
        gm_layout.addLayout(memb_btns)

        gm_widget.setLayout(gm_layout)
        self.tabs.addTab(gm_widget,"Groups & Membership")

        # 2) Permissions
        perm_widget=QWidget()
        perm_layout=QVBoxLayout(perm_widget)

        top_h=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        top_h.addWidget(QLabel("Select Group:"))
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["TargetTable"])
        perm_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp=QPushButton("Add Permission")
        addp.clicked.connect(self.add_permission)
        ph.addWidget(addp)
        remp=QPushButton("Remove Permission")
        remp.clicked.connect(self.remove_permission)
        ph.addWidget(remp)
        ph.addStretch()
        perm_layout.addLayout(ph)

        perm_widget.setLayout(perm_layout)
        self.tabs.addTab(perm_widget,"Permissions")

        # 3) Approvers
        appr_widget=QWidget()
        appr_layout=QVBoxLayout(appr_widget)

        ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        ah.addWidget(QLabel("Group:"))
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        appr_layout.addWidget(self.appr_table)

        ab=QHBoxLayout()
        add_a=QPushButton("Add Approver")
        add_a.clicked.connect(self.add_approver)
        ab.addWidget(add_a)
        del_a=QPushButton("Remove Approver")
        del_a.clicked.connect(self.remove_approver)
        ab.addWidget(del_a)
        ab.addStretch()
        appr_layout.addLayout(ab)

        appr_widget.setLayout(appr_layout)
        self.tabs.addTab(appr_widget,"Approvers")

        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_group_combo()
        self.load_appr_group_combo()

    # Groups
    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.groups_table.setItem(r_i,col_i,it)

    def get_selected_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            return None
        it=self.groups_table.item(row,0)
        if not it:
            return None
        return it.text().strip()

    def add_group(self):
        gname,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not gname.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",(gname.strip(),desc.strip(),em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Group {gname} created.")
        self.load_data()

    def rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename",f"New name for {grp}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Dup","Another group with that name exists.")
            return
        try:
            oldd={"GROUP_NAME":grp}
            newd={"GROUP_NAME":new_name.strip()}
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name.strip(),grp))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RENAME_GROUP","BUSINESS_GROUPS",grp,self.user_id,oldd,newd)
            QMessageBox.information(self,"Renamed",f"{grp} => {new_name}")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        if QMessageBox.question(self,"Confirm",f"Delete {grp}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            oldd={"group":grp}
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
            c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
            c.commit()
            insert_audit_log(self.connection,"DELETE_GROUP","BUSINESS_GROUPS",grp,self.user_id,oldd,None)
            QMessageBox.information(self,"Deleted",f"{grp} removed.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    # membership
    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.users_table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_user_id(self):
        row=self.users_table.currentRow()
        if row<0:
            return None
        it=self.users_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user_to_group(self):
        uid=self.get_selected_user_id()
        if not uid:
            return
        grp,ok=QInputDialog.getText(self,"Assign","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Missing",f"No group {grp}")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        c.commit()
        insert_audit_log(self.connection,"ADD_USER_TO_GROUP","USERS",uid,self.user_id,None,{"to":grp.strip()})
        QMessageBox.information(self,"Assigned",f"User {uid} => {grp}")
        self.load_data()

    def remove_user_from_group(self):
        uid=self.get_selected_user_id()
        if not uid:
            return
        if QMessageBox.question(self,"Confirm","Remove user from group => set to BG1?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        oldg=c.fetchone()[0] if c.fetchone() else None
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        c.commit()
        insert_audit_log(self.connection,"REMOVE_USER_FROM_GROUP","USERS",uid,self.user_id,{"was":oldg},{"now":"BG1"})
        QMessageBox.information(self,"Removed",f"User {uid} => BG1")
        self.load_data()

    # perms
    def load_perm_group_combo(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            self.perm_group_combo.addItem(row[0])
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        if self.perm_group_combo.count()>0:
            self.perm_group_combo.setCurrentIndex(0)
            self.load_permissions()

    def load_permissions(self):
        grp=self.perm_group_combo.currentText()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))

    def add_permission(self):
        grp=self.perm_group_combo.currentText()
        if not grp:
            return
        tbl,ok=QInputDialog.getText(self,"Add Perm",f"Table name for group {grp}:")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)
        """,(grp.strip(),tbl.strip()))
        c.commit()
        insert_audit_log(self.connection,"ADD_PERMISSION","GROUP_PERMISSIONS",grp,self.user_id,None,{"table":tbl.strip()})
        QMessageBox.information(self,"Added",f"{grp} => {tbl}")
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentText()
        row=self.perm_table.currentRow()
        if row<0:
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        tbl=it.text()
        if QMessageBox.question(self,"Confirm",f"Remove {grp} => {tbl}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp,tbl))
        c.commit()
        insert_audit_log(self.connection,"REMOVE_PERMISSION","GROUP_PERMISSIONS",grp,self.user_id,{"table":tbl},None)
        QMessageBox.information(self,"Removed",f"{grp} no longer sees {tbl}")
        self.load_permissions()

    # approvers
    def load_appr_group_combo(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            self.appr_group_combo.addItem(row[0])
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        if self.appr_group_combo.count()>0:
            self.appr_group_combo.setCurrentIndex(0)
            self.load_approvers()

    def load_approvers(self):
        grp=self.appr_group_combo.currentText()
        if not grp:
            return
        self.appr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT APPROVER_ID,USERNAME
          FROM BUSINESS_GROUP_APPROVERS
          WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for row in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def add_approver(self):
        grp=self.appr_group_combo.currentText()
        if not grp:
            return
        un,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not un.strip():
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME)
          VALUES(?,?)
        """,(grp.strip(), un.strip()))
        c.commit()
        insert_audit_log(self.connection,"ADD_APPROVER","BUSINESS_GROUP_APPROVERS",grp,self.user_id,None,{"user":un})
        QMessageBox.information(self,"Added",f"{un} => {grp}")
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentText()
        row=self.appr_table.currentRow()
        if row<0:
            return
        it=self.appr_table.item(row,0)
        if not it:
            return
        appr_id=int(it.text())
        if QMessageBox.question(self,"Confirm",f"Remove approver {appr_id}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        c.commit()
        insert_audit_log(self.connection,"REMOVE_APPROVER","BUSINESS_GROUP_APPROVERS",grp,self.user_id,{"app_id":appr_id},None)
        QMessageBox.information(self,"Removed",f"Approver {appr_id} removed.")
        self.load_approvers()

class UserManagementTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)
        if not is_admin_user(user_group):
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["UserID","Username","Password","Group"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        bh.addWidget(del_btn)

        pw_btn=QPushButton("Change Password")
        pw_btn.clicked.connect(self.change_password)
        bh.addWidget(pw_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.table.setItem(r_i,col_i,it)

    def get_selected_userid(self):
        sel=self.table.currentRow()
        if sel<0:
            return None
        it=self.table.item(sel,0)
        if not it:
            return None
        return int(it.text())

    def add_user(self):
        un,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not un.strip():
            return
        pw,ok2=QInputDialog.getText(self,"Password","Plain text:")
        if not ok2 or not pw.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(BG1 or Admin..):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(un.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username in use.")
            return
        c.execute("""
          INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP)
          VALUES(?,?,?)
        """,(un.strip(),pw.strip(),grp.strip()))
        c.commit()
        insert_audit_log(self.connection,"ADD_USER","USERS",un,self.user_id,None,{"pw":pw.strip(),"grp":grp.strip()})
        QMessageBox.information(self,"Added",f"{un} created.")
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_userid()
        if not uid:
            return
        if QMessageBox.question(self,"Confirm",f"Delete user {uid}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("SELECT USERNAME,PASSWORD,USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        old=c.fetchone()
        oldd={"USER":old[0],"PW":old[1],"GRP":old[2]}
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        c.commit()
        insert_audit_log(self.connection,"DELETE_USER","USERS",uid,self.user_id,oldd,None)
        QMessageBox.information(self,"Deleted",f"User {uid} removed.")
        self.load_users()

    def change_password(self):
        uid=self.get_selected_userid()
        if not uid:
            return
        new_pw,ok=QInputDialog.getText(self,"Change","New password:")
        if not ok or not new_pw.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT PASSWORD FROM USERS WHERE USER_ID=?",(uid,))
        old=c.fetchone()
        if not old:
            QMessageBox.warning(self,"Missing","User not found.")
            return
        oldd={"PW":old[0]}
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(new_pw.strip(),uid))
        c.commit()
        insert_audit_log(self.connection,"CHANGE_PWD","USERS",uid,self.user_id,oldd,{"new":new_pw.strip()})
        QMessageBox.information(self,"Changed","Password updated.")
        self.load_users()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 7:
  - CustomRuleGroupEnhancedTab: advanced management of custom groups, BFS membership, backups
  - AlertsAndDashboardsTab: old approvals, upcoming schedules, performance usage stats
"""

import sys
import json
import math
import logging
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QPlainTextEdit, QPushButton, QMessageBox,
    QInputDialog, QLabel, QLineEdit, QDialog, QFileDialog, QTableWidget,
    QTableWidgetItem
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor

# Reuse from prior: fetch_one_dict, fetch_all_dict, insert_audit_log,
# BFS or adjacency if needed, 
# Also references "RULE_EXECUTION_LOGS" for performance usage

def custom_bfs_references(conn, start_rule_id):
    """
    BFS => child rules => gather. Or you can unify with existing BFS from part2
    if that suits your usage.
    """
    from Part2File import load_rule_relationships
    adjacency, roots = load_rule_relationships(conn)
    visited=set()
    stack=[start_rule_id]
    while stack:
        cur=stack.pop()
        if cur in visited:
            continue
        visited.add(cur)
        if cur in adjacency:
            for ch in adjacency[cur]:
                if ch not in visited:
                    stack.append(ch)
    return visited

class CustomRuleGroupEnhancedTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_group_edit=QLineEdit()
        self.new_group_edit.setPlaceholderText("New custom group name")
        top_h.addWidget(self.new_group_edit)
        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)
        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)
        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)
        backup_btn=QPushButton("Backup")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)
        restore_btn=QPushButton("Restore")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        from PyQt5.QtWidgets import QSplitter
        splitter=QSplitter(Qt.Horizontal)

        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_w=QWidget()
        rw_lay=QVBoxLayout(right_w)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search unassigned rules..")
        self.rule_search.textChanged.connect(self.load_unassigned_rules)
        rw_lay.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        rw_lay.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected -> Group")
        assign_btn.clicked.connect(self.assign_rules)
        rw_lay.addWidget(assign_btn)

        splitter.addWidget(right_w)
        layout.addWidget(splitter)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_unassigned_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
          SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
          FROM BRM_CUSTOM_RULE_GROUPS
          ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for g_ in groups:
            cg_id=g_[0]
            cg_name=g_[1]
            ow_bg=g_[2] or ""
            disp=f"{cg_name} (Owner={ow_bg})"
            parent_item=QTreeWidgetItem([disp])
            parent_item.setData(0, Qt.UserRole, cg_id)
            self.tree.addTopLevelItem(parent_item)
            # child => assigned rules
            c2=self.connection.cursor()
            c2.execute("""
              SELECT M.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
              FROM BRM_CUSTOM_GROUP_MEMBERS M
              JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
              WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for row2 in assigned:
                rid=row2[0]
                rname=row2[1]
                isg=row2[2]
                isc=row2[3]
                txt=f"Rule {rid}: {rname}"
                child_item=QTreeWidgetItem([txt])
                child_item.setData(0, Qt.UserRole, rid)
                if isg:
                    child_item.setBackground(0,QBrush(QColor("lightblue")))
                if isc:
                    child_item.setBackground(0,QBrush(QColor("tomato")))
                parent_item.addChild(child_item)
        self.tree.expandAll()

    def load_unassigned_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        # find assigned set
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=[x[0] for x in c.fetchall()]
        if txt:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP
              FROM BRM_RULES
              WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
              ORDER BY RULE_ID DESC
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,OWNER_GROUP
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            if row[0] in assigned:
                continue
            disp=f"Rule {row[0]}: {row[1]} (Owner={row[2]})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,row[0])
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # child => rule => show "Remove"
            from PyQt5.QtWidgets import QMenu
            menu=QMenu()
            rem=menu.addAction("Remove from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem:
                grp_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                  DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                  WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(grp_id,rule_id))
                self.connection.commit()
                insert_audit_log(self.connection,"REMOVE_RULE","BRM_CUSTOM_GROUP_MEMBERS",grp_id,self.user_id,{"rule":rule_id},None)
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group {grp_id}")
                self.refresh_all()

    def create_group(self):
        name=self.new_group_edit.text().strip()
        if not name:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c=self.connection.cursor()
        c.execute("""
          INSERT INTO BRM_CUSTOM_RULE_GROUPS(
            CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY, CREATED_TIMESTAMP
          )
          VALUES(?,?,?,GETDATE())
        """,(name,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        insert_audit_log(self.connection,"CREATE_CG","BRM_CUSTOM_RULE_GROUPS",name,self.user_id,None,{"group":name})
        QMessageBox.information(self,"Created",f"Custom group '{name}' created.")
        self.new_group_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        pr=it.parent()
        if pr:
            it=pr
        gid=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (gid,disp)

    def rename_group(self):
        (cg_id,disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_name,ok=QInputDialog.getText(self,"Rename",f"New name for ID={cg_id}:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        old=c.fetchone()
        if not old:
            QMessageBox.warning(self,"Missing","Group not found.")
            return
        cols=[desc[0] for desc in c.description]
        old_data=dict(zip(cols,old))
        c.execute("BEGIN TRANSACTION")
        c.execute("""
          UPDATE BRM_CUSTOM_RULE_GROUPS
          SET CUSTOM_GROUP_NAME=?
          WHERE CUSTOM_GROUP_ID=?
        """,(new_name.strip(),cg_id))
        c.execute("COMMIT")
        new_data=dict(old_data)
        new_data["CUSTOM_GROUP_NAME"]=new_name.strip()
        insert_audit_log(self.connection,"RENAME_CG","BRM_CUSTOM_RULE_GROUPS",cg_id,self.user_id,old_data,new_data)
        QMessageBox.information(self,"Renamed",f"{disp} => {new_name}")
        self.refresh_all()

    def delete_group(self):
        (cg_id,disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        if QMessageBox.question(self,"Confirm",f"Delete custom group {cg_id}?")!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        old=c.fetchone()
        if not old:
            QMessageBox.warning(self,"Missing","Group not found.")
            return
        cols=[desc[0] for desc in c.description]
        old_data=dict(zip(cols,old))
        c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        self.connection.commit()
        insert_audit_log(self.connection,"DELETE_CG","BRM_CUSTOM_RULE_GROUPS",cg_id,self.user_id,old_data,None)
        QMessageBox.information(self,"Deleted",f"Group {cg_id} removed.")
        self.refresh_all()

    def backup_group(self):
        (cg_id,disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing","Group not found.")
            return
        grp_name=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
        members=[r[0] for r in c.fetchall()]
        backup_json=json.dumps({"group_name":grp_name,"members":members})
        c.execute("""
          SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
        """,(cg_id,))
        v=c.fetchone()
        new_ver= v[0] if v else 1
        c.execute("""
          INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
            CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
          )
          VALUES(?,GETDATE(),?,?)
        """,(cg_id,new_ver,backup_json))
        self.connection.commit()
        insert_audit_log(self.connection,"BACKUP_CG","BRM_CUSTOM_GROUP_BACKUPS",cg_id,self.user_id,None,{"ver":new_ver})
        QMessageBox.information(self,"Backup",f"Group {cg_id} => version {new_ver} saved.")

    def restore_group(self):
        (cg_id,disp)=self.get_selected_tree_group()
        if not cg_id:
            QMessageBox.warning(self,"None","No group selected.")
            return
        c=self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
          ORDER BY BACKUP_VERSION DESC
        """,(cg_id,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {r[0]} @ {r[1]}" for r in rows]
        ver_str,ok=QInputDialog.getItem(self,"Restore","Pick version to restore:",items,0,False)
        if not ok or not ver_str:
            return
        # parse version
        num=None
        for r_ in rows:
            vs=f"Version {r_[0]} @"
            if ver_str.startswith(vs):
                num=r_[0]
                backup_json=r_[2]
                break
        if not num:
            QMessageBox.warning(self,"Missing","Could not parse version.")
            return
        if QMessageBox.question(self,"Confirm",f"Restore group {cg_id} => version {num}?")!=QMessageBox.Yes:
            return
        try:
            data=json.loads(backup_json)
            gname=data["group_name"]
            members=data["members"]
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(gname,cg_id))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(cg_id,))
            for r_ in members:
                c.execute("""
                  INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(cg_id,r_))
            c.execute("COMMIT")
            insert_audit_log(self.connection,"RESTORE_CG","BRM_CUSTOM_GROUP_BACKUPS",cg_id,self.user_id,{"ver":num},data)
            QMessageBox.information(self,"Restored",f"Group {cg_id} => version {num} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        top=sel[0]
        if top.parent():
            top=top.parent()
        grp_id=top.data(0,Qt.UserRole)
        if not grp_id:
            QMessageBox.warning(self,"Error","No valid group ID found.")
            return
        selected_rules=self.rule_list.selectedItems()
        if not selected_rules:
            QMessageBox.warning(self,"None","No rules selected on right side.")
            return
        c=self.connection.cursor()
        assigned=0
        for it in selected_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                  INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(grp_id,rid))
                assigned+=1
            except:
                pass
        c.commit()
        insert_audit_log(self.connection,"ASSIGN_RULES","BRM_CUSTOM_GROUP_MEMBERS",grp_id,self.user_id,None,{"count":assigned})
        QMessageBox.information(self,"Assigned",f"{assigned} rule(s) assigned.")
        self.refresh_all()

class AlertsAndDashboardsTab(QWidget):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        # performance usage summary
        perf_box=QWidget()
        perf_layout=QVBoxLayout(perf_box)
        lbl=QLabel("Performance Usage Stats:")
        perf_layout.addWidget(lbl)
        self.perf_table=QTableWidget(0,5)
        self.perf_table.setHorizontalHeaderLabels(["RuleID","AvgMs","ExecCount","Success%","LastExec"])
        self.perf_table.horizontalHeader().setStretchLastSection(True)
        perf_layout.addWidget(self.perf_table)
        loadb=QPushButton("Load Performance Stats")
        loadb.clicked.connect(self.load_perf)
        perf_layout.addWidget(loadb)
        layout.addWidget(perf_box)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        # old approvals => older than 3 days
        c=self.connection.cursor()
        c.execute("""
          SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
                 DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
          FROM BRM_RULE_APPROVALS A
          JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
          WHERE A.APPROVED_FLAG=0
            AND A.APPROVAL_STAGE=(
              SELECT MIN(APPROVAL_STAGE)
              FROM BRM_RULE_APPROVALS
              WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
            )
            AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        oldap=c.fetchall()
        if oldap:
            lines.append("Approvals older than 3 days:")
            for row in oldap:
                lines.append(f" - Rule {row[0]}, stage={row[1]}, age={row[3]}, {row[2]}")
        else:
            lines.append("No old approvals >3d found.")
        lines.append("")
        # upcoming schedules => 24h
        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
          FROM RULE_SCHEDULES
          WHERE STATUS='Scheduled'
            AND SCHEDULE_TIME>=GETDATE()
            AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
          ORDER BY SCHEDULE_TIME
        """)
        ups=c.fetchall()
        if ups:
            lines.append("Upcoming schedules (<24h):")
            for row in ups:
                lines.append(f" - Sched={row[0]}, rule={row[1]}, time={row[2]}")
        else:
            lines.append("No upcoming schedules in next 24h.")
        self.alert_text.setPlainText("\n".join(lines))

    def load_perf(self):
        self.perf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,
                 AVG(EXECUTION_TIME_MS) as avg_ms,
                 COUNT(*) as exec_count,
                 SUM(CASE WHEN PASS_FLAG=1 THEN 1 ELSE 0 END)*100.0/COUNT(*) as success_pct,
                 MAX(EXECUTION_TIMESTAMP) as last_ts
          FROM RULE_EXECUTION_LOGS
          GROUP BY RULE_ID
          ORDER BY RULE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.perf_table.rowCount()
            self.perf_table.insertRow(r_i)
            for col_i in range(5):
                val=str(row[col_i]) if row[col_i] is not None else ""
                self.perf_table.setItem(r_i,col_i,QTableWidgetItem(val))
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
PART 8 (FINAL):
 - The BRMTool QMainWindow, integrating all tabs and features from Parts 1–7.
 - Database connection + login flow
 - BFS run button
 - Scheduling checks (timer)
 - Sync metadata capturing data types
 - UI/UX improvements
"""

import sys
import math
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QComboBox,
    QPushButton, QLabel, QMessageBox, QDialog, QInputDialog, QLineEdit,
    QAction, QMenuBar
)
from PyQt5.QtCore import QTimer, Qt

# We assume we have from Parts 1–7:
#   DatabaseConnectionDialog, LoginDialog, OnboardingWizard
#   insert_audit_log, fetch_one_dict, fetch_all_dict
#   execute_rules_dag_bfs
#   SingleRuleSimulationDialog, ChainOrGroupSimulationDialog
#   sync_metadata_improved
#   DataValidationTab, ScheduleManagementTab, etc.
#   RuleDashboard, MultiStepApprovalTab, GlobalCriticalAdminTab,
#   HierarchyViewTab, EnhancedLineageGraphWidget, 
#   CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab,
#   GroupManagementTab, UserManagementTab, CtrlTablesTab, MetricsDashboardTab,
#   RuleSearchDialog, AuditLogViewer, VersionHistoryDialog,
#   RuleEditorDialog
# …plus the BFS logic for scheduling checks.

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool (Part 8 - Final)")
        self.resize(1400,900)
        self.connection=None
        self.user_id=None
        self.user_group=None
        self.logged_in_username=None

        # Step 1: DB connect
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            conn=dbdlg.get_connection()
            if not conn:
                sys.exit(1)
            self.connection=conn
        else:
            sys.exit(0)

        # Step 2: login
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="UnknownUser"

        # optional onboarding
        # wizard=OnboardingWizard(self.connection)
        # wizard.exec_()

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        syncAct=QAction("Sync Metadata",self)
        syncAct.triggered.connect(self.sync_metadata_action)
        fileMenu.addAction(syncAct)

        metricsAct=QAction("Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        schedAct=QAction("New Schedule (Dialog)",self)
        schedAct.triggered.connect(self.new_schedule_dialog)
        fileMenu.addAction(schedAct)

        chainAct=QAction("Simulate Chain BFS",self)
        chainAct.triggered.connect(self.launch_chain_sim)
        fileMenu.addAction(chainAct)

        grpAct=QAction("Simulate CustomGroup BFS",self)
        grpAct.triggered.connect(self.launch_group_sim)
        fileMenu.addAction(grpAct)

        helpMenu=menubar.addMenu("Help")
        usageAct=QAction("Show Tips",self)
        usageAct.triggered.connect(self.show_help)
        helpMenu.addAction(usageAct)

        toolsMenu=menubar.addMenu("Tools")
        auditAct=QAction("View Audit Logs",self)
        auditAct.triggered.connect(self.launch_audit_viewer)
        toolsMenu.addAction(auditAct)

        srchAct=QAction("Search Rules",self)
        srchAct.triggered.connect(self.launch_rule_search)
        toolsMenu.addAction(srchAct)

        verAct=QAction("Version History",self)
        verAct.triggered.connect(self.launch_version_history)
        toolsMenu.addAction(verAct)

        cw=QWidget()
        main_layout=QVBoxLayout(cw)

        # If admin, impersonation
        if self.user_group.lower()=="admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            main_layout.addLayout(top_h)
            self.populate_switch_combo()

        self.tabs=QTabWidget()
        main_layout.addWidget(self.tabs)

        # Business Rules tab => with BFS run, sim single rule, add/update/deactivate/delete
        brw=QWidget()
        br_layout=QVBoxLayout(brw)
        top_h2=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule_handler)
        top_h2.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.update_rule_handler)
        top_h2.addWidget(upd_btn)

        deact_btn=QPushButton("Deactivate")
        deact_btn.clicked.connect(self.deactivate_rule_handler)
        top_h2.addWidget(deact_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.delete_rule_handler)
        top_h2.addWidget(del_btn)

        bfs_btn=QPushButton("Run ETL BFS")
        bfs_btn.clicked.connect(self.run_full_etl_bfs)
        top_h2.addWidget(bfs_btn)

        sim1_btn=QPushButton("Sim Single Rule")
        sim1_btn.clicked.connect(self.simulate_single_rule)
        top_h2.addWidget(sim1_btn)

        top_h2.addStretch()
        br_layout.addLayout(top_h2)

        self.brm_dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_layout.addWidget(self.brm_dashboard)
        brw.setLayout(br_layout)
        self.tabs.addTab(brw,"Business Rules")

        # approvals
        self.approv_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # GCR admin if admin
        if self.user_group.lower()=="admin":
            self.gcr_tab=GlobalCriticalAdminTab(self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # hierarchy
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # lineage
        lw=QWidget()
        lw_lay=QVBoxLayout(lw)
        lineage_top=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search in lineage..")
        sr_btn=QPushButton("Search")
        sr_btn.clicked.connect(self.do_lineage_search)
        lineage_top.addWidget(self.lineage_search)
        lineage_top.addWidget(sr_btn)

        reset_btn=QPushButton("Reset")
        reset_btn.clicked.connect(self.reset_lineage_view)
        lineage_top.addWidget(reset_btn)

        ref_lin=QPushButton("Refresh Graph")
        ref_lin.clicked.connect(self.refresh_lineage_graph)
        lineage_top.addWidget(ref_lin)
        lineage_top.addStretch()
        lw_lay.addLayout(lineage_top)

        self.lineage_view=EnhancedLineageGraphWidget(self.connection)
        lw_lay.addWidget(self.lineage_view)
        lw.setLayout(lw_lay)
        self.tabs.addTab(lw,"Lineage")

        # custom groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # scheduling
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # control tables
        self.ctrl_tab=CtrlTablesTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # alerts
        self.alert_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts & Perf")

        # group mgmt
        self.grp_mgmt_tab=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # user mgmt => admin
        if self.user_group.lower()=="admin":
            self.user_mgmt_tab=UserManagementTab(self.connection,self.user_id,self.user_group)
            self.tabs.addTab(self.user_mgmt_tab,"User Management")

        # data validation
        self.validation_tab=DataValidationTab(self.connection)
        self.tabs.addTab(self.validation_tab,"Data Validation")

        cw.setLayout(main_layout)
        self.setCentralWidget(cw)

        # timers
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(5000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules_due)
        self.schedule_timer.start(60000)

        self.show()

    def sync_metadata_action(self):
        sync_metadata_improved(self.connection)

    def show_metrics_dialog(self):
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(900,600)
        from PyQt5.QtWidgets import QVBoxLayout, QPushButton
        l=QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection)
        l.addWidget(chart)
        cl=QPushButton("Close")
        cl.clicked.connect(dlg.close)
        l.addWidget(cl)
        dlg.exec_()

    def new_schedule_dialog(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()

    def launch_chain_sim(self):
        dlg=ChainOrGroupSimulationDialog(self.connection,is_group=False,self=self)
        dlg.exec_()

    def launch_group_sim(self):
        dlg=ChainOrGroupSimulationDialog(self.connection,is_group=True,self=self)
        dlg.exec_()

    def show_help(self):
        QMessageBox.information(self,"Help","BRM Tool integrated solution.\nUse tabs & menu for BFS, scheduling, approvals, lineage, etc.")

    def launch_audit_viewer(self):
        dlg=AuditLogViewer(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_rule_search(self):
        dlg=RuleSearchDialog(self.connection,self.user_group,self)
        dlg.exec_()

    def launch_version_history(self):
        rid,ok=QInputDialog.getInt(self,"Version History","Enter rule ID:")
        if not ok:
            return
        dlg=VersionHistoryDialog(self.connection,rid,self)
        dlg.exec_()

    def populate_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for r_ in rows:
            self.switch_combo.addItem(f"{r_[1]}({r_[2]})",(r_[0],r_[2]))

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        (new_uid,new_ugrp)=data
        if new_uid==self.user_id and new_ugrp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_ugrp
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(new_uid,))
        r_=c.fetchone()
        if r_:
            self.logged_in_username=r_[0]
        else:
            self.logged_in_username="Unknown"

        QMessageBox.information(self,"Switched",f"Now impersonating {self.logged_in_username} => {new_ugrp}")
        # reload relevant tabs
        self.brm_dashboard.user_id=new_uid
        self.brm_dashboard.user_group=new_ugrp
        self.brm_dashboard.load_rules()

        self.approv_tab.logged_in_username=self.logged_in_username
        self.approv_tab.user_group=new_ugrp
        self.approv_tab.load_approvals()

        if hasattr(self,"gcr_tab"):
            self.gcr_tab.user_group=new_ugrp
            self.gcr_tab.load_rule_list()

        self.hier_tab.load_hierarchy()
        self.alert_tab.check_alerts()
        self.grp_mgmt_tab.user_id=new_uid
        self.grp_mgmt_tab.user_group=new_ugrp
        self.grp_mgmt_tab.load_data()
        if hasattr(self,"user_mgmt_tab"):
            self.user_mgmt_tab.user_id=new_uid
            self.user_mgmt_tab.user_group=new_ugrp
            self.user_mgmt_tab.load_users()

    def add_rule_handler(self):
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def update_rule_handler(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if len(sel)!=1:
            QMessageBox.warning(self,"Error","Select exactly one rule to update.")
            return
        rid=sel[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Missing",f"Rule {rid} not found.")
            return
        colnames=[desc[0] for desc in c.description]
        rd=dict(zip(colnames,row))
        dlg=RuleEditorDialog(self.connection,self.user_group,rd,self)
        if dlg.exec_()==QDialog.Accepted:
            self.brm_dashboard.load_rules()

    def deactivate_rule_handler(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        from Part2File import deactivate_rule
        done=0
        fails=[]
        for r_ in sel:
            try:
                deactivate_rule(self.connection,r_,f"UserID:{self.user_id}",self.user_group)
                done+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivated => {done}"
        if fails:
            msg+="\nFailures:\n"+"\n".join(fails)
        QMessageBox.information(self,"Deactivate",msg)
        self.brm_dashboard.load_rules()

    def delete_rule_handler(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        from Part2File import delete_rule
        if QMessageBox.question(self,"Confirm",f"Delete {len(sel)} rules?")!=QMessageBox.Yes:
            return
        done=0
        fails=[]
        for r_ in sel:
            try:
                delete_rule(self.connection,r_,f"UserID:{self.user_id}",self.user_group)
                done+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deleted => {done}"
        if fails:
            msg+="\nFailures:\n"+"\n".join(fails)
        QMessageBox.information(self,"Delete",msg)
        self.brm_dashboard.load_rules()

    def run_full_etl_bfs(self):
        from Part2File import execute_rules_dag_bfs
        ex,sk = execute_rules_dag_bfs(self.connection)
        msg=f"ETL BFS => executed={ex}, skipped={list(sk)}"
        QMessageBox.information(self,"ETL BFS",msg)
        self.brm_dashboard.load_rules()

    def simulate_single_rule(self):
        sel=self.brm_dashboard.get_selected_rule_ids()
        if len(sel)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=sel[0]
        dlg=SingleRuleSimulationDialog(self.connection,rid,self)
        dlg.exec_()

    def check_schedules_due(self):
        # look for due schedules => run them
        nowstr=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
          SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
          FROM RULE_SCHEDULES
          WHERE STATUS='Scheduled' AND SCHEDULE_TIME<=?
        """,(nowstr,))
        due=c.fetchall()
        for row in due:
            sid=row[0]
            rid=row[1]
            # mark in-progress
            c2=self.connection.cursor()
            c2.execute("UPDATE RULE_SCHEDULES SET STATUS='InProgress' WHERE SCHEDULE_ID=?",(sid,))
            self.connection.commit()
            # run BFS or direct rule
            c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            r2=c2.fetchone()
            if not r2:
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sid,))
                self.connection.commit()
                continue
            rule_sql=r2[0]
            start=datetime.now()
            pass_flag=True
            msg=""
            rec_count=0
            sc=conn.cursor()
            sc.execute("BEGIN TRAN")
            try:
                if rule_sql.strip():
                    sc.execute(rule_sql)
                    rows_=sc.fetchall()
                    if rows_:
                        rec_count=len(rows_)
                        val=rows_[0][0]
                        pass_flag=(val==1)
                        msg=f"Returned: {val}"
                    else:
                        msg="No rows => pass"
                else:
                    msg="Empty => pass"
                if pass_flag:
                    sc.execute("COMMIT")
                else:
                    sc.execute("ROLLBACK")
            except Exception as ex:
                sc.execute("ROLLBACK")
                pass_flag=False
                msg=str(ex)
            end=datetime.now()
            elapsed_ms=(end-start).total_seconds()*1000
            sc2=conn.cursor()
            sc2.execute("""
              INSERT INTO RULE_EXECUTION_LOGS(
                RULE_ID,EXECUTION_TIMESTAMP,PASS_FLAG,MESSAGE,RECORD_COUNT,EXECUTION_TIME_MS
              )
              VALUES(?,GETDATE(),?,?,?,?)
            """,(rid,1 if pass_flag else 0,msg,rec_count,elapsed_ms))
            if pass_flag:
                sc2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sid,))
            else:
                sc2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sid,))
            conn.commit()
        self.sch_tab.load_schedules()

    def do_lineage_search(self):
        txt=self.lineage_search.text().strip()
        self.lineage_view.perform_search(txt)

    def reset_lineage_view(self):
        self.lineage_view.reset_view()

    def refresh_lineage_graph(self):
        self.lineage_view.load_graph()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

def main():
    from PyQt5.QtWidgets import QApplication
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())
    
