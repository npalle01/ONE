#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 1 of 8 (FINAL, REVISED + FULLY ENHANCED)
Core foundation includes:
  • Centralized logging config
  • EmailNotifier class (with environment-based config)
  • DatabaseConnectionDialog
  • Basic DB helpers (fetch, audit insertion)
  • LoginDialog (with placeholder for hashed passwords)
  • A unified LockManager for rules:
     – Stores locks in BRM_RULE_LOCKS
     – Auto-expires stale locks
     – force lock/unlock logic
  • detect_operation_type (extended)
  • parse_sql_dependencies (advanced)
  • OnboardingWizard (optional usage)

No references to older placeholders; everything is spelled out and fully functional.
"""

import sys
import os
import json
import logging
import logging.config
import smtplib
import pyodbc
import sqlparse
import re

from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout,
    QMessageBox, QComboBox, QPlainTextEdit, QCalendarWidget, QTimeEdit,
    QFormLayout, QWidget, QCheckBox
)

###############################################################################
# 1) LOGGING CONFIG
###############################################################################

# A dictionary-based logging config, reading from environment variables for
# log file/path or fallback defaults.

LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "standard",
            "level": "DEBUG"
        },
        "file": {
            "class": "logging.FileHandler",
            "filename": os.getenv("BRM_LOG_FILE", "brm_core.log"),
            "formatter": "standard",
            "level": os.getenv("BRM_LOG_LEVEL", "INFO")
        }
    },
    "root": {
        "handlers": ["console","file"],
        "level": "DEBUG"
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")


###############################################################################
# 2) EMAIL NOTIFIER
###############################################################################
class EmailNotifier:
    """
    Sends emails via SMTP, reading credentials from environment variables
    or falling back to placeholder defaults. Example usage:
    
        notifier = EmailNotifier()
        notifier.send_email("Test subject", "Hello world", ["someone@example.com"])
    """

    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", 587))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "your_smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "your_smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("No recipients provided for email.")
            return
        try:
            msg = MIMEText(body, 'plain')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email to {recipients}: {e}")
            raise


###############################################################################
# 3) DATABASE CONNECTION DIALOG
###############################################################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Lets user pick an ODBC DSN or enter a custom ODBC conn string.
    On accept, we store self.connection if successful.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Part 1")
        self.resize(400, 200)

        main_layout = QVBoxLayout(self)
        lbl = QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or enter custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)
        main_layout.addLayout(btn_h)

    def get_connection(self):
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            sel = self.dsn_combo.currentData()
            if not sel:
                QMessageBox.critical(self, "Error", "No DSN or custom connection string provided.")
                return None
            conn_str = f"DSN={sel};Trusted_Connection=yes;"
        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "Connection Error", str(ex))
            logger.error(f"DB connection failed: {ex}")
            return None

    def accept(self):
        test_conn = self.get_connection()
        if test_conn:
            self.connection = test_conn
            super().accept()
        else:
            # remain in the dialog
            pass


###############################################################################
# 4) BASIC DB HELPERS
###############################################################################
def fetch_all_dict(cursor):
    """
    Fetch all rows into a list of dicts if description is present, else raw rows.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        out = []
        for r_ in rows:
            out.append(dict(zip(colnames, r_)))
        return out
    else:
        return rows

def fetch_one_dict(cursor):
    """
    Fetch the next row as dict (if present) or None.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert an audit record into BRM_AUDIT_LOG with optional old/new data as JSON.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action, table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"Audit log inserted => action={action}, table={table_name}, record_id={record_id}, actor={actor}")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")


###############################################################################
# 5) LOCK MANAGER (UNIFIED APPROACH)
###############################################################################
class LockManager:
    """
    A consolidated approach storing locks in BRM_RULE_LOCKS with expiry.
    Provides:
      • auto_unlock_expired_locks: called periodically to free stale locks
      • rule_current_lock_owner: returns lock info if active
      • lock_rule_for_edit: tries to lock or refresh lock
      • unlock_rule_for_edit: normal or forced unlock

    The BRM_RULE_LOCKS table might be:
       RULE_ID INT,
       LOCKED_BY VARCHAR(100),
       LOCK_TIMESTAMP DATETIME,
       EXPIRY_TIMESTAMP DATETIME,
       FORCE_LOCK BIT,
       ACTIVE_LOCK BIT
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        """
        Free up locks whose EXPIRY_TIMESTAMP < now. 
        Sets ACTIVE_LOCK=0. 
        """
        now = datetime.now()
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE ACTIVE_LOCK=1
              AND EXPIRY_TIMESTAMP < ?
        """, (now,))
        rc = c.rowcount
        conn.commit()
        if rc > 0:
            logger.info(f"Auto-unlocked {rc} expired rule locks.")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        """
        Returns (locked_by, lock_ts, expiry_ts, force_lock_flag) or None if not locked or expired.
        Also auto-deactivates the lock if found expired upon check.
        """
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, et, fflag = row
        now = datetime.now()
        if et and now > et:
            # Immediately expire it
            c2 = conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """, (rule_id,))
            conn.commit()
            return None
        return (locked_by, lts, et, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        """
        Attempt to lock:
          - if rule is already locked by same user => just refresh expiry
          - if locked by someone else => error unless force
          - if not locked => create new lock row
        """
        # first auto-unlock any expired
        LockManager.auto_unlock_expired_locks(conn)

        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()

        if info is not None:
            locked_by, old_ts, old_exp, fflag = info
            if locked_by == user_id:
                # refresh expiry
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock for rule {rule_id} refreshed by {user_id}. Force={force}")
                return
            else:
                # locked by another user
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    # forcibly override
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                          FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly re-locked by {user_id}.")
                    return
        else:
            # not locked => create
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by {user_id}, force={force}.")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        """
        Normal unlock => must match locked_by unless force => then set ACTIVE_LOCK=0
        """
        # also auto-unlock expired first
        LockManager.auto_unlock_expired_locks(conn)

        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return  # not locked or was expired
        locked_by, lts, et, fflag = info
        if locked_by != user_id and not force:
            raise ValueError(f"Rule {rule_id} is locked by {locked_by}, cannot unlock.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by user {user_id}, force={force}.")


###############################################################################
# 6) ADVANCED SQL PARSER
###############################################################################
def detect_operation_type(sql_text: str) -> str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, or OTHER
    – We do a quick parse ignoring leading comments or whitespace.
    – For advanced usage, we might rely on sqlparse to identify the first DML token.
    """
    # strip leading whitespace + comments
    cleaned = sql_text.lstrip()
    # quick check if it starts with something
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"


def parse_sql_dependencies(sql_text: str):
    """
    Use sqlparse to identify table references, columns, CTE usage, etc.
    Return dict => {
      'tables': [ (schema, table, alias, is_subselect) ],
      'cte_tables': [ (cte_name, cte_refs) ],
      'alias_map': { alias: (schema, table) },
      'columns': [list_of_colnames]
    }

    This is advanced but not perfect for all T-SQL edge cases.
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []

    for stmt in statements:
        ctes = _extract_with_clauses(stmt)
        for cName, cRefs in ctes.items():
            cte_info.append((cName, cRefs))

        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)

    unique_tables = list({x for x in all_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }

def _extract_with_clauses(statement):
    """
    Identify CTEs in a statement => return { cte_name: [list_of_sub_refs], ... }
    """
    tokens = list(statement.tokens)
    i = 0
    cte_map = {}
    from sqlparse.tokens import Keyword

    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() == "WITH":
            i += 1
            i = _parse_cte_block(tokens, i, cte_map)
            continue
        i += 1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    from sqlparse.sql import Identifier, Parenthesis
    from sqlparse.tokens import Keyword

    while i < len(tokens):
        tk = tokens[i]
        if isinstance(tk, Identifier):
            cte_name = tk.get_real_name()
            i += 1
            i = _parse_cte_as_clause(tokens, i, cte_name, cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i += 1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    from sqlparse.sql import Parenthesis
    while i < len(tokens):
        tk = tokens[i]
        if tk.value.upper() == "AS":
            i += 1
            if i < len(tokens):
                sub = tokens[i]
                if isinstance(sub, Parenthesis):
                    sub_refs = _extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name] = sub_refs
                    i += 1
                    return i
        else:
            i += 1
    return i

def _extract_subselect_tokens(tokens):
    """
    Recursively parse subselect tokens => find (schema, table, alias, is_sub).
    """
    from sqlparse.sql import IdentifierList, Identifier
    from sqlparse.tokens import Keyword
    results = []
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if hasattr(tk,"is_group") and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, set())
                    st = (st[0], st[1], st[2], True)
                    results.append(st)
            elif isinstance(tk, Identifier):
                st = _parse_identifier(tk, set())
                st = (st[0], st[1], st[2], True)
                results.append(st)
        i += 1
    return results

def _is_subselect(token):
    from sqlparse.tokens import DML
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper() == "SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import IdentifierList, Identifier
    results = []
    alias_map = {}
    tokens = list(tokenlist)
    from_seen = False
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if hasattr(tk,"is_group") and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen = True
            else:
                from_seen = False
        if from_seen:
            if isinstance(tk, IdentifierList):
                for ident in tk.get_identifiers():
                    st = _parse_identifier(ident, known_cte_names)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]] = (st[0],st[1])
            elif isinstance(tk, Identifier):
                st = _parse_identifier(tk, known_cte_names)
                results.append(st)
                if st[2]:
                    alias_map[st[2]] = (st[0], st[1])
        i += 1
    return (results, alias_map)

def _parse_identifier(ident, known_cte_names):
    alias = ident.get_alias()
    real_name = ident.get_real_name()
    schema = ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema, real_name, alias, False)

def _extract_columns(statement):
    """
    For demonstration: gather col references. 
    This approach might not be fully robust for all T-SQL edge cases
    but works for typical simple queries.
    """
    from sqlparse.tokens import DML, Keyword
    from sqlparse.sql import IdentifierList, Identifier, Parenthesis
    results = []
    tokens = list(statement.tokens)
    i = 0
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is DML:
            upv = tk.value.upper()
            if upv == "SELECT":
                results.extend(_parse_select_list(tokens,i+1))
            elif upv in ("INSERT","UPDATE"):
                results.extend(_parse_dml_columns(tokens,i,upv))
        i += 1
    return results

def _parse_select_list(tokens, start_idx):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import IdentifierList, Identifier
    columns = []
    i = start_idx
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword:
            upv = tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk, IdentifierList):
            for ident in tk.get_identifiers():
                nm = ident.get_name()
                if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(nm)
        elif isinstance(tk, Identifier):
            nm = tk.get_name()
            if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(nm)
        i += 1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import Parenthesis, IdentifierList, Identifier
    columns = []
    if dml_word == "INSERT":
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.is_group and isinstance(tk, Parenthesis):
                for sub in tk.tokens:
                    if isinstance(sub, IdentifierList):
                        for ident in sub.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(sub, Identifier):
                        columns.append(sub.get_name())
                return columns
            i += 1
    elif dml_word == "UPDATE":
        found_set = False
        i = start_idx
        while i < len(tokens):
            tk = tokens[i]
            if tk.ttype is Keyword and tk.value.upper() == "SET":
                found_set = True
                i += 1
                columns.extend(_parse_update_set_list(tokens, i))
                break
            i += 1
    return columns

def _parse_update_set_list(tokens, start_i):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import Identifier
    cols = []
    i = start_i
    while i < len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk, Identifier):
            cols.append(tk.get_name())
        i += 1
    return cols


###############################################################################
# 7) LOGIN DIALOG (with placeholder for hashed password)
###############################################################################
def hash_password(plain_text):
    """
    For demonstration only. In production, use bcrypt or similar.
    This might simply reverse the string or do a static prefix as example.
    """
    return "enc_" + plain_text[::-1]


class LoginDialog(QtWidgets.QDialog):
    """
    Minimal user/password => checks USERS table => sets user_id, user_group.
    If your DB has hashed passwords, adapt the check accordingly.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None

        self.setWindowTitle("Login – Part 1 (Enhanced)")
        self.resize(300, 150)

        main_l = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        main_l.addWidget(QLabel("Username:"))
        main_l.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_l.addWidget(QLabel("Password:"))
        main_l.addWidget(self.pass_edit)

        login_btn = QPushButton("Login")
        login_btn.clicked.connect(self.do_login)
        main_l.addWidget(login_btn)

        self.setLayout(main_l)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Both username and password required.")
            return

        # If your USERS table stores hashed passwords, do:
        # hashed = hash_password(pw)
        # Then compare hashed instead of plain text:
        hashed = hash_password(pw)

        c = self.connection.cursor()
        c.execute("""
            SELECT USER_ID, USER_GROUP 
            FROM USERS
            WHERE USERNAME=? AND PASSWORD=?
        """, (un, hashed))  # or (un, pw) if still storing plain
        row = c.fetchone()
        if row:
            self.user_id = row[0]
            self.user_group = row[1]
            logger.info(f"User {un} logged in. user_id={self.user_id}, group={self.user_group}")
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid credentials.")


###############################################################################
# 8) ONBOARDING WIZARD (OPTIONAL)
###############################################################################
class OnboardingWizard(QDialog):
    """
    A multi-step wizard for brand-new users:
      Step 1) create a group
      Step 2) create a rule
      Step 3) schedule it
    Then done. This can be optional or only shown on first login, etc.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_step = 0
        self.setWindowTitle("Onboarding Wizard – Part 1")
        self.resize(400, 250)
        main_l = QVBoxLayout(self)

        self.label = QLabel("Welcome to the BRM Tool! This wizard helps new users do a basic setup.")
        main_l.addWidget(self.label)

        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.advance_step)
        main_l.addWidget(self.next_btn)

        self.setLayout(main_l)

    def advance_step(self):
        self.current_step += 1
        if self.current_step == 1:
            self.label.setText("Step 1: Go to 'Group Management' => create a new group.")
        elif self.current_step == 2:
            self.label.setText("Step 2: Go to 'Business Rules' => add a new rule.")
        elif self.current_step == 3:
            self.label.setText("Step 3: Go to 'Scheduling' => schedule your new rule.")
        else:
            self.label.setText("All done! Enjoy using the BRM Tool.")
            self.accept()


###############################################################################
# UTILITY: SYNC METADATA (IMPROVED)
###############################################################################
def sync_metadata_improved(conn):
    """
    Example function: 
      - Gathers real tables from sys.tables
      - Compares with BRM_RULE_TABLE_DEPENDENCIES => marks missing references with 'MISSING_' prefix
      - Returns a summary string
    """
    c = conn.cursor()
    c.execute("""
        SELECT s.name AS schema_name, t.name AS table_name
        FROM sys.tables t
        JOIN sys.schemas s ON t.schema_id=s.schema_id
        ORDER BY s.name, t.name
    """)
    actual_tables = set()
    for row in c.fetchall():
        full_n = (f"{row[0]}.{row[1]}").lower()
        actual_tables.add(full_n)

    c.execute("""
        SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME
        FROM BRM_RULE_TABLE_DEPENDENCIES
    """)
    deps = c.fetchall()
    missing_count = 0
    for (dep_id, dbn, tbl) in deps:
        if not tbl:
            continue
        low_tbl = tbl.lower().strip()
        if "." not in low_tbl:
            low_tbl = f"dbo.{low_tbl}"
        if low_tbl not in actual_tables:
            # mark missing
            c2 = conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_TABLE_DEPENDENCIES
                SET TABLE_NAME = 'MISSING_' + TABLE_NAME
                WHERE DEPENDENCY_ID=?
            """, (dep_id,))
            missing_count += 1

    conn.commit()
    msg = (f"Metadata sync complete. Found {len(actual_tables)} real DB tables.\n"
           f"Scanned {len(deps)} dependencies.\n"
           f"Marked {missing_count} references as 'MISSING_'.")
    logger.info(msg)
    return msg
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 2 of 8 (FINAL, REVISED + FULLY ENHANCED)
Builds on Part 1’s foundation. Now includes:
  • BFS-based rule execution (unified approach).
  • Conflict & composite adjacency logic.
  • Multi-level approvals (including impacted child/global rules => BFS).
  • Advanced CRUD with deeper lifecycle handling (insert/update/deactivate/delete).
  • Data Validation execution logic integrated (calls out to run_data_validations).
  • Strict parent->child checks for deactivate/delete.
  • Lock/unlock usage from Part 1's LockManager.
  • Detecting operation type (INSERT/UPDATE/DELETE/SELECT/DECISION_TABLE).
  • parse_sql_dependencies usage for table references, columns, etc.

Requires “Part 1” to be imported, specifically for:
  - logger, fetch_all_dict, fetch_one_dict, insert_audit_log
  - LockManager (lock_rule_for_edit, unlock_rule_for_edit)
  - parse_sql_dependencies, detect_operation_type
  - Possibly data validations references (run_data_validations), or a separate import from data validations.
"""

import sys
import math
import json
import logging
import re
import time

from datetime import datetime, timedelta
from collections import deque

# We assume the following are imported from Part 1 (brm_core_foundation):
#   from brm_core_foundation import (
#       logger, fetch_all_dict, fetch_one_dict, insert_audit_log,
#       LockManager, parse_sql_dependencies, detect_operation_type
#   )
#
# Also, if you integrated data validations in the same or separate file, you might do:
#   from brm_data_validations import run_data_validations   # or similar

###############################################################################
# 1) BFS RULE EXECUTION (UNIFIED)
###############################################################################
def execute_rules_unified_bfs(conn, dry_run=False):
    """
    A unified BFS that tries to run from all ‘root’ rules,
    includes child/parent logic, conflict adjacency, composite rule references,
    and global-critical skipping. Also calls data validations first if desired
    (or call separately).
    
    If a rule fails and is CRITICAL => we skip adjacency.
    If dry_run=True => we always rollback changes after each rule attempt.
    
    Returns (executed_list, skipped_set).
    """

    # Optionally: you can run data validations first, or do that selectively:
    # run_data_validations(conn)

    adjacency, roots, parent_map = load_rule_relationships(conn)
    rule_lookup = get_all_rules_map(conn)

    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info = rule_lookup[rid]

        # run single rule in transaction
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)

        # log outcome to RULE_EXECUTION_LOGS or similar
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            # enqueue adjacency
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # if fails => skip adjacency if CRITICAL or GLOBAL
            is_crit = (info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1)
            if is_crit:
                if rid in adjacency:
                    for ch in adjacency[rid]:
                        skip_all_descendants(ch, adjacency, skipped)
            # skip direct adjacency
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)

    return (executed, skipped)


def load_rule_relationships(conn):
    """
    Construct adjacency for:
      - child rules (via PARENT_RULE_ID),
      - conflict links (RULE_CONFLICTS),
      - global-critical links (BRM_GLOBAL_CRITICAL_LINKS),
      - composite references (COMPOSITE_RULES).
    
    Return: (adjacency_dict, list_of_roots, parent_map).
      adjacency_dict: rule_id -> set(of child/related rule_ids).
      list_of_roots: those with no parent
      parent_map: child->parent
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()

    adjacency = {}
    parent_map = {}
    all_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid

    # conflict links => each conflict is a two-way adjacency
    c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
    conflicts = c.fetchall()
    for (r1, r2) in conflicts:
        adjacency.setdefault(r1, set()).add(r2)
        adjacency.setdefault(r2, set()).add(r1)

    # global-critical => one-way adjacency from GCR_RULE_ID => TARGET_RULE_ID
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    gcrs = c.fetchall()
    for (gcr, tgt) in gcrs:
        adjacency.setdefault(gcr, set()).add(tgt)

    # composite => e.g. COMPOSITE_RULES => for each subrule in expression => adjacency sub->composite
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp_rows = c.fetchall()
    import re
    pat = re.compile(r"Rule(\d+)")
    for (comp_id, expr) in comp_rows:
        if expr:
            matches = pat.findall(expr)
            for m_ in matches:
                try:
                    sub_id = int(m_)
                    adjacency.setdefault(sub_id, set()).add(comp_id)
                except:
                    pass

    # find roots => those not in parent_map
    child_ids = set(parent_map.keys())
    roots = [x for x in all_ids if x not in child_ids]
    return (adjacency, roots, parent_map)


def skip_all_descendants(start_id, adjacency, skipped):
    """
    BFS or stack approach => skip all rules reachable from start_id in adjacency.
    """
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch in adjacency[cur]:
                if ch not in skipped:
                    stack.append(ch)


def get_all_rules_map(conn):
    """
    Return a dict of rule_id -> full row from BRM_RULES
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    out = {}
    for row in rows:
        d = dict(zip(colnames, row))
        out[d["RULE_ID"]] = d
    return out


def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    If rule is DECISION_TABLE => handle that logic. 
    If normal SQL => run in a transaction => if returns 1 => pass, else fail.
    Return (ok, msg, record_count).
    """
    op_type = rule_info.get("OPERATION_TYPE", "OTHER")
    if op_type == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        # We can do real logic => for demonstration, assume pass:
        return (True, f"DecisionTable {dt_id} => PASS", 1)

    sql_ = rule_info.get("RULE_SQL") or ""
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(sql_)
        rows = c.fetchall()
        if rows:
            rec_count = len(rows)
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        c.execute("ROLLBACK")
        success = False
        msg = str(ex)

    return (success, msg, rec_count)


def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert a row in RULE_EXECUTION_LOGS => BFS or scheduled runs. 
    Could store additional metrics (time, CPU, memory) if desired.
    """
    c = conn.cursor()
    c.execute("""
        INSERT INTO RULE_EXECUTION_LOGS(
          RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
          MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
          CPU_USAGE, MEM_USAGE
        )
        VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
    """, (rule_id, 1 if pass_flag else 0, message, record_count))
    conn.commit()


###############################################################################
# 2) DATA VALIDATION RUNS
###############################################################################
def run_data_validations(conn):
    """
    Example that runs all data validations from a “DATA_VALIDATIONS” table,
    storing pass/fail results in “DATA_VALIDATION_RESULTS”.
    For demonstration, only two types: NOT NULL or numeric range.
    """
    c = conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS
    """)
    validations = c.fetchall()
    for (vid, tbl, col, vtype, pars) in validations:
        pass_flag = True
        message = "OK"
        try:
            if vtype.upper() == "NOT NULL":
                q = f"SELECT COUNT(*) FROM {tbl} WHERE [{col}] IS NULL"
                c.execute(q)
                cnt = c.fetchone()[0]
                if cnt > 0:
                    pass_flag = False
                    message = f"{cnt} null(s) found in {tbl}.{col}"
            elif vtype.upper() == "RANGE":
                # parse e.g. param: "min=0;max=100"
                min_ = None
                max_ = None
                if pars:
                    pairs = pars.split(";")
                    for p in pairs:
                        if "min=" in p.lower():
                            min_ = float(p.split("=")[1])
                        if "max=" in p.lower():
                            max_ = float(p.split("=")[1])
                    if min_ is not None and max_ is not None:
                        q = f"SELECT COUNT(*) FROM {tbl} WHERE [{col}] < {min_} OR [{col}] > {max_}"
                        c.execute(q)
                        out_of_range = c.fetchone()[0]
                        if out_of_range > 0:
                            pass_flag = False
                            message = f"{out_of_range} out-of-range in {tbl}.{col}"
            # else custom validations
        except Exception as ex:
            pass_flag = False
            message = str(ex)

        # store result
        c2 = conn.cursor()
        c2.execute("""
            INSERT INTO DATA_VALIDATION_RESULTS(
              VALIDATION_ID, PASS_FLAG, MESSAGE, RUN_TIMESTAMP
            )
            VALUES(?,?,?,GETDATE())
        """, (vid, 1 if pass_flag else 0, message))
        conn.commit()


###############################################################################
# 3) MULTI-STEP APPROVALS
###############################################################################
def create_multistep_approvals(conn, rule_id, initiated_by):
    """
    For demonstration: build a pipeline of group approvals => store in BRM_RULE_APPROVALS.
    If we detect certain table references => add BG2 or BG3, etc.
    """
    impacted = find_impacted_business_groups_advanced(conn, rule_id)

    # check table references => if “finance” => need BG2, if “sensitive” => BG3, etc.
    c2 = conn.cursor()
    c2.execute("SELECT TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
    trows = c2.fetchall()
    require_bg2 = False
    require_bg3 = False
    for (tn,) in trows:
        lo = (tn or "").lower()
        if "finance" in lo or "credit" in lo:
            require_bg2 = True
        if "sensitive_data" in lo or "personal_info" in lo:
            require_bg3 = True

    pipeline = []
    pipeline.append("BG1")
    if require_bg2 or "BG2" in impacted:
        pipeline.append("BG2")
    if require_bg3 or "BG3" in impacted:
        pipeline.append("BG3")

    # also add any custom impacted groups from BFS logic
    for grp in impacted:
        if grp not in ("BG1","BG2","BG3"):
            pipeline.append(grp)

    # final
    pipeline.append("FINAL")

    c = conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_id,))

    stage = 1
    for grp in pipeline:
        if grp == "FINAL":
            # single row => final_approver
            c.execute("""
                INSERT INTO BRM_RULE_APPROVALS(
                  RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                  APPROVED_TIMESTAMP, APPROVAL_STAGE
                )
                VALUES(?, 'FINAL', 'final_approver', 0, NULL, ?)
            """, (rule_id, stage))
            stage += 1
        else:
            # insert for each group’s real approvers
            c2 = conn.cursor()
            c2.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?", (grp,))
            arows = c2.fetchall()
            if not arows:
                # fallback => single row
                c.execute("""
                    INSERT INTO BRM_RULE_APPROVALS(
                      RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                      APPROVED_TIMESTAMP, APPROVAL_STAGE
                    )
                    VALUES(?,?,?,?,NULL,?)
                """, (rule_id, grp, f"{grp}_approver", 0, stage))
            else:
                for (apuser,) in arows:
                    c.execute("""
                        INSERT INTO BRM_RULE_APPROVALS(
                          RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG,
                          APPROVED_TIMESTAMP, APPROVAL_STAGE
                        )
                        VALUES(?,?,?,?,NULL,?)
                    """, (rule_id, grp, apuser, 0, stage))
            stage += 1

    conn.commit()


def find_impacted_business_groups_advanced(conn, rule_id):
    """
    BFS => from rule_id => find all connected rules => gather their OWNER_GROUP => return set of groups.
    """
    visited = unified_get_related_rules(conn, rule_id)
    groups = set()
    c = conn.cursor()
    for rid in visited:
        c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if row:
            groups.add(row[0])
    return groups

def unified_get_related_rules(conn, start_rule_id):
    """
    BFS => adjacency from load_rule_relationships => all reachable rules (including start).
    """
    adjacency, roots, pmap = load_rule_relationships(conn)
    visited = set()
    queue = [start_rule_id]
    while queue:
        cur = queue.pop(0)
        if cur in visited:
            continue
        visited.add(cur)
        if cur in adjacency:
            for ch_ in adjacency[cur]:
                if ch_ not in visited:
                    queue.append(ch_)
    return visited


###############################################################################
# 4) ADVANCED CRUD (with locking, lifecycle, approvals, child checks)
###############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    """
    Insert a new rule => parse => set lifecycle => create approvals => check table-level perms => lock if needed.
    Return new rule_id.
    """
    c = conn.cursor()
    # check duplicates (by name in that group)
    c.execute("""
        SELECT RULE_ID
        FROM BRM_RULES
        WHERE OWNER_GROUP=? AND RULE_NAME=?
    """, (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    if c.fetchone():
        raise ValueError("Duplicate rule name in that group.")

    # check same SQL
    new_sql = (rule_data.get("RULE_SQL") or "").strip()
    if new_sql:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?", (new_sql,))
        row2 = c.fetchone()
        if row2:
            raise ValueError("Another rule with that exact SQL already exists.")

    # set lifecycle => 'DRAFT'
    rule_data["LIFECYCLE_STATE"] = "DRAFT"
    # if user attempts to create global rule => must be admin
    if rule_data.get("IS_GLOBAL", 0) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create a global rule.")

    op_type = detect_operation_type(new_sql)
    if (not new_sql) and rule_data.get("DECISION_TABLE_ID"):
        op_type = "DECISION_TABLE"
    rule_data["OPERATION_TYPE"] = op_type

    # parse => store table deps
    parse_info = {}
    col_op = "READ"
    if op_type not in ("DECISION_TABLE","OTHER") and new_sql:
        parse_info = parse_sql_dependencies(new_sql)
        if op_type in ("INSERT","UPDATE","DELETE"):
            col_op = "WRITE"

    # (Optional) check DB perms for each table (some function check_group_permission)
    for (sch, tb, alias, issub) in parse_info.get("tables", []):
        if tb and not tb.startswith("(CTE)"):
            # check_group_permission(conn, rule_data["OWNER_GROUP"], (sch, tb))

            # Pseudocode: if not allowed => raise ValueError
            pass

    nowstr = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    row = c.execute("""
        INSERT INTO BRM_RULES(
          GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
          EFFECTIVE_START_DATE, EFFECTIVE_END_DATE,
          STATUS, VERSION,
          CREATED_BY, DESCRIPTION, OPERATION_TYPE,
          BUSINESS_JUSTIFICATION, CREATED_TIMESTAMP,
          UPDATED_BY, OWNER_GROUP, CLUSTER_NAME,
          APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE,
          CRITICAL_SCOPE, CDC_TYPE, LIFECYCLE_STATE,
          DECISION_TABLE_ID
        )
        OUTPUT inserted.RULE_ID
        VALUES(?,?,?,?,?,
               ?,?,
               ?,?,
               ?,?,?,?,?,?,
               ?,?,?,?,
               ?,?,?,?)
    """, (
        rule_data.get("GROUP_ID"),
        rule_data.get("PARENT_RULE_ID"),
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"].strip(),
        new_sql,

        rule_data["EFFECTIVE_START_DATE"],
        rule_data.get("EFFECTIVE_END_DATE"),

        rule_data.get("STATUS","INACTIVE"),
        1,

        created_by,
        rule_data.get("DESCRIPTION",""),
        op_type,

        rule_data.get("BUSINESS_JUSTIFICATION",""),
        nowstr,

        None,
        rule_data["OWNER_GROUP"],
        rule_data.get("CLUSTER_NAME",""),

        "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0),
        rule_data.get("CRITICAL_RULE",0),

        rule_data.get("CRITICAL_SCOPE","NONE"),
        rule_data.get("CDC_TYPE","NONE"),
        rule_data["LIFECYCLE_STATE"],
        rule_data.get("DECISION_TABLE_ID",None)
    )).fetchone()

    if not row:
        raise ValueError("Insert failed => no RULE_ID returned.")
    new_id = row[0]

    # store table deps
    if op_type not in ("DECISION_TABLE","OTHER") and new_sql:
        for (sch, tb, alias, issub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                      RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                    )
                    VALUES(?,?,?,?,?)
                """, (new_id, sch if sch else "N/A", tb, "AutoCol", col_op))

    # log
    insert_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    # create approvals
    create_multistep_approvals(conn, new_id, created_by)
    return new_id


def update_rule(conn, rule_data, updated_by, user_group):
    """
    Update => re-approval => parse new SQL => check perms => lock/unlock => 
    set status=INACTIVE => lifecycle=UNDER_APPROVAL => version++ => store deps.
    """
    c = conn.cursor()
    rid = rule_data["RULE_ID"]

    # lock
    LockManager.lock_rule_for_edit(conn, rid, updated_by)

    try:
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        old = c.fetchone()
        if not old:
            raise ValueError("Rule not found.")
        cols = [d[0] for d in c.description]
        old_data = dict(zip(cols, old))

        if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
            raise ValueError("Only Admin can update a global rule.")

        new_sql = (rule_data.get("RULE_SQL") or "").strip()
        if new_sql and new_sql != (old_data["RULE_SQL"] or "").strip():
            # check for duplicates
            c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_SQL=?", (new_sql,))
            row2 = c.fetchone()
            if row2 and row2[0] != rid:
                raise ValueError("Another rule with that SQL already exists.")

        final_op = detect_operation_type(new_sql)
        if (not new_sql) and rule_data.get("DECISION_TABLE_ID"):
            final_op = "DECISION_TABLE"
        rule_data["OPERATION_TYPE"] = final_op

        parse_info = {}
        col_op = "READ"
        if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
            parse_info = parse_sql_dependencies(new_sql)
            if final_op in ("INSERT","UPDATE","DELETE"):
                col_op = "WRITE"

        # check perms
        for (sch, tb, alias, issub) in parse_info.get("tables", []):
            if tb and not tb.startswith("(CTE)"):
                pass
                # check_group_permission(conn, old_data["OWNER_GROUP"], f"{sch}.{tb}")

        c.execute("""
            UPDATE BRM_RULES
            SET GROUP_ID=?,
                PARENT_RULE_ID=?,
                RULE_TYPE_ID=?,
                RULE_NAME=?,
                RULE_SQL=?,
                EFFECTIVE_START_DATE=?,
                EFFECTIVE_END_DATE=?,
                STATUS='INACTIVE',
                VERSION=VERSION+1,
                UPDATED_BY=?,
                DESCRIPTION=?,
                OPERATION_TYPE=?,
                BUSINESS_JUSTIFICATION=?,
                OWNER_GROUP=?,
                CLUSTER_NAME=?,
                APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                IS_GLOBAL=?,
                CRITICAL_RULE=?,
                CRITICAL_SCOPE=?,
                CDC_TYPE=?,
                LIFECYCLE_STATE='UNDER_APPROVAL',
                DECISION_TABLE_ID=?
            WHERE RULE_ID=?
        """, (
            rule_data.get("GROUP_ID", old_data["GROUP_ID"]),
            rule_data.get("PARENT_RULE_ID", old_data["PARENT_RULE_ID"]),
            rule_data["RULE_TYPE_ID"],
            rule_data["RULE_NAME"].strip(),
            new_sql,
            rule_data["EFFECTIVE_START_DATE"],
            rule_data.get("EFFECTIVE_END_DATE"),
            updated_by,
            rule_data.get("DESCRIPTION", old_data["DESCRIPTION"]),
            final_op,
            rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
            rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
            rule_data.get("CLUSTER_NAME", old_data["CLUSTER_NAME"]),
            rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
            rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
            rule_data.get("CRITICAL_SCOPE", old_data["CRITICAL_SCOPE"]),
            rule_data.get("CDC_TYPE", old_data["CDC_TYPE"]),
            rule_data.get("DECISION_TABLE_ID", old_data["DECISION_TABLE_ID"]),
            rid
        ))

        # refresh table deps
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
        if final_op not in ("DECISION_TABLE","OTHER") and new_sql:
            for (sch, tb, alias, issub) in parse_info["tables"]:
                if tb and not tb.startswith("(CTE)"):
                    c.execute("""
                        INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                          RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                        )
                        VALUES(?,?,?,?,?)
                    """, (rid, sch if sch else "N/A", tb, "AutoCol", col_op))

        new_data = dict(old_data)
        for k,v in rule_data.items():
            new_data[k] = v
        new_data["VERSION"] = old_data["VERSION"] + 1

        insert_audit_log(conn, "UPDATE", "BRM_RULES", rid, updated_by, old_data, new_data)
        conn.commit()

        # re-create approvals
        create_multistep_approvals(conn, rid, updated_by)

    finally:
        LockManager.unlock_rule_for_edit(conn, rid, updated_by)


def deactivate_rule(conn, rule_id, updated_by, user_group, force=False):
    """
    Deactivate => must be fully APPROVED => no active children => if global => admin only => check lock => or force
    """
    LockManager.lock_rule_for_edit(conn, rule_id, updated_by, force=force)
    try:
        c = conn.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        old = c.fetchone()
        if not old:
            raise ValueError("Rule not found.")
        cols = [d[0] for d in c.description]
        old_data = dict(zip(cols, old))

        if old_data["APPROVAL_STATUS"] != "APPROVED" and not force:
            raise ValueError("Cannot deactivate => not fully APPROVED (use force if Admin).")

        if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
            raise ValueError("Only Admin can deactivate a global rule.")

        # child check
        c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
        if c.fetchone():
            raise ValueError("Deactivate child rules first (some are ACTIVE).")

        c.execute("""
            UPDATE BRM_RULES
            SET STATUS='INACTIVE',
                UPDATED_BY=?,
                VERSION=VERSION+1,
                LIFECYCLE_STATE='INACTIVE'
            WHERE RULE_ID=?
        """, (updated_by, rule_id))

        new_data = dict(old_data)
        new_data["STATUS"] = "INACTIVE"
        new_data["VERSION"] = old_data["VERSION"] + 1
        new_data["LIFECYCLE_STATE"] = "INACTIVE"

        insert_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
        conn.commit()
    finally:
        LockManager.unlock_rule_for_edit(conn, rule_id, updated_by, force=force)


def delete_rule(conn, rule_id, action_by, user_group, force=False):
    """
    Fully-approved & inactive => no children => no references => if global => admin only => remove
    from BRM_RULES. Also remove from approvals, table deps, etc. Checks lock or force.
    """
    LockManager.lock_rule_for_edit(conn, rule_id, action_by, force=force)
    try:
        c = conn.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        old = c.fetchone()
        if not old:
            raise ValueError("Rule not found.")
        cols = [d[0] for d in c.description]
        old_data = dict(zip(cols, old))

        if old_data["IS_GLOBAL"] == 1 and user_group != "Admin":
            raise ValueError("Only Admin can delete a global rule.")
        if old_data["APPROVAL_STATUS"] != "APPROVED" and not force:
            raise ValueError("Cannot delete unless fully APPROVED (or force if Admin).")
        if old_data["STATUS"] != "INACTIVE" and not force:
            raise ValueError("Must be INACTIVE first (or force).")

        # child check
        c.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
        if c.fetchone():
            raise ValueError("Child rules exist; cannot delete unless forced, or remove them first.")

        # references check (like BRM_COLUMN_MAPPING or custom)
        c.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
        if c.fetchone():
            raise ValueError("Remove references from BRM_COLUMN_MAPPING first (or force).")

        c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
        insert_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
        conn.commit()
    finally:
        LockManager.unlock_rule_for_edit(conn, rule_id, action_by, force=force)
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 3 of 8 (FINAL, REVISED + FULLY ENHANCED)
Focuses on:
 • Scheduling + ScheduleManagementTab (advanced scheduling UI)
 • Chain/Group Simulation (dry-run BFS) dialogs
 • DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab, SnapshotManagerTab,
   TagsManagerTab, DataValidationTab, WhatIfTestTab
 • sync_metadata_improved (optionally re-used from Part 1 or here)
 • Additional data validation invocation (manual run) + pass/fail display
No references to old placeholders. 
All advanced BFS, concurrency, logging from Parts 1–2 are assumed to be accessible.
"""

import sys
import os
import logging
import re
import csv
import math
import time
import pyodbc
import sqlparse
from datetime import datetime, timedelta
from collections import deque

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDate, QTime, QDateTime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox,
    QMessageBox, QLineEdit, QDialog, QTableWidget, QTableWidgetItem,
    QCalendarWidget, QCheckBox, QInputDialog, QPlainTextEdit, QFileDialog
)

# from brm_core_foundation (Part 1) we typically import:
#   logger, fetch_all_dict, fetch_one_dict, insert_audit_log, parse_sql_dependencies, LockManager, etc.
# from brm_tool_part2_crud_bfs (Part 2) we import BFS logic or other advanced calls.

###############################################################################
# SYNC METADATA (IMPROVED) – optionally re-used from Part 1
###############################################################################
def sync_metadata_improved(conn):
    """
    Mark references to missing tables in BRM_RULE_TABLE_DEPENDENCIES with 'MISSING_' prefix.
    Also returns a summary message or logs it. (If not already in Part 1, we define here.)
    """
    c = conn.cursor()
    c.execute("""
        SELECT s.name as schema_name, t.name as table_name
        FROM sys.tables t
        JOIN sys.schemas s ON t.schema_id=s.schema_id
        ORDER BY s.name, t.name
    """)
    actual_tables = set()
    for row in c.fetchall():
        full_name = (f"{row[0]}.{row[1]}").lower()
        actual_tables.add(full_name)

    c.execute("SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps = c.fetchall()
    missing_count = 0
    for (dep_id, dbn, tbl) in deps:
        if not tbl:
            continue
        low_tbl = tbl.lower().strip()
        if "." not in low_tbl:
            low_tbl = f"dbo.{low_tbl}"
        if low_tbl not in actual_tables:
            # mark missing
            c2 = conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_TABLE_DEPENDENCIES
                SET TABLE_NAME='MISSING_' + TABLE_NAME
                WHERE DEPENDENCY_ID=?
            """, (dep_id,))
            missing_count += 1

    conn.commit()
    msg = (f"Metadata sync complete. Found {len(actual_tables)} real DB tables.\n"
           f"Scanned {len(deps)} dependencies.\n"
           f"Marked {missing_count} references as 'MISSING_'.")
    logging.info(msg)
    return msg


###############################################################################
# DRY-RUN SIMULATIONS (CHAIN or GROUP)
###############################################################################
def dry_run_rule_sql(conn, sql_text):
    """
    Attempt to run the given SQL in a transaction => if row[0][0] == 1 => PASS else FAIL => rollback.
    Return (pass_flag, message).
    """
    c = conn.cursor()
    c.execute("BEGIN TRANSACTION")
    pass_flag = True
    message = ""
    try:
        c.execute(sql_text)
        rows = c.fetchall()
        if rows:
            val = rows[0][0]
            pass_flag = (val == 1)
            message = f"Returned: {val}"
        else:
            pass_flag = True
            message = "No rows => PASS"
    except Exception as ex:
        pass_flag = False
        message = str(ex)

    c.execute("ROLLBACK")  # always rollback for a dry run
    return (pass_flag, message)


def simulate_chain_bfs(conn, parent_rule_id):
    """
    BFS => from parent_rule => if fail => skip children => returns (executed, skipped).
    We assume conflict or composite logic if needed, or we do a simpler adjacency from Part 2.
    """
    adjacency, roots, parent_map = load_rule_relationships(conn)  # from Part 2
    # gather rule SQL
    c = conn.cursor()
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE FROM BRM_RULES")
    rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_) in rows:
        rule_map[rid] = (sql_ or "", op_ or "OTHER")

    executed = []
    skipped = set()
    queue = [parent_rule_id]

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        (sql_text, op_type) = rule_map[rid]
        if op_type == "DECISION_TABLE":
            # treat as pass for chain sim
            executed.append(rid)
            if rid in adjacency:
                for ch_ in adjacency[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            (ok, msg) = dry_run_rule_sql(conn, sql_text)
            if ok:
                executed.append(rid)
                if rid in adjacency:
                    for ch_ in adjacency[rid]:
                        if ch_ not in skipped:
                            queue.append(ch_)
            else:
                skipped.add(rid)
    return (executed, skipped)


def simulate_custom_group_rules(conn, custom_group_id):
    """
    For a custom group => gather all member rules => run them individually => pass/fail => no BFS chain logic (unless wanted).
    Return (passed, failed).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rule_ids = [r[0] for r in c.fetchall()]

    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE FROM BRM_RULES")
    all_rows = c.fetchall()
    rule_map = {}
    for (rid, sql_, op_) in all_rows:
        rule_map[rid] = (sql_ or "", op_ or "OTHER")

    passed = []
    failed = []
    for rid in rule_ids:
        if rid not in rule_map:
            failed.append(rid)
            continue
        (sql_text, op_type) = rule_map[rid]
        if op_type == "DECISION_TABLE":
            # treat as pass for sim
            passed.append(rid)
        else:
            (ok, msg) = dry_run_rule_sql(conn, sql_text)
            if ok:
                passed.append(rid)
            else:
                failed.append(rid)
    return (passed, failed)


###############################################################################
# ADVANCED SCHEDULING
###############################################################################
class EnhancedScheduleDialog(QtWidgets.QDialog):
    """
    A scheduling dialog => pick rule, pick date/time => store => advanced approach
    includes optional data validations or BFS chain selection, etc.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Enhanced Scheduling – Part 3")
        self.resize(400, 300)

        layout = QVBoxLayout(self)

        form = QFormLayout()

        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        for (rid, rn) in rows:
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QtWidgets.QCalendarWidget()
        self.calendar.setSelectedDate(QtCore.QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit = QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        self.run_val_checkbox = QCheckBox("Run Data Validations Before Rule?")
        self.run_val_checkbox.setChecked(False)
        form.addRow(self.run_val_checkbox)

        layout.addLayout(form)

        bh = QHBoxLayout()
        sch_btn = QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)

        cb = QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_schedule(self):
        rid = self.rule_combo.currentData()
        date_ = self.calendar.selectedDate()
        time_ = self.time_edit.time()
        dt_str = f"{date_.toString('yyyy-MM-dd')} {time_.toString('HH:mm:ss')}"

        run_val_flag = 1 if self.run_val_checkbox.isChecked() else 0

        c = self.connection.cursor()
        c.execute("""
            INSERT INTO RULE_SCHEDULES(
              RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, RUN_DATA_VALIDATIONS
            )
            VALUES(?,?, 'Scheduled', GETDATE(), ?)
        """, (rid, dt_str, run_val_flag))
        self.connection.commit()
        QMessageBox.information(self, "Scheduled",
                                f"Rule {rid} scheduled at {dt_str}, validations={bool(run_val_flag)}.")
        self.close()


class ScheduleManagementTab(QtWidgets.QWidget):
    """
    Shows RULE_SCHEDULES => add/update/delete => includes run_data_validations column.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID", "RuleID", "ScheduleTime", "Status", "RunVal?", "Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh = QHBoxLayout()
        refb = QPushButton("Refresh")
        refb.clicked.connect(self.load_schedules)
        bh.addWidget(refb)

        addb = QPushButton("Add New Schedule")
        addb.clicked.connect(self.add_schedule)
        bh.addWidget(addb)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS
            FROM RULE_SCHEDULES
            ORDER BY SCHEDULE_TIME DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.table.rowCount()
            self.table.insertRow(r_i)
            self.table.setItem(r_i, 0, QTableWidgetItem(str(row[0])))
            self.table.setItem(r_i, 1, QTableWidgetItem(str(row[1])))
            self.table.setItem(r_i, 2, QTableWidgetItem(str(row[2])))
            self.table.setItem(r_i, 3, QTableWidgetItem(str(row[3])))
            self.table.setItem(r_i, 4, QTableWidgetItem(str(row[4])))

            wdg = QWidget()
            lay = QHBoxLayout(wdg)
            lay.setContentsMargins(0,0,0,0)
            upd_btn = QPushButton("Update")
            upd_btn.clicked.connect(lambda _, rdx=r_i: self.update_schedule(rdx))
            lay.addWidget(upd_btn)

            del_btn = QPushButton("Delete")
            del_btn.clicked.connect(lambda _, rdx=r_i: self.delete_schedule(rdx))
            lay.addWidget(del_btn)
            lay.addStretch()
            self.table.setCellWidget(r_i, 5, wdg)

        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_idx):
        it = self.table.item(row_idx, 0)
        if not it:
            return
        sch_id = int(it.text())
        newdt, ok = QInputDialog.getText(self, "Update Schedule", "New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not newdt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE RULE_SCHEDULES
                SET SCHEDULE_TIME=?
                WHERE SCHEDULE_ID=?
            """, (newdt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
        self.load_schedules()

    def delete_schedule(self, row_idx):
        it = self.table.item(row_idx, 0)
        if not it:
            return
        sch_id = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {sch_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sch_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", f"Schedule {sch_id} removed.")
        self.load_schedules()


###############################################################################
# CHAIN/GROUP SIMULATION DIALOGS (BFS DRY-RUN)
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    BFS => from chosen parent => pass/fail => skip children on fail => show result.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation – Part 3")
        self.resize(550, 400)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Parent Rule:"))
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid, rn) in c.fetchall():
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Run Chain BFS (Dry-run)")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)
        cl_btn = QPushButton("Close")
        cl_btn.clicked.connect(self.close)
        bh.addWidget(cl_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        rid = self.rule_combo.currentData()
        executed, skipped = simulate_chain_bfs(self.connection, rid)
        msg = (
            f"Chain BFS => start={rid}\n"
            f"Executed => {executed}\n"
            f"Skipped => {list(skipped)}\n"
        )
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Chain Sim", msg)


class GroupSimulationDialog(QDialog):
    """
    For a custom group => gather all rules => run them individually => pass/fail => show result.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation – Part 3")
        self.resize(600, 450)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        top_h.addWidget(QLabel("Select Custom Group:"))
        self.group_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for (cid, gn) in c.fetchall():
            disp = f"{cid} - {gn}"
            self.group_combo.addItem(disp, cid)
        top_h.addWidget(self.group_combo)
        layout.addLayout(top_h)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        bh = QHBoxLayout()
        run_btn = QPushButton("Run Group BFS (Individual Dry-run)")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)

    def do_sim(self):
        cg_id = self.group_combo.currentData()
        passed, failed = simulate_custom_group_rules(self.connection, cg_id)
        msg = (
            f"Group BFS => group_id={cg_id}\n"
            f"Passed => {passed}\n"
            f"Failed => {failed}\n"
        )
        self.result_text.setPlainText(msg)
        QMessageBox.information(self, "Group Sim", msg)


###############################################################################
# ADVANCED FEATURE TABS (DecisionTablesTab, ConflictPriorityManagerTab, etc.)
###############################################################################
class DecisionTablesTab(QtWidgets.QWidget):
    """
    Manage DECISION_TABLES => advanced references from Part 2 BFS if OPERATION_TYPE=DECISION_TABLE
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dt_table = QTableWidget(0, 3)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID", "Name", "Description"])
        layout.addWidget(self.dt_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn = QPushButton("Delete DT")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        run_btn = QPushButton("Run DT (Stub)")  # or a real run logic
        run_btn.clicked.connect(self.run_dt)
        bh.addWidget(run_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION
            FROM DECISION_TABLES
            ORDER BY DECISION_TABLE_ID
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.dt_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add DT", "Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Desc", "Optional:")
        if not ok2:
            desc = ""
        c = self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES(?,?)",
                  (name.strip(), desc.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Decision Table created.")
        self.load_dt()

    def del_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            return
        it = self.dt_table.item(row, 0)
        if not it:
            return
        dt_id = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete DT {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "DT removed.")
        self.load_dt()

    def run_dt(self):
        row = self.dt_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No DT selected.")
            return
        it = self.dt_table.item(row, 0)
        dt_id = int(it.text())
        QMessageBox.information(self, "Stub", f"Running DT => pass/fail depends on custom logic. ID={dt_id}")


class ConflictPriorityManagerTab(QtWidgets.QWidget):
    """
    Manage RULE_CONFLICTS => BFS in Part 2 uses them => advanced skip logic if higher-priority rule fails, etc.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.cf_table = QTableWidget(0, 4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID", "Rule1", "Rule2", "Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh = QHBoxLayout()
        addb = QPushButton("Add Conflict")
        addb.clicked.connect(self.add_conflict)
        bh.addWidget(addb)

        setp_btn = QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)

        delb = QPushButton("Delete Conflict")
        delb.clicked.connect(self.del_conflict)
        bh.addWidget(delb)

        refb = QPushButton("Refresh")
        refb.clicked.connect(self.load_conflicts)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY
            FROM RULE_CONFLICTS
            ORDER BY CONFLICT_ID
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.cf_table.rowCount()
            self.cf_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.cf_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def add_conflict(self):
        r1, ok = QInputDialog.getInt(self, "Add Conflict", "RuleID1:")
        if not ok:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "RuleID2:")
        if not ok2:
            return
        pri, ok3 = QInputDialog.getInt(self, "Priority", "int priority:")
        if not ok3:
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)", (r1, r2, pri))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        row = self.cf_table.currentRow()
        if row < 0:
            return
        cfid_item = self.cf_table.item(row, 0)
        if not cfid_item:
            return
        cf_id = int(cfid_item.text())
        newp, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c = self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (newp, cf_id))
        self.connection.commit()
        QMessageBox.information(self, "Updated", "Conflict priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        row = self.cf_table.currentRow()
        if row < 0:
            return
        cfid_item = self.cf_table.item(row, 0)
        if not cfid_item:
            return
        cf_id = int(cfid_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Conflict removed.")
        self.load_conflicts()


class CompositeRulesTab(QtWidgets.QWidget):
    """
    Manage COMPOSITE_RULES => BFS in Part 2 references them => adjacency skipping if subrule fails.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection

        layout = QVBoxLayout(self)
        self.cr_table = QTableWidget(0, 4)
        self.cr_table.setHorizontalHeaderLabels(["CompRuleID", "Name", "Expr", "ActionOnPass"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh = QHBoxLayout()
        addb = QPushButton("Add Composite")
        addb.clicked.connect(self.add_comp)
        bh.addWidget(addb)

        delb = QPushButton("Delete Composite")
        delb.clicked.connect(self.del_comp)
        bh.addWidget(delb)

        refb = QPushButton("Refresh")
        refb.clicked.connect(self.load_composites)
        bh.addWidget(refb)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.cr_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
            FROM COMPOSITE_RULES
            ORDER BY COMPOSITE_RULE_ID
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.cr_table.rowCount()
            self.cr_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.cr_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def add_comp(self):
        nm, ok = QInputDialog.getText(self, "New Composite", "Name:")
        if not ok or not nm.strip():
            return
        expr, ok2 = QInputDialog.getText(self, "LogicExpr",
                                         "(e.g. 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr = ""
        act, ok3 = QInputDialog.getText(self, "ActionOnPass", "(Optional) e.g. 'SendEmail'")
        if not ok3:
            act = ""
        c = self.connection.cursor()
        c.execute("""
            INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
            VALUES(?,?,?)
        """, (nm.strip(), expr.strip(), act.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Created", "Composite rule created.")
        self.load_composites()

    def del_comp(self):
        row = self.cr_table.currentRow()
        if row < 0:
            return
        it = self.cr_table.item(row, 0)
        cid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete composite rule {cid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (cid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Composite rule removed.")
        self.load_composites()


class SnapshotManagerTab(QtWidgets.QWidget):
    """
    Snapshots => store entire BRM_RULES as JSON => can do rollbacks or referencing.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID", "Name", "CreatedBy", "CreatedTS", "JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)

        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snapshot)
        bh.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP, SNAPSHOT_JSON
            FROM RULE_SNAPSHOTS
            ORDER BY SNAPSHOT_ID DESC
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.ss_table.rowCount()
            self.ss_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.ss_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def take_snapshot(self):
        nm, ok = QInputDialog.getText(self, "Snapshot", "Snapshot name:")
        if not ok or not nm.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows = c.fetchall()
        colnames = [desc[0] for desc in c.description]
        arr = []
        for r_ in rows:
            arr.append(dict(zip(colnames, r_)))
        snap_json = json.dumps(arr, indent=2)
        c.execute("""
            INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
            VALUES(?,?,?)
        """, (nm.strip(), "SnapshotUser", snap_json))
        self.connection.commit()
        QMessageBox.information(self, "Snapshot", "Snapshot created.")
        self.load_snapshots()

    def del_snapshot(self):
        row = self.ss_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No snapshot selected.")
            return
        it = self.ss_table.item(row, 0)
        sid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {sid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (sid,))
        self.connection.commit()
        QMessageBox.information(self, "Deleted", "Snapshot removed.")
        self.load_snapshots()


class TagsManagerTab(QtWidgets.QWidget):
    """
    Manage RULE_TAGS => link textual tags to rules
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tags_table = QTableWidget(0, 3)
        self.tags_table.setHorizontalHeaderLabels(["TagID", "RuleID", "TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)

        rm_btn = QPushButton("Remove Tag")
        rm_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rm_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT TAG_ID, RULE_ID, TAG_NAME
            FROM RULE_TAGS
            ORDER BY TAG_ID DESC
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.tags_table.rowCount()
            self.tags_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.tags_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def add_tag(self):
        rid, ok = QInputDialog.getInt(self, "Add Tag", "RuleID:")
        if not ok:
            return
        tg, ok2 = QInputDialog.getText(self, "Tag", "Name:")
        if not ok2 or not tg.strip():
            return
        c = self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?,?)", (rid, tg.strip()))
        self.connection.commit()
        QMessageBox.information(self, "Added", "Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No tag selected.")
            return
        it = self.tags_table.item(row, 0)
        if not it:
            return
        tg_id = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tg_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tg_id,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Tag removed.")
        self.load_tags()


class DataValidationTab(QtWidgets.QWidget):
    """
    Manage DATA_VALIDATIONS => plus a 'Run All Validations' => display pass/fail or last result
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dv_table = QTableWidget(0, 6)
        self.dv_table.setHorizontalHeaderLabels([
            "ValID","TableName","ColumnName","ValType","Params","LastResult"
        ])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh = QHBoxLayout()
        addb = QPushButton("Add Validation")
        addb.clicked.connect(self.add_validation)
        bh.addWidget(addb)

        delb = QPushButton("Remove Validation")
        delb.clicked.connect(self.remove_validation)
        bh.addWidget(delb)

        runb = QPushButton("Run All Validations")
        runb.clicked.connect(self.run_all_validations)
        bh.addWidget(runb)

        refb = QPushButton("Refresh")
        refb.clicked.connect(self.load_validations)
        bh.addWidget(refb)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT V.VALIDATION_ID, V.TABLE_NAME, V.COLUMN_NAME, V.VALIDATION_TYPE,
                   V.PARAMS,
                   (SELECT TOP 1 MESSAGE FROM DATA_VALIDATION_RESULTS R
                    WHERE R.VALIDATION_ID=V.VALIDATION_ID
                    ORDER BY R.RUN_TIMESTAMP DESC
                   ) AS LAST_RESULT
            FROM DATA_VALIDATIONS V
            ORDER BY V.VALIDATION_ID
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.dv_table.rowCount()
            self.dv_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.dv_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))

    def add_validation(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Table name (e.g. dbo.Customers):")
        if not ok or not tbl.strip():
            return
        col, ok2 = QInputDialog.getText(self, "Column", "Column name:")
        if not ok2 or not col.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "(e.g. 'NOT NULL','RANGE'):")
        if not ok3 or not vtype.strip():
            return
        pars, ok4 = QInputDialog.getText(self, "Params", "(Optional) param string => e.g. 'min=0;max=100'")
        if not ok4:
            pars = ""
        c = self.connection.cursor()
        c.execute("""
            INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS)
            VALUES(?,?,?,?)
        """, (tbl.strip(), col.strip(), vtype.strip(), pars.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Data validation added.")
        self.load_validations()

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        it = self.dv_table.item(row, 0)
        if not it:
            return
        vid = int(it.text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation ID={vid}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
        self.connection.commit()
        QMessageBox.information(self, "Removed", "Validation removed.")
        self.load_validations()

    def run_all_validations(self):
        from_part = run_data_validations  # referencing function from Part 2 or separate
        from_part(self.connection)
        QMessageBox.information(self,"Validation Run","All validations have been executed. Check results.")
        self.load_validations()


class WhatIfTestTab(QtWidgets.QWidget):
    """
    Let user pick a rule => optionally upload CSV => then do a BFS dry-run or single rule test => show pass/fail.
    Could incorporate partial data validations if desired.
    """

    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.csv_path = None

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.rule_combo = QComboBox()
        c = connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rr = c.fetchall()
        for (rid, rn) in rr:
            disp = f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        up_btn = QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(up_btn)

        run_btn = QPushButton("Run Dry-Run")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Pick CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        self.csv_path = path
        QMessageBox.information(self, "Uploaded", 
                                f"CSV {path} selected.\nYou can process it in the rule logic if needed.")

    def run_test(self):
        rid = self.rule_combo.currentData()
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL, OPERATION_TYPE FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            self.result_text.setPlainText("Rule not found.")
            return
        (sql_text, op_type) = row
        if op_type == "DECISION_TABLE":
            self.result_text.setPlainText(f"Rule {rid} => DECISION_TABLE => PASS")
            return
        (ok, msg) = dry_run_rule_sql(self.connection, sql_text or "")
        self.result_text.setPlainText(f"Rule {rid} => {'PASS' if ok else 'FAIL'} => {msg}")

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
BRM TOOL – PART 4 of 8 (FINAL, REVISED + FULLY ENHANCED)
Focuses on:
 • AuditLogViewer (search + CSV export)
 • RuleSearchDialog (with real-time filtering)
 • VersionHistoryDialog (with rollback including line-by-line comparison)
 • RuleDashboard (pagination, status filter, advanced search)
 • RuleEditorDialog (add/update rules + encryption lock/unlock + real-time validation)
 • Integration with multi-level approvals from Part 2 and data validations from Part 3

All imports assumed in prior parts (1–3). This code references:
  - BFS adjacency for advanced usage
  - LockManager for rule locking
  - parse_sql_dependencies, etc., if needed
  - run_data_validations, if we want partial checks.
"""

import sys
import json
import csv
import math
import difflib
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QTableWidget, QTableWidgetItem, QLineEdit, QMessageBox,
    QFileDialog, QPlainTextEdit, QInputDialog, QComboBox, QCheckBox,
    QTextEdit, QDateTimeEdit, QFormLayout, QGroupBox
)
from PyQt5.QtCore import Qt, QDateTime, QTimer
from PyQt5.QtGui import QColor

# from brm_core_foundation import (
#     logger, fetch_all_dict, fetch_one_dict, insert_audit_log
# )
# from brm_rule_engine (Part 2) => advanced BFS, approvals, etc.
# from brm_data_validations (Part 3) => run_data_validations if desired
# from brm_core_foundation import LockManager  # For rule lock/unlock

###############################################################################
# AUDIT LOG VIEWER
###############################################################################
class AuditLogViewer(QDialog):
    """
    Displays BRM_AUDIT_LOG with optional text filter on action, table, actor,
    plus CSV export. 
    Typically shows top 1000 or so, with a basic search bar.
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs – Part 4")
        self.resize(900,600)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search action, table, or actor..")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.log_table = QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        bh = QHBoxLayout()
        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)

        csv_btn = QPushButton("Export to CSV")
        csv_btn.clicked.connect(self.export_csv)
        bh.addWidget(csv_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)

        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("""
            SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            FROM BRM_AUDIT_LOG
            ORDER BY ACTION_TIMESTAMP DESC
            OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows = c.fetchall()
        for row in rows:
            r_i = self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            for col_i in range(8):
                val = row[col_i]
                if col_i in (5,6) and val:  # old_data, new_data
                    try:
                        dd = json.loads(val)
                        val = json.dumps(dd, indent=2)
                    except:
                        pass
                item_text = str(val) if val else ""
                self.log_table.setItem(r_i, col_i, QTableWidgetItem(item_text))

    def perform_search(self, text):
        tlow = text.lower()
        for row_i in range(self.log_table.rowCount()):
            row_visible = False
            # check columns 1=Action, 2=Table, 4=ActionBy
            for col_i in (1,2,4):
                it = self.log_table.item(row_i, col_i)
                if it and tlow in it.text().lower():
                    row_visible = True
                    break
            self.log_table.setRowHidden(row_i, not row_visible)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            headers = [self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for r_i in range(self.log_table.rowCount()):
                if self.log_table.isRowHidden(r_i):
                    continue
                rowdata = []
                for c_i in range(self.log_table.columnCount()):
                    it = self.log_table.item(r_i, c_i)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self, "Exported", f"Audit logs exported to {path}.")


###############################################################################
# RULE SEARCH DIALOG
###############################################################################
class RuleSearchDialog(QDialog):
    """
    Simple search by name or snippet => top 1000 => shows in table => no direct actions
    beyond viewing. 
    """

    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules – Part 4")
        self.resize(800,500)

        layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter rule name or SQL snippet..")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["RuleID","RuleName","RULE_SQL","STATUS","VERSION","CREATED_BY"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.res_table)

        refb = QPushButton("Refresh")
        refb.clicked.connect(self.load_results)
        layout.addWidget(refb)

        self.setLayout(layout)
        self.load_results()

    def load_results(self):
        txt = self.search_edit.text().strip()
        c = self.connection.cursor()
        if txt:
            c.execute("""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """, (f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
                SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
                OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
            """)
        rows = c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r_i = self.res_table.rowCount()
            self.res_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.res_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))


###############################################################################
# VERSION HISTORY + DIFF
###############################################################################
class VersionHistoryDialog(QDialog):
    """
    Show audit log for a single rule => can rollback to old_data.
    Includes a line-by-line diff button.
    """

    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4)")
        self.resize(900,500)

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels(["AuditID","Action","Timestamp","OldData","NewData","Diff"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh = QHBoxLayout()
        rb_btn = QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.do_rollback)
        bh.addWidget(rb_btn)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)

        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_history()

    def load_history(self):
        c = self.connection.cursor()
        c.execute("""
            SELECT AUDIT_ID, ACTION, ACTION_TIMESTAMP, OLD_DATA, NEW_DATA
            FROM BRM_AUDIT_LOG
            WHERE TABLE_NAME='BRM_RULES'
              AND RECORD_ID=?
              AND ACTION IN ('INSERT','UPDATE')
            ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows = c.fetchall()
        self.table.setRowCount(0)

        for row in rows:
            r_ = self.table.rowCount()
            self.table.insertRow(r_)

            # columns => 0=ID,1=Action,2=Time,3=OldData,4=NewData,5=Diff button
            self.table.setItem(r_, 0, QTableWidgetItem(str(row[0])))
            self.table.setItem(r_, 1, QTableWidgetItem(str(row[1])))
            self.table.setItem(r_, 2, QTableWidgetItem(str(row[2])))

            old_str = ""
            if row[3]:
                try:
                    d_ = json.loads(row[3])
                    old_str = json.dumps(d_, indent=2)
                except:
                    old_str = str(row[3])
            self.table.setItem(r_, 3, QTableWidgetItem(old_str))

            new_str = ""
            if row[4]:
                try:
                    d2 = json.loads(row[4])
                    new_str = json.dumps(d2, indent=2)
                except:
                    new_str = str(row[4])
            self.table.setItem(r_, 4, QTableWidgetItem(new_str))

            diff_btn = QPushButton("Show Diff")
            diff_btn.clicked.connect(lambda _, idx=r_: self.show_diff(idx))
            self.table.setCellWidget(r_, 5, diff_btn)

    def show_diff(self, row_idx):
        old_data_item = self.table.item(row_idx, 3)
        new_data_item = self.table.item(row_idx, 4)
        if not old_data_item or not new_data_item:
            QMessageBox.warning(self, "No Data", "Cannot diff empty data.")
            return
        old_lines = old_data_item.text().splitlines()
        new_lines = new_data_item.text().splitlines()
        diff = difflib.unified_diff(old_lines, new_lines, fromfile="old", tofile="new", lineterm="")
        diff_text = "\n".join(list(diff))
        diff_dialog = QDialog(self)
        diff_dialog.setWindowTitle("Line-by-Line Diff")
        diff_dialog.resize(800,600)
        lay = QVBoxLayout(diff_dialog)
        txt = QPlainTextEdit()
        txt.setReadOnly(True)
        txt.setPlainText(diff_text if diff_text.strip() else "No differences.")
        lay.addWidget(txt)
        cb = QPushButton("Close")
        cb.clicked.connect(diff_dialog.close)
        lay.addWidget(cb)
        diff_dialog.exec_()

    def do_rollback(self):
        sel = self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self, "None", "No row selected.")
            return
        row_i = sel[0].row()
        old_data_item = self.table.item(row_i, 3)
        if not old_data_item:
            QMessageBox.warning(self, "No Data", "No old_data found.")
            return
        old_data_str = old_data_item.text().strip()
        if not old_data_str:
            QMessageBox.warning(self, "Empty", "Empty old_data => cannot rollback.")
            return
        confirm = QMessageBox.question(self, "Confirm","Rollback to this version?")
        if confirm != QMessageBox.Yes:
            return
        try:
            old_data = json.loads(old_data_str)
        except Exception as ex:
            QMessageBox.critical(self, "JSON Error", str(ex))
            return
        self.apply_rollback(old_data)
        QMessageBox.information(self, "Rolled Back","Version rollback done. You might need to refresh.")
        self.load_history()

    def apply_rollback(self, old_data):
        """
        Minimal approach => forcibly sets rule fields => sets status=INACTIVE => re-approval => re-parse dependencies.
        """
        rid = old_data["RULE_ID"]
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")

        new_sql = old_data.get("RULE_SQL","")

        c.execute("BEGIN TRANSACTION")
        c.execute("""
            UPDATE BRM_RULES
            SET RULE_NAME=?,
                RULE_SQL=?,
                OWNER_GROUP=?,
                STATUS='INACTIVE',
                VERSION=VERSION+1,
                UPDATED_BY='Rollback',
                APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
            WHERE RULE_ID=?
        """, (
            old_data["RULE_NAME"],
            new_sql,
            old_data["OWNER_GROUP"],
            rid
        ))

        # re-parse dependencies
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rid,))
        from_part = parse_sql_dependencies  # from Part 1
        parse_info = from_part(new_sql)
        col_op = "READ"
        op_type = detect_operation_type(new_sql)  # from Part 1
        if op_type in ("INSERT","UPDATE","DELETE"):
            col_op = "WRITE"

        for (sch, tb, alias, is_sub) in parse_info["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                    INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                      RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                    )
                    VALUES(?,?,?,?,?)
                """, (rid, sch if sch else "N/A", tb, "RolledBackCol", col_op))

        c.execute("COMMIT")


###############################################################################
# RULE DASHBOARD
###############################################################################
class RuleDashboard(QGroupBox):
    """
    Paginated, filterable table of rules => multi-select => advanced CR operations 
    triggered externally (Add/Update/Deactivate). 
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL..")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table = QTableWidget(0, 9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","OwnerGroup",
            "CreatedTS","ApprovalStatus","Encrypted?"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_clause(self):
        filters = []
        params = []
        txt = self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        if filters:
            clause = " AND ".join(filters)
        else:
            clause = "1=1"
        return (clause, params)

    def load_rules(self):
        c = self.connection.cursor()
        clause, pars = self.build_filter_clause()

        # count
        ct_q = f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(ct_q, pars)
        rowct = c.fetchone()
        total = rowct[0] if rowct else 0
        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        if self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset = (self.current_page - 1)*self.records_per_page
        data_q = f"""
        SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP,
               CREATED_TIMESTAMP, APPROVAL_STATUS, ENCRYPTED_FLAG
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(data_q, (*pars, offset, self.records_per_page))
        rows = c.fetchall()

        self.rule_table.setRowCount(0)
        for row in rows:
            r_i = self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i, val in enumerate(row):
                it = QTableWidgetItem(str(val) if val else "")
                # color for status
                if col_i == 3:
                    if val and str(val).upper() == "ACTIVE":
                        it.setBackground(QColor(144,238,144)) # lightgreen
                    else:
                        it.setBackground(QColor(255,182,193)) # lightpink
                self.rule_table.setItem(r_i, col_i, it)

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row, 0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id = None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        out = []
        for i_ in idxs:
            row = i_.row()
            it = self.rule_table.item(row, 0)
            if it:
                out.append(int(it.text()))
        return out

    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()

    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()


###############################################################################
# RULE EDITOR + Encryption Lock
###############################################################################
class RuleEditorDialog(QDialog):
    """
    Add or Update a rule => merges references to Part 2’s multi-level approvals => 
    includes encryption lock/unlock for the SQL field (just a stub).
    Real-time validation can also be done (placeholder).
    """

    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.rule_data = rule_data
        self.is_update = (rule_data is not None)

        title = "Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title+" – Part 4")
        self.resize(800,600)

        main_layout = QVBoxLayout(self)
        form_l = QFormLayout()

        # group
        self.grp_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        gr = c.fetchall()
        for (gid, gname) in gr:
            disp = f"{gname} (ID={gid})"
            self.grp_combo.addItem(disp, gid)
        form_l.addRow("Group:", self.grp_combo)

        # parent
        self.parent_combo = QComboBox()
        self.parent_combo.addItem("(No Parent)", None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        pr = c.fetchall()
        for (rid,rn) in pr:
            disp2 = f"{rn} (ID={rid})"
            self.parent_combo.addItem(disp2, rid)
        form_l.addRow("Parent Rule:", self.parent_combo)

        self.name_edit = QLineEdit()
        form_l.addRow("Rule Name:", self.name_edit)

        # rule type
        self.type_combo = QComboBox()
        c.execute("SELECT RULE_TYPE_ID, RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        trows = c.fetchall()
        for (tid, tnm) in trows:
            self.type_combo.addItem(tnm,tid)
        form_l.addRow("Rule Type:", self.type_combo)

        # status
        self.status_combo = QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_l.addRow("Status:", self.status_combo)

        # dates
        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_l.addRow("Effective Start:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_l.addRow("Effective End:", self.end_dt)

        # cdc
        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_l.addRow("CDC Type:", self.cdc_combo)

        # encryption lock
        self.encrypted_check = QCheckBox("Encrypt SQL?")
        form_l.addRow(self.encrypted_check)

        # sql
        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, 0 => FAIL.")
        self.sql_edit.textChanged.connect(self.live_validate_sql)
        form_l.addRow("Rule SQL:", self.sql_edit)

        # desc + justification
        self.desc_edit = QTextEdit()
        form_l.addRow("Description:", self.desc_edit)

        self.just_edit = QTextEdit()
        form_l.addRow("Justification:", self.just_edit)

        # global/critical
        self.global_cb = None
        if self.user_group == "Admin":
            self.global_cb = QCheckBox("Global")
            form_l.addRow("Global (Admin Only):", self.global_cb)

        self.crit_cb = QCheckBox()
        form_l.addRow("Critical Rule:", self.crit_cb)

        self.crit_scope_combo = QComboBox()
        self.crit_scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_l.addRow("Critical Scope:", self.crit_scope_combo)

        main_layout.addLayout(form_l)

        bh = QHBoxLayout()
        self.save_btn = QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.save_rule)
        bh.addWidget(self.save_btn)

        cb = QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(cb)
        main_layout.addLayout(bh)
        self.setLayout(main_layout)

        if self.is_update and self.rule_data:
            self.load_existing()

    def load_existing(self):
        rd = self.rule_data
        # group
        gid = rd.get("GROUP_ID")
        if gid:
            ix = self.grp_combo.findData(gid)
            if ix>=0:
                self.grp_combo.setCurrentIndex(ix)
        # parent
        pid = rd.get("PARENT_RULE_ID")
        if pid:
            ix2 = self.parent_combo.findData(pid)
            if ix2>=0:
                self.parent_combo.setCurrentIndex(ix2)
        self.name_edit.setText(rd.get("RULE_NAME",""))
        # type
        rtid = rd.get("RULE_TYPE_ID")
        if rtid:
            ix3 = self.type_combo.findData(rtid)
            if ix3>=0:
                self.type_combo.setCurrentIndex(ix3)
        # status
        st = rd.get("STATUS","INACTIVE")
        i_s = self.status_combo.findText(st)
        if i_s>=0:
            self.status_combo.setCurrentIndex(i_s)
        # dates
        fmt = "%Y-%m-%d %H:%M:%S"
        sd = rd.get("EFFECTIVE_START_DATE")
        if sd:
            try:
                from datetime import datetime
                dt_ = datetime.strptime(sd, fmt)
                self.start_dt.setDateTime(dt_)
            except:
                pass
        ed = rd.get("EFFECTIVE_END_DATE")
        if ed:
            try:
                dt2_ = datetime.strptime(ed, fmt)
                self.end_dt.setDateTime(dt2_)
            except:
                pass
        # cdc
        cdcv = rd.get("CDC_TYPE","NONE").upper()
        ix4 = self.cdc_combo.findText(cdcv)
        if ix4>=0:
            self.cdc_combo.setCurrentIndex(ix4)

        # encrypted
        enc_f = rd.get("ENCRYPTED_FLAG",0)
        self.encrypted_check.setChecked(bool(enc_f))

        # sql
        self.sql_edit.setPlainText(rd.get("RULE_SQL",""))
        # desc
        self.desc_edit.setText(rd.get("DESCRIPTION",""))
        # justification
        self.just_edit.setText(rd.get("BUSINESS_JUSTIFICATION",""))
        # global
        if self.user_group=="Admin" and self.global_cb:
            if rd.get("IS_GLOBAL",0)==1:
                self.global_cb.setChecked(True)
        # critical
        if rd.get("CRITICAL_RULE",0)==1:
            self.crit_cb.setChecked(True)
        # scope
        scp = rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp = self.crit_scope_combo.findText(scp)
        if i_scp>=0:
            self.crit_scope_combo.setCurrentIndex(i_scp)

    def live_validate_sql(self):
        # stub => advanced parse or partial check => highlight errors
        pass

    def save_rule(self):
        nm = self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self, "Error", "Rule name is required.")
            return
        sql_ = self.sql_edit.toPlainText().strip()

        grp_id = self.grp_combo.currentData()
        par_id = self.parent_combo.currentData()
        rt_id = self.type_combo.currentData()
        st = self.status_combo.currentText()
        sdt_str = self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        edt_str = self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        cdcv = self.cdc_combo.currentText().upper()

        desc_ = self.desc_edit.toPlainText().strip()
        just_ = self.just_edit.toPlainText().strip()

        is_g = 0
        if self.user_group=="Admin" and self.global_cb:
            if self.global_cb.isChecked():
                is_g = 1
        is_c = 1 if self.crit_cb.isChecked() else 0
        scp = self.crit_scope_combo.currentText().upper()

        enc_flag = 1 if self.encrypted_check.isChecked() else 0

        # find group name from GROUP_ID
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?", (grp_id,))
        rg = c.fetchone()
        if rg:
            gname = rg[0]
        else:
            gname = "BG1"

        rule_d = {
            "GROUP_ID": grp_id,
            "PARENT_RULE_ID": par_id if par_id else None,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sdt_str,
            "EFFECTIVE_END_DATE": edt_str,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": is_g,
            "CRITICAL_RULE": is_c,
            "CRITICAL_SCOPE": scp,
            "CDC_TYPE": cdcv,
            "OWNER_GROUP": gname,
            "ENCRYPTED_FLAG": enc_flag
        }

        from_part = add_rule if not self.is_update else update_rule  # from Part 2

        if self.is_update:
            rule_d["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm","Update rule + re-approval?")
            if confirm != QMessageBox.Yes:
                return
            try:
                from_part(self.connection, rule_d, "CurrentUser", self.user_group)
                QMessageBox.information(self, "Success", "Rule updated. Approval re-started.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
        else:
            confirm = QMessageBox.question(self, "Confirm","Add new rule + approval flow?")
            if confirm != QMessageBox.Yes:
                return
            try:
                new_id = from_part(self.connection, rule_d, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Created",f"Rule created (ID={new_id}). Approval started.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self, "Error", str(ex))
            
      

