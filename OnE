
import os
import sys
import json
import logging
import logging.config
import smtplib
import pyodbc
import sqlparse
import re
import hashlib
from datetime import datetime, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5 imports
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout,
    QMessageBox, QComboBox, QPlainTextEdit, QCalendarWidget, QTimeEdit,
    QFormLayout, QWidget, QCheckBox , QInputDialog , QGraphicsRectItem
)


import sys
import json
import logging
import re
import math
import pyodbc
import time
from datetime import datetime, timedelta
from collections import deque

# PyQt5
from PyQt5.QtCore import (
    Qt, QTimer, QAbstractTableModel, QModelIndex
)
from PyQt5.QtGui import (
    QFont, QBrush, QColor, QPen, QPainter
)
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QDialog, QComboBox, QPlainTextEdit, QMessageBox,
    QLineEdit, QCheckBox, QCalendarWidget, QTimeEdit, QTableView, QFormLayout,
    QGroupBox, QListWidget, QListWidgetItem, QMenu, QTreeWidget, QTreeWidgetItem,
    QFileDialog, QInputDialog, QGraphicsView, QGraphicsScene, QGraphicsItem,
    QGraphicsTextItem, QGraphicsEllipseItem, QGraphicsLineItem, QFrame
)


###############################################################################
# Helpers from your "core" module or replicate them here:
###############################################################################

def fetch_all_dict(cursor):
    """Fetch all rows as list of dicts, if columns exist."""
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        result = []
        for r_ in rows:
            result.append(dict(zip(colnames, r_)))
        return result
    else:
        return rows

def fetch_one_dict(cursor):
    """Fetch one row as dict, or None if no row or no desc."""
    row = cursor.fetchone()
    if row and cursor.description:
        colnames = [d[0] for d in cursor.description]
        return dict(zip(colnames, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """Insert into BRM_AUDIT_LOG or similar."""
    try:
        c=conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """,(
            action, table_name, str(record_id), actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
    except Exception as ex:
        logging.error(f"Audit log insert failed: {ex}")

def rule_current_lock_owner(conn, rule_id):
    """
    Check BRM_RULE_LOCKS for active lock. Return (locked_by, lock_ts, expiry_ts, force_bit).
    If not locked or expired => return None.
    """
    c=conn.cursor()
    c.execute("""
        SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
        FROM BRM_RULE_LOCKS
        WHERE RULE_ID=? AND ACTIVE_LOCK=1
    """,(rule_id,))
    row=c.fetchone()
    if not row:
        return None
    locked_by, lts, ets, fflag, active_l = row
    if not active_l:
        return None
    now=datetime.now()
    if ets and now>ets:
        # expired => free it
        c2=conn.cursor()
        c2.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        conn.commit()
        return None
    return (locked_by, lts, ets, fflag)

def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
    """
    Attempt to lock rule => create or refresh.
    """
    info = rule_current_lock_owner(conn, rule_id)
    now = datetime.now()
    expiry = now + timedelta(minutes=lock_minutes)
    c = conn.cursor()

    if info:
        locked_by, _, _, fflag = info
        if locked_by==user_id:
            # refresh
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """,(now, expiry, 1 if force else 0, rule_id))
            conn.commit()
            return
        else:
            if not force:
                raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
            else:
                # forcibly override
                c.execute("UPDATE BRM_RULE_LOCKS SET ACTIVE_LOCK=0 WHERE RULE_ID=? AND ACTIVE_LOCK=1",(rule_id,))
                c.execute("""
                    INSERT INTO BRM_RULE_LOCKS(
                        RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                        FORCE_LOCK, ACTIVE_LOCK
                    ) VALUES(?,?,?,?,?,1)
                """,(rule_id, user_id, now, expiry, 1 if force else 0))
                conn.commit()
                return
    else:
        # create new
        c.execute("""
            INSERT INTO BRM_RULE_LOCKS(
                RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                FORCE_LOCK, ACTIVE_LOCK
            ) VALUES(?,?,?,?,?,1)
        """,(rule_id, user_id, now, expiry, 1 if force else 0))
        conn.commit()

def unlock_rule_for_edit(conn, rule_id, user_id=None, force=False):
    """
    Unlock => if user_id matches locked_by or if force => set ACTIVE_LOCK=0
    """
    info = rule_current_lock_owner(conn, rule_id)
    if not info:
        return
    (locked_by, lts, ets, fflag) = info
    if not force and user_id and locked_by!=user_id:
        raise ValueError(f"Rule {rule_id} locked by {locked_by}, cannot unlock.")
    c=conn.cursor()
    c.execute("""
        UPDATE BRM_RULE_LOCKS
        SET ACTIVE_LOCK=0
        WHERE RULE_ID=? AND ACTIVE_LOCK=1
    """,(rule_id,))
    conn.commit()


###############################################################################
# 1) run_data_validations_for_table
###############################################################################
def run_data_validations_for_table(conn, table_name):
    """
    Load validations for table_name from DATA_VALIDATIONS => run them =>
    return True if all pass, or False if any fail. Also log in DATA_VALIDATION_LOGS.
    """
    c=conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID, VALIDATION_TYPE, PARAMS, COLUMN_NAME
        FROM DATA_VALIDATIONS
        WHERE LOWER(TABLE_NAME)=LOWER(?)
    """,(table_name,))
    rows=c.fetchall()
    all_pass=True
    for row in rows:
        vid, vtype, params, col = row
        ok, details = _run_single_validation(conn, table_name, col, vtype, params, vid)
        if not ok:
            all_pass=False
    return all_pass

def _run_single_validation(conn, tab, col, vtype, params, val_id):
    c=conn.cursor()
    pass_flag=True
    details=""
    try:
        if vtype.upper()=="NOT NULL":
            qry=f"SELECT COUNT(*) FROM {tab} WHERE {col} IS NULL"
            c.execute(qry)
            n=c.fetchone()[0]
            if n>0:
                pass_flag=False
                details=f"{n} NULL values found."
        elif vtype.upper()=="RANGE":
            parts=(params or "").split(",")
            if len(parts)!=2:
                pass_flag=False
                details="Invalid range params."
            else:
                try:
                    mn=float(parts[0])
                    mx=float(parts[1])
                    qry=f"SELECT COUNT(*) FROM {tab} WHERE {col}<{mn} OR {col}>{mx}"
                    c.execute(qry)
                    out_of_range=c.fetchone()[0]
                    if out_of_range>0:
                        pass_flag=False
                        details=f"{out_of_range} row(s) out of [{mn},{mx}]"
                except:
                    pass_flag=False
                    details="Parsing range params failed."
        elif vtype.upper()=="REGEX":
            # naive approach => fetch all
            pat=params or ".*"
            c.execute(f"SELECT {col} FROM {tab}")
            mismatch=0
            pattern=re.compile(pat)
            for (val,) in c.fetchall():
                sval=str(val) if val is not None else ""
                if not pattern.match(sval):
                    mismatch+=1
            if mismatch>0:
                pass_flag=False
                details=f"{mismatch} row(s) not matching regex {pat}"
        else:
            pass_flag=False
            details=f"Unknown validation type {vtype}"
    except Exception as ex:
        pass_flag=False
        details=str(ex)

    res_flag = "PASS" if pass_flag else "FAIL"
    # log
    c2=conn.cursor()
    c2.execute("""
        INSERT INTO DATA_VALIDATION_LOGS(
            VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP,
            TABLE_NAME, COLUMN_NAME
        )
        VALUES(?,?,?,?,?,?)
    """,(val_id, res_flag, details, datetime.now(), tab, col))
    conn.commit()
    return (pass_flag, details)


###############################################################################
# 2) DashboardCardsTab
###############################################################################
class DashboardCardsTab(QWidget):
    """
    Shows card-style metrics:
      - Active rules
      - Approvals pending
      - Open defects
      - Critical rules
      - Next 24h schedules
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout=QVBoxLayout(self)
        top_lbl=QLabel("Dashboard (Cards)")
        top_lbl.setStyleSheet("font-size:16pt; font-weight:bold;")
        layout.addWidget(top_lbl)

        self.cards_layout=QHBoxLayout()
        layout.addLayout(self.cards_layout)

        # create 5 cards
        self.card_active = _DashboardCard("Active Rules")
        self.card_approvals = _DashboardCard("Approvals Pending")
        self.card_defects = _DashboardCard("Open Defects")
        self.card_critical = _DashboardCard("Critical Rules")
        self.card_schedules = _DashboardCard("Schedules <24h")

        self.cards_layout.addWidget(self.card_active)
        self.cards_layout.addWidget(self.card_approvals)
        self.cards_layout.addWidget(self.card_defects)
        self.cards_layout.addWidget(self.card_critical)
        self.cards_layout.addWidget(self.card_schedules)

        ref_btn=QPushButton("Refresh Dashboard")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        # 1) active
        try:
            c.execute("SELECT COUNT(*) FROM BRM_RULES WHERE STATUS='ACTIVE'")
            val=c.fetchone()[0]
            self.card_active.set_count(val)
        except:
            self.card_active.set_count("N/A")

        # 2) approvals => distinct rule_ids pending
        try:
            c.execute("""
                SELECT COUNT(DISTINCT RULE_ID)
                FROM BRM_RULE_APPROVALS
                WHERE APPROVED_FLAG=0
            """)
            val=c.fetchone()[0]
            self.card_approvals.set_count(val)
        except:
            self.card_approvals.set_count("N/A")

        # 3) open defects => status in Open or In Progress
        try:
            c.execute("""
                SELECT COUNT(*) 
                FROM BRM_DEFECT_LOGS
                WHERE STATUS IN ('Open','In Progress')
            """)
            val=c.fetchone()[0]
            self.card_defects.set_count(val)
        except:
            self.card_defects.set_count("N/A")

        # 4) critical => CRITICAL_RULE=1 or IS_GLOBAL=1
        try:
            c.execute("""
                SELECT COUNT(*)
                FROM BRM_RULES
                WHERE CRITICAL_RULE=1 OR IS_GLOBAL=1
            """)
            val=c.fetchone()[0]
            self.card_critical.set_count(val)
        except:
            self.card_critical.set_count("N/A")

        # 5) schedules <24h
        try:
            c.execute("""
                SELECT COUNT(*)
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled'
                  AND SCHEDULE_TIME>=GETDATE()
                  AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
            """)
            val=c.fetchone()[0]
            self.card_schedules.set_count(val)
        except:
            self.card_schedules.set_count("N/A")


class _DashboardCard(QFrame):
    """Helper card widget used by DashboardCardsTab."""
    def __init__(self, title, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.StyledPanel)
        self.setStyleSheet("background-color:#F0F0F0; padding:10px; border-radius:5px;")
        layout=QVBoxLayout(self)
        self.title_label=QLabel(title)
        self.title_label.setStyleSheet("font-weight:bold;")
        layout.addWidget(self.title_label)

        self.count_label=QLabel("0")
        self.count_label.setStyleSheet("font-size:24px; color:blue;")
        layout.addWidget(self.count_label)
        self.setLayout(layout)

    def set_count(self, val):
        self.count_label.setText(str(val))


###############################################################################
# 3) MultiStepApprovalTab
###############################################################################
class MultiStepApprovalTab(QWidget):
    """
    Displays pending approvals for the current user => minimal stage only.
    Allows Approve/Reject => updates BRM_RULE_APPROVALS and sets rule status.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.approval_table=QTableWidget(0,8)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","Group","RuleName","Stage","Approved?","Approve","Reject","ForceUnlock"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approval_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG,
                   A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS
            FROM BRM_RULE_APPROVALS A
            JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
            WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
            ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()

        def get_min_stage(rid_):
            c2=self.connection.cursor()
            c2.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rid_,))
            ro=c2.fetchone()
            return ro[0] if ro and ro[0] else None

        displayable=[]
        for row in rows:
            rid=row[0]
            stage=row[4]
            cur_st=get_min_stage(rid)
            if cur_st==stage:
                displayable.append(row)

        self.approval_table.setRowCount(len(displayable))
        for r_i, row_data in enumerate(displayable):
            (rule_id, grp, usern, ap_flag, ap_stage, rname, apr_stat)=row_data
            self.approval_table.setItem(r_i,0,QTableWidgetItem(str(rule_id)))
            self.approval_table.setItem(r_i,1,QTableWidgetItem(str(grp)))
            self.approval_table.setItem(r_i,2,QTableWidgetItem(str(rname)))
            self.approval_table.setItem(r_i,3,QTableWidgetItem(str(ap_stage)))
            self.approval_table.setItem(r_i,4,QTableWidgetItem(str(ap_flag)))

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, idx=r_i: self.do_approve(idx))
            self.approval_table.setCellWidget(r_i,5,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, idx=r_i: self.do_reject(idx))
            self.approval_table.setCellWidget(r_i,6,reject_btn)

            force_unlock_btn=QPushButton("ForceUnlock")
            force_unlock_btn.setEnabled(self.user_group=="Admin")
            force_unlock_btn.clicked.connect(lambda _, idx=r_i: self.do_force_unlock(idx))
            self.approval_table.setCellWidget(r_i,7,force_unlock_btn)

        self.approval_table.resizeColumnsToContents()

    def do_approve(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=grp_item.text()

        c=self.connection.cursor()
        c.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
            WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid, grp, self.logged_in_username))

        # check if all approvals done
        def get_min_stage(rr):
            c2=self.connection.cursor()
            c2.execute("""
                SELECT MIN(APPROVAL_STAGE)
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=? AND APPROVED_FLAG=0
            """,(rr,))
            row_=c2.fetchone()
            return row_[0] if row_ and row_[0] else None

        nxt=get_min_stage(rid)
        if nxt is None:
            # all approved => set rule status=ACTIVE, LIFECYCLE_STATE=ACTIVE
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE'
                WHERE RULE_ID=?
            """,(rid,))
        else:
            # still pending => remain inactive
            c.execute("""
                UPDATE BRM_RULES
                SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                WHERE RULE_ID=?
            """,(rid,))
        insert_audit_log(self.connection,"APPROVE","BRM_RULE_APPROVALS",rid,self.logged_in_username,{"approved_flag":0},{"approved_flag":1})
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} => approved at group {grp}.")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        if not rid_item or not grp_item:
            return
        rid=int(rid_item.text())
        grp=grp_item.text()
        confirm=QMessageBox.question(self,"Reject",f"Reject rule {rid} at group {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            UPDATE BRM_RULE_APPROVALS
            SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
            WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username))
        c.execute("""
            UPDATE BRM_RULES
            SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
            WHERE RULE_ID=?
        """,(rid,))
        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,None,{"rejected":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} => rejected.")
        self.load_approvals()

    def do_force_unlock(self, row_i):
        if self.user_group!="Admin":
            QMessageBox.warning(self,"Denied","Only Admin can force unlock.")
            return
        rid_item=self.approval_table.item(row_i,0)
        if not rid_item:
            return
        rid=int(rid_item.text())
        confirm=QMessageBox.question(self,"Force Unlock",f"Force unlock rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            unlock_rule_for_edit(self.connection, rid, user_id=None, force=True)
            QMessageBox.information(self,"Unlocked",f"Rule {rid} forcibly unlocked.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_approvals()


###############################################################################
# 4) GlobalCriticalAdminTab
###############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    Admin-only => set rule as global/critical => manage scope => forcibly lock/unlock => link child.
    """
    def __init__(self, main_window, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_window=main_window
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        top_h=QHBoxLayout()
        self.gcr_chk=QCheckBox("Set Global?")
        self.crit_chk=QCheckBox("Set Critical?")
        top_h.addWidget(self.gcr_chk)
        top_h.addWidget(self.crit_chk)

        top_h.addWidget(QLabel("Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        top_h.addWidget(self.scope_combo)

        apply_btn=QPushButton("Apply G/C to Selected")
        apply_btn.clicked.connect(self.apply_gc)
        top_h.addWidget(apply_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IS_GLOBAL","CRITICAL_RULE","CRITICAL_SCOPE","STATUS","LOCK_STATUS","Action"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        link_h=QHBoxLayout()
        self.parent_gcr_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.parent_gcr_combo)
        self.child_rule_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.child_rule_combo)
        link_btn=QPushButton("Link Child")
        unlink_btn=QPushButton("Unlink Child")
        link_btn.clicked.connect(self.do_link_child)
        unlink_btn.clicked.connect(self.do_unlink_child)
        link_h.addWidget(link_btn)
        link_h.addWidget(unlink_btn)
        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR","Child Rule"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.load_parent_combo()
        self.load_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,STATUS,LOCK_STATUS
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.rule_table.rowCount()
            self.rule_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val is not None else "")
                self.rule_table.setItem(r_i,col_i,it)
            act_w=QWidget()
            ah=QHBoxLayout(act_w)
            ah.setContentsMargins(0,0,0,0)
            lock_btn=QPushButton("Lock/Unlock")
            lock_btn.clicked.connect(lambda _,rid=row[0]: self.toggle_lock(rid))
            ah.addWidget(lock_btn)
            ah.addStretch()
            self.rule_table.setCellWidget(r_i,8,act_w)

    def load_parent_combo(self):
        self.parent_gcr_combo.clear()
        c=self.connection.cursor()
        c.execute("""
            SELECT RULE_ID,RULE_NAME
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID
        """)
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.parent_gcr_combo.addItem(disp,rid)

    def load_child_combo(self):
        self.child_rule_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.child_rule_combo.addItem(disp,rid)

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT GCR_RULE_ID,TARGET_RULE_ID
            FROM BRM_GLOBAL_CRITICAL_LINKS
            ORDER BY LINK_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.link_view.rowCount()
            self.link_view.insertRow(r_i)
            self.link_view.setItem(r_i,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_i,1,QTableWidgetItem(str(row[1])))

    def apply_gc(self):
        selected_ids=self.get_selected_rule_ids()
        if not selected_ids:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        isg=1 if self.gcr_chk.isChecked() else 0
        iscrit=1 if self.crit_chk.isChecked() else 0
        scope=self.scope_combo.currentText().upper()
        c=self.connection.cursor()
        for rid in selected_ids:
            c.execute("""
                UPDATE BRM_RULES
                SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
                WHERE RULE_ID=?
            """,(isg, iscrit, scope, rid))
            insert_audit_log(self.connection,"GCR_UPDATE","BRM_RULES",rid,"Admin",None,{"IS_GLOBAL":isg,"CRITICAL_RULE":iscrit,"scope":scope})
        self.connection.commit()
        QMessageBox.information(self,"Done",f"Updated {len(selected_ids)} rule(s).")
        self.load_rule_list()

    def get_selected_rule_ids(self):
        sel=self.rule_table.selectionModel().selectedRows()
        out=[]
        for ix in sel:
            row=ix.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def toggle_lock(self, rule_id):
        c=self.connection.cursor()
        # check lock status
        c.execute("SELECT LOCK_STATUS,LOCKED_BY FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
        row=c.fetchone()
        if not row:
            return
        st, lb = row
        if not st or st.upper()=="UNLOCKED":
            # lock
            # forcibly lock
            c.execute("""
                UPDATE BRM_RULES
                SET LOCK_STATUS='LOCKED', LOCKED_BY='AdminOverride', LOCKED_AT=GETDATE()
                WHERE RULE_ID=?
            """,(rule_id,))
            c.commit()
            QMessageBox.information(self,"Locked",f"Rule {rule_id} => locked by Admin.")
        else:
            # unlock
            c.execute("""
                UPDATE BRM_RULES
                SET LOCK_STATUS='UNLOCKED', LOCKED_BY=NULL, LOCKED_AT=NULL
                WHERE RULE_ID=?
            """,(rule_id,))
            c.commit()
            QMessageBox.information(self,"Unlocked",f"Rule {rule_id} => unlocked.")
        self.load_rule_list()

    def do_link_child(self):
        pid=self.parent_gcr_combo.currentData()
        cid=self.child_rule_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link child {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID)
            VALUES(?,?)
        """,(pid,cid))
        insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"parent":pid,"child":cid})
        self.connection.commit()
        self.load_link_view()

    def do_unlink_child(self):
        pid=self.parent_gcr_combo.currentData()
        cid=self.child_rule_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
            WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
        """,(pid,cid))
        insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",{"old":"linked"},None)
        self.connection.commit()
        self.load_link_view()


###############################################################################
# 5) HierarchyViewTab
###############################################################################
class HierarchyViewTab(QTreeWidget):
    """
    Group -> Rule. Drag rule => new group or new parent => update DB re-parenting.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(self.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        # load groups
        c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        groups=c.fetchall()
        group_items={}
        for (gid,gname) in groups:
            it=QTreeWidgetItem([f"{gname} (ID={gid})"])
            it.setData(0,Qt.UserRole,("group",gid))
            self.addTopLevelItem(it)
            group_items[gid]=it

        # load rules
        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        all_rules=c.fetchall()
        rule_map={}
        # place top-level
        for (rid,rn,gid,pid) in all_rules:
            if not pid:
                if gid in group_items:
                    child=QTreeWidgetItem([f"Rule {rid}: {rn}"])
                    child.setData(0,Qt.UserRole,("rule",rid))
                    group_items[gid].addChild(child)
                    rule_map[rid]=child

        # second pass => nest children
        for (rid,rn,gid,pid) in all_rules:
            if pid and pid in rule_map:
                parent_it=rule_map[pid]
                child=QTreeWidgetItem([f"Rule {rid}: {rn}"])
                child.setData(0,Qt.UserRole,("rule",rid))
                parent_it.addChild(child)
                rule_map[rid]=child

        self.expandAll()

    def dropEvent(self, event):
        super().dropEvent(event)
        # after reorder => walk the tree => update DB
        self.update_reparenting()
        self.load_hierarchy()

    def update_reparenting(self):
        top_count=self.topLevelItemCount()
        c=self.connection.cursor()
        for i in range(top_count):
            grp_it=self.topLevelItem(i)
            self._recursive_update(grp_it, None, c)
        c.commit()

    def _recursive_update(self, parent_item, parent_rule_id, cursor):
        data_=parent_item.data(0,Qt.UserRole)
        if not data_:
            return
        if data_[0]=="group":
            grp_id=data_[1]
            for i in range(parent_item.childCount()):
                child=parent_item.child(i)
                self._recursive_update(child, None, cursor)  # top-level rules => no parent rule
        elif data_[0]=="rule":
            rid=data_[1]
            # find group => must go up chain
            grp_id=self._find_group_of_item(parent_item)
            # set PARENT_RULE_ID=? GROUP_ID=?
            cursor.execute("""
                UPDATE BRM_RULES
                SET GROUP_ID=?, PARENT_RULE_ID=?,
                    STATUS='INACTIVE', APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
                    VERSION=VERSION+1, UPDATED_BY='HierarchyDrag'
                WHERE RULE_ID=?
            """,(grp_id, parent_rule_id, rid))
            # children
            for i in range(parent_item.childCount()):
                ch=parent_item.child(i)
                self._recursive_update(ch, rid, cursor)

    def _find_group_of_item(self, item):
        if not item:
            return None
        data_=item.data(0,Qt.UserRole)
        if not data_:
            return None
        if data_[0]=="group":
            return data_[1]  # group ID
        # else go up
        p=item.parent()
        if p:
            return self._find_group_of_item(p)
        return None


###############################################################################
# 6) EnhancedLineageGraphWidget
###############################################################################
class EnhancedLineageGraphWidget(QGraphicsView):
    """
    A QGraphicsView that draws rule nodes + table nodes => arrow lines. BFS layout or simple grid.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(self.viewport().Antialiasing)
        self.node_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        # gather rules
        c=self.connection.cursor()
        c.execute("""
            SELECT RULE_ID,RULE_NAME,STATUS,IS_GLOBAL,CRITICAL_RULE
            FROM BRM_RULES
            ORDER BY RULE_ID
        """)
        rules=c.fetchall()

        xgap=220
        ygap=120
        x0=50
        y0=50
        for i, row in enumerate(rules):
            (rid,rn,st,isg,isc)=row
            node=RuleNodeItem(rid,rn,st,isg,isc)
            xx=x0+(i%5)*xgap
            yy=y0+(i//5)*ygap
            node.setPos(xx,yy)
            self.scene.addItem(node)
            self.node_map[f"RULE_{rid}"]=node

        # gather dependencies => for table nodes
        dep_cursor=self.connection.cursor()
        dep_cursor.execute("""
            SELECT RULE_ID, DATABASE_NAME, TABLE_NAME
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps=dep_cursor.fetchall()
        table_map={}
        for (rid,dbn,tbn) in deps:
            if tbn:
                key=f"{dbn}.{tbn}".lower()
                if key not in table_map:
                    table_map[key]=[]
                table_map[key].append(rid)

        # place tables on right side
        tidx=0
        for tblkey, ruleids in table_map.items():
            tnode=TableNodeItem(tblkey)
            tx=900
            ty=y0+tidx*80
            tnode.setPos(tx,ty)
            self.scene.addItem(tnode)
            self.node_map[f"TBL_{tblkey}"]=tnode
            tidx+=1

        # edges
        for (rid,dbn,tbn) in deps:
            if tbn:
                rnode=self.node_map.get(f"RULE_{rid}")
                tnode=self.node_map.get(f"TBL_{dbn}.{tbn}".lower())
                if rnode and tnode:
                    edge=LineageEdgeItem(rnode, tnode)
                    self.scene.addItem(edge)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def resetView(self):
        self.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)

    def apply_search_highlight(self, text):
        txt=text.lower()
        for it in self.scene.items():
            if isinstance(it,(RuleNodeItem,TableNodeItem)):
                info=str(it.toolTip()).lower()
                if txt in info:
                    it.setOpacity(1.0)
                else:
                    it.setOpacity(0.2)


class RuleNodeItem(QGraphicsRectItem):
    """A rectangle representing a rule node."""
    def __init__(self, rule_id, rule_name, status, is_global, is_crit):
        super().__init__(0,0,140,60)
        self.rule_id=rule_id
        self.rule_name=rule_name
        self.status=status
        self.is_global=is_global
        self.is_crit=is_crit

        fill=QColor("lightgray")
        if status.upper()=="ACTIVE":
            fill=QColor("lightgreen")
        elif status.upper()=="INACTIVE":
            fill=QColor("tomato")

        pen=QPen(Qt.black,2)
        if is_crit or is_global:
            pen.setStyle(Qt.DashLine)
            pen.setColor(QColor("red"))
        self.setBrush(QBrush(fill))
        self.setPen(pen)
        self.setToolTip(f"Rule {rule_id}: {rule_name}\nStatus={status}")

        self.text_item=QGraphicsTextItem(f"{rule_name}\n(ID={rule_id})", self)
        self.text_item.setDefaultTextColor(Qt.black)
        self.text_item.setFont(QFont("Arial",9))
        r=self.rect()
        tr=self.text_item.boundingRect()
        self.text_item.setPos(r.width()/2 - tr.width()/2, r.height()/2 - tr.height()/2)


class TableNodeItem(QGraphicsEllipseItem):
    """Ellipse representing a table node."""
    def __init__(self, table_key):
        super().__init__(0,0,100,100)
        self.table_key=table_key
        self.setBrush(QBrush(QColor("lightblue")))
        self.setPen(QPen(Qt.darkBlue,2))
        self.setToolTip(f"Table: {table_key}")

        self.txt=QGraphicsTextItem(table_key,self)
        self.txt.setDefaultTextColor(Qt.black)
        self.txt.setFont(QFont("Arial",8))
        tr=self.txt.boundingRect()
        self.txt.setPos(50 - tr.width()/2, 50 - tr.height()/2)


class LineageEdgeItem(QGraphicsLineItem):
    """Line connecting a rule node to a table node."""
    def __init__(self, source_item, target_item, parent=None):
        super().__init__(parent)
        self.source=source_item
        self.target=target_item
        self.setPen(QPen(QColor("darkblue"),2))
        self.adjust()

    def adjust(self):
        sr=self.source.sceneBoundingRect().center()
        tr=self.target.sceneBoundingRect().center()
        self.setLine(sr.x(), sr.y(), tr.x(), tr.y())

    def paint(self, painter, option, widget=None):
        self.adjust()
        super().paint(painter, option, widget)


###############################################################################
# 7) CustomRuleGroupEnhancedTab
###############################################################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manage custom groups:
     - create/rename/delete,
     - backup/restore,
     - assign rules => BFS if needed,
     - if locked => skip or forcibly unlock if admin
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_grp_edit=QLineEdit()
        self.new_grp_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_grp_edit)
        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)
        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)
        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)
        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)
        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        # splitter => left tree, right => rule list
        split_h=QHBoxLayout()
        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        split_h.addWidget(self.tree)

        right_w=QVBoxLayout()
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search available rules..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        right_w.addWidget(self.rule_search)
        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QListWidget.ExtendedSelection)
        right_w.addWidget(self.rule_list)
        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        right_w.addWidget(assign_btn)
        rw_frame=QWidget()
        rw_frame.setLayout(right_w)
        split_h.addWidget(rw_frame)
        layout.addLayout(split_h)

        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
            SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP
            FROM BRM_CUSTOM_RULE_GROUPS
            ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for (cgid, cgname, owner) in groups:
            disp=f"{cgname} (Owner={owner})"
            top=QTreeWidgetItem([disp])
            top.setData(0,Qt.UserRole,cgid)
            self.tree.addTopLevelItem(top)

            # assigned
            c2=self.connection.cursor()
            c2.execute("""
                SELECT R.RULE_ID, R.RULE_NAME, R.LOCK_STATUS
                FROM BRM_CUSTOM_GROUP_MEMBERS M
                JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
                WHERE M.CUSTOM_GROUP_ID=?
            """,(cgid,))
            assigned=c2.fetchall()
            for (rid,rn,lk) in assigned:
                txt=f"Rule {rid}: {rn}"
                if lk and lk.upper()=="LOCKED":
                    txt+= " [LOCKED]"
                child=QTreeWidgetItem([txt])
                child.setData(0,Qt.UserRole,rid)
                top.addChild(child)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        # skip rules that are already in custom groups
        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set(x[0] for x in c2.fetchall())

        if txt:
            c.execute("""
                SELECT RULE_ID,RULE_NAME
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID DESC")
        rows=c.fetchall()
        for (rid,rn) in rows:
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rn}"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # rule => remove
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                self.remove_rule_from_group(group_id, rule_id)

    def remove_rule_from_group(self, group_id, rule_id):
        # check lock
        if self.is_rule_locked(rule_id):
            if self.user_group!="Admin":
                QMessageBox.warning(self,"Locked","Rule is locked, only admin can forcibly remove.")
                return
            else:
                self.force_unlock(rule_id)
        c=self.connection.cursor()
        c.execute("""
            DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
            WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
        """,(group_id, rule_id))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"Rule {rule_id} removed from group {group_id}.")
        self.refresh_all()

    def is_rule_locked(self, rule_id):
        c=self.connection.cursor()
        c.execute("SELECT LOCK_STATUS FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
        row=c.fetchone()
        if row and row[0] and row[0].upper()=="LOCKED":
            return True
        return False

    def force_unlock(self, rule_id):
        c=self.connection.cursor()
        c.execute("""
            UPDATE BRM_RULES
            SET LOCK_STATUS='UNLOCKED', LOCKED_BY=NULL, LOCKED_AT=NULL
            WHERE RULE_ID=?
        """,(rule_id,))
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        self.connection.commit()

    def create_group(self):
        gn=self.new_grp_edit.text().strip()
        if not gn:
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO BRM_CUSTOM_RULE_GROUPS(
                CUSTOM_GROUP_NAME, OWNER_BUSINESS_GROUP, CREATED_BY
            )
            VALUES(?,?,?)
        """,(gn,self.user_group,str(self.user_id)))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Group '{gn}' created.")
        self.new_grp_edit.clear()
        self.refresh_all()

    def rename_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return
        it=sel[0]
        if it.parent():
            it=it.parent()
        gid=it.data(0,Qt.UserRole)
        old_text=it.text(0)
        new_name,ok=QInputDialog.getText(self,"Rename Group",f"New name for '{old_text}'?:")
        if not ok or not new_name.strip():
            return
        c=self.connection.cursor()
        c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
        """,(new_name.strip(), gid))
        self.connection.commit()
        self.refresh_all()

    def delete_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return
        it=sel[0]
        if it.parent():
            it=it.parent()
        gid=it.data(0,Qt.UserRole)
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        self.connection.commit()
        self.refresh_all()

    def backup_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return
        it=sel[0]
        if it.parent():
            it=it.parent()
        gid=it.data(0,Qt.UserRole)
        # fetch group name
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            return
        grpname=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        assigned=[r[0] for r in c.fetchall()]
        backup_data={
            "group_name":grpname,
            "members":assigned,
            "backup_user": self.user_id,
            "ts": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        c.execute("""
            SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
            FROM BRM_CUSTOM_GROUP_BACKUPS
            WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        ver=c.fetchone()[0]
        c.execute("""
            INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
                CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
            )
            VALUES(?,GETDATE(),?,?)
        """,(gid, ver, json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup created => version={ver}.")
        self.refresh_all()

    def restore_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return
        it=sel[0]
        if it.parent():
            it=it.parent()
        gid=it.data(0,Qt.UserRole)
        c=self.connection.cursor()
        c.execute("""
            SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
            FROM BRM_CUSTOM_GROUP_BACKUPS
            WHERE CUSTOM_GROUP_ID=?
            ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        backups=c.fetchall()
        if not backups:
            QMessageBox.information(self,"None","No backups for that group.")
            return
        items=[f"Version {b[0]} (ts={b[1]})" for b in backups]
        selver,ok=QInputDialog.getItem(self,"Restore Backup","Pick version:", items,0,False)
        if not ok or not selver:
            return
        m=re.search(r"Version\s+(\d+)",selver)
        if not m:
            return
        version=int(m.group(1))
        backup_json=None
        for b in backups:
            if b[0]==version:
                backup_json=b[2]
                break
        if not backup_json:
            return
        data=json.loads(backup_json)
        new_gname=data.get("group_name","RestoredGroup")
        members=data.get("members",[])
        c.execute("BEGIN TRANSACTION")
        try:
            c.execute("""
                UPDATE BRM_CUSTOM_RULE_GROUPS
                SET CUSTOM_GROUP_NAME=?
                WHERE CUSTOM_GROUP_ID=?
            """,(new_gname,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                if self.is_rule_locked(mid):
                    if self.user_group=="Admin":
                        self.force_unlock(mid)
                    else:
                        continue
                c.execute("""
                    INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                    VALUES(?,?)
                """,(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => version {version} restored.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.refresh_all()

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        gitem=sel[0]
        if gitem.parent():
            gitem=gitem.parent()
        gid=gitem.data(0,Qt.UserRole)
        if not gid:
            return
        selected_rules=self.rule_list.selectedItems()
        if not selected_rules:
            return
        c=self.connection.cursor()
        assigned_count=0
        for it in selected_rules:
            rid=it.data(Qt.UserRole)
            if self.is_rule_locked(rid):
                if self.user_group=="Admin":
                    self.force_unlock(rid)
                else:
                    continue
            c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
            """,(gid,rid))
            assigned_count+=1
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{assigned_count} rule(s) assigned to group {gid}.")
        self.refresh_all()


###############################################################################
# 8) DefectManagementTab
###############################################################################
class DefectManagementTab(QWidget):
    """
    Show defects from BRM_DEFECT_LOGS => add/edit/delete => search => notifications
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.last_defect_count=0
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search by desc, severity, reporter, status...")
        self.search_edit.textChanged.connect(self.search_defects)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        self.defect_table=QTableWidget(0,7)
        self.defect_table.setHorizontalHeaderLabels([
            "DefectID","RuleID","Description","Severity","Reporter","Status","Timestamp"
        ])
        self.defect_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.defect_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Defect")
        add_btn.clicked.connect(self.add_defect)
        btn_h.addWidget(add_btn)
        edit_btn=QPushButton("Edit Defect")
        edit_btn.clicked.connect(self.edit_defect)
        btn_h.addWidget(edit_btn)
        del_btn=QPushButton("Delete Defect")
        del_btn.clicked.connect(self.delete_defect)
        btn_h.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_defects)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.notification_label=QLabel("")
        self.notification_label.setStyleSheet("color:green; font-weight:bold;")
        layout.addWidget(self.notification_label)

        self.setLayout(layout)
        self.load_defects()
        # optional auto refresh
        self.timer=QTimer(self)
        self.timer.timeout.connect(self.load_defects)
        self.timer.start(30000)

    def load_defects(self):
        self.defect_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT DEFECT_ID,RULE_ID,DESCRIPTION,SEVERITY,REPORTER,STATUS,TIMESTAMP
            FROM BRM_DEFECT_LOGS
            ORDER BY TIMESTAMP DESC
        """)
        rows=c.fetchall()
        current_count=len(rows)
        for row in rows:
            r_i=self.defect_table.rowCount()
            self.defect_table.insertRow(r_i)
            for col_i,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val else "")
                self.defect_table.setItem(r_i,col_i,it)

        if self.last_defect_count and current_count>self.last_defect_count:
            new_ct=current_count - self.last_defect_count
            self.notification_label.setText(f"{new_ct} new defects logged.")
            QTimer.singleShot(5000, lambda: self.notification_label.setText(""))
        self.last_defect_count=current_count

        self.defect_table.resizeColumnsToContents()

    def search_defects(self, text):
        txt=text.lower()
        for r in range(self.defect_table.rowCount()):
            show=False
            for c in range(self.defect_table.columnCount()):
                it=self.defect_table.item(r,c)
                if it and txt in it.text().lower():
                    show=True
                    break
            self.defect_table.setRowHidden(r, not show)

    def get_selected_defect_id(self):
        r=self.defect_table.currentRow()
        if r<0:
            return None
        it=self.defect_table.item(r,0)
        if not it:
            return None
        return int(it.text())

    def add_defect(self):
        dlg=_DefectDialog(self.connection)
        if dlg.exec_()==QDialog.Accepted:
            self.load_defects()

    def edit_defect(self):
        did=self.get_selected_defect_id()
        if not did:
            QMessageBox.warning(self,"None","No defect selected.")
            return
        c=self.connection.cursor()
        c.execute("""
            SELECT DEFECT_ID,RULE_ID,DESCRIPTION,SEVERITY,REPORTER,STATUS,RESOLUTION
            FROM BRM_DEFECT_LOGS
            WHERE DEFECT_ID=?
        """,(did,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No defect {did}")
            return
        dd={
            "DEFECT_ID":row[0],
            "RULE_ID":row[1],
            "DESCRIPTION":row[2],
            "SEVERITY":row[3],
            "REPORTER":row[4],
            "STATUS":row[5],
            "RESOLUTION":row[6]
        }
        dlg=_DefectDialog(self.connection, dd)
        if dlg.exec_()==QDialog.Accepted:
            self.load_defects()

    def delete_defect(self):
        did=self.get_selected_defect_id()
        if not did:
            QMessageBox.warning(self,"None","No defect selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete defect {did}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_DEFECT_LOGS WHERE DEFECT_ID=?",(did,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Defect {did} removed.")
        self.load_defects()


class _DefectDialog(QDialog):
    """Dialog to add/edit a defect record."""
    def __init__(self, connection, defect_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.defect_data=defect_data
        self.is_edit=(defect_data is not None)
        self.init_ui()

    def init_ui(self):
        t="Edit Defect" if self.is_edit else "Add Defect"
        self.setWindowTitle(t)
        self.resize(500,400)
        layout=QVBoxLayout(self)
        form=QFormLayout()
        self.rule_id_edit=QLineEdit()
        form.addRow("Rule ID:", self.rule_id_edit)
        self.desc_edit=QPlainTextEdit()
        form.addRow("Description:", self.desc_edit)
        self.sev_combo=QComboBox()
        self.sev_combo.addItems(["Low","Medium","High","Critical"])
        form.addRow("Severity:", self.sev_combo)
        self.reporter_edit=QLineEdit()
        form.addRow("Reporter:", self.reporter_edit)
        self.status_combo=QComboBox()
        self.status_combo.addItems(["Open","In Progress","Resolved","Closed"])
        form.addRow("Status:", self.status_combo)
        self.res_edit=QPlainTextEdit()
        form.addRow("Resolution:", self.res_edit)
        layout.addLayout(form)

        bh=QHBoxLayout()
        save_btn=QPushButton("Save")
        save_btn.clicked.connect(self.save_defect)
        bh.addWidget(save_btn)
        cb=QPushButton("Cancel")
        cb.clicked.connect(self.reject)
        bh.addWidget(cb)
        layout.addLayout(bh)

        if self.is_edit and self.defect_data:
            self.load_data()

        self.setLayout(layout)

    def load_data(self):
        dd=self.defect_data
        if dd.get("RULE_ID"):
            self.rule_id_edit.setText(str(dd["RULE_ID"]))
        self.desc_edit.setPlainText(dd.get("DESCRIPTION",""))
        s=dd.get("SEVERITY","Low")
        ix=self.sev_combo.findText(s,Qt.MatchFixedString)
        if ix>=0:
            self.sev_combo.setCurrentIndex(ix)
        self.reporter_edit.setText(dd.get("REPORTER",""))
        st=dd.get("STATUS","Open")
        ix2=self.status_combo.findText(st,Qt.MatchFixedString)
        if ix2>=0:
            self.status_combo.setCurrentIndex(ix2)
        self.res_edit.setPlainText(dd.get("RESOLUTION",""))

    def save_defect(self):
        try:
            rid_txt=self.rule_id_edit.text().strip()
            rid=int(rid_txt) if rid_txt else None
        except:
            QMessageBox.warning(self,"Error","Rule ID must be integer or blank.")
            return
        desc=self.desc_edit.toPlainText().strip()
        if not desc:
            QMessageBox.warning(self,"Error","Description required.")
            return
        sev=self.sev_combo.currentText()
        rep=self.reporter_edit.text().strip()
        if not rep:
            QMessageBox.warning(self,"Error","Reporter required.")
            return
        st=self.status_combo.currentText()
        res=self.res_edit.toPlainText().strip() or None

        c=self.connection.cursor()
        if self.is_edit:
            did=self.defect_data["DEFECT_ID"]
            try:
                c.execute("""
                    UPDATE BRM_DEFECT_LOGS
                    SET RULE_ID=?, DESCRIPTION=?, SEVERITY=?, REPORTER=?,
                        STATUS=?, RESOLUTION=?, TIMESTAMP=GETDATE()
                    WHERE DEFECT_ID=?
                """,(rid,desc,sev,rep,st,res,did))
                self.connection.commit()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
                return
        else:
            try:
                c.execute("""
                    INSERT INTO BRM_DEFECT_LOGS(
                        RULE_ID, DESCRIPTION, SEVERITY, REPORTER, STATUS, RESOLUTION, TIMESTAMP
                    )
                    VALUES(?,?,?,?,?,?,GETDATE())
                """,(rid,desc,sev,rep,st,res))
                self.connection.commit()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
                return
        self.accept()


###############################################################################
# 9) ControlTablesTab
###############################################################################
class ControlTablesTab(QWidget):
    """
    Simple admin tool => pick a table => load => show => (admin => can save changes).
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)

        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_DEFECT_LOGS","BRM_RULE_APPROVALS","BRM_GLOBAL_CRITICAL_LINKS",
            "RULE_SCHEDULES","RULE_EXECUTION_LOGS","COMPOSITE_RULES","RULE_CONFLICTS",
            "DECISION_TABLES","RULE_TAGS","DATA_VALIDATIONS","DATA_VALIDATION_LOGS",
            "BRM_CUSTOM_RULE_GROUPS","BRM_CUSTOM_GROUP_MEMBERS","BRM_CUSTOM_GROUP_BACKUPS",
            "RULE_SNAPSHOTS","DECISION_TABLE_EXEC_LOGS","BRM_ACTIVITY_LOG"
        ]

        self.tbl_combo=QComboBox()
        for t_ in self.table_list:
            self.tbl_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.load_data)
        layout.addWidget(load_btn)

        self.data_table=QTableWidget(0,0)
        if self.user_group=="Admin":
            self.data_table.setEditTriggers(QTableWidget.DoubleClicked)
        else:
            self.data_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.data_table)

        save_btn=QPushButton("Save Changes (Admin Only)")
        if self.user_group!="Admin":
            save_btn.setEnabled(False)
        save_btn.clicked.connect(self.save_changes)
        layout.addWidget(save_btn)

        self.setLayout(layout)
        self.columns=[]
        self.current_table=None

    def load_data(self):
        tbl=self.tbl_combo.currentText()
        self.current_table=tbl
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            self.columns=[d[0] for d in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving columns: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 500 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Error retrieving data: {ex}")
            return
        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(self.columns))
        self.data_table.setHorizontalHeaderLabels(self.columns)
        for row in rows:
            r_i=self.data_table.rowCount()
            self.data_table.insertRow(r_i)
            for cc,val in enumerate(row):
                it=QTableWidgetItem(str(val) if val is not None else "")
                self.data_table.setItem(r_i,cc,it)
        self.data_table.resizeColumnsToContents()

    def save_changes(self):
        if self.user_group!="Admin":
            QMessageBox.warning(self,"NoPerm","Only admin can save changes.")
            return
        if not self.current_table:
            QMessageBox.warning(self,"None","No table loaded.")
            return
        confirm=QMessageBox.question(self,"Confirm","Naive re-write approach; proceed?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        rowcount=self.data_table.rowCount()
        colcount=self.data_table.columnCount()
        try:
            try:
                c.execute(f"TRUNCATE TABLE {self.current_table}")
            except:
                c.execute(f"DELETE FROM {self.current_table}")
            for rr in range(rowcount):
                vals=[]
                for cc in range(colcount):
                    it=self.data_table.item(rr,cc)
                    vals.append(it.text().strip() if it else "")
                placeholders=",".join(["?"]*colcount)
                colnames=",".join(self.columns)
                q=f"INSERT INTO {self.current_table}({colnames}) VALUES({placeholders})"
                c.execute(q, vals)
            self.connection.commit()
            QMessageBox.information(self,"Saved",f"Wrote {rowcount} row(s) to {self.current_table}.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 10) MetricsDashboardTab
###############################################################################
class MetricsDashboardTab(QWidget):
    """
    Example of a chart-based tab => rule status, execution trends, etc.
    We can use pyqtgraph or placeholders.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        # placeholders
        self.status_label=QLabel("Rule Status Counts (placeholder chart).")
        layout.addWidget(self.status_label)

        self.exec_label=QLabel("Execution Trends (placeholder chart).")
        layout.addWidget(self.exec_label)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_metrics)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        try:
            c.execute("SELECT STATUS, COUNT(*) FROM BRM_RULES GROUP BY STATUS")
            rows=c.fetchall()
            txt="Status counts:\n"
            for r_ in rows:
                txt+=f"{r_[0]} => {r_[1]}\n"
            self.status_label.setText(txt)
        except:
            self.status_label.setText("Error retrieving rule status counts.")

        try:
            c.execute("""
                SELECT CONVERT(varchar(10),EXECUTION_TIMESTAMP,120) as d, COUNT(*)
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP>=DATEADD(day, -7, GETDATE())
                GROUP BY CONVERT(varchar(10),EXECUTION_TIMESTAMP,120)
                ORDER BY d
            """)
            rows=c.fetchall()
            txt="Exec last 7 days:\n"
            for r_ in rows:
                txt+=f"{r_[0]} => {r_[1]} executions\n"
            self.exec_label.setText(txt)
        except:
            self.exec_label.setText("Error retrieving execution trends.")


###############################################################################
# 11) AlertsAndDashboardsTab
###############################################################################
class AlertsAndDashboardsTab(QWidget):
    """
    Show overdue approvals, upcoming schedules, stale locks, performance outliers, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)
        self.text_edit=QPlainTextEdit()
        self.text_edit.setReadOnly(True)
        layout.addWidget(self.text_edit)

        ref_btn=QPushButton("Refresh Alerts")
        ref_btn.clicked.connect(self.check_alerts)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()

        # 1) overdue approvals
        try:
            c.execute("""
                SELECT A.RULE_ID, A.APPROVAL_STAGE, R.RULE_NAME,
                       DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as Age
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.APPROVED_FLAG=0
                  AND A.APPROVAL_STAGE=(
                    SELECT MIN(APPROVAL_STAGE)
                    FROM BRM_RULE_APPROVALS
                    WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
                  )
                  AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
            """)
            overdue=c.fetchall()
            if overdue:
                lines.append("** Overdue Approvals (>3 days) **")
                for row in overdue:
                    lines.append(f"   Rule {row[0]} '{row[2]}', stage={row[1]}, age={row[3]} days")
            else:
                lines.append("No overdue approvals >3 days found.")
        except Exception as ex:
            lines.append(f"Approvals error: {ex}")

        lines.append("")

        # 2) upcoming schedules <24h
        try:
            c.execute("""
                SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
                FROM RULE_SCHEDULES
                WHERE STATUS='Scheduled'
                  AND SCHEDULE_TIME>=GETDATE()
                  AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
                ORDER BY SCHEDULE_TIME
            """)
            scheds=c.fetchall()
            if scheds:
                lines.append("** Upcoming Schedules (next 24h)**")
                for s_ in scheds:
                    lines.append(f"   Sched {s_[0]}, Rule {s_[1]}, time={s_[2]}")
            else:
                lines.append("No schedules in next 24h.")
        except Exception as ex:
            lines.append(f"Schedules error: {ex}")

        lines.append("")

        # 3) stale locks => locked>6h
        try:
            c.execute("""
                SELECT RULE_ID,LOCKED_BY,LOCKED_AT,
                DATEDIFF(HOUR,LOCKED_AT,GETDATE()) as hrs
                FROM BRM_RULES
                WHERE LOCK_STATUS='LOCKED'
                  AND LOCKED_AT IS NOT NULL
                  AND DATEDIFF(HOUR,LOCKED_AT,GETDATE())>6
            """)
            stale=c.fetchall()
            if stale:
                lines.append("** Stale Locks (>6h)**")
                for s_ in stale:
                    lines.append(f"   Rule {s_[0]}, locked by {s_[1]}, for {s_[3]} hrs")
            else:
                lines.append("No stale locks.")
        except Exception as ex:
            lines.append(f"Locks error: {ex}")

        lines.append("")

        # 4) performance outliers => RULE_EXECUTION_LOGS => >3000 ms last 7d
        try:
            c.execute("""
                SELECT LOG_ID,RULE_ID,EXECUTION_TIME_MS,EXECUTION_TIMESTAMP
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIME_MS>3000
                  AND EXECUTION_TIMESTAMP>=DATEADD(day,-7,GETDATE())
                ORDER BY EXECUTION_TIMESTAMP DESC
            """)
            outl=c.fetchall()
            if outl:
                lines.append("** Performance outliers (>3s in last 7 days)**")
                for o_ in outl:
                    lines.append(f"   Log {o_[0]}, Rule {o_[1]}, time={o_[2]} ms at {o_[3]}")
            else:
                lines.append("No performance outliers >3s last 7d.")
        except Exception as ex:
            lines.append(f"Perf error: {ex}")

        self.text_edit.setPlainText("\n".join(lines))


###############################################################################
# 12) GroupManagementTab
###############################################################################
class GroupManagementTab(QWidget):
    """
    Admin => manage business groups, membership, permissions, approvers
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only."))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # groups + membership
        gm_widget=QWidget()
        gm_layout=QVBoxLayout(gm_widget)

        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        gm_layout.addWidget(QLabel("Business Groups:"))
        gm_layout.addWidget(self.groups_table)

        grp_btn_h=QHBoxLayout()
        add_grp_btn=QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.add_group)
        grp_btn_h.addWidget(add_grp_btn)
        rename_grp_btn=QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.rename_group)
        grp_btn_h.addWidget(rename_grp_btn)
        del_grp_btn=QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.delete_group)
        grp_btn_h.addWidget(del_grp_btn)
        grp_btn_h.addStretch()
        gm_layout.addLayout(grp_btn_h)

        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        gm_layout.addWidget(QLabel("User Membership:"))
        gm_layout.addWidget(self.users_table)

        memb_btn_h=QHBoxLayout()
        add_usr_btn=QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.add_user_to_group)
        memb_btn_h.addWidget(add_usr_btn)
        rem_usr_btn=QPushButton("Remove User => BG1")
        rem_usr_btn.clicked.connect(self.remove_user_from_group)
        memb_btn_h.addWidget(rem_usr_btn)
        memb_btn_h.addStretch()
        gm_layout.addLayout(memb_btn_h)

        gm_widget.setLayout(gm_layout)
        self.tabs.addTab(gm_widget,"Groups & Membership")

        # permissions
        perm_widget=QWidget()
        perm_layout=QVBoxLayout(perm_widget)
        top_ph=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        top_ph.addWidget(QLabel("Group:"))
        top_ph.addWidget(self.perm_group_combo)
        top_ph.addStretch()
        perm_layout.addLayout(top_ph)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_layout.addWidget(self.perm_table)

        perm_btn_h=QHBoxLayout()
        addp_btn=QPushButton("Add Permission")
        addp_btn.clicked.connect(self.add_permission)
        perm_btn_h.addWidget(addp_btn)
        remp_btn=QPushButton("Remove Permission")
        remp_btn.clicked.connect(self.remove_permission)
        perm_btn_h.addWidget(remp_btn)
        perm_btn_h.addStretch()
        perm_layout.addLayout(perm_btn_h)
        perm_widget.setLayout(perm_layout)
        self.tabs.addTab(perm_widget,"Permissions")

        # approvers
        appr_widget=QWidget()
        appr_layout=QVBoxLayout(appr_widget)
        top_ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        top_ah.addWidget(QLabel("Group:"))
        top_ah.addWidget(self.appr_group_combo)
        top_ah.addStretch()
        appr_layout.addLayout(top_ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btn_h=QHBoxLayout()
        add_appr_btn=QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.add_approver)
        appr_btn_h.addWidget(add_appr_btn)
        del_appr_btn=QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.remove_approver)
        appr_btn_h.addWidget(del_appr_btn)
        appr_btn_h.addStretch()
        appr_layout.addLayout(appr_btn_h)

        appr_widget.setLayout(appr_layout)
        self.tabs.addTab(appr_widget,"Approvers")

        ref_btn=QPushButton("Refresh All")
        ref_btn.clicked.connect(self.load_data)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_groups()
        self.load_appr_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.groups_table.rowCount()
            self.groups_table.insertRow(r_i)
            for cc,vv in enumerate(r_):
                it=QTableWidgetItem(str(vv) if vv else "")
                self.groups_table.setItem(r_i,cc,it)

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for cc,vv in enumerate(r_):
                it=QTableWidgetItem(str(vv) if vv else "")
                self.users_table.setItem(r_i,cc,it)

    def add_group(self):
        gn,ok=QInputDialog.getText(self,"Add Group","Group name:")
        if not ok or not gn.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        email,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            email=""
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gn.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("""
            INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
            VALUES(?,?,?)
        """,(gn.strip(),desc.strip(),email.strip()))
        self.connection.commit()
        self.load_data()

    def rename_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No group selected.")
            return
        old_gn=self.groups_table.item(row,0).text().strip()
        new_gn,ok=QInputDialog.getText(self,"Rename Group",f"New name for '{old_gn}':")
        if not ok or not new_gn.strip():
            return
        c=self.connection.cursor()
        # also update BRM_RULES => OWNER_GROUP
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_gn.strip(),old_gn))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_gn.strip(), old_gn))
            c.execute("COMMIT")
        except:
            c.execute("ROLLBACK")
        self.load_data()

    def delete_group(self):
        row=self.groups_table.currentRow()
        if row<0:
            return
        gn=self.groups_table.item(row,0).text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{gn}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(gn,))
            self.connection.commit()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def load_perm_groups(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for (gn,) in rows:
            self.perm_group_combo.addItem(gn,gn)
        self.load_permissions()

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        self.perm_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT TARGET_TABLE
            FROM GROUP_PERMISSIONS
            WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.perm_table.rowCount()
            self.perm_table.insertRow(r_i)
            self.perm_table.setItem(r_i,0,QTableWidgetItem(str(r_[0])))

    def add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        tbn,ok=QInputDialog.getText(self,"Add Permission","(e.g. 'dbo.MyTable'):")
        if not ok or not tbn.strip():
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE)
            VALUES(?,?)
        """,(grp,tbn.strip()))
        self.connection.commit()
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        row=self.perm_table.currentRow()
        if row<0:
            return
        tbn=self.perm_table.item(row,0).text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{tbn}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
            DELETE FROM GROUP_PERMISSIONS
            WHERE GROUP_NAME=? AND TARGET_TABLE=?
        """,(grp,tbn))
        self.connection.commit()
        self.load_permissions()

    def load_appr_groups(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for (gn,) in rows:
            self.appr_group_combo.addItem(gn,gn)
        self.load_approvers()

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        self.appr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT APPROVER_ID,USERNAME
            FROM BUSINESS_GROUP_APPROVERS
            WHERE GROUP_NAME=?
        """,(grp,))
        rows=c.fetchall()
        for r_ in rows:
            r_i=self.appr_table.rowCount()
            self.appr_table.insertRow(r_i)
            self.appr_table.setItem(r_i,0,QTableWidgetItem(str(r_[0])))
            self.appr_table.setItem(r_i,1,QTableWidgetItem(str(r_[1])))

    def add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        uname,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not uname.strip():
            return
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME)
            VALUES(?,?)
        """,(grp,uname.strip()))
        self.connection.commit()
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            return
        appr_id=int(self.appr_table.item(row,0).text())
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        self.load_approvers()

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.users_table.rowCount()
            self.users_table.insertRow(r_i)
            for cc,val in enumerate(row):
                self.users_table.setItem(r_i,cc,QTableWidgetItem(str(val) if val else ""))

    def add_user_to_group(self):
        row=self.users_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No user selected.")
            return
        uid=self.users_table.item(row,0).text()
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name?")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(), uid))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"User {uid} => group {grp}.")
        self.load_users()

    def remove_user_from_group(self):
        row=self.users_table.currentRow()
        if row<0:
            return
        uid=self.users_table.item(row,0).text()
        confirm=QMessageBox.question(self,"Confirm",f"Remove user {uid} => BG1 ?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        self.load_users()

###############################################################################
# 13) UserManagementTab
###############################################################################
class UserManagementTab(QWidget):
    """
    Admin => manage users => add/delete => change password => see user_group
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.user_table=QTableWidget(0,4)
        self.user_table.setHorizontalHeaderLabels(["UserID","Username","Password(Encrypted)","UserGroup"])
        self.user_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.user_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add User")
        add_btn.clicked.connect(self.add_user)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete User")
        del_btn.clicked.connect(self.delete_user)
        bh.addWidget(del_btn)

        pass_btn=QPushButton("Change Password")
        pass_btn.clicked.connect(self.change_password)
        bh.addWidget(pass_btn)

        bh.addStretch()
        layout.addLayout(bh)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_users)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_users()

    def load_users(self):
        self.user_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.user_table.rowCount()
            self.user_table.insertRow(r_i)
            for cc,vv in enumerate(row):
                self.user_table.setItem(r_i,cc,QTableWidgetItem(str(vv) if vv else ""))

    def get_selected_user(self):
        r=self.user_table.currentRow()
        if r<0:
            return None
        it=self.user_table.item(r,0)
        if it:
            return int(it.text())
        return None

    def add_user(self):
        uname,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not uname.strip():
            return
        pwd,ok2=QInputDialog.getText(self,"Password","Enter password:")
        if not ok2 or not pwd.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(uname.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Conflict","Username already exists.")
            return
        enc_pw="enc_"+pwd[::-1]  # example encryption
        c.execute("""
            INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP)
            VALUES(?,?,?)
        """,(uname.strip(), enc_pw, grp.strip()))
        self.connection.commit()
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_user()
        if not uid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user ID={uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        self.load_users()

    def change_password(self):
        uid=self.get_selected_user()
        if not uid:
            return
        pwd,ok=QInputDialog.getText(self,"New Password","Enter new password:")
        if not ok or not pwd.strip():
            return
        enc_pw="enc_"+pwd[::-1]
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(enc_pw,uid))
        self.connection.commit()
        QMessageBox.information(self,"Changed",f"Password changed for user {uid}.")
        self.load_users()


###############################################################################
# 14) AdvancedDecisionTablesTab
###############################################################################
class AdvancedDecisionTablesTab(QWidget):
    """
    List DECISION_TABLES => add/edit/delete => run => logs results in DECISION_TABLE_EXEC_LOGS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dt_table=QTableWidget(0,4)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","TableName","Description","Query"])
        self.dt_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dt_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add DecisionTable")
        add_btn.clicked.connect(self.add_dt)
        btn_h.addWidget(add_btn)
        edit_btn=QPushButton("Edit DecisionTable")
        edit_btn.clicked.connect(self.edit_dt)
        btn_h.addWidget(edit_btn)
        del_btn=QPushButton("Delete DecisionTable")
        del_btn.clicked.connect(self.delete_dt)
        btn_h.addWidget(del_btn)
        run_btn=QPushButton("Execute")
        run_btn.clicked.connect(self.run_dt)
        btn_h.addWidget(run_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION,DECISION_QUERY
            FROM DECISION_TABLES
            ORDER BY DECISION_TABLE_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.dt_table.rowCount()
            self.dt_table.insertRow(r_i)
            for cc,vv in enumerate(row):
                self.dt_table.setItem(r_i,cc,QTableWidgetItem(str(vv) if vv else ""))

    def get_selected_dt_id(self):
        r=self.dt_table.currentRow()
        if r<0:
            return None
        it=self.dt_table.item(r,0)
        if it:
            return int(it.text())
        return None

    def add_dt(self):
        nm,ok=QInputDialog.getText(self,"Add DT","TableName:")
        if not ok or not nm.strip():
            return
        desc,ok2=QInputDialog.getMultiLineText(self,"Desc","Optional desc:")
        if not ok2:
            desc=""
        q_,ok3=QInputDialog.getMultiLineText(self,"DecisionQuery","SQL returning 1 => PASS:")
        if not ok3:
            q_=""
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION,DECISION_QUERY,CREATED_TIMESTAMP)
            VALUES(?,?,?,GETDATE())
        """,(nm.strip(), desc.strip(), q_.strip()))
        self.connection.commit()
        self.load_dt()

    def edit_dt(self):
        dtid=self.get_selected_dt_id()
        if not dtid:
            QMessageBox.warning(self,"None","No decision table selected.")
            return
        c=self.connection.cursor()
        c.execute("""
            SELECT TABLE_NAME,DESCRIPTION,DECISION_QUERY
            FROM DECISION_TABLES
            WHERE DECISION_TABLE_ID=?
        """,(dtid,))
        row=c.fetchone()
        if not row:
            return
        oldnm=row[0]
        olddesc=row[1] or ""
        oldq=row[2] or ""

        newnm,ok=QInputDialog.getText(self,"Edit","Table name:",text=oldnm)
        if not ok or not newnm.strip():
            return
        newdesc,ok2=QInputDialog.getMultiLineText(self,"Desc","",text=olddesc)
        if not ok2:
            newdesc=olddesc
        newq,ok3=QInputDialog.getMultiLineText(self,"Query","",text=oldq)
        if not ok3:
            newq=oldq
        c.execute("""
            UPDATE DECISION_TABLES
            SET TABLE_NAME=?,DESCRIPTION=?,DECISION_QUERY=?,UPDATED_TIMESTAMP=GETDATE()
            WHERE DECISION_TABLE_ID=?
        """,(newnm.strip(), newdesc.strip(), newq.strip(), dtid))
        self.connection.commit()
        self.load_dt()

    def delete_dt(self):
        dtid=self.get_selected_dt_id()
        if not dtid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete DT {dtid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dtid,))
        self.connection.commit()
        self.load_dt()

    def run_dt(self):
        dtid=self.get_selected_dt_id()
        if not dtid:
            return
        dlg=_DecisionTableExecDialog(self.connection, dtid)
        dlg.exec_()
        self.load_dt()

class _DecisionTableExecDialog(QDialog):
    """Executes a single decision table => logs pass/fail => shows result."""
    def __init__(self, connection, dt_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.dt_id=dt_id
        self.setWindowTitle(f"Execute DecisionTable {dt_id}")
        self.resize(400,300)
        layout=QVBoxLayout(self)

        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        run_btn=QPushButton("Run (DryRun)")
        run_btn.clicked.connect(self.do_run)
        layout.addWidget(run_btn)

        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setLayout(layout)

    def do_run(self):
        (ok,msg,rc)=self.simulate_dt_execution(self.dt_id, dry_run=True)
        text=f"DecisionTable {self.dt_id} => pass={ok}, message={msg}, rec_count={rc}"
        self.output.setPlainText(text)

    def simulate_dt_execution(self, dt_id, dry_run=True):
        c=self.connection.cursor()
        c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        row=c.fetchone()
        if not row or not row[0]:
            return (False,"No query",0)
        q_=row[0]
        start=time.time()
        c.execute("BEGIN TRANSACTION")
        pass_flag=True
        message=""
        rec_count=0
        try:
            c.execute(q_)
            rows=c.fetchall()
            rec_count=len(rows)
            if rows:
                val=rows[0][0]
                pass_flag=(val==1)
                message=f"Returned {val}"
            else:
                pass_flag=True
                message="No rows => pass"
            if not pass_flag or dry_run:
                c.execute("ROLLBACK")
            else:
                c.execute("COMMIT")
        except Exception as ex:
            pass_flag=False
            message=str(ex)
            c.execute("ROLLBACK")
        end=time.time()
        elapsed_ms=int((end-start)*1000)
        # log
        c2=self.connection.cursor()
        c2.execute("""
            INSERT INTO DECISION_TABLE_EXEC_LOGS(
                DECISION_TABLE_ID,EXEC_TIMESTAMP,PASS_FLAG,
                MESSAGE,RECORD_COUNT,EXECUTION_TIME_MS,DRY_RUN
            )
            VALUES(?,GETDATE(),?,?,?,?,?)
        """,(dt_id,1 if pass_flag else 0, message, rec_count, elapsed_ms,1 if dry_run else 0))
        self.connection.commit()
        return (pass_flag, message, rec_count)


###############################################################################
# 15) PerformanceAlertingTab
###############################################################################
class PerformanceAlertingTab(QWidget):
    """
    Let user pick a rule => show daily average time => highlight if above threshold for consecutive days.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.rule_combo=QComboBox()
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)
        self.threshold_edit=QLineEdit()
        self.threshold_edit.setPlaceholderText("Threshold ms (e.g. 2000)")
        top_h.addWidget(QLabel("Threshold:"))
        top_h.addWidget(self.threshold_edit)
        apply_btn=QPushButton("Apply")
        apply_btn.clicked.connect(self.load_data)
        top_h.addWidget(apply_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_label=QLabel("")
        layout.addWidget(self.result_label)

        self.setLayout(layout)
        self.load_rule_list()

    def load_rule_list(self):
        self.rule_combo.clear()
        self.rule_combo.addItem("All Rules",None)
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)

    def load_data(self):
        rid=self.rule_combo.currentData()
        try:
            thr=float(self.threshold_edit.text().strip())
        except:
            thr=2000.0
        c=self.connection.cursor()
        if rid:
            c.execute("""
                SELECT CAST(EXECUTION_TIMESTAMP as date) as d, AVG(EXECUTION_TIME_MS)
                FROM RULE_EXECUTION_LOGS
                WHERE RULE_ID=?
                  AND EXECUTION_TIMESTAMP>=DATEADD(day,-30,GETDATE())
                GROUP BY CAST(EXECUTION_TIMESTAMP as date)
                ORDER BY d
            """,(rid,))
        else:
            c.execute("""
                SELECT CAST(EXECUTION_TIMESTAMP as date) as d, AVG(EXECUTION_TIME_MS)
                FROM RULE_EXECUTION_LOGS
                WHERE EXECUTION_TIMESTAMP>=DATEADD(day,-30,GETDATE())
                GROUP BY CAST(EXECUTION_TIMESTAMP as date)
                ORDER BY d
            """)
        rows=c.fetchall()
        if not rows:
            self.result_label.setText("No performance data last 30 days.")
            return
        avg_values=[float(x[1] or 0) for x in rows]
        consecutive=0
        max_consecutive=0
        for val in avg_values:
            if val>thr:
                consecutive+=1
                if consecutive>max_consecutive:
                    max_consecutive=consecutive
            else:
                consecutive=0
        if max_consecutive>0:
            self.result_label.setText(f"ALERT: {max_consecutive} consecutive day(s) above threshold {thr} ms.")
        else:
            self.result_label.setText("No consecutive alerts above threshold.")


###############################################################################
# 16) ActivityTrackingTab
###############################################################################
class ActivityTrackingTab(QWidget):
    """
    Show BRM_ACTIVITY_LOG => filter by user/event => CSV export
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.user_search=QLineEdit()
        self.user_search.setPlaceholderText("Filter by username..")
        top_h.addWidget(QLabel("User:"))
        top_h.addWidget(self.user_search)

        self.event_combo=QComboBox()
        self.event_combo.addItem("All","")
        known_events=["LOGIN","LOGOFF","BFS_RUN","SCHEDULE_TRIGGER","RULE_SIM","DEFECT","ETC"]
        for ev in known_events:
            self.event_combo.addItem(ev,ev)
        top_h.addWidget(QLabel("Event:"))
        top_h.addWidget(self.event_combo)

        self.txt_search=QLineEdit()
        self.txt_search.setPlaceholderText("Search in details..")
        top_h.addWidget(self.txt_search)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_logs)
        top_h.addWidget(ref_btn)

        exp_btn=QPushButton("Export CSV")
        exp_btn.clicked.connect(self.export_csv)
        top_h.addWidget(exp_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.log_table=QTableWidget(0,5)
        self.log_table.setHorizontalHeaderLabels(["ActivityID","EventType","Username","Timestamp","Details"])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.log_table)

        self.setLayout(layout)
        self.load_logs()

    def load_logs(self):
        # naive => top 1000
        c=self.connection.cursor()
        c.execute("""
            SELECT TOP 1000 ACTIVITY_ID, EVENT_TYPE, USERNAME, TIMESTAMP, DETAILS
            FROM BRM_ACTIVITY_LOG
            ORDER BY ACTIVITY_ID DESC
        """)
        rows=c.fetchall()

        userf=self.user_search.text().lower()
        evtf=self.event_combo.currentData()
        txtf=self.txt_search.text().lower()

        self.log_table.setRowCount(0)
        for row in rows:
            (aid, et, un, ts, d_) = row
            # filter
            if userf and userf not in (un or "").lower():
                continue
            if evtf and evtf.lower() not in (et or "").lower():
                continue
            if txtf and txtf not in (d_ or "").lower():
                continue
            r_i=self.log_table.rowCount()
            self.log_table.insertRow(r_i)
            self.log_table.setItem(r_i,0,QTableWidgetItem(str(aid)))
            self.log_table.setItem(r_i,1,QTableWidgetItem(str(et)))
            self.log_table.setItem(r_i,2,QTableWidgetItem(str(un)))
            self.log_table.setItem(r_i,3,QTableWidgetItem(str(ts)))
            self.log_table.setItem(r_i,4,QTableWidgetItem(str(d_)))

        self.log_table.resizeColumnsToContents()

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export Activity Logs","","CSV Files (*.csv)")
        if not path:
            return
        import csv
        with open(path,"w",newline="",encoding="utf-8") as f:
            wr=csv.writer(f)
            headers=[self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            wr.writerow(headers)
            for rr in range(self.log_table.rowCount()):
                rowdata=[]
                for cc in range(self.log_table.columnCount()):
                    it=self.log_table.item(rr,cc)
                    rowdata.append(it.text() if it else "")
                wr.writerow(rowdata)
        QMessageBox.information(self,"Exported",f"Activity logs exported => {path}.")


###############################################################################
# 17) DataValidationTab
###############################################################################
class DataValidationTab(QWidget):
    """
    Manage DATA_VALIDATIONS => add/edit/del => run validations => show pass/fail
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dv_table=QTableWidget(0,5)
        self.dv_table.setHorizontalHeaderLabels(["ValID","TableName","ColumnName","Type","Params"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_h.addWidget(add_btn)
        rem_btn=QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_validation)
        btn_h.addWidget(rem_btn)
        run_btn=QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all)
        btn_h.addWidget(run_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_validations)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS
            FROM DATA_VALIDATIONS
            ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.dv_table.rowCount()
            self.dv_table.insertRow(r_i)
            for cc,vv in enumerate(row):
                self.dv_table.setItem(r_i,cc,QTableWidgetItem(str(vv) if vv else ""))

    def add_validation(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name (dbo.MyTable):")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2 or not col.strip():
            return
        vtype,ok3=QInputDialog.getText(self,"Type","(NOT NULL, RANGE, REGEX):")
        if not ok3 or not vtype.strip():
            return
        pars,ok4=QInputDialog.getText(self,"Params","e.g. '0,100' or '^[A-Z]+$' :")
        if not ok4:
            pars=""
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO DATA_VALIDATIONS(TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS)
            VALUES(?,?,?,?)
        """,(tbl.strip(), col.strip(), vtype.strip(), pars.strip()))
        self.connection.commit()
        self.load_validations()

    def remove_validation(self):
        row=self.dv_table.currentRow()
        if row<0:
            return
        vid=self.dv_table.item(row,0).text()
        confirm=QMessageBox.question(self,"Confirm",f"Remove validation ID={vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        self.load_validations()

    def run_all(self):
        # from the BFS code snippet => run all validations
        c=self.connection.cursor()
        c.execute("SELECT DISTINCT TABLE_NAME FROM DATA_VALIDATIONS")
        tabs=c.fetchall()
        fails=[]
        for (tab,) in tabs:
            pass_ok=run_data_validations_for_table(self.connection, tab.lower())
            if not pass_ok:
                fails.append(tab)
        if fails:
            QMessageBox.warning(self,"Validation Results",f"Some validations failed for: {fails}")
        else:
            QMessageBox.information(self,"Validation Results","All validations passed.")


###############################################################################
# 18) InlineEditingTab
###############################################################################
class InlineEditingTab(QWidget):
    """
    A table view for editing BRM_RULES in place => advanced QAbstractTableModel approach.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.model=_InlineEditModel(connection, user_id, user_group, self)
        layout=QVBoxLayout(self)
        self.table=QTableView()
        self.table.setModel(self.model)
        layout.addWidget(self.table)
        ref_btn=QPushButton("Refresh Data")
        ref_btn.clicked.connect(self.refresh_data)
        layout.addWidget(ref_btn)
        self.setLayout(layout)

    def refresh_data(self):
        self.model.fetch_data()
        # model will reset => table updates


class _InlineEditModel(QAbstractTableModel):
    """
    Model for inline editing RULE_ID, RULE_NAME, STATUS, OWNER_GROUP in BRM_RULES
    with locking checks, admin checks, etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.columns=["RULE_ID","RULE_NAME","STATUS","OWNER_GROUP"]
        self.data_rows=[]
        self.fetch_data()

    def fetch_data(self):
        self.beginResetModel()
        c=self.connection.cursor()
        c.execute("""
            SELECT TOP 200 RULE_ID,RULE_NAME,STATUS,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
        """)
        rows=c.fetchall()
        self.data_rows=[]
        for r_ in rows:
            d={"RULE_ID":r_[0], "RULE_NAME":r_[1], "STATUS":r_[2], "OWNER_GROUP":r_[3]}
            self.data_rows.append(d)
        self.endResetModel()

    def rowCount(self, parent=QModelIndex()):
        return len(self.data_rows)

    def columnCount(self, parent=QModelIndex()):
        return len(self.columns)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        row=index.row()
        col=index.column()
        colname=self.columns[col]
        val=self.data_rows[row][colname]
        if role in (Qt.DisplayRole,Qt.EditRole):
            return str(val) if val is not None else ""
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation==Qt.Horizontal and role==Qt.DisplayRole:
            return self.columns[section]
        return super().headerData(section, orientation, role)

    def flags(self, index):
        if not index.isValid():
            return Qt.ItemIsEnabled
        colname=self.columns[index.column()]
        if colname=="RULE_ID":
            return Qt.ItemIsEnabled|Qt.ItemIsSelectable
        return Qt.ItemIsEnabled|Qt.ItemIsSelectable|Qt.ItemIsEditable

    def setData(self, index, value, role=Qt.EditRole):
        if role==Qt.EditRole and index.isValid():
            row=index.row()
            col=index.column()
            colname=self.columns[col]
            old_val=self.data_rows[row][colname]
            new_val=value.strip() if isinstance(value,str) else value
            if new_val==old_val:
                return True
            rid=self.data_rows[row]["RULE_ID"]
            # attempt lock
            try:
                lock_rule_for_edit(self.connection, rid, self.user_id, force=False)
            except Exception as ex:
                QMessageBox.warning(None,"Lock Error",str(ex))
                return False

            # do update
            if not self.update_rule_in_db(rid, colname, new_val):
                # revert lock
                unlock_rule_for_edit(self.connection, rid, user_id=self.user_id, force=False)
                return False

            # unlock or keep locked => let's unlock
            try:
                unlock_rule_for_edit(self.connection, rid, user_id=self.user_id, force=False)
            except:
                pass

            self.data_rows[row][colname]=new_val
            self.dataChanged.emit(index,index,[Qt.DisplayRole,Qt.EditRole])
            return True
        return False

    def update_rule_in_db(self, rule_id, colname, new_val):
        c=self.connection.cursor()
        try:
            if colname=="RULE_NAME":
                c.execute("""
                    UPDATE BRM_RULES
                    SET RULE_NAME=?,UPDATED_BY=?,VERSION=VERSION+1
                    WHERE RULE_ID=?
                """,(new_val,str(self.user_id),rule_id))
            elif colname=="STATUS":
                if new_val.upper() not in ("ACTIVE","INACTIVE"):
                    QMessageBox.warning(None,"Invalid Value","Status must be ACTIVE or INACTIVE.")
                    return False
                c.execute("""
                    UPDATE BRM_RULES
                    SET STATUS=?,UPDATED_BY=?,VERSION=VERSION+1
                    WHERE RULE_ID=?
                """,(new_val.upper(),str(self.user_id),rule_id))
            elif colname=="OWNER_GROUP":
                # check permission => if user can assign to that group
                if self.user_group!="Admin" and new_val!=self.user_group:
                    QMessageBox.warning(None,"Denied",f"You cannot assign rule to group '{new_val}'.")
                    return False
                c.execute("""
                    UPDATE BRM_RULES
                    SET OWNER_GROUP=?,UPDATED_BY=?,VERSION=VERSION+1
                    WHERE RULE_ID=?
                """,(new_val,str(self.user_id),rule_id))
            else:
                return False
            self.connection.commit()
            return True
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(None,"DB Error",str(ex))
            return False


###############################################################################
# 19) SqlToBusinessLanguageConverterTab
###############################################################################
class SqlToBusinessLanguageConverterTab(QWidget):
    """
    Select a rule => input JSON => convert table/column references => display result
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Rule:"))
        self.rule_combo=QComboBox()
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)

        map_h=QHBoxLayout()
        map_h.addWidget(QLabel("Business Mapping (JSON):"))
        self.map_input=QPlainTextEdit()
        map_h.addWidget(self.map_input)
        layout.addLayout(map_h)

        conv_btn=QPushButton("Convert SQL")
        conv_btn.clicked.connect(self.convert_sql)
        layout.addWidget(conv_btn)

        layout.addWidget(QLabel("Output:"))
        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        self.setLayout(layout)
        self.load_rules()

    def load_rules(self):
        self.rule_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)

    def convert_sql(self):
        rid=self.rule_combo.currentData()
        if not rid:
            return
        c=self.connection.cursor()
        c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row or not row[0]:
            self.output.setPlainText("No SQL for that rule.")
            return
        sql_text=row[0]
        # parse
        parse_info=self._parse_sql_deps(sql_text)
        # load mapping
        try:
            mapping=json.loads(self.map_input.toPlainText())
        except:
            mapping={}
        converted=self._apply_mapping(sql_text, parse_info, mapping)
        self.output.setPlainText(converted)

    def _parse_sql_deps(self, sql_):
        # minimal parse => find FROM / JOIN => (schema,table)
        # you can integrate your advanced parser. Here is a naive approach:
        lines=re.split(r"\s+",sql_.upper())
        tables=[]
        if "FROM" in lines:
            idx=lines.index("FROM")
            if idx<len(lines)-1:
                t_ = lines[idx+1]
                if "." in t_:
                    parts=t_.split(".")
                    sch=parts[0]
                    tb=parts[1]
                    tables.append((sch,tb,"alias",False))
                else:
                    tables.append((None,t_,None,False))
        # not robust => but placeholder
        return {"tables":tables}

    def _apply_mapping(self, sql_text, parse_info, mapping):
        converted=sql_text
        for (sch,tb,al,sub) in parse_info["tables"]:
            key=(f"{sch}.{tb}" if sch else tb).strip(".")
            if key in mapping:
                converted=re.sub(r'\b'+re.escape(tb)+r'\b', mapping[key], converted, flags=re.IGNORECASE)
        return converted


###############################################################################
# 20) CollaborationManager
###############################################################################
class CollaborationManager(Qt.QObject):
    """
    Poll the DB every few seconds => find active locks => emit a signal locks_updated
    """
    locks_updated = Qt.pyqtSignal(list)

    def __init__(self, connection, poll_interval_ms=5000, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.timer=QTimer(self)
        self.timer.timeout.connect(self.poll_locks)
        self.timer.start(poll_interval_ms)

    def poll_locks(self):
        c=self.connection.cursor()
        try:
            c.execute("""
                SELECT RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
                FROM BRM_RULE_LOCKS
                WHERE ACTIVE_LOCK=1
            """)
            rows=c.fetchall()
            lock_list=[]
            for r_ in rows:
                lock_list.append((r_[0],r_[1],r_[2],r_[3],r_[4]))
            self.locks_updated.emit(lock_list)
        except Exception as ex:
            logging.error(f"Error polling locks: {ex}")


###############################################################################
# 21) CollaborationTab
###############################################################################
class CollaborationTab(QWidget):
    """
    Show which rules are locked, by whom, how long => Force unlock if admin
    """
    def __init__(self, connection, collab_manager, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.collab_manager=collab_manager
        layout=QVBoxLayout(self)

        top_lbl=QLabel("Live Collaboration: current rule locks")
        top_lbl.setStyleSheet("font-weight:bold; font-size:14px;")
        layout.addWidget(top_lbl)

        self.lock_table=QTableWidget(0,5)
        self.lock_table.setHorizontalHeaderLabels([
            "RuleID","LockedBy","LockTS","Expiry","ForceLock?"
        ])
        self.lock_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.lock_table)

        bh=QHBoxLayout()
        force_btn=QPushButton("Force Unlock Selected")
        force_btn.clicked.connect(self.do_force_unlock)
        bh.addWidget(force_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.collab_manager.locks_updated.connect(self.update_locks)

    def update_locks(self, lock_list):
        self.lock_table.setRowCount(0)
        for lk in lock_list:
            r_i=self.lock_table.rowCount()
            self.lock_table.insertRow(r_i)
            for cc,vv in enumerate(lk):
                self.lock_table.setItem(r_i,cc,QTableWidgetItem(str(vv) if vv else ""))

    def get_selected_rule_id(self):
        r=self.lock_table.currentRow()
        if r<0:
            return None
        it=self.lock_table.item(r,0)
        if it:
            return int(it.text())
        return None

    def do_force_unlock(self):
        rid=self.get_selected_rule_id()
        if not rid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force unlock rule {rid}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            unlock_rule_for_edit(self.connection, rid, user_id=None, force=True)
            QMessageBox.information(self,"Unlocked",f"Rule {rid} forcibly unlocked.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


###############################################################################
# 22) GroupSimulationDialog
###############################################################################
class GroupSimulationDialog(QDialog):
    """
    BFS from all rules in a custom group => skip validations or not
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Group BFS Simulation")
        self.resize(500,400)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Custom Group:"))
        self.grp_combo=QComboBox()
        top_h.addWidget(self.grp_combo)
        layout.addLayout(top_h)

        self.skip_val_cb=QCheckBox("Skip Data Validations?")
        layout.addWidget(self.skip_val_cb)

        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        bh=QHBoxLayout()
        run_btn=QPushButton("Run BFS")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_groups()

    def load_groups(self):
        self.grp_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
        for (gid,gn) in c.fetchall():
            disp=f"{gid} - {gn}"
            self.grp_combo.addItem(disp,gid)

    def do_sim(self):
        gid=self.grp_combo.currentData()
        skipv=self.skip_val_cb.isChecked()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        rules=[r[0] for r in c.fetchall()]
        if not rules:
            self.output.setPlainText("No rules in that group.")
            return
        exed,skp,failv = self.execute_rules_bfs(rules, skip_data_validation=skipv)
        txt=(
            f"Group BFS => groupID={gid}\n"
            f"Executed => {exed}\n"
            f"Skipped => {list(skp)}\n"
            f"FailedVal => {list(failv)}"
        )
        self.output.setPlainText(txt)

    def execute_rules_bfs(self, start_rules, skip_data_validation=False):
        """
        BFS => gather adjacency => run rule => if fail => skip children
        For demonstration, we do a minimal adjacency from BRM_RULES => PARENT_RULE_ID logic
        or from RULE_CONFLICTS, BRM_GLOBAL_CRITICAL_LINKS, etc.
        """
        adjacency, root_ids= self.load_rule_adjacency()
        visited=[]
        skipped=set()
        failed_val=set()

        queue = list(start_rules)
        while queue:
            rid=queue.pop(0)
            if rid in visited or rid in skipped:
                continue
            # optional data validations
            if not skip_data_validation:
                # check table deps => run_data_validations_for_table
                c2=self.connection.cursor()
                c2.execute("""
                    SELECT DISTINCT DATABASE_NAME,TABLE_NAME
                    FROM BRM_RULE_TABLE_DEPENDENCIES
                    WHERE RULE_ID=?
                """,(rid,))
                deps=c2.fetchall()
                valfail=False
                for (dbn,tbn) in deps:
                    if tbn:
                        fulln=(dbn+"."+tbn).lower()
                        pass_ok=run_data_validations_for_table(self.connection, fulln)
                        if not pass_ok:
                            valfail=True
                            failed_val.add(fulln)
                if valfail:
                    skipped.add(rid)
                    self.skip_descendants(rid, adjacency, skipped)
                    continue

            # run rule => we do a minimal approach => always pass
            visited.append(rid)
            # add children to queue
            if rid in adjacency:
                for ch in adjacency[rid]:
                    if ch not in visited and ch not in skipped:
                        queue.append(ch)
        return (visited, skipped, failed_val)

    def skip_descendants(self, start_id, adjacency, skipped):
        stack=[start_id]
        while stack:
            cur=stack.pop()
            if cur in skipped:
                continue
            skipped.add(cur)
            if cur in adjacency:
                for ch in adjacency[cur]:
                    if ch not in skipped:
                        stack.append(ch)

    def load_rule_adjacency(self):
        """
        Build adjacency => we combine PARENT_RULE_ID and any global link or conflicts if desired.
        """
        adjacency={}
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
        rows=c.fetchall()
        root_ids=[]
        all_ids=set()
        child_ids=set()
        for (rid,pid) in rows:
            all_ids.add(rid)
            if pid:
                adjacency.setdefault(pid,[]).append(rid)
                child_ids.add(rid)
        for rid in all_ids:
            if rid not in child_ids:
                root_ids.append(rid)
        return adjacency, root_ids


###############################################################################
# 23) ChainSimulationDialog
###############################################################################
class ChainSimulationDialog(QDialog):
    """
    BFS from a parent rule => run => skip or pass => optional validations
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Chain BFS Simulation")
        self.resize(500,400)
        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Select Parent Rule:"))
        self.rule_combo=QComboBox()
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)

        self.skip_cb=QCheckBox("Skip Data Validations?")
        layout.addWidget(self.skip_cb)

        self.output=QPlainTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        bh=QHBoxLayout()
        run_btn=QPushButton("Run BFS Chain")
        run_btn.clicked.connect(self.do_sim)
        bh.addWidget(run_btn)
        cb=QPushButton("Close")
        cb.clicked.connect(self.close)
        bh.addWidget(cb)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_rules()

    def load_rules(self):
        self.rule_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)

    def do_sim(self):
        rid=self.rule_combo.currentData()
        skipv=self.skip_cb.isChecked()
        exed,skp,fv=self.execute_bfs([rid], skip_data_validation=skipv)
        txt=(
            f"Chain BFS => start={rid}\n"
            f"Executed => {exed}\n"
            f"Skipped => {list(skp)}\n"
            f"FailedVal => {list(fv)}"
        )
        self.output.setPlainText(txt)

    def execute_bfs(self, starts, skip_data_validation=False):
        adjacency, roots = self.load_rule_adjacency()
        visited=[]
        skipped=set()
        failed_val=set()
        queue=list(starts)
        while queue:
            rr=queue.pop(0)
            if rr in visited or rr in skipped:
                continue
            # validations?
            if not skip_data_validation:
                c2=self.connection.cursor()
                c2.execute("""
                    SELECT DATABASE_NAME,TABLE_NAME
                    FROM BRM_RULE_TABLE_DEPENDENCIES
                    WHERE RULE_ID=?
                """,(rr,))
                deps=c2.fetchall()
                valfail=False
                for d_ in deps:
                    fulln=(d_[0]+"."+d_[1]).lower()
                    ok=run_data_validations_for_table(self.connection,fulln)
                    if not ok:
                        valfail=True
                        failed_val.add(fulln)
                if valfail:
                    skipped.add(rr)
                    self.skip_desc(rr, adjacency, skipped)
                    continue

            visited.append(rr)
            if rr in adjacency:
                for ch in adjacency[rr]:
                    if ch not in visited and ch not in skipped:
                        queue.append(ch)
        return (visited, skipped, failed_val)

    def skip_desc(self, rid, adjacency, skipped):
        stack=[rid]
        while stack:
            cur=stack.pop()
            if cur in skipped:
                continue
            skipped.add(cur)
            if cur in adjacency:
                for ch in adjacency[cur]:
                    if ch not in skipped:
                        stack.append(ch)

    def load_rule_adjacency(self):
        adjacency={}
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
        rows=c.fetchall()
        all_ids=set()
        child_ids=set()
        for r_ in rows:
            (rid,pid)=r_
            all_ids.add(rid)
            if pid:
                adjacency.setdefault(pid,[]).append(rid)
                child_ids.add(rid)
        roots=[x for x in all_ids if x not in child_ids]
        return adjacency, roots
# ----------------------------------------------------------------------------
# 1) LOGGING CONFIGURATION
# ----------------------------------------------------------------------------
# We can read from environment or a dictionary-based config. This example:
LOG_FILE = os.getenv("BRM_LOG_FILE", "brm_production.log")
LOG_LEVEL = os.getenv("BRM_LOG_LEVEL", "INFO")

LOG_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "detailed": {
            "format": "%(asctime)s [%(levelname)s] %(name)s - %(message)s"
        }
    },
    "handlers": {
        "file": {
            "class": "logging.FileHandler",
            "filename": LOG_FILE,
            "formatter": "detailed",
            "level": LOG_LEVEL
        },
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "detailed",
            "level": LOG_LEVEL
        }
    },
    "root": {
        "handlers": ["file","console"],
        "level": LOG_LEVEL
    }
}

logging.config.dictConfig(LOG_CONFIG)
logger = logging.getLogger("brm_core_foundation")

# ----------------------------------------------------------------------------
# 2) EMAIL NOTIFIER (ADVANCED)
# ----------------------------------------------------------------------------
class EmailNotifier:
    """
    Sends emails via SMTP with environment-based config overrides.
    Supports TLS for secure sending.
    """
    def __init__(self):
        self.smtp_server = os.getenv("BRM_SMTP_SERVER", "smtp.example.com")
        self.smtp_port = int(os.getenv("BRM_SMTP_PORT", "587"))
        self.smtp_username = os.getenv("BRM_SMTP_USERNAME", "smtp_user")
        self.smtp_password = os.getenv("BRM_SMTP_PASSWORD", "smtp_pass")
        self.sender_email = os.getenv("BRM_SENDER_EMAIL", "noreply@example.com")

    def send_email(self, subject: str, body: str, recipients: list):
        if not recipients:
            logger.warning("EmailNotifier: No recipients provided.")
            return
        try:
            msg = MIMEText(body, 'plain', 'utf-8')
            msg['Subject'] = subject
            msg['From'] = self.sender_email
            msg['To'] = ", ".join(recipients)

            smtp = smtplib.SMTP(self.smtp_server, self.smtp_port)
            smtp.starttls()
            smtp.login(self.smtp_username, self.smtp_password)
            smtp.sendmail(self.sender_email, recipients, msg.as_string())
            smtp.quit()
            logger.info(f"Email sent to {recipients}")
        except Exception as e:
            logger.error(f"Error sending email to {recipients}: {e}")
            raise

# ----------------------------------------------------------------------------
# 3) DATABASE CONNECTION DIALOG (Enhanced UI)
# ----------------------------------------------------------------------------
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Allows user to pick an ODBC DSN or enter a custom connection string.
    On accept, we store the pyodbc connection in self.connection.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("DB Connection – Advanced BRM")
        self.resize(450, 220)

        main_layout = QVBoxLayout(self)

        desc_label = QLabel(
            "Select a SQL Server ODBC DSN or enter a custom ODBC connection string.\n"
            "If using a DSN, you must have it configured in your OS ODBC settings."
        )
        desc_label.setWordWrap(True)
        main_layout.addWidget(desc_label)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            # Filter only those that have "SQL SERVER" or "SQL" in the driver.
            for dsn_name, driver in dsn_dict.items():
                if "SQL" in driver.upper():
                    self.dsn_combo.addItem(f"DSN: {dsn_name}", dsn_name)
        except Exception as ex:
            logger.error(f"Error enumerating DSNs: {ex}")
        main_layout.addWidget(self.dsn_combo)

        self.conn_str_edit = QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string here (optional)")
        main_layout.addWidget(self.conn_str_edit)

        btn_h = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)

        main_layout.addLayout(btn_h)
        self.setLayout(main_layout)

    def get_connection(self):
        """
        After the dialog is accepted, call this to retrieve the pyodbc connection.
        """
        custom_str = self.conn_str_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            dsn_selected = self.dsn_combo.currentData()
            if not dsn_selected:
                QMessageBox.critical(self, "Error", "No DSN or custom connection provided.")
                return None
            conn_str = f"DSN={dsn_selected};Trusted_Connection=yes;"

        try:
            conn = pyodbc.connect(conn_str)
            logger.info("Database connection established successfully.")
            return conn
        except Exception as ex:
            QMessageBox.critical(self, "DB Connection Error", str(ex))
            logger.error(f"Connection failed: {ex}")
            return None

    def accept(self):
        test_cxn = self.get_connection()
        if test_cxn:
            self.connection = test_cxn
            super().accept()
        else:
            # stay open
            pass

# ----------------------------------------------------------------------------
# 4) DATABASE HELPERS
# ----------------------------------------------------------------------------
def fetch_all_dict(cursor):
    """
    Fetch all rows into a list of dict. If cursor.description is None => raw rows.
    """
    rows = cursor.fetchall()
    if cursor.description:
        colnames = [d[0] for d in cursor.description]
        out = []
        for r_ in rows:
            out.append(dict(zip(colnames, r_)))
        return out
    else:
        return rows

def fetch_one_dict(cursor):
    """
    Fetch a single row as dict, or None if no row.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        cols = [d[0] for d in cursor.description]
        return dict(zip(cols, row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert an audit record. old_data/new_data can be dict => store as JSON.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG (
                ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, 
                OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES (?,?,?,?,?,?,GETDATE())
        """, (
            action,
            table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"Audit inserted => action={action}, table={table_name}, rec_id={record_id}, user={actor}")
    except Exception as ex:
        logger.error(f"Error inserting audit log: {ex}")

# ----------------------------------------------------------------------------
# 5) ADVANCED PASSWORD HANDLING (Hash-based)
# ----------------------------------------------------------------------------
def hash_password(plain_text: str, salt: str = "SOME_SALT"):
    """
    Simple SHA256-based hashing for demonstration.
    Production should use a better approach (bcrypt, argon2, etc.).
    """
    # Combine salt + plain
    to_hash = (salt + plain_text).encode("utf-8")
    return hashlib.sha256(to_hash).hexdigest()

# ----------------------------------------------------------------------------
# 6) LOGIN DIALOG (SECURE)
# ----------------------------------------------------------------------------
class LoginDialog(QtWidgets.QDialog):
    """
    Secure login => fetch hashed password from DB => compare with hash_password.
    We store user_id, user_group if success.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login – BRM Tool")
        self.resize(330, 160)

        main_layout = QVBoxLayout(self)

        main_layout.addWidget(QLabel("Username:"))
        self.user_edit = QLineEdit()
        main_layout.addWidget(self.user_edit)

        main_layout.addWidget(QLabel("Password:"))
        self.pass_edit = QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        main_layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        main_layout.addWidget(btn)

        self.setLayout(main_layout)

    def do_login(self):
        un = self.user_edit.text().strip()
        pw = self.pass_edit.text().strip()
        if not un or not pw:
            QMessageBox.warning(self, "Error", "Please enter both username and password.")
            return
        # Hash the input password
        hashed_input = hash_password(pw, salt="SOME_SALT")

        # check DB
        try:
            c = self.connection.cursor()
            c.execute("""
                SELECT USER_ID, PASSWORD, USER_GROUP
                FROM USERS
                WHERE USERNAME=?
            """,(un,))
            row = c.fetchone()
            if not row:
                QMessageBox.warning(self, "Login Failed", "User not found.")
                return
            user_id_db, stored_hash, user_grp_db = row
            if stored_hash == hashed_input:
                self.user_id = user_id_db
                self.user_group = user_grp_db
                logger.info(f"User '{un}' logged in. user_id={self.user_id}, group={self.user_group}")
                self.accept()
            else:
                QMessageBox.warning(self, "Login Failed", "Incorrect password.")
        except Exception as ex:
            QMessageBox.critical(self, "DB Error", str(ex))

# ----------------------------------------------------------------------------
# 7) LOCK MANAGER (advanced)
# ----------------------------------------------------------------------------
class LockManager:
    """
    Provides advanced locking with expiry.
    We assume a table BRM_RULE_LOCKS with columns:
      LOCK_ID, RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
    """
    @staticmethod
    def auto_unlock_expired_locks(conn):
        """
        Freed up locks that are past expiry.
        """
        now = datetime.now()
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE ACTIVE_LOCK=1
              AND EXPIRY_TIMESTAMP < ?
        """,(now,))
        rowcount = c.rowcount
        conn.commit()
        if rowcount>0:
            logger.debug(f"Auto-unlocked {rowcount} expired locks.")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        """
        Return (locked_by, lock_ts, expiry_ts, force_flag) or None if not locked or expired.
        Also auto-deactivate if expired.
        """
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lts, expiry, fflag, act = row
        if not act:
            return None
        if expiry and datetime.now() > expiry:
            # expire it
            c2 = conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE RULE_ID=? AND ACTIVE_LOCK=1
            """,(rule_id,))
            conn.commit()
            return None
        return (locked_by, lts, expiry, fflag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        """
        Attempt to lock a rule.
        If locked by same user => refresh expiry
        If locked by another => raise, unless force => override.
        """
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)
        c = conn.cursor()

        if info:
            locked_by, old_ts, old_exp, fflag = info
            if locked_by == user_id:
                # refresh
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """,(now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"Lock refreshed by user {user_id} => rule {rule_id}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by {locked_by}.")
                else:
                    # forcibly override
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """,(rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
                        VALUES(?,?,?,?,?,1)
                    """,(rule_id, user_id, now, expiry, 1 if force else 0))
                    conn.commit()
                    logger.debug(f"Rule {rule_id} forcibly locked by {user_id}.")
        else:
            # not locked => create new
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK)
                VALUES(?,?,?,?,?,1)
            """,(rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"Rule {rule_id} locked by user {user_id}, force={force}")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        """
        Unlock => if user_id != locked_by => fail unless force.
        """
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return
        locked_by, lts, exp, ff = info
        if locked_by != user_id and not force:
            raise ValueError(f"Cannot unlock => locked by {locked_by}.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """,(rule_id,))
        conn.commit()
        logger.debug(f"Rule {rule_id} unlocked by {user_id}, force={force}.")

# ----------------------------------------------------------------------------
# 8) ADVANCED SQL PARSING
# ----------------------------------------------------------------------------
def detect_operation_type(sql_text: str)->str:
    """
    Return "INSERT","UPDATE","DELETE","SELECT","OTHER" based on first keyword.
    """
    st = sql_text.strip().upper()
    if st.startswith("INSERT"):
        return "INSERT"
    elif st.startswith("UPDATE"):
        return "UPDATE"
    elif st.startswith("DELETE"):
        return "DELETE"
    elif st.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"

def parse_sql_dependencies(sql_text: str):
    """
    Parse an SQL string => identify table references, columns, cte usage, etc.
    Return a dict => { "tables": [(schema,table,alias,is_sub)] , "columns": [], "cte_tables": [], "alias_map":{} }
    """
    statements = sqlparse.parse(sql_text)
    all_tables = []
    cte_info = []
    alias_map = {}
    columns = []

    for stmt in statements:
        # extract ctes
        ctes = _extract_with_clauses(stmt)
        for cname, crefs in ctes.items():
            cte_info.append((cname,crefs))

        main_refs, main_alias = _extract_main_from(stmt.tokens, set(ctes.keys()))
        all_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs = _extract_columns(stmt)
        columns.extend(col_refs)

    # remove duplicates
    unique_tables = list({x for x in all_tables})

    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": columns
    }

def _extract_with_clauses(statement):
    from sqlparse.tokens import Keyword
    cte_map={}
    tokens = list(statement.tokens)
    i=0
    while i<len(tokens):
        tk = tokens[i]
        if tk.ttype is Keyword and tk.value.upper()=="WITH":
            i+=1
            i=_parse_cte_block(tokens,i,cte_map)
            continue
        i+=1
    return cte_map

def _parse_cte_block(tokens, i, cte_map):
    from sqlparse.sql import Identifier
    from sqlparse.tokens import Keyword
    while i<len(tokens):
        tk=tokens[i]
        if isinstance(tk, Identifier):
            cte_name = tk.get_real_name()
            i+=1
            i=_parse_cte_as_clause(tokens,i,cte_name,cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i+=1
    return i

def _parse_cte_as_clause(tokens, i, cte_name, cte_map):
    from sqlparse.sql import Parenthesis
    while i<len(tokens):
        tk=tokens[i]
        if tk.value.upper()=="AS":
            i+=1
            if i<len(tokens):
                sub=tokens[i]
                if isinstance(sub, Parenthesis):
                    subrefs=_extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name]=subrefs
                    i+=1
                    return i
        else:
            i+=1
    return i

def _extract_subselect_tokens(tokens):
    from sqlparse.sql import IdentifierList, Identifier
    from sqlparse.tokens import Keyword, DML
    results=[]
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if hasattr(tk,"is_group") and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            up=tk.value.upper()
            if up in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk,IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, set())
                    st=(st[0],st[1],st[2],True)
                    results.append(st)
            elif isinstance(tk,Identifier):
                st=_parse_identifier(tk,set())
                st=(st[0],st[1],st[2],True)
                results.append(st)
        i+=1
    return results

def _is_subselect(token):
    from sqlparse.tokens import DML
    if not token.is_group:
        return False
    for t_ in token.tokens:
        if t_.ttype is DML and t_.value.upper()=="SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_ctes):
    from sqlparse.tokens import Keyword
    from sqlparse.sql import IdentifierList, Identifier
    results=[]
    alias_map={}
    tokens=list(tokenlist)
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if hasattr(tk,"is_group") and tk.is_group and _is_subselect(tk):
            results.extend(_extract_subselect_tokens(tk.tokens))
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk,IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, known_ctes)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]]=(st[0],st[1])
            elif isinstance(tk,Identifier):
                st=_parse_identifier(tk, known_ctes)
                results.append(st)
                if st[2]:
                    alias_map[st[2]]=(st[0],st[1])
        i+=1
    return (results, alias_map)

def _parse_identifier(ident, known_cte_names):
    alias=ident.get_alias()
    real_name=ident.get_real_name()
    schema_name=ident.get_parent_name()
    if real_name and real_name.upper() in (k.upper() for k in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    """
    Return list of (colName, isWrite, isRead).
    We'll do a simpler approach: parse DML for SELECT => read, UPDATE/INSERT => write, etc.
    """
    from sqlparse.tokens import DML
    results=[]
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is DML:
            upv=tk.value.upper()
            if upv=="SELECT":
                # parse select list
                csel=_parse_select_list(tokens,i+1)
                for c_ in csel:
                    results.append((c_,False,True))
            elif upv in ("INSERT","UPDATE","DELETE"):
                # for demonstration, everything is write
                # we skip column-level logic if time-limited
                results.append((f"{upv}_OP",True,False))
        i+=1
    return results

def _parse_select_list(tokens, start_i):
    from sqlparse.sql import IdentifierList, Identifier
    from sqlparse.tokens import Keyword
    columns=[]
    i=start_i
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword:
            up=tk.value.upper()
            if up in ("FROM","WHERE","GROUP","ORDER","JOIN","UNION","INTERSECT"):
                break
        if isinstance(tk,IdentifierList):
            for ident in tk.get_identifiers():
                nm=ident.get_name()
                if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(nm)
        elif isinstance(tk,Identifier):
            nm=tk.get_name()
            if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(nm)
        i+=1
    return columns

# ----------------------------------------------------------------------------
# 9) OPTIONAL: ONBOARDING WIZARD
# ----------------------------------------------------------------------------
class OnboardingWizard(QDialog):
    """
    A simple multi-step wizard for new users.
    Step 1 => create group, step 2 => create rule, step 3 => create schedule
    You can skip if not needed.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.current_step=0
        self.setWindowTitle("Onboarding Wizard – BRM")
        self.resize(400, 250)
        main_l= QVBoxLayout(self)
        self.label= QLabel("Welcome to the Onboarding Wizard!")
        main_l.addWidget(self.label)
        self.next_btn= QPushButton("Next")
        self.next_btn.clicked.connect(self.next_step)
        main_l.addWidget(self.next_btn)
        self.setLayout(main_l)

    def next_step(self):
        self.current_step+=1
        if self.current_step==1:
            self.label.setText("Step 1: In 'Group Management' tab, create a new group.")
        elif self.current_step==2:
            self.label.setText("Step 2: In 'Business Rules' tab, create your first rule.")
        elif self.current_step==3:
            self.label.setText("Step 3: In 'Scheduling' tab, create a schedule.")
        else:
            self.label.setText("All done! Enjoy the BRM Tool.")
            self.accept()

# ----------------------------------------------------------------------------
# 10) sync_metadata_improved (Placeholder if needed)
# ----------------------------------------------------------------------------
def sync_metadata_improved(connection):
    """
    Example function that checks sys.tables vs BRM_RULE_TABLE_DEPENDENCIES
    and sets 'MISSING_' for those that don't exist.
    Real logic can vary.
    Return a message summarizing results.
    """
    try:
        c=connection.cursor()
        c.execute("""
            SELECT s.name AS schema_name, t.name AS table_name
            FROM sys.tables t
            JOIN sys.schemas s ON t.schema_id=s.schema_id
        """)
        actual_tables=set()
        for row in c.fetchall():
            fulln=(row[0]+"."+row[1]).lower()
            actual_tables.add(fulln)

        c2=connection.cursor()
        c2.execute("""
            SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME
            FROM BRM_RULE_TABLE_DEPENDENCIES
        """)
        deps=c2.fetchall()
        missing_count=0
        for (dep_id, dbn, tbn) in deps:
            if not tbn:
                continue
            candidate=(dbn+"."+tbn).lower().strip(".")
            if candidate not in actual_tables:
                c3=connection.cursor()
                c3.execute("""
                    UPDATE BRM_RULE_TABLE_DEPENDENCIES
                    SET TABLE_NAME='MISSING_'+TABLE_NAME
                    WHERE DEPENDENCY_ID=?
                """,(dep_id,))
                missing_count+=1
        connection.commit()

        msg=(
            f"Metadata sync complete.\n"
            f"Found {len(actual_tables)} real DB tables.\n"
            f"Scanned {len(deps)} dependencies.\n"
            f"Marked {missing_count} references as missing."
        )
        logger.info(msg)
        return msg
    except Exception as ex:
        logger.error(f"sync_metadata_improved error: {ex}")
        return f"Error during metadata sync: {ex}"
#!/usr/bin/env python
# -*- coding: utf-8 -*-



import sys
import json
import time
import logging
from datetime import datetime
from collections import deque

import pyodbc
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QLineEdit, QMessageBox, QComboBox, QDialog, QPlainTextEdit
)
from PyQt5.QtCore import Qt, QTimer




def run_single_validation(conn, validation_id):
    c = conn.cursor()
    c.execute("""
        SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
        FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?
    """, (validation_id,))
    row = c.fetchone()
    if not row:
        logger.error(f"Validation rule not found (ID={validation_id}).")
        return (False, f"Validation rule not found (ID={validation_id}).")
    vid, tbl, col, vtype, params = row
    try:
        result = _execute_validation_check(conn, tbl, col, vtype, params)
    except Exception as ex:
        result = (False, str(ex))
    c2 = conn.cursor()
    res_flag = "PASS" if result[0] else "FAIL"
    c2.execute("""
        INSERT INTO DATA_VALIDATION_LOGS(VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP, TABLE_NAME, COLUMN_NAME)
        VALUES(?, ?, ?, GETDATE(), ?, ?)
    """, (vid, res_flag, result[1], tbl, col))
    conn.commit()
    return result

def _execute_validation_check(conn, table_name, column_name, validation_type, params):
    vtype = validation_type.upper().strip()
    c = conn.cursor()
    if not table_name or not column_name:
        return (False, "Invalid table/column.")
    if vtype == "NOT NULL":
        c.execute(f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} IS NULL")
        cnt = c.fetchone()[0]
        return (cnt == 0, f"{cnt} NULL values found in {table_name}.{column_name}" if cnt > 0 else "No NULLs found.")
    elif vtype == "RANGE":
        parts = params.split(",")
        if len(parts) != 2:
            return (False, "Invalid range parameters; expected format 'min,max'.")
        try:
            min_val, max_val = float(parts[0]), float(parts[1])
        except:
            return (False, "Range parameters must be numeric.")
        c.execute(f"SELECT COUNT(*) FROM {table_name} WHERE {column_name} < {min_val} OR {column_name} > {max_val}")
        out_of_range = c.fetchone()[0]
        return (out_of_range == 0, f"{out_of_range} values out of range [{min_val}, {max_val}]." if out_of_range > 0 else "All values within range.")
    elif vtype == "REGEX":
        pattern = re.compile(params or ".*")
        c.execute(f"SELECT {column_name} FROM {table_name}")
        rows = c.fetchall()
        mismatch = 0
        for (val,) in rows:
            if val is None or not pattern.match(str(val)):
                mismatch += 1
        return (mismatch == 0, f"{mismatch} rows did not match regex '{params}'." if mismatch > 0 else "All rows matched regex.")
    else:
        return (False, f"Unknown validation type '{validation_type}'.")

def run_validations_for_table(conn, table_name):
    c = conn.cursor()
    c.execute("SELECT VALIDATION_ID FROM DATA_VALIDATIONS WHERE LOWER(TABLE_NAME)=LOWER(?)", (table_name,))
    results = []
    for (vid,) in c.fetchall():
        results.append(run_single_validation(conn, vid))
    return results

def run_all_validations(conn):
    c = conn.cursor()
    c.execute("SELECT VALIDATION_ID FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
    results = []
    for (vid,) in c.fetchall():
        pf, dt = run_single_validation(conn, vid)
        c2 = conn.cursor()
        c2.execute("SELECT TABLE_NAME, COLUMN_NAME FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
        row = c2.fetchone()
        tbl, col = (row[0], row[1]) if row else ("?", "?")
        results.append((vid, tbl, col, pf, dt))
    return results

def run_validations_for_rule(conn, rule_id):
    c = conn.cursor()
    c.execute("SELECT DISTINCT DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_id,))
    all_pass = True
    fail_details = []
    for (dbn, tbn) in c.fetchall():
        if not tbn:
            continue
        fulltbl = f"{dbn}.{tbn}".lower()
        table_results = run_validations_for_table(conn, fulltbl)
        for (vid, pf, dt) in [(r[0], r[3], r[4]) for r in run_all_validations(conn) if r[1].lower() == fulltbl]:
            if not pf:
                all_pass = False
                fail_details.append((vid, dt))
    return (all_pass, fail_details)

class DataValidationManagerTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.init_ui()
        self.load_validations()
    def init_ui(self):
        layout = QVBoxLayout(self)
        self.val_table = QTableWidget(0, 5)
        self.val_table.setHorizontalHeaderLabels(["ValidationID", "TableName", "ColumnName", "Type", "Params"])
        self.val_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.val_table)
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        btn_h.addWidget(add_btn)
        del_btn = QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_validation)
        btn_h.addWidget(del_btn)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all)
        btn_h.addWidget(run_btn)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_validations)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
    def load_validations(self):
        self.val_table.setRowCount(0)
        c = self.connection.cursor()
        c.execute("SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS FROM DATA_VALIDATIONS ORDER BY VALIDATION_ID")
        for row in c.fetchall():
            r_i = self.val_table.rowCount()
            self.val_table.insertRow(r_i)
            for col, val in enumerate(row):
                self.val_table.setItem(r_i, col, QTableWidgetItem(str(val) if val is not None else ""))
    def add_validation(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Table name (e.g., 'dbo.Customers'):")
        if not ok or not tbl.strip():
            return
        col, ok2 = QInputDialog.getText(self, "Column", "Column name:")
        if not ok2 or not col.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "(NOT NULL, RANGE, REGEX, ...)")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Params", "Example for RANGE: '0,100' / for REGEX: '^[A-Z]+$'")
        params = params.strip() if ok4 else ""
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP) VALUES(?,?,?,?,GETDATE())", (tbl.strip(), col.strip(), vtype.strip(), params))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Validation rule added.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def remove_validation(self):
        row = self.val_table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "None", "No validation selected.")
            return
        vid_item = self.val_table.item(row, 0)
        if not vid_item:
            return
        vid = int(vid_item.text())
        if QMessageBox.question(self, "Confirm", f"Remove validation ID={vid}?") != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Validation rule removed.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
    def run_all(self):
        results = run_all_validations(self.connection)
        fails = [r for r in results if not r[3]]
        if fails:
            fail_str = "\n".join([f"ID={f[0]} => {f[4]}" for f in fails])
            QMessageBox.warning(self, "Validation Results", f"Some validations failed:\n{fail_str}")
        else:
            QMessageBox.information(self, "Validation Results", "All validations passed.")


###############################################################################
# PERMISSIONS (TABLE-LEVEL)
###############################################################################
def user_has_table_permission(conn, user_group, table_name):
    """
    Check if `user_group` can access `table_name`.
    If we store it in GROUP_PERMISSIONS (GROUP_NAME, TARGET_TABLE).
    Return True if permitted, else False.
    """
    c = conn.cursor()
    c.execute("""
        SELECT 1
        FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME=? AND LOWER(TARGET_TABLE)=LOWER(?)
    """,(user_group, table_name.lower()))
    row = c.fetchone()
    return bool(row)

def enforce_permissions_for_rule_sql(conn, user_group, sql_text):
    """
    Parse the rule’s SQL => gather all table references => check if group has permission.
    Raise ValueError if any violation found.
    """
    info = parse_sql_dependencies(sql_text)
    for (schema, table, alias, is_sub) in info.get("tables",[]):
        if table and not table.startswith("(CTE)"):
            sch = schema if schema else "dbo"
            full_table = f"{sch}.{table}".lower()
            if not user_has_table_permission(conn, user_group, full_table):
                raise ValueError(f"Group {user_group} has no permission for table: {full_table}.")


###############################################################################
# BFS LOGIC (CHILD, GLOBAL-CRITICAL, CONFLICTS, COMPOSITE)
###############################################################################
def load_rule_relationships(conn):
    """
    Return adjacency dict => rid => set of children. Also a parent_map => rid => parent_rid
    Also gather GCR links, conflicts, composites as adjacency.
    """
    adjacency = {}
    parent_map = {}
    all_ids = set()

    c = conn.cursor()
    # 1) child relationship (BRM_RULES.PARENT_RULE_ID => RULE_ID)
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            parent_map[rid] = pid

    # 2) global-critical (BRM_GLOBAL_CRITICAL_LINKS => GCR_RULE_ID => TARGET_RULE_ID)
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    for (gcr, trg) in c.fetchall():
        adjacency.setdefault(gcr, set()).add(trg)

    # 3) conflicts (RULE_CONFLICTS => both directions if we want?)
    c.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
    for (r1, r2, pri) in c.fetchall():
        adjacency.setdefault(r1, set()).add(r2)
        # optionally r2 => r1 if conflict is symmetrical

    # 4) composites (COMPOSITE_RULES => parse "RuleX" references in LOGIC_EXPR => adjacency from sub => composite)
    import re
    pat = re.compile(r"Rule(\d+)", re.IGNORECASE)
    c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
    comp_rows = c.fetchall()
    for (cid, expr) in comp_rows:
        if expr:
            matches = pat.findall(expr)
            for m_ in matches:
                try:
                    sub_id=int(m_)
                    adjacency.setdefault(sub_id, set()).add(cid)
                except:
                    pass

    # find root IDs => those that are not a child of anything
    # (we’ll handle BFS from specific start rules or all roots if needed)
    return adjacency, parent_map


def gather_all_related_rule_ids(conn, start_rule_id):
    """
    BFS from start_rule_id => gather all reachable.
    Adjacency includes child, gcr, conflict, composite, etc.
    """
    adjacency, pmap = load_rule_relationships(conn)
    visited = set()
    queue = [start_rule_id]
    while queue:
        rid = queue.pop(0)
        if rid in visited:
            continue
        visited.add(rid)
        if rid in adjacency:
            for ch in adjacency[rid]:
                if ch not in visited:
                    queue.append(ch)
    return visited

###############################################################################
# DATA VALIDATIONS IN BFS (OPTIONAL)
###############################################################################
def run_data_validations_for_bfs(conn, rule_ids):
    """
    For a list of rule IDs, gather their tables, run validations on each.
    Return (validated_tables, failed_tables).
    """
    validated = set()
    failed = set()
    # gather all tables from all rule_ids
    c=conn.cursor()
    placeholders=",".join("?" for _ in rule_ids)
    if not placeholders:
        return (validated, failed)
    c.execute(f"""
        SELECT DISTINCT DATABASE_NAME, TABLE_NAME
        FROM BRM_RULE_TABLE_DEPENDENCIES
        WHERE RULE_ID IN ({placeholders})
    """, tuple(rule_ids))
    rows=c.fetchall()
    # run validations
    for (dbn,tbn) in rows:
        if not tbn:
            continue
        fulln=f"{dbn}.{tbn}".lower()
        # Suppose we do run_data_validations_for_table(...) from the data validations module
        #from brm_data_validations import run_data_validations_for_table
        result_ok = True
        validations_result = run_data_validations_for_table(conn, fulln)
        # That returns a list of (validationID, pass_flag, detail), or something similar
        for (vID, passflag, detail) in validations_result:
            if not passflag:
                result_ok=False
        if result_ok:
            validated.add(fulln)
        else:
            failed.add(fulln)
    return (validated, failed)

###############################################################################
# BFS EXECUTION
###############################################################################
def run_single_rule(conn, rule_id, is_dry_run=False):
    """
    Execute the rule’s SQL. If the first row’s first col is 1 => pass, else fail => rollback if fail or dry_run.
    Return (ok_flag, message, record_count, elapsed_ms).
    Also insert into RULE_EXECUTION_LOGS.
    """
    c=conn.cursor()
    c.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row=c.fetchone()
    if not row or not row[0]:
        return (False, "No SQL present", 0, 0)
    sql_ = row[0]
    start_time = time.time()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    rec_count=0
    try:
        c.execute(sql_)
        rows = c.fetchall()
        rec_count = len(rows)
        if rows:
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"

        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")

    except Exception as ex:
        c.execute("ROLLBACK")
        success=False
        msg=str(ex)

    elapsed_ms=int((time.time()-start_time)*1000)

    # insert rule_execution_logs
    c2=conn.cursor()
    c2.execute("""
        INSERT INTO RULE_EXECUTION_LOGS(
            RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS
        )
        VALUES(?,GETDATE(),?,?,?,?)
    """,(rule_id, 1 if success else 0, msg, rec_count, elapsed_ms))
    conn.commit()
    return (success, msg, rec_count, elapsed_ms)


def execute_rules_bfs(conn, start_rule_ids, skip_data_validation=False):
    """
    BFS from the given start_rule_ids => gather all reachable => for each, run rule.
    If data_validation is not skipped, run validations on each rule's tables first.
    If any fail => skip that rule and its children.
    Return (executed_rules, skipped_rules, failed_validation_tables).
    """
    adjacency, pmap = load_rule_relationships(conn)
    visited=set()
    skipped=set()
    failed_val_tables=set()
    executed=[]

    queue=list(start_rule_ids)
    while queue:
        rid=queue.pop(0)
        if rid in visited or rid in skipped:
            continue

        # run data validations if not skipping
        if not skip_data_validation:
            # gather tables
            c2=conn.cursor()
            c2.execute("""
                SELECT DATABASE_NAME, TABLE_NAME
                FROM BRM_RULE_TABLE_DEPENDENCIES
                WHERE RULE_ID=?
            """,(rid,))
            trows=c2.fetchall()
            val_failed=False
            #from brm_data_validations import run_data_validations_for_table
            for (dbn,tbn) in trows:
                if not tbn:
                    continue
                fulln=(dbn+"."+tbn).lower()
                pass_ok = True
                vresults = run_data_validations_for_table(conn, fulln)
                for (vid, pflag, detail) in vresults:
                    if not pflag:
                        pass_ok=False
                        failed_val_tables.add(fulln)
                if not pass_ok:
                    val_failed=True
                    break
            if val_failed:
                skipped.add(rid)
                # skip children
                if rid in adjacency:
                    for ch in adjacency[rid]:
                        if ch not in skipped:
                            skip_bfs_descendants(ch, adjacency, skipped)
                continue

        # run rule
        (ok, msg, rc, elapsed)=run_single_rule(conn, rid, is_dry_run=False)
        if ok:
            executed.append(rid)
            visited.add(rid)
            # add children
            if rid in adjacency:
                for ch in adjacency[rid]:
                    if ch not in visited and ch not in skipped:
                        queue.append(ch)
        else:
            # if fail => skip children
            visited.add(rid)
            skipped.add(rid)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_bfs_descendants(ch, adjacency, skipped)

    return (executed, skipped, failed_val_tables)

def skip_bfs_descendants(start_id, adjacency, skip_set):
    stack=[start_id]
    while stack:
        cur=stack.pop()
        if cur in skip_set:
            continue
        skip_set.add(cur)
        if cur in adjacency:
            for ch in adjacency[cur]:
                if ch not in skip_set:
                    stack.append(ch)

###############################################################################
# ADVANCED CRUD (Add, Update, Delete) + Lifecycle + Approvals
###############################################################################
def create_multistep_approvals(conn, rule_id):
    """
    Insert rows into BRM_RULE_APPROVALS for multi-level pipeline.
    This can be dynamic based on references or your design.
    For demonstration, we do a static approach: BG1 => BG2 => FINAL.
    """
    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))

    # Suppose BG1 => stage1
    c.execute("""
        INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
        VALUES(?,?,?,0,1)
    """,(rule_id, "BG1", "approver_bg1",))

    # BG2 => stage2
    c.execute("""
        INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
        VALUES(?,?,?,0,2)
    """,(rule_id, "BG2", "approver_bg2",))

    # final
    c.execute("""
        INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE)
        VALUES(?,?,?,0,3)
    """,(rule_id, "FINAL", "final_approver",))

    conn.commit()
    logger.debug(f"Multistep approvals created for rule {rule_id}.")


def add_rule(conn, rule_data, created_by_user_id, created_by_group):
    """
    Insert new rule => parse dependencies => set lifecycle=DRAFT => create approvals =>
    enforce table-level permissions => lock/unlock is not needed for brand new rule.
    `rule_data` might have keys: RULE_NAME, RULE_SQL, OWNER_GROUP, ...
    Return new_rule_id.
    """
    rule_sql = rule_data.get("RULE_SQL","").strip()
    if rule_sql:
        # check permissions
        enforce_permissions_for_rule_sql(conn, created_by_group, rule_sql)
    # parse dependencies
    deps = parse_sql_dependencies(rule_sql)
    op_type = detect_operation_type(rule_sql)

    c=conn.cursor()
    # check duplicates by name in that group
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?",
        (rule_data["OWNER_GROUP"], rule_data["RULE_NAME"].strip()))
    row_check = c.fetchone()
    if row_check:
        raise ValueError("Duplicate rule name in that group.")

    # insert
    c.execute("""
        INSERT INTO BRM_RULES(
            RULE_NAME, RULE_SQL, OWNER_GROUP, CREATED_BY,
            STATUS, VERSION, LIFECYCLE_STATE, OPERATION_TYPE, APPROVAL_STATUS, 
            IS_GLOBAL, CRITICAL_RULE, BUSINESS_JUSTIFICATION, CREATED_TIMESTAMP
        )
        OUTPUT inserted.RULE_ID
        VALUES(?,?,?,?,?,  ?,?,?,?,  ?,?,?, GETDATE())
    """,(
        rule_data["RULE_NAME"].strip(),
        rule_sql,
        rule_data["OWNER_GROUP"],
        str(created_by_user_id),

        "INACTIVE", 1, "DRAFT", op_type, "APPROVAL_IN_PROGRESS",
        rule_data.get("IS_GLOBAL",0), rule_data.get("CRITICAL_RULE",0),
        rule_data.get("BUSINESS_JUSTIFICATION","")
    ))
    new_row = c.fetchone()
    if not new_row:
        raise ValueError("Insert returned no RULE_ID.")
    new_rule_id = new_row[0]

    # insert brm_rule_table_dependencies
    col_op = "READ" if op_type=="SELECT" else "WRITE"
    for (sch,tbl,al,subs) in deps["tables"]:
        if tbl and not tbl.startswith("(CTE)"):
            dbn = sch if sch else "dbo"
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                    RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES(?,?,?,?,?)
            """,(new_rule_id, dbn, tbl, "AutoCol", col_op))

    # insert audit
    insert_audit_log(conn, "INSERT", "BRM_RULES", new_rule_id, str(created_by_user_id), None, rule_data)
    conn.commit()

    # create approvals
    create_multistep_approvals(conn, new_rule_id)
    logger.info(f"New rule {new_rule_id} created by user {created_by_user_id} in group {rule_data['OWNER_GROUP']}.")

    return new_rule_id


def update_rule(conn, rule_data, updated_by_user_id, updated_by_group):
    """
    Update existing rule => must have lock => parse new SQL => re-approval =>
    enforce permission => set status=INACTIVE => lifecycle=UNDER_APPROVAL => refresh deps => create approvals.
    """
    rule_id = rule_data["RULE_ID"]
    c=conn.cursor()
    # check lock
    info = LockManager.rule_current_lock_owner(conn, rule_id)
    if not info:
        raise ValueError(f"Rule {rule_id} is not locked => cannot update.")
    (locked_by, lts, exp, fflag) = info
    if locked_by!=updated_by_user_id and updated_by_group!="Admin":
        raise ValueError("Lock owned by another user => cannot update.")
    # fetch old
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row = c.fetchone()
    if not old_row:
        raise ValueError(f"Rule {rule_id} not found.")
    colnames=[d[0] for d in c.description]
    old_data=dict(zip(colnames, old_row))

    # global rule => only admin can update
    if old_data["IS_GLOBAL"]==1 and updated_by_group!="Admin":
        raise ValueError("Only Admin can update a global rule.")

    # new SQL => permission check
    new_sql = rule_data.get("RULE_SQL","").strip()
    if new_sql:
        enforce_permissions_for_rule_sql(conn, updated_by_group, new_sql)

    # check if changed => parse new
    op_type = detect_operation_type(new_sql)
    deps = parse_sql_dependencies(new_sql)

    # update
    c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY=?,
            LIFECYCLE_STATE='UNDER_APPROVAL',
            OPERATION_TYPE=?,
            BUSINESS_JUSTIFICATION=?,
            CRITICAL_RULE=?,
            IS_GLOBAL=?,
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
    """,(
       rule_data["RULE_NAME"].strip(),
       new_sql,
       rule_data.get("OWNER_GROUP", old_data["OWNER_GROUP"]),
       str(updated_by_user_id),
       op_type,
       rule_data.get("BUSINESS_JUSTIFICATION", old_data["BUSINESS_JUSTIFICATION"]),
       rule_data.get("CRITICAL_RULE", old_data["CRITICAL_RULE"]),
       rule_data.get("IS_GLOBAL", old_data["IS_GLOBAL"]),
       rule_id
    ))

    # refresh dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rule_id,))
    col_op = "READ" if op_type=="SELECT" else "WRITE"
    for (sch,tbl,al,subs) in deps["tables"]:
        if tbl and not tbl.startswith("(CTE)"):
            dbn=sch if sch else "dbo"
            c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                    RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME, COLUMN_OP
                )
                VALUES(?,?,?,?,?)
            """,(rule_id, dbn, tbl, "AutoCol", col_op))

    # build new_data for audit
    new_data=dict(old_data)
    for k,v in rule_data.items():
        new_data[k]=v
    new_data["STATUS"]="INACTIVE"
    new_data["APPROVAL_STATUS"]="APPROVAL_IN_PROGRESS"
    new_data["LIFECYCLE_STATE"]="UNDER_APPROVAL"
    new_data["VERSION"]=old_data["VERSION"]+1

    insert_audit_log(conn, "UPDATE", "BRM_RULES", rule_id, str(updated_by_user_id), old_data, new_data)
    conn.commit()

    # re-create approvals
    create_multistep_approvals(conn, rule_id)
    logger.info(f"Rule {rule_id} updated => under approval by user {updated_by_user_id}.")


def force_activate_rule(conn, rule_id, user_id, user_group):
    """
    Force-activate => bypass approvals => set status=ACTIVE => must have lock if not admin.
    """
    if user_group!="Admin":
        # check lock
        info=LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            raise ValueError("Rule not locked => cannot force activate.")
        (locked_by, _, _, _)=info
        if locked_by!=user_id:
            raise ValueError("You do not own the lock => cannot force activate.")
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs, old_row))

    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='ACTIVE', LIFECYCLE_STATE='ACTIVE', APPROVAL_STATUS='FORCE_ACTIVATED'
        WHERE RULE_ID=?
    """,(rule_id,))
    new_data=dict(old_data)
    new_data["STATUS"]="ACTIVE"
    new_data["LIFECYCLE_STATE"]="ACTIVE"
    new_data["APPROVAL_STATUS"]="FORCE_ACTIVATED"

    insert_audit_log(conn,"FORCE_ACTIVATE","BRM_RULES",rule_id,str(user_id),old_data,new_data)
    conn.commit()
    logger.info(f"Rule {rule_id} forcibly activated by user {user_id}.")


def force_deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Force-deactivate => set status=INACTIVE => skip approvals => must have lock if not admin.
    """
    if user_group!="Admin":
        info=LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            raise ValueError("Rule not locked => cannot force deactivate.")
        (locked_by, _, _, _)=info
        if locked_by!=user_id:
            raise ValueError("Lock owned by another => cannot force deactivate.")
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs, old_row))

    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE', APPROVAL_STATUS='FORCE_DEACTIVATED'
        WHERE RULE_ID=?
    """,(rule_id,))
    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["LIFECYCLE_STATE"]="INACTIVE"
    new_data["APPROVAL_STATUS"]="FORCE_DEACTIVATED"
    insert_audit_log(conn,"FORCE_DEACTIVATE","BRM_RULES",rule_id,str(user_id),old_data,new_data)
    conn.commit()
    logger.info(f"Rule {rule_id} forcibly deactivated by user {user_id}.")


def deactivate_rule(conn, rule_id, user_id, user_group):
    """
    Normal (non-force) => must be fully approved => must have lock => no active children => if global => admin only.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs, old_row))

    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate => not fully APPROVED.")
    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate global rule.")
    # lock check if not admin
    if user_group!="Admin":
        info=LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            raise ValueError("Not locked => cannot deactivate.")
        (locked_by,_,_,_)=info
        if locked_by!=user_id:
            raise ValueError("Lock is owned by another => cannot deactivate.")

    # check active children
    c2=conn.cursor()
    c2.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    if c2.fetchone():
        raise ValueError("Deactivate child rules first => some are ACTIVE.")

    # do it
    c.execute("""
        UPDATE BRM_RULES
        SET STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE', VERSION=VERSION+1
        WHERE RULE_ID=?
    """,(rule_id,))
    new_data=dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["LIFECYCLE_STATE"]="INACTIVE"
    new_data["VERSION"]=old_data["VERSION"]+1
    insert_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,str(user_id),old_data,new_data)
    conn.commit()
    logger.info(f"Rule {rule_id} deactivated normally by user {user_id}.")


def delete_rule(conn, rule_id, user_id, user_group):
    """
    Normal (non-force) delete => must be fully approved => must be inactive => no children => if global => admin only => must have lock if not admin.
    """
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old_row=c.fetchone()
    if not old_row:
        raise ValueError("Rule not found.")
    descs=[d[0] for d in c.description]
    old_data=dict(zip(descs, old_row))

    if old_data["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old_data["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete => not fully APPROVED.")
    if old_data["STATUS"]!="INACTIVE":
        raise ValueError("Rule must be INACTIVE first.")
    # check lock if not admin
    if user_group!="Admin":
        info=LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            raise ValueError("Rule not locked => cannot delete.")
        (locked_by,_,_,_)=info
        if locked_by!=user_id:
            raise ValueError("Lock is owned by another => cannot delete.")

    # check children
    c2=conn.cursor()
    c2.execute("SELECT 1 FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    if c2.fetchone():
        raise ValueError("Child rules exist => remove them first.")
    # references?
    c2.execute("SELECT 1 FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id, rule_id))
    if c2.fetchone():
        raise ValueError("Remove references from BRM_COLUMN_MAPPING first if your design demands it.")

    # final delete
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    insert_audit_log(conn,"DELETE","BRM_RULES",rule_id,str(user_id),old_data,None)
    conn.commit()
    logger.info(f"Rule {rule_id} deleted by user {user_id}.")


###############################################################################
# UI: BusinessRulesTab => BFS + CRUD
###############################################################################
class BusinessRulesTab(QWidget):

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.init_ui()
        self.load_rules()

    def set_user(self, user_id, user_group):
        """
        Called if user impersonates => refresh.
        """
        self.user_id=user_id
        self.user_group=user_group
        self.load_rules()

    def init_ui(self):
        layout=QVBoxLayout(self)
        # top bar: search?
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search rule name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_rules)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)

        # table
        self.rules_table=QTableWidget(0,8)
        self.rules_table.setHorizontalHeaderLabels([
            "RuleID","Name","Status","OwnerGroup","OpType","Version","LockStatus","Select"
        ])
        self.rules_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rules_table)

        # button row
        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.add_rule_dialog)
        btn_h.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.update_rule_dialog)
        btn_h.addWidget(upd_btn)

        f_act_btn=QPushButton("Force Activate")
        f_act_btn.clicked.connect(self.do_force_activate)
        btn_h.addWidget(f_act_btn)

        f_deact_btn=QPushButton("Force Deactivate")
        f_deact_btn.clicked.connect(self.do_force_deactivate)
        btn_h.addWidget(f_deact_btn)

        del_btn=QPushButton("Delete Rule")
        del_btn.clicked.connect(self.do_delete_rule)
        btn_h.addWidget(del_btn)

        run_bfs_btn=QPushButton("Execute BFS (Selected)")
        run_bfs_btn.clicked.connect(self.run_bfs_on_selected)
        btn_h.addWidget(run_bfs_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def load_rules(self):
        self.rules_table.setRowCount(0)
        txt=self.search_edit.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
                SELECT TOP 500 RULE_ID,RULE_NAME,STATUS,OWNER_GROUP,OPERATION_TYPE,VERSION,LOCK_STATUS
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
                SELECT TOP 500 RULE_ID,RULE_NAME,STATUS,OWNER_GROUP,OPERATION_TYPE,VERSION,LOCK_STATUS
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.rules_table.rowCount()
            self.rules_table.insertRow(r_i)
            for col_i in range(7):
                val=row[col_i]
                it=QTableWidgetItem(str(val) if val else "")
                self.rules_table.setItem(r_i, col_i, it)
            # a hidden select or a widget
            sel_item=QTableWidgetItem("Select")
            sel_item.setCheckState(Qt.Unchecked)
            self.rules_table.setItem(r_i,7, sel_item)
        self.rules_table.resizeColumnsToContents()

    def get_selected_rule_ids(self):
        """
        Return list of rule_ids where the "Select" column is checked.
        """
        out=[]
        for r_i in range(self.rules_table.rowCount()):
            check_item=self.rules_table.item(r_i,7)
            if check_item and check_item.checkState()==Qt.Checked:
                rid_item=self.rules_table.item(r_i,0)
                if rid_item:
                    out.append(int(rid_item.text()))
        return out

    def add_rule_dialog(self):
        dlg=AddOrUpdateRuleDialog(self.connection, self.user_id, self.user_group, is_new=True)
        if dlg.exec_()==QDialog.Accepted:
            QMessageBox.information(self,"Created",f"Rule created => ID={dlg.created_rule_id}")
            self.load_rules()

    def update_rule_dialog(self):
        # must have exactly 1 selected
        selected=self.get_selected_rule_ids()
        if len(selected)!=1:
            QMessageBox.warning(self,"Error","Select exactly one rule to update.")
            return
        rid=selected[0]
        dlg=AddOrUpdateRuleDialog(self.connection, self.user_id, self.user_group, is_new=False, rule_id=rid)
        if dlg.exec_()==QDialog.Accepted:
            QMessageBox.information(self,"Updated",f"Rule {rid} updated => under approval.")
            self.load_rules()

    def do_force_activate(self):
        sel=self.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force-activate {len(sel)} rule(s)? This overrides approvals.")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                force_activate_rule(self.connection, rid, self.user_id, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        QMessageBox.information(self,"Result",f"Force-activated: {success}, fails: {len(fails)} => {fails}")
        self.load_rules()

    def do_force_deactivate(self):
        sel=self.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force-deactivate {len(sel)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                force_deactivate_rule(self.connection, rid, self.user_id, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        QMessageBox.information(self,"Result",f"Force-deactivated={success}, fails={fails}")
        self.load_rules()

    def do_delete_rule(self):
        sel=self.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(sel)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        success=0
        fails=[]
        for rid in sel:
            try:
                delete_rule(self.connection, rid, self.user_id, self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        QMessageBox.information(self,"Result",f"Deleted={success}, fails={fails}")
        self.load_rules()

    def run_bfs_on_selected(self):
        sel=self.get_selected_rule_ids()
        if not sel:
            QMessageBox.warning(self,"None","No rule selected.")
            return
        skip_val=False
        (executed, skipped, failed_tables)=execute_rules_bfs(self.connection, sel, skip_data_validation=skip_val)
        msg=(
            f"BFS => start rules={sel}\n"
            f"Executed => {executed}\n"
            f"Skipped => {list(skipped)}\n"
            f"ValidationFailed => {list(failed_tables)}"
        )
        QMessageBox.information(self,"BFS Execution",msg)


###############################################################################
# Helper: AddOrUpdateRuleDialog
###############################################################################
class AddOrUpdateRuleDialog(QDialog):
    """
    Dialog for adding or updating a rule.
    If is_new=True => Add; else => load existing, update.
    Must do lock if updating.
    """
    def __init__(self, connection, user_id, user_group, is_new=True, rule_id=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group
        self.is_new=is_new
        self.rule_id=rule_id
        self.created_rule_id=None
        self.setWindowTitle("Add Rule" if is_new else f"Update Rule {rule_id}")
        self.resize(600, 400)
        self.init_ui()
        if not self.is_new and self.rule_id:
            self.load_existing()

    def init_ui(self):
        layout=QVBoxLayout(self)

        form_l=QHBoxLayout()
        col1=QVBoxLayout()
        col2=QVBoxLayout()

        col1.addWidget(QLabel("Rule Name:"))
        self.name_edit=QLineEdit()
        col1.addWidget(self.name_edit)

        col1.addWidget(QLabel("Owner Group:"))
        self.group_edit=QLineEdit()
        col1.addWidget(self.group_edit)

        col1.addWidget(QLabel("Business Justification:"))
        self.just_edit=QPlainTextEdit()
        col1.addWidget(self.just_edit)

        col2.addWidget(QLabel("SQL:"))
        self.sql_edit=QPlainTextEdit()
        col2.addWidget(self.sql_edit)

        form_l.addLayout(col1)
        form_l.addLayout(col2)
        layout.addLayout(form_l)

        btn_h=QHBoxLayout()
        save_btn=QPushButton("Save")
        save_btn.clicked.connect(self.save_rule)
        btn_h.addWidget(save_btn)

        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(cancel_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def load_existing(self):
        # attempt to lock
        try:
            LockManager.lock_rule_for_edit(self.connection, self.rule_id, self.user_id, force=False, lock_minutes=30)
        except Exception as ex:
            QMessageBox.warning(self,"Lock Error",str(ex))
            self.reject()
            return
        # fetch
        c=self.connection.cursor()
        c.execute("""
            SELECT RULE_ID, RULE_NAME, RULE_SQL, OWNER_GROUP, BUSINESS_JUSTIFICATION
            FROM BRM_RULES
            WHERE RULE_ID=?
        """,(self.rule_id,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"Rule {self.rule_id} not found.")
            self.reject()
            return
        self.name_edit.setText(row[1] or "")
        self.sql_edit.setPlainText(row[2] or "")
        self.group_edit.setText(row[3] or "")
        self.just_edit.setPlainText(row[4] or "")

    def save_rule(self):
        rn=self.name_edit.text().strip()
        if not rn:
            QMessageBox.warning(self,"Error","Rule name is required.")
            return
        og=self.group_edit.text().strip()
        if not og:
            QMessageBox.warning(self,"Error","Owner group is required.")
            return
        sql_=self.sql_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()

        rule_data={
            "RULE_NAME":rn,
            "RULE_SQL":sql_,
            "OWNER_GROUP":og,
            "BUSINESS_JUSTIFICATION":just_
        }

        if self.is_new:
            try:
                new_id=add_rule(self.connection, rule_data, self.user_id, self.user_group)
                self.created_rule_id=new_id
                QMessageBox.information(self,"Created",f"Rule ID={new_id} created => under approval.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            # updating
            rule_data["RULE_ID"]=self.rule_id
            try:
                update_rule(self.connection, rule_data, self.user_id, self.user_group)
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))

    def reject(self):
        # if we're updating and locked => unlock
        if not self.is_new and self.rule_id:
            try:
                LockManager.unlock_rule_for_edit(self.connection, self.rule_id, self.user_id, force=False)
            except:
                pass
        super().reject()

    def accept(self):
        # also unlock if updating
        if not self.is_new and self.rule_id:
            try:
                LockManager.unlock_rule_for_edit(self.connection, self.rule_id, self.user_id, force=False)
            except:
                pass
        super().accept()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Part 3: brm_scheduling_sync_advanced.py

Description:
  Builds on Parts 1 & 2. Focuses on:
   • Scheduling and Simulation logic (EnhancedScheduleDialog, ScheduleManagementTab, check_due_schedules).
   • Sync Metadata improvements (detect missing tables, rename them, or mark MISSING_).
   • Additional advanced tabs: 
       - DecisionTablesTab (managing DECISION_TABLES),
       - ConflictPriorityManagerTab (RULE_CONFLICTS),
       - CompositeRulesTab (COMPOSITE_RULES),
       - SnapshotManagerTab or TagsManagerTab if needed,
       - WhatIfTestTab for CSV input or BFS tests.
"""

import sys
import math
import logging
import time
import json
import pyodbc
from datetime import datetime
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QTimer, QDate, QTime, QDateTime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QMessageBox, QDialog, QLineEdit, QPlainTextEdit,
    QCalendarWidget, QCheckBox, QComboBox, QFileDialog
)

# from brm_core_foundation import logger, fetch_all_dict, fetch_one_dict, insert_audit_log
# from brm_rule_engine import execute_rules_bfs, run_single_rule
# from brm_data_validations import run_data_validations_for_table
# Possibly from Part 2 or 1, we have BFS logic references.

###############################################################################
# 1) Scheduling
###############################################################################
class EnhancedScheduleDialog(QDialog):
    """
    A dialog to pick a rule, a date/time, and whether to run data validations.
    Inserts into RULE_SCHEDULES => the user can see it in the ScheduleManagementTab.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Scheduling – Advanced")
        self.resize(420,300)

        layout=QVBoxLayout(self)

        # form
        form_l=QVBoxLayout()
        row1=QHBoxLayout()
        row1.addWidget(QLabel("Select Rule:"))
        self.rule_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows=c.fetchall()
        for (rid,rn) in rows:
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp, rid)
        row1.addWidget(self.rule_combo)
        form_l.addLayout(row1)

        row2=QHBoxLayout()
        row2.addWidget(QLabel("Pick Date:"))
        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QtCore.QDate.currentDate())
        row2.addWidget(self.calendar)
        form_l.addLayout(row2)

        row3=QHBoxLayout()
        row3.addWidget(QLabel("Pick Time:"))
        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        row3.addWidget(self.time_edit)
        form_l.addLayout(row3)

        self.run_validation_cb=QCheckBox("Run Data Validations before execution?")
        form_l.addWidget(self.run_validation_cb)

        layout.addLayout(form_l)

        btn_h=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        btn_h.addWidget(sch_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        date_str=self.calendar.selectedDate().toString("yyyy-MM-dd")
        time_str=self.time_edit.time().toString("HH:mm:ss")
        dt_str=f"{date_str} {time_str}"
        c=self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(
                    RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, VALIDATION_FLAG
                )
                VALUES(?,?, 'Scheduled', GETDATE(), ?)
            """,(rid, dt_str, 1 if self.run_validation_cb.isChecked() else 0))
            self.connection.commit()
            QMessageBox.information(self,"Scheduled",f"Rule {rid} at {dt_str}.")
            self.close()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))


class ScheduleManagementTab(QWidget):
    """
    Shows RULE_SCHEDULES => up to 1000 => user can add, update, delete.
    Integration with BFS occurs in check_due_schedules function (outside).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels([
            "ScheduleID","RuleID","ScheduleTime","Status","Validate?","Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_h=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_schedules)
        btn_h.addWidget(ref_btn)

        add_btn=QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_h.addWidget(add_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT TOP 1000 SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS,VALIDATION_FLAG
            FROM RULE_SCHEDULES
            ORDER BY SCHEDULE_TIME DESC
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(5):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(row[col_i]) if row[col_i] is not None else ""))
            # actions
            act_widget=QWidget()
            ah=QHBoxLayout(act_widget)
            ah.setContentsMargins(0,0,0,0)

            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _, i=r_i: self.update_schedule(i))
            ah.addWidget(upd_btn)

            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _, i=r_i: self.delete_schedule(i))
            ah.addWidget(del_btn)
            ah.addStretch()
            self.table.setCellWidget(r_i,5,act_widget)
        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self, row_i):
        it=self.table.item(row_i,0)
        if not it:
            return
        sch_id=int(it.text())
        new_dt,ok=QInputDialog.getText(self,"Update","New datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",
                      (new_dt.strip(), sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self, row_i):
        it=self.table.item(row_i,0)
        if not it:
            return
        sch_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()


def check_due_schedules(conn):
    """
    Poll RULE_SCHEDULES => if any is 'Scheduled' with time <= now => run BFS or single rule.
    Mark them 'Executed' or 'Failed'. Log the performance in RULE_EXECUTION_LOGS.
    Also handle data validation if VALIDATION_FLAG=1.
    This is typically called in a QTimer from the main aggregator.
    """
    now_str=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    c=conn.cursor()
    c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,VALIDATION_FLAG
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME<=?
    """,(now_str,))
    rows=c.fetchall()
    for (sch_id, rid, stime, val_flag) in rows:
        # BFS or single?
        try:
            #from brm_rule_engine import execute_rules_bfs
            (exed,skp,fails)=execute_rules_bfs(conn, [rid], skip_data_validation=(not bool(val_flag)))
            # if rid is in exed => success => set 'Executed'
            if rid in exed:
                c2=conn.cursor()
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
            else:
                c2=conn.cursor()
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
            conn.commit()
        except Exception as ex:
            logging.error(f"Schedule {sch_id} => error: {ex}")
            c2=conn.cursor()
            c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
            conn.commit()


###############################################################################
# 2) Sync Metadata (Improved)
###############################################################################
def sync_metadata_improved(conn):
    """
    Compare sys.tables with BRM_RULE_TABLE_DEPENDENCIES. If any table is not found =>
    update that dependency row to have 'MISSING_<table>'.
    Or your logic to mark them. Return a user-friendly message.
    """
    c=conn.cursor()
    c.execute("""
        SELECT s.name as schema_name, t.name as table_name
        FROM sys.tables t
        JOIN sys.schemas s ON t.schema_id=s.schema_id
        ORDER BY s.name, t.name
    """)
    actual_tables=set()
    for row in c.fetchall():
        fulln=f"{row[0]}.{row[1]}".lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID, DATABASE_NAME, TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps=c.fetchall()
    missing_count=0
    total=len(deps)
    for (did,dbn,tn) in deps:
        if not tn:
            continue
        candidate=(f"{dbn}.{tn}").lower().strip(".")
        if candidate not in actual_tables:
            # update => prefix MISSING_
            c2=conn.cursor()
            c2.execute("""
                UPDATE BRM_RULE_TABLE_DEPENDENCIES
                SET TABLE_NAME='MISSING_' + TABLE_NAME
                WHERE DEPENDENCY_ID=?
            """,(did,))
            missing_count+=1
    conn.commit()
    msg=f"Metadata sync complete. Found {len(actual_tables)} real DB tables.\n"
    msg+=f"Scanned {total} dependencies. Marked {missing_count} as MISSING_."
    return msg


###############################################################################
# 3) Additional Advanced Tabs
###############################################################################

class DecisionTablesTab(QWidget):
    """
    Minimal UI to manage DECISION_TABLES (table_name, description, decision_query).
    For advanced usage, see a more robust approach in brm_advanced_decision_tables.py.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["ID","TableName","Description"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)

        run_btn=QPushButton("Run DT (Stub)")
        run_btn.clicked.connect(self.run_dt)
        bh.addWidget(run_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)

        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i in range(3):
                val=row[col_i]
                self.table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))
        self.table.resizeColumnsToContents()

    def add_dt(self):
        nm,ok=QInputDialog.getText(self,"Add","DT name (table_name)?")
        if not ok or not nm.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Desc","Description:")
        if not ok2:
            desc=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION) VALUES(?,?)",(nm.strip(),desc.strip()))
        self.connection.commit()
        self.load_dt()

    def del_dt(self):
        row=self.table.currentRow()
        if row<0:
            return
        dtid_item=self.table.item(row,0)
        if not dtid_item:
            return
        dt_id=int(dtid_item.text())
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        self.load_dt()

    def run_dt(self):
        QMessageBox.information(self,"Run DT","Stub => see advanced part for real execution logic.")


class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS => (rule_id1, rule_id2, priority).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT CONFLICT_ID, RULE_ID1, RULE_ID2
            FROM RULE_CONFLICTS
            ORDER BY CONFLICT_ID
        """)
        rows=c.fetchall()
        for row in rows:
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i, val in enumerate(row):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))
        self.table.resizeColumnsToContents()

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule1 ID:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule2 ID:")
        if not ok2:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,0)",
                  (r1,r2))
        self.connection.commit()
        self.load_conflicts()

    def del_conflict(self):
        row=self.table.currentRow()
        if row<0:
            return
        cid_item=self.table.item(row,0)
        if not cid_item:
            return
        cid=int(cid_item.text())
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cid,))
        self.connection.commit()
        self.load_conflicts()


class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES => (COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS).
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["CompositeID","Name","LogicExpr","ActionOnPass"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add")
        add_btn.clicked.connect(self.add_composite)
        bh.addWidget(add_btn)

        del_btn=QPushButton("Delete")
        del_btn.clicked.connect(self.del_composite)
        bh.addWidget(del_btn)

        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_composite)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_composite()

    def load_composite(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
            SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
            FROM COMPOSITE_RULES
            ORDER BY COMPOSITE_RULE_ID
        """)
        for row in c.fetchall():
            r_i=self.table.rowCount()
            self.table.insertRow(r_i)
            for col_i,val in enumerate(row):
                self.table.setItem(r_i,col_i,QTableWidgetItem(str(val) if val else ""))
        self.table.resizeColumnsToContents()

    def add_composite(self):
        nm,ok=QInputDialog.getText(self,"Add","Composite Name:")
        if not ok or not nm.strip():
            return
        expr,ok2=QInputDialog.getMultiLineText(self,"Expr","(e.g. 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"ActionOnPass","(Optional) e.g. 'SendEmail'")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
            INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
            VALUES(?,?,?)
        """,(nm.strip(), expr.strip(), act.strip()))
        self.connection.commit()
        self.load_composite()

    def del_composite(self):
        row=self.table.currentRow()
        if row<0:
            return
        cid_item=self.table.item(row,0)
        if not cid_item:
            return
        cid=int(cid_item.text())
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
        self.connection.commit()
        self.load_composite()


class WhatIfTestTab(QWidget):
    """
    A tab letting the user pick a rule => BFS => optionally skip validations =>
    upload CSV => run test => see pass/fail.
    This is a minimal approach; you can expand to load CSV into a staging table, etc.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.csv_path=None

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()

        top_h.addWidget(QLabel("Select Rule:"))
        self.rule_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            disp=f"{rid} - {rn}"
            self.rule_combo.addItem(disp,rid)
        top_h.addWidget(self.rule_combo)

        self.skip_val_cb=QCheckBox("Skip Validations?")
        top_h.addWidget(self.skip_val_cb)

        layout.addLayout(top_h)

        mid_h=QHBoxLayout()
        up_btn=QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        mid_h.addWidget(up_btn)

        run_btn=QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        mid_h.addWidget(run_btn)
        mid_h.addStretch()
        layout.addLayout(mid_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if path:
            self.csv_path=path
            QMessageBox.information(self,"Uploaded",f"CSV loaded at {path} (Stub usage).")

    def run_test(self):
        rid=self.rule_combo.currentData()
        skipv=self.skip_val_cb.isChecked()
        #from brm_rule_engine import execute_rules_bfs
        (exed, skipped, fails)=execute_rules_bfs(self.connection, [rid], skip_data_validation=skipv)
        msg=(
            f"WhatIf => BFS from {rid}\n"
            f"Executed => {exed}\n"
            f"Skipped => {list(skipped)}\n"
            f"ValidationFail => {list(fails)}\n"
            f"CSV path => {self.csv_path or 'No CSV'}"
        )
        self.result_text.setPlainText(msg)
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Part 4: brm_tool_final_aggregator.py

Brings everything together into a final QMainWindow with:
 - DatabaseConnectionDialog
 - LoginDialog
 - The advanced tabs from previous parts: BFS, Approvals, Scheduling, 
   Defect management, Rule editor, Data validations, Collaboration, etc.
 - Timers for auto-refresh (approvals, schedules, alerts).
 - Admin user impersonation.
 - Material or modern style (optional).
"""

import sys
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget,
    QLabel, QComboBox, QPushButton, QMessageBox, QAction
)
from PyQt5.QtCore import QTimer, Qt

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Final Aggregator (Parts 1–4)")
        self.resize(1500,900)

        self.connection = None
        self.user_id = None
        self.user_group = None
        self.logged_in_username = None

        # Step 1: Connect DB
        dbdlg = DatabaseConnectionDialog()
        if dbdlg.exec_() == dbdlg.Accepted:
            conn = dbdlg.get_connection()
            if not conn:
                sys.exit(1)
            self.connection = conn
        else:
            sys.exit(0)

        # Step 2: Login
        logdlg = LoginDialog(self.connection)
        if logdlg.exec_() != logdlg.Accepted:
            sys.exit(0)
        self.user_id = logdlg.user_id
        self.user_group = logdlg.user_group

        # fetch actual username
        c = self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row = c.fetchone()
        if row:
            self.logged_in_username = row[0]
        else:
            self.logged_in_username = "UnknownUser"

        self.init_ui()

    def init_ui(self):
        # Menu
        menubar = self.menuBar()
        fileMenu = menubar.addMenu("File")

        syncAct = QAction("Sync Metadata", self)
        syncAct.triggered.connect(self.on_sync_metadata)
        fileMenu.addAction(syncAct)

        exitAct = QAction("Exit", self)
        exitAct.triggered.connect(self.close)
        fileMenu.addAction(exitAct)

        # Tools
        toolsMenu = menubar.addMenu("Tools")
        auditAct = QAction("Activity Logs", self)
        auditAct.triggered.connect(self.show_activity_logs)
        toolsMenu.addAction(auditAct)

        # BFS chain sim
        chainSimAct = QAction("Chain BFS Simulation", self)
        chainSimAct.triggered.connect(self.launch_chain_sim)
        toolsMenu.addAction(chainSimAct)

        # BFS group sim
        groupSimAct = QAction("Group BFS Simulation", self)
        groupSimAct.triggered.connect(self.launch_group_sim)
        toolsMenu.addAction(groupSimAct)

        # Help
        helpMenu = menubar.addMenu("Help")
        aboutAct = QAction("About", self)
        aboutAct.triggered.connect(self.show_about)
        helpMenu.addAction(aboutAct)

        cw = QWidget()
        main_l = QVBoxLayout(cw)

        # If admin => impersonation
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            self.switch_btn=QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.do_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            main_l.addLayout(top_h)
            self.populate_switch_user()

        self.tabs = QTabWidget()
        main_l.addWidget(self.tabs)

        # 1) Dashboard (cards)
        self.cards_tab = DashboardCardsTab(self.connection)
        self.tabs.addTab(self.cards_tab, "Dashboard")

        # 2) Biz rules tab
        self.biz_rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.biz_rules_tab,"Business Rules")

        # 3) Approvals
        self.approvals_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approvals_tab,"Approvals")

        # 4) GCR admin if admin
        if self.user_group=="Admin":
            self.gcr_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gcr_tab,"GCR Admin")

        # 5) Hierarchy
        self.hier_tab = HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # 6) Enhanced lineage
        lineage_widget=QWidget()
        lw=QVBoxLayout(lineage_widget)
        self.lineage_graph=EnhancedLineageGraphWidget(self.connection)
        lw.addWidget(self.lineage_graph)
        lineage_widget.setLayout(lw)
        self.tabs.addTab(lineage_widget,"Lineage")

        # 7) Custom groups
        self.custom_tab=CustomRuleGroupEnhancedTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Groups")

        # 8) Scheduling
        self.sched_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sched_tab,"Scheduling")

        # 9) Defects
        self.defect_tab=DefectManagementTab(self.connection)
        self.tabs.addTab(self.defect_tab,"Defects")

        # 10) Control Tables
        self.ctrl_tab=ControlTablesTab(self.connection, self.user_group)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # 11) Metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # 12) Alerts
        self.alerts_tab=AlertsAndDashboardsTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.alerts_tab,"Alerts")

        # 13) Group mgmt
        self.grp_mgmt_tab=GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.grp_mgmt_tab,"Group Management")

        # 14) User mgmt if admin
        if self.user_group=="Admin":
            self.user_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_tab,"User Management")

        # 15) Advanced decision tables
        self.adv_dt_tab = AdvancedDecisionTablesTab(self.connection)
        self.tabs.addTab(self.adv_dt_tab,"Decision Tables++")

        # 16) Perf alerting
        self.perf_tab=PerformanceAlertingTab(self.connection)
        self.tabs.addTab(self.perf_tab,"Perf Trends")

        # 17) Activity logs
        self.activity_tab=ActivityTrackingTab(self.connection)
        self.tabs.addTab(self.activity_tab,"Activity Logs")

        # Data validations
        self.data_val_tab=DataValidationTab(self.connection)
        self.tabs.addTab(self.data_val_tab,"Data Validations")

        # Inline editing
        self.inline_tab=InlineEditingTab(self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.inline_tab,"Inline Editing")

        # SQL → Business
        self.sqlconv_tab=SqlToBusinessLanguageConverterTab(self.connection)
        self.tabs.addTab(self.sqlconv_tab,"SQL→Business")

        # Additional “WhatIfTestTab”
        self.whatif_tab=WhatIfTestTab(self.connection)
        self.tabs.addTab(self.whatif_tab,"WhatIf Testing")

        # DecisionTablesTab (if needed) or ConflictPriority, Composite
        self.simple_dt_tab=DecisionTablesTab(self.connection)
        self.conflict_tab=ConflictPriorityManagerTab(self.connection)
        self.comp_tab=CompositeRulesTab(self.connection)
        self.tabs.addTab(self.simple_dt_tab,"Simple DT")
        self.tabs.addTab(self.conflict_tab,"Conflicts")
        self.tabs.addTab(self.comp_tab,"Composite")

        # Collaboration
        self.collab_manager=CollaborationManager(self.connection, poll_interval_ms=5000, parent=self)
        self.collab_tab=CollaborationTab(self.connection,self.collab_manager)
        self.tabs.addTab(self.collab_tab,"Collaboration")

        cw.setLayout(main_l)
        self.setCentralWidget(cw)

        # Timers
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.refresh_approvals)
        self.approv_timer.start(4000)

        self.sched_timer=QTimer(self)
        self.sched_timer.timeout.connect(self.do_check_schedules)
        self.sched_timer.start(60000)

        self.alert_timer=QTimer(self)
        self.alert_timer.timeout.connect(self.alerts_tab.check_alerts)
        self.alert_timer.start(90000)

        self.show()

    def populate_switch_user(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            uid,un,ug=row
            disp=f"{un} ({ug})"
            self.switch_combo.addItem(disp,(uid,ug))

    def do_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        new_uid,new_grp=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        # fetch user name
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(new_uid,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="Unknown"
        QMessageBox.information(self,"Switched",f"Impersonating user {self.logged_in_username} (group={new_grp}).")
        # refresh relevant tabs
        self.approvals_tab.logged_in_username=self.logged_in_username
        self.approvals_tab.user_group=self.user_group
        self.approvals_tab.load_approvals()

        self.biz_rules_tab.set_user(self.user_id,self.user_group)
        self.grp_mgmt_tab.user_id=self.user_id
        self.grp_mgmt_tab.user_group=self.user_group
        self.grp_mgmt_tab.load_data()
        if self.user_group!="Admin" and hasattr(self,"user_tab"):
            # possibly disable or hide
            pass

    def refresh_approvals(self):
        self.approvals_tab.load_approvals()

    def do_check_schedules(self):
        check_due_schedules(self.connection)
        self.sched_tab.load_schedules()

    def show_activity_logs(self):
        self.tabs.setCurrentWidget(self.activity_tab)

    def on_sync_metadata(self):
        try:
            msg=sync_metadata_improved(self.connection)
            QMessageBox.information(self,"Sync Metadata",msg)
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def launch_chain_sim(self):
        # from part 3 or 2, if you have a chain simulation dialog
        #from brm_scheduling_sync_advanced import ChainSimulationDialog
        dlg=ChainSimulationDialog(self.connection,self)
        dlg.exec_()

    def launch_group_sim(self):
        #from brm_scheduling_sync_advanced import GroupSimulationDialog
        dlg=GroupSimulationDialog(self.connection,self)
        dlg.exec_()

    def show_about(self):
        msg=(
            "BRM Tool – Final aggregator (Parts 1–4).\n"
            "All advanced features integrated: BFS, approvals, scheduling, data validations,\n"
            "defects, lineage, collaboration, impersonation, rule editor, etc.\n"
        )
        QMessageBox.information(self,"About",msg)

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()


def main():
    app = QApplication(sys.argv)
    # Optionally: from brm_enhanced_workflow_pipeline import apply_modern_theme
    apply_modern_theme(app)
    tool = BRMTool()
    tool.show()
    sys.exit(app.exec_())


if __name__=="__main__":
    main()
