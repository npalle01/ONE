Below are five common scenario-based SQL interview questions along with example answers and explanations. The exact SQL syntax may differ depending on your SQL dialect (e.g., SQL Server, MySQL, PostgreSQL), but the core logic remains similar.

1. Finding Top Customers by Purchase Amount

Scenario
You have two tables:
	•	Customers: contains customer_id, customer_name, and other customer details.
	•	Orders: contains order_id, customer_id, order_amount, and order_date.

You want to find the top 3 customers (by name) who have spent the most money overall (sum of their order_amount).

Question
Write a SQL query to list each customer’s total spending. Then retrieve only the top 3 spenders.

Answer (Example using a subquery and an analytic function or LIMIT)

-- Using a GROUP BY and ORDER BY + LIMIT (MySQL/PostgreSQL syntax)
SELECT 
    c.customer_name,
    SUM(o.order_amount) AS total_spent
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_name
ORDER BY total_spent DESC
LIMIT 3;

Explanation
	1.	JOIN the Customers table with the Orders table on customer_id.
	2.	GROUP BY customer name to get the sum of all their order amounts.
	3.	ORDER BY the total amount descending to see the highest spenders first.
	4.	Use LIMIT 3 (or TOP 3 in SQL Server) to get the top 3 records.

2. Identifying and Deleting Duplicate Records

Scenario
You have a table called Users with the following columns:
	•	user_id (primary key, auto-increment)
	•	email
	•	full_name
	•	created_at

Some users were accidentally inserted multiple times, creating duplicate emails. You only want to keep the earliest record (the one with the smallest user_id or the earliest created_at) for each email, and remove the rest.

Question
Write a SQL statement (or series of statements) to delete the duplicate records, preserving only the earliest record.

Answer (Example using a common approach)

-- Approach 1: Using a self-join to identify duplicates (general SQL approach)
DELETE Users
FROM Users
JOIN (
    SELECT 
        email,
        MIN(user_id) AS min_user_id
    FROM Users
    GROUP BY email
) AS sub ON Users.email = sub.email
WHERE Users.user_id > sub.min_user_id;

Explanation
	1.	First, identify the minimum user_id for each email (the earliest record).
	2.	Join the main Users table back to this sub-result.
	3.	Delete rows whose user_id is greater than the minimum (which means they’re duplicates).

Note: Deletion of duplicates can differ by SQL dialect and constraints; always test in a safe environment before running in production.

3. Finding Employees Without Managers or With No Direct Reports

Scenario
You have an Employees table with these columns:
	•	employee_id
	•	employee_name
	•	manager_id (links back to an employee_id in the same table)
	•	hire_date

Part A: Find all employees who do not have a manager (i.e., manager_id is NULL).
Part B: Find all employees who are not a manager to anyone else.

Question
Provide queries that address both parts of the scenario.

Answer

Part A: Employees with no manager

SELECT 
    employee_id,
    employee_name
FROM Employees
WHERE manager_id IS NULL;

Part B: Employees who are not a manager

SELECT 
    e.employee_id,
    e.employee_name
FROM Employees e
WHERE e.employee_id NOT IN (
    SELECT manager_id
    FROM Employees
    WHERE manager_id IS NOT NULL
);

Explanation
	1.	Part A is straightforward: filter where manager_id is NULL.
	2.	Part B uses a subquery listing all manager_id values (excluding nulls), then selects all employees whose ID is not in that list. That means they never appear as someone else’s manager.

4. Calculating Monthly Sales with JOINs and Grouping

Scenario
You have three tables:
	1.	Orders: order_id, customer_id, order_date
	2.	OrderDetails: order_detail_id, order_id, product_id, quantity, price
	3.	Products: product_id, product_name, category

You want to find the total revenue per month (i.e., for each calendar month) over the last year.

Question
Write a query to calculate total monthly revenue (sum of quantity * price), grouping by month and sorted by the newest month first.

Answer (Example using date functions)

-- Example in SQL Server
SELECT 
    FORMAT(o.order_date, 'yyyy-MM') AS MonthYear,
    SUM(od.quantity * od.price) AS total_revenue
FROM Orders o
JOIN OrderDetails od ON o.order_id = od.order_id
WHERE o.order_date >= DATEADD(YEAR, -1, GETDATE())  -- last 12 months
GROUP BY FORMAT(o.order_date, 'yyyy-MM')
ORDER BY MonthYear DESC;

-- Example in MySQL
SELECT 
    DATE_FORMAT(o.order_date, '%Y-%m') AS MonthYear,
    SUM(od.quantity * od.price) AS total_revenue
FROM Orders o
JOIN OrderDetails od ON o.order_id = od.order_id
WHERE o.order_date >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH)
GROUP BY DATE_FORMAT(o.order_date, '%Y-%m')
ORDER BY MonthYear DESC;

Explanation
	1.	We JOIN Orders with OrderDetails so we can multiply quantity * price.
	2.	We filter only orders in the last 12 months.
	3.	We GROUP by the month-year component of order_date.
	4.	We ORDER the results descending by the month-year so the newest month is on top.

5. Returning Records Where the Latest Status Applies

Scenario
You have a table TicketStatus that tracks the status of support tickets over time:
	•	ticket_id
	•	status (e.g., “Open”, “In Progress”, “Resolved”, “Closed”)
	•	updated_at (the timestamp when the status was set)

A ticket can appear multiple times, each time with a different status or update time. You need to retrieve only the most recent status for each ticket.

Question
Write a query to list each ticket’s most recent status and the time it was updated.

Answer (Example using ROW_NUMBER in SQL Server / Window Functions)

WITH LatestStatus AS (
    SELECT
        ticket_id,
        status,
        updated_at,
        ROW_NUMBER() OVER (PARTITION BY ticket_id ORDER BY updated_at DESC) AS rn
    FROM TicketStatus
)
SELECT
    ticket_id,
    status,
    updated_at
FROM LatestStatus
WHERE rn = 1;

Explanation
	1.	Use a window function (ROW_NUMBER() OVER (PARTITION BY ticket_id ORDER BY updated_at DESC)) to rank the statuses by the update time for each ticket.
	2.	The most recent status has a ROW_NUMBER of 1.
	3.	Select only rows where rn = 1, giving you the latest record for each ticket.

Final Tips
	1.	Understand the Data Model: Read the schema carefully—knowing how tables relate (primary/foreign keys) is crucial.
	2.	Use Proper Indexing: On large datasets, queries involving JOINS, GROUP BY, or ORDER BY can benefit significantly from correct indexing.
	3.	Test and Validate: Especially for DELETE or UPDATE statements, always validate logic in a non-production environment or by wrapping the statement in a transaction.

These scenarios demonstrate real-world SQL challenges such as combining data from multiple tables, handling duplicates, retrieving hierarchical data, grouping by time periods, and fetching the latest version of a record. They are common in interviews to test both SQL knowledge and problem-solving skills.