#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM TOOL – PART 1 of 8 (Advanced/Production-Ready)
Core foundation with concurrency table, extended concurrency logic placeholders, 
logging, email config, DB connection, basic DB helpers, 
lifecycle states, onboarding wizard, etc.
"""

########################################
#               IMPORTS
########################################
import sys
import os
import json
import math
import smtplib
import logging
import pyodbc
import sqlparse
import csv
import re
from datetime import datetime, date, time, timedelta
from collections import deque
from email.mime.text import MIMEText

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QDateTime, QTimer, QDate, QMimeData, QPoint
)
from PyQt5.QtGui import (
    QColor, QPainter, QBrush, QPen, QDrag, QIcon
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTabWidget, QComboBox, QMessageBox, QLineEdit, QDialog,
    QTableWidget, QTableWidgetItem, QTextEdit, QPlainTextEdit, QFormLayout,
    QGroupBox, QDateTimeEdit, QCheckBox, QTreeWidget, QTreeWidgetItem,
    QListWidget, QListWidgetItem, QMenu, QFileDialog, QInputDialog,
    QCalendarWidget, QAbstractItemView, QDockWidget
)
import pyqtgraph as pg
from sqlparse.sql import (
    Identifier, IdentifierList, Parenthesis, Token
)
from sqlparse.tokens import Keyword, DML

########################################
#               LOGGING
########################################
logging.basicConfig(
    filename='brm_tool_production.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

########################################
#           EMAIL CONFIG
########################################
EMAIL_CONFIG = {
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_username": "your_smtp_user",
    "smtp_password": "your_smtp_pass",
    "sender_email": "noreply@example.com"
}

def send_email_notification(subject: str, body: str, recipients: list):
    """
    SMTP-based email sending using the above config.
    """
    try:
        msg = MIMEText(body, 'plain')
        msg['Subject'] = subject
        msg['From'] = EMAIL_CONFIG['sender_email']
        msg['To'] = ", ".join(recipients)

        smtp = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        smtp.starttls()
        smtp.login(EMAIL_CONFIG['smtp_username'], EMAIL_CONFIG['smtp_password'])
        smtp.sendmail(EMAIL_CONFIG['sender_email'], recipients, msg.as_string())
        smtp.quit()
        logger.info(f"Email sent to {recipients}")
    except Exception as ex:
        logger.error(f"Error sending email to {recipients}: {ex}")

########################################
#       DATABASE CONNECTION
########################################
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    ODBC DSN or custom string for connecting to SQL Server.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection=None
        self.setWindowTitle("DB Connection – Part 1 (Advanced)")
        self.resize(400,200)

        main_layout=QVBoxLayout(self)
        lbl=QLabel("Select ODBC DSN or provide a custom connection string:")
        main_layout.addWidget(lbl)

        self.conn_type_combo=QComboBox()
        try:
            dsn_dict=pyodbc.dataSources()
            for dsn_name,driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.conn_type_combo.addItem(f"ODBC DSN: {dsn_name}", dsn_name)
        except Exception as e:
            logger.error(f"Error listing DSNs: {e}")
        main_layout.addWidget(self.conn_type_combo)

        self.conn_str_edit=QLineEdit()
        self.conn_str_edit.setPlaceholderText("Or custom ODBC connection string (optional)")
        main_layout.addWidget(self.conn_str_edit)

        bh=QHBoxLayout()
        ok_btn=QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(ok_btn)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

    def get_connection(self):
        override=self.conn_str_edit.text().strip()
        if override:
            conn_str=override
        else:
            choice=self.conn_type_combo.currentData()
            if not choice:
                QMessageBox.critical(self,"Error","No DSN or conn string chosen.")
                return None
            conn_str=f"DSN={choice};Trusted_Connection=yes;"
        try:
            return pyodbc.connect(conn_str)
        except Exception as ex:
            QMessageBox.critical(self,"Connection Error",str(ex))
            return None

########################################
#       DB HELPERS + LOCK TABLE
########################################

def fetch_all_dict(cursor):
    """
    Return fetchall as list[dict], if description present.
    """
    rows = cursor.fetchall()
    if cursor.description:
        cols = [d[0] for d in cursor.description]
        return [dict(zip(cols, r)) for r in rows]
    return rows

def fetch_one_dict(cursor):
    """
    Return a single row as dict if description present.
    """
    row = cursor.fetchone()
    if row and cursor.description:
        cols=[d[0] for d in cursor.description]
        return dict(zip(cols,row))
    return None

def insert_audit_log(conn, action, table_name, record_id, actor, old_data, new_data):
    """
    Insert a record into BRM_AUDIT_LOG => storing old/new data as JSON.
    """
    c=conn.cursor()
    c.execute("""
    INSERT INTO BRM_AUDIT_LOG(
      ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
      OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
    )
    VALUES(?,?,?,?,?,?,GETDATE())
    """,(
        action,
        table_name,
        str(record_id) if record_id else None,
        actor,
        json.dumps(old_data) if old_data else None,
        json.dumps(new_data) if new_data else None
    ))
    conn.commit()

###############################################
#       CONCURRENCY / LOCKING TABLE
###############################################
# *We assume you created a table:
#   CREATE TABLE BRM_RULE_LOCKS (
#       LOCK_ID INT IDENTITY PRIMARY KEY,
#       RULE_ID INT NOT NULL,
#       LOCKED_BY VARCHAR(100) NOT NULL,
#       LOCK_TIMESTAMP DATETIME NOT NULL DEFAULT GETDATE(),
#       EXPIRES_AT DATETIME NOT NULL,
#       FORCE_LOCKED_BY VARCHAR(100) NULL
#   );

def lock_rule(conn, rule_id, user_id, user_group, lock_minutes=30):
    """
    Acquire or refresh lock on a rule. If locked by another user => if user is Admin => force it.
    Otherwise => error.
    """
    cur = conn.cursor()
    # check existing lock
    cur.execute("""
        SELECT LOCK_ID,LOCKED_BY,EXPIRES_AT
        FROM BRM_RULE_LOCKS
        WHERE RULE_ID=? AND EXPIRES_AT>GETDATE()
    """,(rule_id,))
    row = cur.fetchone()
    if row:
        (lock_id, locked_by, exp_ts) = row
        if locked_by != user_id:
            if user_group=="Admin":
                # force lock
                cur.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCKED_BY=?, FORCE_LOCKED_BY=?, LOCK_TIMESTAMP=GETDATE(),
                        EXPIRES_AT=DATEADD(MINUTE,?,GETDATE())
                    WHERE LOCK_ID=?
                """,(user_id,user_id,lock_minutes,lock_id))
            else:
                raise ValueError(f"Rule {rule_id} is locked by {locked_by} until {exp_ts}")
        else:
            # refresh lock
            cur.execute("""
                UPDATE BRM_RULE_LOCKS
                SET EXPIRES_AT=DATEADD(MINUTE,?,GETDATE())
                WHERE LOCK_ID=?
            """,(lock_minutes,lock_id))
    else:
        # no active lock => create
        cur.execute("""
            INSERT INTO BRM_RULE_LOCKS(RULE_ID,LOCKED_BY,LOCK_TIMESTAMP,EXPIRES_AT)
            VALUES(?,?,GETDATE(),DATEADD(MINUTE,?,GETDATE()))
        """,(rule_id,user_id,lock_minutes))
    conn.commit()

def unlock_rule(conn, rule_id, user_id, user_group):
    """
    Release lock if user holds it or user is admin
    """
    cur = conn.cursor()
    cur.execute("""
        SELECT LOCK_ID,LOCKED_BY
        FROM BRM_RULE_LOCKS
        WHERE RULE_ID=? AND EXPIRES_AT>GETDATE()
    """,(rule_id,))
    row = cur.fetchone()
    if row:
        (lock_id, locked_by) = row
        if locked_by!=user_id and user_group!="Admin":
            raise ValueError(f"You do not hold lock on rule {rule_id}; only Admin can force unlock.")
        # remove lock
        cur.execute("DELETE FROM BRM_RULE_LOCKS WHERE LOCK_ID=?",(lock_id,))
        conn.commit()

########################################
#           LIFECYCLE STATES
########################################
RULE_LIFECYCLE_STATES = [
    "DRAFT",
    "UNDER_APPROVAL",
    "APPROVED",
    "ACTIVE",
    "INACTIVE",
    "ARCHIVED"
]

########################################
#       ONBOARDING WIZARD
########################################
class OnboardingWizard(QDialog):
    """
    Optional wizard => create group, create rule, schedule => done.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Welcome Wizard (Part 1 - Advanced)")
        self.resize(400,300)

        main_layout=QVBoxLayout(self)
        self.steps_label=QLabel("Welcome to the advanced BRM Tool!\nThis wizard helps new users do basic setup.")
        main_layout.addWidget(self.steps_label)

        self.current_step=0
        next_btn=QPushButton("Next")
        next_btn.clicked.connect(self.advance_step)
        main_layout.addWidget(next_btn)
        self.setLayout(main_layout)

    def advance_step(self):
        self.current_step+=1
        if self.current_step==1:
            self.steps_label.setText("Step 1: Go to 'Group Management' => 'Add Group'.")
        elif self.current_step==2:
            self.steps_label.setText("Step 2: Go to 'Business Rules' => 'Add Rule'.")
        elif self.current_step==3:
            self.steps_label.setText("Step 3: Go to 'Scheduling' => 'Add New Schedule'.")
        else:
            self.steps_label.setText("All done. Enjoy the BRM Tool.")
            self.accept()
"""
BRM TOOL – PART 2 of 8 (Advanced BFS + Concurrency + Parallel Approvals + Table Permissions)
No references to old code or placeholders.
"""

import json
import logging
from datetime import datetime
from collections import deque

########################################
# DETECT OPERATION TYPE
########################################
def detect_operation_type(rule_sql: str, decision_table_id=None)->str:
    """
    Return one of INSERT/UPDATE/DELETE/SELECT/DECISION_TABLE/OTHER.
    If rule_sql is blank but there's a decision_table_id => DECISION_TABLE.
    """
    if (not rule_sql.strip()) and decision_table_id:
        return "DECISION_TABLE"
    up=rule_sql.strip().upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

########################################
# ADVANCED SQL PARSER
########################################
def parse_sql_dependencies(sql_text:str):
    """
    Return dict => { 'tables': [...], 'cte_tables': [...], 'alias_map':..., 'columns':... }.
    Using sqlparse => see Part 1 imports.
    """
    statements=sqlparse.parse(sql_text)
    final_tables=[]
    cte_info=[]
    alias_map={}
    column_list=[]

    for stmt in statements:
        ctes=_extract_with_clauses(stmt)
        for cName, cRefs in ctes.items():
            cte_info.append((cName,cRefs))

        main_refs, main_alias=_extract_main_from(stmt.tokens, set(ctes.keys()))
        final_tables.extend(main_refs)
        alias_map.update(main_alias)

        col_refs=_extract_columns(stmt)
        column_list.extend(col_refs)

    unique_tables=list({x for x in final_tables})
    return {
        "tables": unique_tables,
        "cte_tables": cte_info,
        "alias_map": alias_map,
        "columns": column_list
    }

#--- helper functions used by parse_sql_dependencies
def _extract_with_clauses(statement):
    cte_map={}
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper()=="WITH":
            i+=1
            i=_parse_cte_block(tokens,i,cte_map)
            continue
        i+=1
    return cte_map

def _parse_cte_block(tokens,i,cte_map):
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and hasattr(tk,"tokens"):
            pass
        if isinstance(tk,sqlparse.sql.Identifier):
            cte_name=tk.get_real_name()
            i+=1
            i=_parse_cte_as_clause(tokens,i,cte_name,cte_map)
        elif tk.ttype is Keyword and tk.value.upper() in ("SELECT","INSERT","UPDATE","DELETE"):
            return i
        else:
            i+=1
    return i

def _parse_cte_as_clause(tokens,i,cte_name,cte_map):
    while i<len(tokens):
        tk=tokens[i]
        val=tk.value.upper() if tk.ttype else ""
        if val=="AS":
            i+=1
            if i<len(tokens):
                sub=tokens[i]
                if isinstance(sub,sqlparse.sql.Parenthesis):
                    sub_refs=_extract_subselect_tokens(sub.tokens)
                    cte_map[cte_name]=sub_refs
                    i+=1
                    return i
        else:
            i+=1
    return i

def _extract_subselect_tokens(tokens):
    results=[]
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk,sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident,set())
                    st=(st[0],st[1],st[2],True)
                    results.append(st)
            elif isinstance(tk,sqlparse.sql.Identifier):
                st=_parse_identifier(tk,set())
                st=(st[0],st[1],st[2],True)
                results.append(st)
        i+=1
    return results

def _is_subselect(token):
    if not token.is_group:
        return False
    for sub in token.tokens:
        if sub.ttype is DML and sub.value.upper()=="SELECT":
            return True
    return False

def _extract_main_from(tokenlist, known_cte_names):
    results=[]
    alias_map={}
    tokens=list(tokenlist)
    from_seen=False
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.is_group and _is_subselect(tk):
            sub2=_extract_subselect_tokens(tk.tokens)
            results.extend(sub2)
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","INNER JOIN","LEFT JOIN","RIGHT JOIN","FULL JOIN"):
                from_seen=True
            else:
                from_seen=False
        if from_seen:
            if isinstance(tk,sqlparse.sql.IdentifierList):
                for ident in tk.get_identifiers():
                    st=_parse_identifier(ident, known_cte_names)
                    results.append(st)
                    if st[2]:
                        alias_map[st[2]]=(st[0],st[1])
            elif isinstance(tk,sqlparse.sql.Identifier):
                st=_parse_identifier(tk, known_cte_names)
                results.append(st)
                if st[2]:
                    alias_map[st[2]]=(st[0],st[1])
        i+=1
    return (results,alias_map)

def _parse_identifier(ident, known_cte_names):
    alias=ident.get_alias()
    real_name=ident.get_real_name()
    schema_name=ident.get_parent_name()
    if real_name and real_name.upper() in (n.upper() for n in known_cte_names):
        return (None, f"(CTE) {real_name}", alias, False)
    return (schema_name, real_name, alias, False)

def _extract_columns(statement):
    results=[]
    tokens=list(statement.tokens)
    i=0
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is DML:
            word=tk.value.upper()
            if word=="SELECT":
                col_refs=_parse_select_list(tokens,i+1)
                for c_ in col_refs:
                    results.append((c_, False, True))
            elif word in ("INSERT","UPDATE"):
                col_refs2=_parse_dml_columns(tokens,i,word)
                for c_ in col_refs2:
                    results.append((c_,True,False))
        i+=1
    return results

def _parse_select_list(tokens, start_idx):
    columns=[]
    i=start_idx
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword:
            upv=tk.value.upper()
            if upv in ("FROM","JOIN","WHERE","GROUP","ORDER","UNION","INTERSECT"):
                break
        if isinstance(tk,sqlparse.sql.IdentifierList):
            for ident in tk.get_identifiers():
                nm=ident.get_name()
                if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                    columns.append(nm)
        elif isinstance(tk,sqlparse.sql.Identifier):
            nm=tk.get_name()
            if nm and nm.upper() not in ("DISTINCT","TOP","ALL"):
                columns.append(nm)
        i+=1
    return columns

def _parse_dml_columns(tokens, start_idx, dml_word):
    columns=[]
    if dml_word=="INSERT":
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.is_group and isinstance(tk,sqlparse.sql.Parenthesis):
                for subiden in tk.tokens:
                    if isinstance(subiden,sqlparse.sql.IdentifierList):
                        for ident in subiden.get_identifiers():
                            columns.append(ident.get_name())
                    elif isinstance(subiden,sqlparse.sql.Identifier):
                        columns.append(subiden.get_name())
                return columns
            i+=1
    elif dml_word=="UPDATE":
        found_set=False
        i=start_idx
        while i<len(tokens):
            tk=tokens[i]
            if tk.ttype is Keyword and tk.value.upper()=="SET":
                found_set=True
                i+=1
                columns.extend(_parse_update_set_list(tokens,i))
                break
            i+=1
    return columns

def _parse_update_set_list(tokens, start_i):
    columns=[]
    i=start_i
    while i<len(tokens):
        tk=tokens[i]
        if tk.ttype is Keyword and tk.value.upper() in ("WHERE","FROM"):
            break
        if isinstance(tk,sqlparse.sql.Identifier):
            columns.append(tk.get_name())
        i+=1
    return columns

########################################
# PERMISSIONS CHECK
########################################
def check_user_table_permissions(conn, user_group, tables_list):
    """
    For each table in 'tables_list', check if user_group has permission in GROUP_PERMISSIONS.
    If not => raise an error.
    """
    c=conn.cursor()
    for tb_ in tables_list:
        # tb_ is (schema, table, alias, issub)
        # We just check the actual table name
        if tb_[1] is None or tb_[1].startswith("(CTE)"):
            continue
        actual_table=tb_[1]  # or f"{tb_[0]}.{tb_[1]}" if needed
        # attempt to find permission
        c.execute("""
        SELECT 1
        FROM GROUP_PERMISSIONS
        WHERE GROUP_NAME=? AND TARGET_TABLE=?
        """,(user_group,actual_table))
        row=c.fetchone()
        if not row:
            # user does not have permission => raise
            raise ValueError(f"Group '{user_group}' lacks permission on table '{actual_table}'")

########################################
# BFS / Approvals / Data Validation / etc.
########################################

def build_conflict_map(conn):
    """
    For advanced BFS => store conflicts => rule1-> set(rule2) if priority is such that rule2 must be skipped if rule1 fails.
    (Implementation depends on domain logic.)
    """
    c=conn.cursor()
    c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS")
    rows=c.fetchall()
    adjacency={}
    # example: adjacency[rule1].add(rule2)
    for (cfid,r1,r2,pri) in rows:
        adjacency.setdefault(r1,set()).add(r2)
    return adjacency

def build_global_critical_links(conn):
    c=conn.cursor()
    c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows=c.fetchall()
    gmap={}
    for (gcr,tgt) in rows:
        gmap.setdefault(gcr,set()).add(tgt)
    return gmap

def build_rule_children_map(conn):
    c=conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows=c.fetchall()
    children={}
    allids=set()
    for (rid,pid) in rows:
        allids.add(rid)
        if pid:
            children.setdefault(pid,[]).append(rid)
    return children

def skip_all_descendants(start_id, adjacency_map, skipped):
    queue=[start_id]
    while queue:
        cur=queue.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency_map:
            for ch_ in adjacency_map[cur]:
                if ch_ not in skipped:
                    queue.append(ch_)

def run_single_rule_transaction(conn, rule_info, is_dry_run=False):
    """
    If rule is DECISION_TABLE => stub pass or advanced logic.
    If normal => run its SQL => if row[0][0]==1 => PASS => commit => else rollback.
    If is_dry_run => always rollback in the end, ignoring success or not.
    Return (success_flag, message, rowcount).
    """
    # concurrency check => optional if BFS or user calls
    # if needed => lock_rule(...) but BFS might skip

    if rule_info["OPERATION_TYPE"]=="DECISION_TABLE":
        dt_id=rule_info.get("DECISION_TABLE_ID")
        return (True, f"DecisionTable {dt_id} => PASS (Stub)",1)

    sql_=rule_info["RULE_SQL"] or ""
    c=conn.cursor()
    c.execute("BEGIN TRANSACTION")
    success=False
    msg=""
    rec_count=0
    try:
        c.execute(sql_)
        rows=c.fetchall()
        if rows:
            rec_count=len(rows)
            val=rows[0][0]
            success=(val==1)
            msg=f"Returned: {val}"
        else:
            success=True
            msg="No rows => PASS"
        if is_dry_run:
            c.execute("ROLLBACK")
        else:
            if success:
                c.execute("COMMIT")
            else:
                c.execute("ROLLBACK")
    except Exception as ex:
        c.execute("ROLLBACK")
        success=False
        msg=str(ex)
    return (success,msg,rec_count)

def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    c=conn.cursor()
    c.execute("""
    INSERT INTO RULE_EXECUTION_LOGS(
      RULE_ID,EXECUTION_TIMESTAMP,PASS_FLAG,MESSAGE,RECORD_COUNT
    )
    VALUES(?,GETDATE(),?,?,?)
    """,(rule_id,1 if pass_flag else 0,message,record_count))
    conn.commit()

def advanced_bfs_execute(conn):
    """
    BFS that checks children, global critical, conflicts, etc.
    Also hooking up data validations if needed, plus potential parallel approvals.
    Return (executed_list, skipped_set).
    """
    # build adjacency
    children_map=build_rule_children_map(conn)
    conflict_map=build_conflict_map(conn)
    gcr_map=build_global_critical_links(conn)
    # gather all rules
    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows=c.fetchall()
    colnames=[desc[0] for desc in c.description]
    rule_lookup={}
    allids=set()
    parent_ids=set()
    for row in rows:
        d=dict(zip(colnames,row))
        rule_lookup[d["RULE_ID"]]=d
        allids.add(d["RULE_ID"])
        if d["PARENT_RULE_ID"]:
            parent_ids.add(d["PARENT_RULE_ID"])
    # find roots
    roots=[r for r in allids if r not in parent_ids]

    executed=[]
    skipped=set()
    queue=list(roots)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue

        info=rule_lookup[rid]
        # concurrency check => not locking each BFS step by default, but possible
        (ok,msg,rc)=run_single_rule_transaction(conn, info, is_dry_run=False)
        insert_rule_execution_log(conn, rid,ok,msg,rc)

        if ok:
            executed.append(rid)
            # enqueue children
            if rid in children_map:
                for c_ in children_map[rid]:
                    if c_ not in skipped:
                        queue.append(c_)
            # also if rid in conflict_map => it means if rid PASS => we can keep going
        else:
            # if fail => skip children if critical
            is_crit=(info["CRITICAL_RULE"]==1 or info["IS_GLOBAL"]==1)
            scope=(info["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and scope!="NONE":
                if rid in children_map:
                    for ch_ in children_map[rid]:
                        skip_all_descendants(ch_, children_map, skipped)
                if rid in gcr_map:
                    for gch in gcr_map[rid]:
                        skip_all_descendants(gch, children_map, skipped)
            # also skip conflicts => if rid is fail => skip any conflicting rule if domain says so
            if rid in conflict_map:
                for conf_child in conflict_map[rid]:
                    skip_all_descendants(conf_child, children_map, skipped)

            skipped.add(rid)

    return (executed, skipped)

########################################
# PARALLEL APPROVALS / LANES
########################################
def create_multilane_approvals(conn, rule_id, lanes: list):
    """
    lanes => e.g. [("Security", ["secUser1","secUser2"]), ("Business", ["busOwner"])]
    Each lane must be fully approved => rule => final approval => "APPROVED".
    Store in BRM_RULE_APPROVALS => new col APPROVAL_LANE.
    """
    c=conn.cursor()
    c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_id,))
    stage_ctr=1
    for lane_name, user_list in lanes:
        for u_ in user_list:
            c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, 
              APPROVED_FLAG, APPROVED_TIMESTAMP, APPROVAL_STAGE,
              APPROVAL_LANE
            )
            VALUES(?,?,?,?,NULL,?,?)
            """,(rule_id, lane_name, u_, 0, stage_ctr, lane_name))
        stage_ctr+=1
    conn.commit()

########################################
#  CI/CD TRIGGER
########################################
def trigger_automatic_deployment(conn, rule_id, environment="PROD"):
    """
    Stub => push changes to production environment once fully approved.
    Could call external script/REST for real CI/CD.
    """
    logger.info(f"Rule {rule_id} auto-deploy to {environment} triggered.")
    # Example:
    #call(["deploy_script.sh","--rule_id",str(rule_id),"--env",environment])
    pass
"""
BRM TOOL – PART 3 of 8 (Enhanced Sims, Scheduling, DecisionTables, Conflicts, Composites, Snapshots, Tags, DataValidation)
No references to old code or placeholders.
"""

import json
import math
import logging
import csv
from datetime import datetime
from collections import deque

########################################
# DRY-RUN BFS UTILITY
########################################
def dry_run_bfs(conn, start_rule_ids):
    """
    BFS from each start rule => ignoring concurrency locks => always rollback => purely test.
    Return (executed, skipped).
    """
    # gather adjacency => from part 2
    from .part2 import (
        build_rule_children_map, build_conflict_map, build_global_critical_links, 
        skip_all_descendants, run_single_rule_transaction
    ) # If single-file, reference directly.
    children_map = build_rule_children_map(conn)
    conflict_map = build_conflict_map(conn)
    gcr_map = build_global_critical_links(conn)

    c=conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows=c.fetchall()
    colnames=[desc[0] for desc in c.description]
    rule_lookup={}
    for row in rows:
        d=dict(zip(colnames,row))
        rule_lookup[d["RULE_ID"]]=d

    executed=[]
    skipped=set()
    queue=list(start_rule_ids)

    while queue:
        rid=queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            skipped.add(rid)
            continue
        info=rule_lookup[rid]
        # do is_dry_run transaction
        (ok,msg,rc)=run_single_rule_transaction(conn, info, is_dry_run=True)
        if ok:
            executed.append(rid)
            if rid in children_map:
                for ch_ in children_map[rid]:
                    if ch_ not in skipped:
                        queue.append(ch_)
        else:
            # skip children if critical
            is_crit=(info["CRITICAL_RULE"]==1 or info["IS_GLOBAL"]==1)
            scope=(info["CRITICAL_SCOPE"] or "NONE").upper()
            if is_crit and scope!="NONE":
                if rid in children_map:
                    for cc in children_map[rid]:
                        skip_all_descendants(cc, children_map, skipped)
                if rid in gcr_map:
                    for c_ in gcr_map[rid]:
                        skip_all_descendants(c_, children_map, skipped)
            if rid in conflict_map:
                for conf_ in conflict_map[rid]:
                    skip_all_descendants(conf_, children_map, skipped)
            skipped.add(rid)

    return (executed, skipped)

########################################
# METADATA SYNC
########################################
def sync_metadata_improved(conn):
    """
    Mark missing table references in BRM_RULE_TABLE_DEPENDENCIES as 'MISSING_' prefix
    if not found in sys.tables
    """
    c=conn.cursor()
    c.execute("""
    SELECT s.name as schema_name, t.name as table_name
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id=s.schema_id
    ORDER BY s.name, t.name
    """)
    actual_tables=set()
    for row in c.fetchall():
        fulln=(f"{row[0]}.{row[1]}").lower()
        actual_tables.add(fulln)

    c.execute("SELECT DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME FROM BRM_RULE_TABLE_DEPENDENCIES")
    deps=c.fetchall()
    missing_count=0
    for (dep_id,rid,dbn,tn) in deps:
        cand=(tn or "").lower().strip()
        if "." not in cand:
            cand=(f"dbo.{cand}").lower()
        if cand not in actual_tables:
            # mark as missing
            c.execute("""
            UPDATE BRM_RULE_TABLE_DEPENDENCIES
            SET TABLE_NAME='MISSING_' + TABLE_NAME
            WHERE DEPENDENCY_ID=?
            """,(dep_id,))
            missing_count+=1
    conn.commit()
    msg=(f"Metadata sync => found {len(actual_tables)} real DB tables.\n"
         f"Scanned {len(deps)} dependencies.\n"
         f"Marked {missing_count} references as MISSING.\n")
    QMessageBox.information(None,"Sync Metadata", msg)

########################################
# SCHEDULING
########################################
class EnhancedScheduleDialog(QDialog):
    """
    Pick a rule => schedule => store in RULE_SCHEDULES => 'Scheduled' status
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Enhanced Scheduling (Part 3)")
        self.resize(400,300)

        layout=QVBoxLayout(self)
        form=QFormLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            self.rule_combo.addItem(f"{rid} - {rn}",rid)
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar=QCalendarWidget()
        self.calendar.setSelectedDate(QDate.currentDate())
        self.calendar.setGridVisible(True)
        form.addRow("Select Date:", self.calendar)

        self.time_edit=QtWidgets.QTimeEdit(QtCore.QTime.currentTime())
        self.time_edit.setDisplayFormat("HH:mm:ss")
        form.addRow("Select Time:", self.time_edit)

        layout.addLayout(form)

        bh=QHBoxLayout()
        sch_btn=QPushButton("Schedule")
        sch_btn.clicked.connect(self.do_schedule)
        bh.addWidget(sch_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        layout.addLayout(bh)
        self.setLayout(layout)

    def do_schedule(self):
        rid=self.rule_combo.currentData()
        d_=self.calendar.selectedDate()
        t_=self.time_edit.time()
        dt_str=f"{d_.toString('yyyy-MM-dd')} {t_.toString('HH:mm:ss')}"
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO RULE_SCHEDULES(RULE_ID,SCHEDULE_TIME,STATUS,CREATED_TIMESTAMP)
        VALUES(?,?,'Scheduled',GETDATE())
        """,(rid, dt_str))
        self.connection.commit()
        QMessageBox.information(self,"Scheduled",f"Rule {rid} scheduled at {dt_str}")
        self.close()

class ScheduleManagementTab(QWidget):
    """
    Show RULE_SCHEDULES => add/update/delete => up to 1000
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.table=QTableWidget(0,5)
        self.table.setHorizontalHeaderLabels(["ScheduleID","RuleID","ScheduleTime","Status","Actions"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh Schedules")
        ref_btn.clicked.connect(self.load_schedules)
        bh.addWidget(ref_btn)
        add_btn=QPushButton("Add New Schedule")
        add_btn.clicked.connect(self.add_schedule)
        bh.addWidget(add_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME,STATUS
        FROM RULE_SCHEDULES
        ORDER BY SCHEDULE_TIME DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        rows=c.fetchall()
        for row in rows:
            r_ = self.table.rowCount()
            self.table.insertRow(r_)
            self.table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.table.setItem(r_,1,QTableWidgetItem(str(row[1])))
            self.table.setItem(r_,2,QTableWidgetItem(str(row[2])))
            self.table.setItem(r_,3,QTableWidgetItem(str(row[3])))

            act_w=QWidget()
            hw=QHBoxLayout(act_w)
            hw.setContentsMargins(0,0,0,0)
            upd_btn=QPushButton("Update")
            upd_btn.clicked.connect(lambda _, idx=r_: self.update_schedule(idx))
            del_btn=QPushButton("Delete")
            del_btn.clicked.connect(lambda _, idx=r_: self.delete_schedule(idx))
            hw.addWidget(upd_btn)
            hw.addWidget(del_btn)
            hw.addStretch()
            self.table.setCellWidget(r_,4,act_w)

        self.table.resizeColumnsToContents()

    def add_schedule(self):
        dlg=EnhancedScheduleDialog(self.connection,self)
        dlg.exec_()
        self.load_schedules()

    def update_schedule(self,row_idx):
        it=self.table.item(row_idx,0)
        if not it:
            return
        sch_id=int(it.text())
        newdt,ok=QInputDialog.getText(self,"Update Schedule","Datetime (YYYY-MM-DD HH:mm:ss)?")
        if not ok or not newdt.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("UPDATE RULE_SCHEDULES SET SCHEDULE_TIME=? WHERE SCHEDULE_ID=?",(newdt.strip(),sch_id))
            self.connection.commit()
            QMessageBox.information(self,"Updated",f"Schedule {sch_id} updated.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_schedules()

    def delete_schedule(self,row_idx):
        it=self.table.item(row_idx,0)
        if not it:
            return
        sch_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete schedule {sch_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?",(sch_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Schedule {sch_id} removed.")
        self.load_schedules()

########################################
# ADVANCED FEATURE TABS
########################################

class DecisionTablesTab(QWidget):
    """
    Manage DECISION_TABLES => BFS references them if OPERATION_TYPE=DECISION_TABLE
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.dt_table=QTableWidget(0,3)
        self.dt_table.setHorizontalHeaderLabels(["DT_ID","TableName","Description"])
        layout.addWidget(self.dt_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Decision Table")
        add_btn.clicked.connect(self.add_dt)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Delete Decision Table")
        del_btn.clicked.connect(self.del_dt)
        bh.addWidget(del_btn)
        run_btn=QPushButton("Run Decision Table (Stub)")
        run_btn.clicked.connect(self.run_dt)
        bh.addWidget(run_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.dt_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT DECISION_TABLE_ID,TABLE_NAME,DESCRIPTION FROM DECISION_TABLES ORDER BY DECISION_TABLE_ID")
        for row in c.fetchall():
            r_ = self.dt_table.rowCount()
            self.dt_table.insertRow(r_)
            self.dt_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.dt_table.setItem(r_,1,QTableWidgetItem(row[1]))
            self.dt_table.setItem(r_,2,QTableWidgetItem(row[2] if row[2] else ""))

    def add_dt(self):
        nm,ok=QInputDialog.getText(self,"Add Decision Table","Name:")
        if not ok or not nm.strip():
            return
        ds,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            ds=""
        c=self.connection.cursor()
        c.execute("INSERT INTO DECISION_TABLES(TABLE_NAME,DESCRIPTION) VALUES(?,?)",(nm.strip(),ds.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Decision table created.")
        self.load_dt()

    def del_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No DT selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete Decision Table {dt_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?",(dt_id,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","DT removed.")
        self.load_dt()

    def run_dt(self):
        row=self.dt_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No DT selected.")
            return
        it=self.dt_table.item(row,0)
        dt_id=int(it.text())
        QMessageBox.information(self,"Stub","DT run => pass/fail not truly implemented.")

class ConflictPriorityManagerTab(QWidget):
    """
    Manage RULE_CONFLICTS => BFS references them
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.cf_table=QTableWidget(0,4)
        self.cf_table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        self.cf_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cf_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        bh.addWidget(add_btn)
        setp_btn=QPushButton("Set Priority")
        setp_btn.clicked.connect(self.set_priority)
        bh.addWidget(setp_btn)
        del_btn=QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.del_conflict)
        bh.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.cf_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT CONFLICT_ID,RULE_ID1,RULE_ID2,PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
        for row in c.fetchall():
            r_ = self.cf_table.rowCount()
            self.cf_table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.cf_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_conflict(self):
        r1,ok=QInputDialog.getInt(self,"Add Conflict","Rule1:")
        if not ok:
            return
        r2,ok2=QInputDialog.getInt(self,"Add Conflict","Rule2:")
        if not ok2:
            return
        pri,ok3=QInputDialog.getInt(self,"Priority","Priority int:")
        if not ok3:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1,RULE_ID2,PRIORITY) VALUES(?,?,?)",(r1,r2,pri))
        self.connection.commit()
        QMessageBox.information(self,"Added","Conflict inserted.")
        self.load_conflicts()

    def set_priority(self):
        rw=self.cf_table.currentRow()
        if rw<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        it=self.cf_table.item(rw,0)
        cf_id=int(it.text())
        newp,ok=QInputDialog.getInt(self,"Set Priority",f"New priority for conflict {cf_id}:")
        if not ok:
            return
        c=self.connection.cursor()
        c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?",(newp,cf_id))
        self.connection.commit()
        QMessageBox.information(self,"Updated","Conflict priority changed.")
        self.load_conflicts()

    def del_conflict(self):
        rw=self.cf_table.currentRow()
        if rw<0:
            QMessageBox.warning(self,"None","No conflict selected.")
            return
        it=self.cf_table.item(rw,0)
        cf_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?",(cf_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Conflict removed.")
        self.load_conflicts()

class CompositeRulesTab(QWidget):
    """
    Manage COMPOSITE_RULES => BFS might skip if sub-rules fail
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)
        self.cr_table=QTableWidget(0,4)
        self.cr_table.setHorizontalHeaderLabels(["CRuleID","CRULE_NAME","LOGIC_EXPR","ACTION_ON_PASS"])
        self.cr_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.cr_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Composite Rule")
        add_btn.clicked.connect(self.add_cr)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Delete Composite Rule")
        del_btn.clicked.connect(self.del_cr)
        bh.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_cr)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.setLayout(layout)
        self.load_cr()

    def load_cr(self):
        self.cr_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT COMPOSITE_RULE_ID,CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS FROM COMPOSITE_RULES ORDER BY COMPOSITE_RULE_ID")
        for row in c.fetchall():
            rr=self.cr_table.rowCount()
            self.cr_table.insertRow(rr)
            for col_i,val in enumerate(row):
                self.cr_table.setItem(rr,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_cr(self):
        nm,ok=QInputDialog.getText(self,"New Composite","Name:")
        if not ok or not nm.strip():
            return
        expr,ok2=QInputDialog.getText(self,"Logic Expr","(e.g. 'Rule10==PASS AND Rule20==PASS'):")
        if not ok2:
            expr=""
        act,ok3=QInputDialog.getText(self,"Action On Pass","Optional action (Email, etc):")
        if not ok3:
            act=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO COMPOSITE_RULES(CRULE_NAME,LOGIC_EXPR,ACTION_ON_PASS)
        VALUES(?,?,?)
        """,(nm.strip(),expr.strip(),act.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Created","Composite rule created.")
        self.load_cr()

    def del_cr(self):
        row=self.cr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No composite rule selected.")
            return
        it=self.cr_table.item(row,0)
        cid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete composite rule {cid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?",(cid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted","Composite rule removed.")
        self.load_cr()

class SnapshotManagerTab(QWidget):
    """
    Snapshots => store entire BRM_RULES as JSON => can be used for rollbacks or archiving.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.ss_table=QTableWidget(0,5)
        self.ss_table.setHorizontalHeaderLabels(["SnapshotID","SNAPSHOT_NAME","CREATED_BY","CREATED_TIMESTAMP","SNAPSHOT_JSON"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        bh=QHBoxLayout()
        take_btn=QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        bh.addWidget(take_btn)
        del_btn=QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.del_snap)
        bh.addWidget(del_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snaps)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_snaps()

    def load_snaps(self):
        self.ss_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT SNAPSHOT_ID,SNAPSHOT_NAME,CREATED_BY,CREATED_TIMESTAMP,SNAPSHOT_JSON
        FROM RULE_SNAPSHOTS
        ORDER BY SNAPSHOT_ID DESC
        """)
        rows=c.fetchall()
        for row in rows:
            rr=self.ss_table.rowCount()
            self.ss_table.insertRow(rr)
            for idx,val in enumerate(row):
                self.ss_table.setItem(rr,idx,QTableWidgetItem(str(val) if val else ""))

    def take_snapshot(self):
        nm,ok=QInputDialog.getText(self,"Snapshot","Snapshot name:")
        if not ok or not nm.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES")
        rows=c.fetchall()
        colnames=[desc[0] for desc in c.description]
        arr=[]
        for row in rows:
            arr.append(dict(zip(colnames,row)))
        snap_json=json.dumps(arr,indent=2)
        c.execute("""
        INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME,CREATED_BY,SNAPSHOT_JSON)
        VALUES(?,?,?)
        """,(nm.strip(),"SnapshotUser",snap_json))
        self.connection.commit()
        QMessageBox.information(self,"Snapshot","Snapshot created.")
        self.load_snaps()

    def del_snap(self):
        row=self.ss_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No snapshot selected.")
            return
        it=self.ss_table.item(row,0)
        sid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?",(sid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Snapshot deleted.")
        self.load_snaps()

class TagsManagerTab(QWidget):
    """
    Manage RULE_TAGS => add or remove textual tags to rules.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.tags_table=QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TAG_ID","RULE_ID","TAG_NAME"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        bh.addWidget(add_btn)
        rem_btn=QPushButton("Remove Tag")
        rem_btn.clicked.connect(self.remove_tag)
        bh.addWidget(rem_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)
        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT TAG_ID,RULE_ID,TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
        for row in c.fetchall():
            r_ = self.tags_table.rowCount()
            self.tags_table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.tags_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def add_tag(self):
        rid,ok=QInputDialog.getInt(self,"Add Tag","Rule ID:")
        if not ok:
            return
        tag,ok2=QInputDialog.getText(self,"Tag","Tag name:")
        if not ok2 or not tag.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO RULE_TAGS(RULE_ID,TAG_NAME) VALUES(?,?)",(rid,tag.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Tag assigned.")
        self.load_tags()

    def remove_tag(self):
        row=self.tags_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No tag selected.")
            return
        it=self.tags_table.item(row,0)
        tag_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?",(tag_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Tag removed.")
        self.load_tags()

class DataValidationTab(QWidget):
    """
    Manage data validations => user can run them individually or run all => results go into DATA_VALIDATION_LOGS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.dv_table=QTableWidget(0,6)
        self.dv_table.setHorizontalHeaderLabels(["VALIDATION_ID","TABLE_NAME","COLUMN_NAME","VALIDATION_TYPE","PARAMS","QUERY"])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        bh=QHBoxLayout()
        add_btn=QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_val)
        bh.addWidget(add_btn)
        del_btn=QPushButton("Remove Validation")
        del_btn.clicked.connect(self.remove_val)
        bh.addWidget(del_btn)
        runone_btn=QPushButton("Run Selected")
        runone_btn.clicked.connect(self.run_selected_val)
        bh.addWidget(runone_btn)
        runall_btn=QPushButton("Run All Validations")
        runall_btn.clicked.connect(self.run_all_validations)
        bh.addWidget(runall_btn)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_vals)
        bh.addWidget(ref_btn)
        bh.addStretch()
        layout.addLayout(bh)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)
        self.load_vals()

    def load_vals(self):
        self.dv_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT VALIDATION_ID,TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS,VALIDATION_QUERY
        FROM DATA_VALIDATIONS
        ORDER BY VALIDATION_ID
        """)
        rows=c.fetchall()
        for r_ in rows:
            rr=self.dv_table.rowCount()
            self.dv_table.insertRow(rr)
            for col_i in range(6):
                val=str(r_[col_i]) if r_[col_i] else ""
                self.dv_table.setItem(rr,col_i,QTableWidgetItem(val))

    def add_val(self):
        tbl,ok=QInputDialog.getText(self,"Add Validation","Table name:")
        if not ok or not tbl.strip():
            return
        col,ok2=QInputDialog.getText(self,"Column","Column name:")
        if not ok2:
            col=""
        vtype,ok3=QInputDialog.getText(self,"Validation Type","(e.g. 'NOT NULL','RANGE'):")
        if not ok3:
            vtype=""
        pars,ok4=QInputDialog.getText(self,"Params","(optional) param string:")
        if not ok4:
            pars=""
        qx,ok5=QInputDialog.getText(self,"Validation Query","SQL returning pass/fail or rowcount:")
        if not ok5:
            qx=""
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO DATA_VALIDATIONS(
          TABLE_NAME,COLUMN_NAME,VALIDATION_TYPE,PARAMS,VALIDATION_QUERY
        )
        VALUES(?,?,?,?,?)
        """,(tbl.strip(), col.strip(), vtype.strip(), pars.strip(), qx.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Data validation added.")
        self.load_vals()

    def remove_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        it=self.dv_table.item(row,0)
        vid=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove data validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(vid,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Validation removed.")
        self.load_vals()

    def run_selected_val(self):
        row=self.dv_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"None","No validation selected.")
            return
        vid_item=self.dv_table.item(row,0)
        if not vid_item:
            return
        vid=int(vid_item.text())
        results = self.run_validation_by_id(vid)
        self.result_text.setPlainText(results)

    def run_validation_by_id(self, validation_id):
        c=self.connection.cursor()
        c.execute("SELECT VALIDATION_QUERY FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?",(validation_id,))
        row=c.fetchone()
        if not row or not row[0]:
            return f"Validation {validation_id} has no query."
        query=row[0]
        msg=""
        pass_flag=False
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute(query)
            rows=c.fetchall()
            # interpret your logic => if 0 rows => PASS, etc.
            pass_flag=True
            msg="Validation PASS"
            c.execute("ROLLBACK") # always rollback
        except Exception as ex:
            msg=str(ex)
            pass_flag=False
            c.execute("ROLLBACK")
        c2=self.connection.cursor()
        c2.execute("""
        INSERT INTO DATA_VALIDATION_LOGS(
          VALIDATION_ID,EXEC_TIMESTAMP,PASS_FLAG,MESSAGE
        )
        VALUES(?,GETDATE(),?,?)
        """,(validation_id,1 if pass_flag else 0,msg))
        self.connection.commit()
        return msg

    def run_all_validations(self):
        c=self.connection.cursor()
        c.execute("SELECT VALIDATION_ID FROM DATA_VALIDATIONS")
        rows=c.fetchall()
        output=[]
        for (vid,) in rows:
            res=self.run_validation_by_id(vid)
            output.append(f"Validation {vid} => {res}")
        self.result_text.setPlainText("\n".join(output))

########################################
# WHAT-IF TEST TAB
########################################
def load_csv_into_list(path):
    data=[]
    with open(path,"r",encoding="utf-8") as f:
        rdr=csv.reader(f)
        headers=next(rdr,None)
        if not headers:
            return data
        for row in rdr:
            data.append(row)
    return data

class WhatIfTestTab(QWidget):
    """
    Upload CSV => BFS or single rule dry-run => show pass/fail
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.csv_path=None

        layout=QVBoxLayout(self)
        top_h=QHBoxLayout()

        self.rule_combo=QComboBox()
        c=connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rn) in c.fetchall():
            self.rule_combo.addItem(f"{rid} - {rn}", rid)
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        up_btn=QPushButton("Upload CSV")
        up_btn.clicked.connect(self.upload_csv)
        top_h.addWidget(up_btn)

        run_btn=QPushButton("Run Test")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.result_text=QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_csv(self):
        path,_=QFileDialog.getOpenFileName(self,"Pick CSV","","CSV Files (*.csv)")
        if not path:
            return
        self.csv_path=path
        QMessageBox.information(self,"Uploaded",f"CSV chosen => {path}\nWe'll parse on run_test as needed.")

    def run_test(self):
        rid=self.rule_combo.currentData()
        # parse CSV if any
        data=[]
        if self.csv_path:
            data=load_csv_into_list(self.csv_path)
        # do a BFS or single rule dry-run
        from .part2 import run_single_rule_transaction
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            self.result_text.setPlainText(f"No rule {rid}")
            return
        colnames=[desc[0] for desc in c.description]
        rdict=dict(zip(colnames,row))
        (ok,msg,rc)=run_single_rule_transaction(self.connection, rdict, is_dry_run=True)
        out=f"BFS Single => {'PASS' if ok else 'FAIL'} => {msg}\nCSV rows loaded={len(data)}"
        self.result_text.setPlainText(out)
"""
BRM TOOL – PART 4 of 8 (AuditLogViewer, Global Search, VersionHistory w/ line diff, 
Advanced concurrency in RuleEditor, etc.)
No references to old code or placeholders.
"""

import sys
import json
import csv
import math
import difflib
from datetime import datetime

########################################
# AUDIT LOG VIEWER
########################################
class AuditLogViewer(QDialog):
    """
    Show BRM_AUDIT_LOG => search => CSV export => possibly filter by table/rule
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.setWindowTitle("Audit Logs (Part 4 - Advanced)")
        self.resize(800,600)

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Filter action, table, or actor..")
        self.search_edit.textChanged.connect(self.do_filter)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.log_table=QTableWidget(0,8)
        self.log_table.setHorizontalHeaderLabels([
            "AuditID","Action","Table","RecordID","ActionBy","OldData","NewData","Timestamp"
        ])
        self.log_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.log_table)

        bh=QHBoxLayout()
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_logs)
        bh.addWidget(ref_btn)
        exp_btn=QPushButton("Export CSV")
        exp_btn.clicked.connect(self.export_csv)
        bh.addWidget(exp_btn)
        bh.addStretch()
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        self.log_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
        FROM BRM_AUDIT_LOG
        ORDER BY ACTION_TIMESTAMP DESC
        OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY
        """)
        self.rows=c.fetchall()
        # store raw in self.rows => display
        for row in self.rows:
            r_ = self.log_table.rowCount()
            self.log_table.insertRow(r_)
            for col_i in range(8):
                val=row[col_i]
                if col_i in (5,6) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.log_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def do_filter(self, text):
        txt=text.lower()
        self.log_table.setRowCount(0)
        for row in self.rows:
            # row => (auditid, action, table, recordid, actor, old_data, new_data, timestamp)
            if txt in str(row[1]).lower() or txt in str(row[2]).lower() or txt in str(row[4]).lower():
                r_ = self.log_table.rowCount()
                self.log_table.insertRow(r_)
                for col_i in range(8):
                    val=row[col_i]
                    if col_i in (5,6) and val:
                        try:
                            d_=json.loads(val)
                            val=json.dumps(d_,indent=2)
                        except:
                            pass
                    self.log_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Export CSV","","CSV Files (*.csv)")
        if not path:
            return
        with open(path,"w",newline="",encoding="utf-8") as f:
            writer=csv.writer(f)
            headers=[self.log_table.horizontalHeaderItem(i).text() for i in range(self.log_table.columnCount())]
            writer.writerow(headers)
            for row_i in range(self.log_table.rowCount()):
                rowdata=[]
                for col_i in range(self.log_table.columnCount()):
                    it=self.log_table.item(row_i,col_i)
                    rowdata.append(it.text() if it else "")
                writer.writerow(rowdata)
        QMessageBox.information(self,"Exported",f"Audit logs exported to {path}.")


########################################
# GLOBAL SEARCH
########################################
def global_search_db(conn, keyword):
    """
    Example => unify queries from BRM_RULES, RULE_TAGS, RULE_SCHEDULES, etc.
    Return list of (objtype, objid, display).
    """
    c=conn.cursor()
    kw=f"%{keyword}%"
    results=[]
    # unify
    c.execute("""
    SELECT 'RULE' as OBJTYPE, RULE_ID, RULE_NAME
    FROM BRM_RULES
    WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
    """,(kw,kw))
    for row in c.fetchall():
        results.append(("RULE", row[1], row[2]))

    c.execute("""
    SELECT 'TAG' as OBJTYPE, TAG_ID, TAG_NAME
    FROM RULE_TAGS
    WHERE TAG_NAME LIKE ?
    """,(kw,))
    for row in c.fetchall():
        results.append(("TAG", row[1], row[2]))

    # etc. 
    return results

class GlobalSearchDialog(QDialog):
    """
    A single search box => lists results => user can jump to relevant object.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setWindowTitle("Global Search (Part 4 - advanced)")

        main_layout=QVBoxLayout(self)
        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search across rules, tags, schedules, etc.")
        top_h.addWidget(self.search_edit)
        go_btn=QPushButton("Search")
        go_btn.clicked.connect(self.do_search)
        top_h.addWidget(go_btn)
        main_layout.addLayout(top_h)

        self.results_table=QTableWidget(0,3)
        self.results_table.setHorizontalHeaderLabels(["Type","ID","Name"])
        self.results_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.results_table)

        self.setLayout(main_layout)

    def do_search(self):
        kw=self.search_edit.text().strip()
        if not kw:
            return
        self.results_table.setRowCount(0)
        rows=global_search_db(self.connection, kw)
        for row in rows:
            r_ = self.results_table.rowCount()
            self.results_table.insertRow(r_)
            self.results_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.results_table.setItem(r_,1,QTableWidgetItem(str(row[1])))
            self.results_table.setItem(r_,2,QTableWidgetItem(str(row[2])))

########################################
# VERSION HISTORY with line-by-line comparison
########################################
class VersionHistoryDialog(QDialog):
    """
    Show audit for a single rule => allow rollback => show diff of old vs new?
    """
    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.rule_id=rule_id
        self.setWindowTitle(f"Version History – Rule {rule_id} (Part 4 advanced)")

        self.resize(900,500)
        main_layout=QVBoxLayout(self)
        self.table=QTableWidget(0,6)
        self.table.setHorizontalHeaderLabels([
            "AuditID","Action","Timestamp","OldData","NewData","Diff"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.table)

        bh=QHBoxLayout()
        rb_btn=QPushButton("Rollback Selected")
        rb_btn.clicked.connect(self.do_rollback)
        bh.addWidget(rb_btn)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.close)
        bh.addWidget(close_btn)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)
        self.load_history()

    def load_history(self):
        c=self.connection.cursor()
        c.execute("""
        SELECT AUDIT_ID,ACTION,ACTION_TIMESTAMP,OLD_DATA,NEW_DATA
        FROM BRM_AUDIT_LOG
        WHERE TABLE_NAME='BRM_RULES'
          AND RECORD_ID=?
          AND ACTION IN ('INSERT','UPDATE')
        ORDER BY ACTION_TIMESTAMP DESC
        """,(self.rule_id,))
        rows=c.fetchall()
        self.table.setRowCount(0)
        for row in rows:
            rr=self.table.rowCount()
            self.table.insertRow(rr)
            for col_i in range(5):
                val=row[col_i]
                if col_i in (3,4) and val:
                    try:
                        d_=json.loads(val)
                        val=json.dumps(d_,indent=2)
                    except:
                        pass
                self.table.setItem(rr,col_i,QTableWidgetItem(str(val) if val else ""))

            # generate diff => if old_data & new_data
            old_ = row[3] or ""
            new_ = row[4] or ""
            self.table.setItem(rr,5,QTableWidgetItem(self.compute_diff_str(old_, new_)))

    def compute_diff_str(self, old_s, new_s):
        # do a line diff
        old_l=old_s.splitlines()
        new_l=new_s.splitlines()
        diff = difflib.unified_diff(old_l, new_l, lineterm='')
        return "\n".join(diff)

    def do_rollback(self):
        sel=self.table.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No row selected for rollback.")
            return
        row_i=sel[0].row()
        old_data_item=self.table.item(row_i,3)
        if not old_data_item:
            QMessageBox.warning(self,"No Data","No old_data.")
            return
        old_data_str=old_data_item.text().strip()
        if not old_data_str:
            QMessageBox.warning(self,"Empty","No old data => cannot rollback.")
            return
        confirm=QMessageBox.question(self,"Confirm","Rollback to selected version?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            old_data=json.loads(old_data_str)
        except Exception as ex:
            QMessageBox.critical(self,"JSON Error",str(ex))
            return
        self.apply_rollback(old_data)
        QMessageBox.information(self,"Rolled Back","Version rollback done.")
        self.load_history()

    def apply_rollback(self, old_data):
        # forcibly sets fields => sets status=INACTIVE => re-approval
        rid=old_data["RULE_ID"]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            raise ValueError("Rule not found => cannot rollback.")
        new_sql=old_data.get("RULE_SQL","")
        c.execute("BEGIN TRANSACTION")
        c.execute("""
        UPDATE BRM_RULES
        SET RULE_NAME=?,
            RULE_SQL=?,
            OWNER_GROUP=?,
            STATUS='INACTIVE',
            VERSION=VERSION+1,
            UPDATED_BY='Rollback',
            APPROVAL_STATUS='APPROVAL_IN_PROGRESS'
        WHERE RULE_ID=?
        """,(old_data["RULE_NAME"],new_sql,old_data["OWNER_GROUP"],rid))
        c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        from .part2 import detect_operation_type, parse_sql_dependencies
        op_=detect_operation_type(new_sql, old_data.get("DECISION_TABLE_ID"))
        deps=parse_sql_dependencies(new_sql)
        col_op="READ" if op_=="SELECT" else "WRITE"
        for (sch,tb,alias,_) in deps["tables"]:
            if tb and not tb.startswith("(CTE)"):
                c.execute("""
                INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                  RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP
                )
                VALUES(?,?,?,?,?)
                """,(rid,sch if sch else "N/A",tb,"RolledBackCol",col_op))
        c.execute("COMMIT")

########################################
# RULE DASHBOARD (with concurrency checks?)
########################################
class RuleDashboard(QGroupBox):
    """
    Paginated, filterable rule table => user can select => concurrency is in Part 2
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard",parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        self.current_page=1
        self.records_per_page=50
        self.total_pages=1

        main_layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.search_edit=QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL..")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter=QComboBox()
        self.status_filter.addItem("All",None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","Name","SQL","Status","Version","OwnerGroup","CreatedTS","ApprovalStatus"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        main_layout.addWidget(self.rule_table)

        nav_h=QHBoxLayout()
        self.prev_btn=QPushButton("Previous")
        self.next_btn=QPushButton("Next")
        self.page_label=QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def build_filter_clause(self):
        filters=[]
        params=[]
        txt=self.search_edit.text().strip()
        if txt:
            filters.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            params.extend([f"%{txt}%",f"%{txt}%"])
        st=self.status_filter.currentData()
        if st:
            filters.append("STATUS=?")
            params.append(st)
        if not filters:
            return ("1=1",[])
        return (" AND ".join(filters),params)

    def load_rules(self):
        c=self.connection.cursor()
        clause,pars=self.build_filter_clause()
        cq=f"SELECT COUNT(*) FROM BRM_RULES WHERE {clause}"
        c.execute(cq,pars)
        rowc=c.fetchone()
        total=rowc[0] if rowc else 0
        self.total_pages=max(1,math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        if self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset=(self.current_page-1)*self.records_per_page
        dq=f"""
        SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
        FROM BRM_RULES
        WHERE {clause}
        ORDER BY RULE_ID DESC
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
        """
        c.execute(dq,(*pars,offset,self.records_per_page))
        rows=c.fetchall()

        self.rule_table.setRowCount(0)
        for rd in rows:
            r_ = self.rule_table.rowCount()
            self.rule_table.insertRow(r_)
            for col_i,val in enumerate(rd):
                it=QTableWidgetItem(str(val) if val else "")
                if col_i==3: 
                    if str(val).upper()=="ACTIVE":
                        it.setBackground(QColor(144,238,144))
                    else:
                        it.setBackground(QColor(255,182,193))
                self.rule_table.setItem(r_,col_i,it)

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out


########################################
# RULE EDITOR (Add/Update) + concurrency + table permissions
########################################
class RuleEditorDialog(QDialog):
    """
    Add or Update => concurrency lock => table-level permissions => detect operation => parse references
    """
    def __init__(self, connection, user_group, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_group=user_group
        self.rule_data=rule_data
        self.is_update=(rule_data is not None)

        title="Update Rule" if self.is_update else "Add Rule"
        self.setWindowTitle(title+" (Part 4 advanced)")
        self.resize(900,600)

        main_layout=QVBoxLayout(self)
        form_l=QFormLayout()

        self.group_combo=QComboBox()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
        for (gid,gname) in c.fetchall():
            self.group_combo.addItem(f"{gname} (ID={gid})",gid)
        form_l.addRow("Rule Group:", self.group_combo)

        self.parent_combo=QComboBox()
        self.parent_combo.addItem("(No Parent)",None)
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for (rid,rnm) in c.fetchall():
            self.parent_combo.addItem(f"{rnm} (ID={rid})",rid)
        form_l.addRow("Parent Rule:", self.parent_combo)

        self.name_edit=QLineEdit()
        form_l.addRow("Rule Name:", self.name_edit)

        self.rule_type_combo=QComboBox()
        c.execute("SELECT RULE_TYPE_ID,RULE_TYPE_NAME FROM BRM_RULE_TYPES ORDER BY RULE_TYPE_ID")
        for (tid,tn) in c.fetchall():
            self.rule_type_combo.addItem(tn,tid)
        form_l.addRow("Rule Type:", self.rule_type_combo)

        self.status_combo=QComboBox()
        self.status_combo.addItems(["INACTIVE","ACTIVE"])
        form_l.addRow("Status:", self.status_combo)

        self.start_dt=QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.start_dt.setCalendarPopup(True)
        form_l.addRow("Effective Start:", self.start_dt)

        self.end_dt=QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_dt.setCalendarPopup(True)
        form_l.addRow("Effective End:", self.end_dt)

        self.cdc_combo=QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])
        form_l.addRow("CDC Type:", self.cdc_combo)

        self.sql_edit=QPlainTextEdit()
        self.sql_edit.setPlaceholderText("SQL returning 1 => PASS, 0 => FAIL.\n(Leave blank if DECISION_TABLE_ID used).")
        form_l.addRow("Rule SQL:", self.sql_edit)

        self.desc_edit=QTextEdit()
        form_l.addRow("Description:", self.desc_edit)
        self.just_edit=QTextEdit()
        form_l.addRow("Business Justification:", self.just_edit)

        self.global_cb=None
        if self.user_group=="Admin":
            self.global_cb=QCheckBox("Global (admin only)")
            form_l.addRow("Global:",self.global_cb)

        self.critical_cb=QCheckBox()
        form_l.addRow("Critical Rule:", self.critical_cb)

        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form_l.addRow("Critical Scope:", self.scope_combo)

        self.dt_id_edit=QLineEdit()
        form_l.addRow("DecisionTableID:", self.dt_id_edit)

        main_layout.addLayout(form_l)

        bh=QHBoxLayout()
        self.save_btn=QPushButton("Update" if self.is_update else "Add")
        self.save_btn.clicked.connect(self.on_save)
        bh.addWidget(self.save_btn)
        cancel_btn=QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        bh.addWidget(cancel_btn)
        main_layout.addLayout(bh)

        self.setLayout(main_layout)

        if self.is_update and self.rule_data:
            self.load_existing()

        # concurrency lock if we are updating
        if self.is_update:
            from .part1 import lock_rule
            try:
                lock_rule(self.connection, self.rule_data["RULE_ID"], "CurrentUser", self.user_group)
            except Exception as ex:
                QMessageBox.critical(self,"Lock Error",str(ex))
                self.reject()

    def load_existing(self):
        rd=self.rule_data
        # group
        gid=rd.get("GROUP_ID")
        if gid:
            idx=self.group_combo.findData(gid)
            if idx>=0:
                self.group_combo.setCurrentIndex(idx)
        # parent
        pid=rd.get("PARENT_RULE_ID")
        if pid:
            ix2=self.parent_combo.findData(pid)
            if ix2>=0:
                self.parent_combo.setCurrentIndex(ix2)
        else:
            self.parent_combo.setCurrentIndex(0)
        self.name_edit.setText(rd.get("RULE_NAME",""))
        rt_id=rd.get("RULE_TYPE_ID")
        if rt_id:
            ix3=self.rule_type_combo.findData(rt_id)
            if ix3>=0:
                self.rule_type_combo.setCurrentIndex(ix3)
        st=rd.get("STATUS","INACTIVE")
        ix_st=self.status_combo.findText(st)
        if ix_st>=0:
            self.status_combo.setCurrentIndex(ix_st)
        fmt="%Y-%m-%d %H:%M:%S"
        sd=rd.get("EFFECTIVE_START_DATE","")
        if sd:
            try:
                dt_=datetime.strptime(sd,fmt)
                self.start_dt.setDateTime(dt_)
            except:
                pass
        ed=rd.get("EFFECTIVE_END_DATE","")
        if ed:
            try:
                dt2_=datetime.strptime(ed,fmt)
                self.end_dt.setDateTime(dt2_)
            except:
                pass
        cdcv=rd.get("CDC_TYPE","NONE").upper()
        i_cdc=self.cdc_combo.findText(cdcv)
        if i_cdc>=0:
            self.cdc_combo.setCurrentIndex(i_cdc)

        self.sql_edit.setPlainText(rd.get("RULE_SQL",""))
        if rd.get("DESCRIPTION"):
            self.desc_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.just_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        if self.user_group=="Admin" and rd.get("IS_GLOBAL")==1 and self.global_cb:
            self.global_cb.setChecked(True)
        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_cb.setChecked(True)
        scp=rd.get("CRITICAL_SCOPE","NONE").upper()
        i_scp=self.scope_combo.findText(scp)
        if i_scp>=0:
            self.scope_combo.setCurrentIndex(i_scp)
        if rd.get("DECISION_TABLE_ID"):
            self.dt_id_edit.setText(str(rd["DECISION_TABLE_ID"]))

    def on_save(self):
        from .part2 import detect_operation_type, parse_sql_dependencies, check_user_table_permissions
        from .part2 import lock_rule, unlock_rule, create_multilane_approvals

        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","Rule name required.")
            return
        sql_=self.sql_edit.toPlainText().strip()
        group_id=self.group_combo.currentData()
        parent_id=self.parent_combo.currentData()
        rt_id=self.rule_type_combo.currentData()
        cdcval=self.cdc_combo.currentText().upper()
        st=self.status_combo.currentText()
        sd_str=self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        ed_str=self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        desc_=self.desc_edit.toPlainText().strip()
        just_=self.just_edit.toPlainText().strip()
        isg=0
        if self.user_group=="Admin" and self.global_cb:
            if self.global_cb.isChecked():
                isg=1
        isc=1 if self.critical_cb.isChecked() else 0
        scp_=self.scope_combo.currentText().upper()
        dt_id=None
        if self.dt_id_edit.text().strip():
            try:
                dt_id=int(self.dt_id_edit.text().strip())
            except:
                dt_id=None

        # fetch group name
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BRM_RULE_GROUPS WHERE GROUP_ID=?",(group_id,))
        rowg=c.fetchone()
        if rowg:
            gname=rowg[0]
        else:
            gname="BG1"

        rule_dict={
            "GROUP_ID": group_id,
            "PARENT_RULE_ID": parent_id,
            "RULE_TYPE_ID": rt_id,
            "RULE_NAME": nm,
            "RULE_SQL": sql_,
            "EFFECTIVE_START_DATE": sd_str,
            "EFFECTIVE_END_DATE": ed_str,
            "STATUS": st,
            "DESCRIPTION": desc_,
            "BUSINESS_JUSTIFICATION": just_,
            "IS_GLOBAL": isg,
            "CRITICAL_RULE": isc,
            "CRITICAL_SCOPE": scp_,
            "CDC_TYPE": cdcval,
            "OWNER_GROUP": gname,
            "DECISION_TABLE_ID": dt_id
        }

        # parse => check table permissions
        final_op=detect_operation_type(sql_, dt_id)
        if final_op not in ("DECISION_TABLE","OTHER") and sql_:
            parse_info=parse_sql_dependencies(sql_)
            tables_list=parse_info["tables"]
            # ensure user group can access them
            check_user_table_permissions(self.connection, gname, tables_list)

        if self.is_update and self.rule_data:
            rule_dict["RULE_ID"]=self.rule_data["RULE_ID"]
            # call update function
            confirm=QMessageBox.question(self,"Confirm","Update rule with concurrency checks?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                from .part5_crud import update_rule  # or reference the updated CRUD
                update_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Updated","Rule updated => re-approval started.")
                # unlock
                from .part1 import unlock_rule
                unlock_rule(self.connection, self.rule_data["RULE_ID"], "CurrentUser", self.user_group)
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
        else:
            # add new
            confirm=QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                from .part5_crud import add_rule
                new_id=add_rule(self.connection, rule_dict, "CurrentUser", self.user_group)
                QMessageBox.information(self,"Created",f"Rule {nm} (ID={new_id}) created. Approval in progress.")
                self.accept()
            except Exception as ex:
                QMessageBox.critical(self,"Error",str(ex))
"""
BRM TOOL – PART 5 of 8 (Approvals, GCR Admin, Hierarchy, Enhanced Lineage Graph, advanced concurrency & search)
No references to old code. All references point to previous parts in this codebase.
"""

import sys
import json
import math
import logging
from datetime import datetime, timedelta
from collections import deque

########################################
# MULTI-STEP / PARALLEL APPROVALS
########################################
class MultiStepApprovalTab(QWidget):
    """
    Shows pending approvals for current user => can Approve/Reject if user is in the minimal stage for that lane.
    Also checks if the approval is “stalled” => older than X days => triggers escalation logic.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.logged_in_username=logged_in_username
        self.user_group=user_group
        self.setWindowTitle("Approvals (Part 5)")

        layout=QVBoxLayout(self)
        self.approval_table=QTableWidget(0,8)
        self.approval_table.setHorizontalHeaderLabels([
            "RuleID","GroupName","RuleName","Stage","Lane","Approved?","Approve","Reject"
        ])
        self.approval_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.approval_table)

        ref_btn=QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)

        # Automatic escalation check
        self.escalation_timer=QTimer(self)
        self.escalation_timer.timeout.connect(self.check_escalations)
        self.escalation_timer.start(120000)  # e.g. every 2min

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        self.approval_table.setRowCount(0)
        c=self.connection.cursor()
        # retrieve approvals for this user => only if APPROVED_FLAG=0
        # we also want to check minimal stage per lane
        c.execute("""
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG,
               A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS,
               A.APPROVAL_LANE
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows=c.fetchall()

        def get_min_stage_for_lane(rid_, lane_):
            c2=self.connection.cursor()
            c2.execute("""
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=? AND APPROVAL_LANE=?
              AND APPROVED_FLAG=0
            """,(rid_,lane_))
            ro=c2.fetchone()
            if ro:
                return ro[0]
            return None

        to_display=[]
        for rd in rows:
            # rd => (rule_id, group_name, username, approved_flag, stage, rule_name, rule_approval_status, lane)
            rid=rd[0]
            lane=rd[7]
            stg=rd[4]
            ms=get_min_stage_for_lane(rid, lane)
            if ms==stg:
                to_display.append(rd)

        # fill table
        for row_data in to_display:
            r_ = self.approval_table.rowCount()
            self.approval_table.insertRow(r_)
            rid=row_data[0]
            grp=row_data[1]
            rname=row_data[5]
            stg=row_data[4]
            lane=row_data[7]
            appflag=row_data[3]

            self.approval_table.setItem(r_,0,QTableWidgetItem(str(rid)))
            self.approval_table.setItem(r_,1,QTableWidgetItem(str(grp)))
            self.approval_table.setItem(r_,2,QTableWidgetItem(str(rname)))
            self.approval_table.setItem(r_,3,QTableWidgetItem(str(stg)))
            self.approval_table.setItem(r_,4,QTableWidgetItem(str(lane)))
            self.approval_table.setItem(r_,5,QTableWidgetItem(str(appflag)))

            approve_btn=QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, rowidx=r_: self.do_approve(rowidx))
            self.approval_table.setCellWidget(r_,6,approve_btn)

            reject_btn=QPushButton("Reject")
            reject_btn.clicked.connect(lambda _, rowidx=r_: self.do_reject(rowidx))
            self.approval_table.setCellWidget(r_,7,reject_btn)

    def do_approve(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        lane_item=self.approval_table.item(row_i,4)
        if not rid_item or not grp_item or not lane_item:
            return
        rid=int(rid_item.text())
        grp=str(grp_item.text())
        lane=str(lane_item.text())
        c=self.connection.cursor()
        # set approved_flag=1 => check if any other user in same lane => if all approved => move to next lane => 
        # if final => rule => APPROVED
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVAL_LANE=?
          AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username,lane))
        self.connection.commit()
        QMessageBox.information(self,"Approved",f"Rule {rid} => lane {lane} => Approved by {self.logged_in_username}")
        self.load_approvals()

    def do_reject(self, row_i):
        rid_item=self.approval_table.item(row_i,0)
        grp_item=self.approval_table.item(row_i,1)
        lane_item=self.approval_table.item(row_i,4)
        if not rid_item or not grp_item or not lane_item:
            return
        rid=int(rid_item.text())
        grp=str(grp_item.text())
        lane=str(lane_item.text())
        confirm=QMessageBox.question(self,"Confirm",f"Reject rule {rid} in lane {lane}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("""
        UPDATE BRM_RULE_APPROVALS
        SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE()
        WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=? AND APPROVAL_LANE=?
          AND APPROVED_FLAG=0
        """,(rid,grp,self.logged_in_username,lane))
        c.execute("""
        UPDATE BRM_RULES
        SET APPROVAL_STATUS='REJECTED', STATUS='INACTIVE', LIFECYCLE_STATE='INACTIVE'
        WHERE RULE_ID=?
        """,(rid,))
        from .part1 import insert_audit_log
        insert_audit_log(self.connection,"REJECT","BRM_RULE_APPROVALS",rid,self.logged_in_username,
                         None,{"lane":lane,"rejected":True})
        self.connection.commit()
        QMessageBox.information(self,"Rejected",f"Rule {rid} => lane {lane} => Rejected.")
        self.load_approvals()

    def check_escalations(self):
        """
        If an approval is older than X days => send escalation email or auto-escalate.
        """
        c=self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.GROUP_NAME,A.APPROVAL_LANE,
               DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) AS age,
               A.USERNAME
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
        """)
        rows=c.fetchall()
        THRESH=3  # 3 days
        for row in rows:
            if row[3]>=THRESH:
                # escalate
                logger.info(f"Escalation => Rule {row[0]}, lane={row[2]}, user={row[4]} is {row[3]} days old.")
                # you could send an email to the manager, etc.

########################################
# GLOBAL/CRITICAL ADMIN TAB
########################################
class GlobalCriticalAdminTab(QWidget):
    """
    Admin only => set rules as global/critical => define scope => link/unlink GCR
    Also forcibly unlock or force deactivate if needed.
    """
    def __init__(self, main_window, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_window=main_window
        self.connection=connection
        self.user_group=user_group
        layout=QVBoxLayout(self)

        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin only"))
            self.setLayout(layout)
            return

        top_h=QHBoxLayout()
        self.show_gcr_cb=QCheckBox("Show only GCR rules")
        self.show_gcr_cb.setChecked(True)
        ref_btn=QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rule_list)
        top_h.addWidget(self.show_gcr_cb)
        top_h.addWidget(ref_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        self.rule_table=QTableWidget(0,9)
        self.rule_table.setHorizontalHeaderLabels([
            "RuleID","RuleName","OwnerGroup","IS_GLOBAL","CRITICAL_RULE",
            "CRITICAL_SCOPE","STATUS","UPDATED_BY","Lock/Unlock"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.rule_table)

        # set global/crit
        scope_h=QHBoxLayout()
        self.global_cb=QCheckBox("Set Global?")
        scope_h.addWidget(self.global_cb)
        self.crit_cb=QCheckBox("Set Critical?")
        scope_h.addWidget(self.crit_cb)
        scope_h.addWidget(QLabel("Critical Scope:"))
        self.scope_combo=QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        scope_h.addWidget(self.scope_combo)

        apply_btn=QPushButton("Apply to Selected")
        apply_btn.clicked.connect(self.apply_gcs)
        scope_h.addWidget(apply_btn)
        scope_h.addStretch()
        layout.addLayout(scope_h)

        # link mgmt
        link_h=QHBoxLayout()
        self.gcr_parent_combo=QComboBox()
        link_h.addWidget(QLabel("Parent GCR:"))
        link_h.addWidget(self.gcr_parent_combo)
        self.gcr_child_combo=QComboBox()
        link_h.addWidget(QLabel("Child Rule:"))
        link_h.addWidget(self.gcr_child_combo)
        link_btn=QPushButton("Link Child")
        link_btn.clicked.connect(self.link_child)
        link_h.addWidget(link_btn)
        unlink_btn=QPushButton("Unlink Child")
        unlink_btn.clicked.connect(self.unlink_child)
        link_h.addWidget(unlink_btn)
        link_h.addStretch()
        layout.addLayout(link_h)

        self.link_view=QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        # forcibly unlock or force deactivate
        forced_h=QHBoxLayout()
        unlock_btn=QPushButton("Force Unlock Selected")
        unlock_btn.clicked.connect(self.force_unlock_selected)
        forced_h.addWidget(unlock_btn)
        deactivate_btn=QPushButton("Force Deactivate Selected")
        deactivate_btn.clicked.connect(self.force_deactivate_selected)
        forced_h.addWidget(deactivate_btn)
        forced_h.addStretch()
        layout.addLayout(forced_h)

        ref_all_btn=QPushButton("Refresh All")
        ref_all_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_all_btn)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_combo()
        self.populate_child_combo()
        self.load_link_view()

    def load_rule_list(self):
        self.rule_table.setRowCount(0)
        c=self.connection.cursor()
        if self.show_gcr_cb.isChecked():
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
            ORDER BY RULE_ID DESC
            """)
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,
                   CRITICAL_SCOPE,STATUS,UPDATED_BY
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            """)
        rows=c.fetchall()
        for row in rows:
            r_ = self.rule_table.rowCount()
            self.rule_table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.rule_table.setItem(r_,col_i,QTableWidgetItem(str(val)))
            # col=8 => lock/unlock
            lock_btn=QPushButton("Lock/Unlock")
            lock_btn.clicked.connect(lambda _,rx=r_: self.toggle_lock(rx))
            self.rule_table.setCellWidget(r_,8,lock_btn)
        self.rule_table.resizeColumnsToContents()

    def get_selected_rule_ids(self):
        idxs=self.rule_table.selectionModel().selectedRows()
        out=[]
        for i_ in idxs:
            row=i_.row()
            it=self.rule_table.item(row,0)
            if it:
                out.append(int(it.text()))
        return out

    def apply_gcs(self):
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rules selected.")
            return
        isg=1 if self.global_cb.isChecked() else 0
        isc=1 if self.crit_cb.isChecked() else 0
        scp=self.scope_combo.currentText().upper()
        confirm=QMessageBox.question(self,"Confirm",
            f"Set is_global={isg}, critical={isc}, scope={scp} for {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        for rid in rids:
            c.execute("""
            UPDATE BRM_RULES
            SET IS_GLOBAL=?, CRITICAL_RULE=?, CRITICAL_SCOPE=?
            WHERE RULE_ID=?
            """,(isg,isc,scp,rid))
        self.connection.commit()
        QMessageBox.information(self,"Done",f"Updated {len(rids)} rule(s).")
        self.load_rule_list()

    def populate_gcr_combo(self):
        self.gcr_parent_combo.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT RULE_ID,RULE_NAME
        FROM BRM_RULES
        WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
        ORDER BY RULE_ID
        """)
        for row in c.fetchall():
            self.gcr_parent_combo.addItem(f"{row[0]} - {row[1]}",row[0])

    def populate_child_combo(self):
        self.gcr_child_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        for row in c.fetchall():
            self.gcr_child_combo.addItem(f"{row[0]} - {row[1]}",row[0])

    def load_link_view(self):
        self.link_view.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID,TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        for row in c.fetchall():
            r_ = self.link_view.rowCount()
            self.link_view.insertRow(r_)
            self.link_view.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.link_view.setItem(r_,1,QTableWidgetItem(str(row[1])))

    def link_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            QMessageBox.warning(self,"Invalid","Pick parent & child.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Link {cid} => parent {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID) VALUES(?,?)",(pid,cid))
        from .part1 import insert_audit_log
        insert_audit_log(self.connection,"LINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",None,{"parent":pid,"child":cid})
        self.connection.commit()
        QMessageBox.information(self,"Linked",f"Child {cid} => parent {pid}")
        self.load_link_view()

    def unlink_child(self):
        pid=self.gcr_parent_combo.currentData()
        cid=self.gcr_child_combo.currentData()
        if not pid or not cid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Unlink child {cid} from {pid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_GLOBAL_CRITICAL_LINKS WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?",(pid,cid))
        from .part1 import insert_audit_log
        insert_audit_log(self.connection,"UNLINK_GCR","BRM_GLOBAL_CRITICAL_LINKS",f"{pid}->{cid}","Admin",{"parent":pid,"child":cid},None)
        self.connection.commit()
        QMessageBox.information(self,"Unlinked",f"Child {cid} from parent {pid}")
        self.load_link_view()

    def toggle_lock(self, row_i):
        it=self.rule_table.item(row_i,0)
        if not it:
            return
        rid=int(it.text())
        from .part1 import lock_rule, unlock_rule
        # we attempt to lock if not locked, else unlock
        try:
            lock_rule(self.connection, rid, f"AdminLock", self.user_group, lock_minutes=10)
            QMessageBox.information(self,"Lock","Lock/Refresh lock done.")
        except:
            # try unlock
            try:
                unlock_rule(self.connection, rid, f"AdminLock", self.user_group)
                QMessageBox.information(self,"Unlock","Rule unlocked.")
            except Exception as ex2:
                QMessageBox.critical(self,"Error",str(ex2))

    def force_unlock_selected(self):
        from .part1 import unlock_rule
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        for rid in rids:
            try:
                unlock_rule(self.connection, rid, "AdminForce", self.user_group)
            except Exception as ex:
                logger.error(f"Force unlock failed for rule {rid}: {ex}")
        QMessageBox.information(self,"Unlocked",f"Force unlocked {len(rids)} rule(s).")

    def force_deactivate_selected(self):
        from .part2_crud import deactivate_rule  # or your final location of advanced CRUD
        rids=self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None","No rule(s) selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Force Deactivate {len(rids)} rule(s)? (Ignores approval status).")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        for rid in rids:
            try:
                c.execute("""
                UPDATE BRM_RULES
                SET STATUS='INACTIVE', UPDATED_BY='AdminForce', 
                    VERSION=VERSION+1, LIFECYCLE_STATE='INACTIVE'
                WHERE RULE_ID=?
                """,(rid,))
                from .part1 import insert_audit_log
                insert_audit_log(self.connection,"FORCE_DEACTIVATE","BRM_RULES",rid,"AdminForce",None,{"forced":True})
                self.connection.commit()
            except Exception as ex:
                logger.error(f"Force deactivate error for rule {rid}: {ex}")
        QMessageBox.information(self,"Deactivated",f"Force deactivated {len(rids)} rule(s).")
        self.load_rule_list()

########################################
# HIERARCHY VIEW (Drag & Drop)
########################################
class HierarchyViewTab(QTreeWidget):
    """
    Show group->rule => user can drag rule to another group => re-parent => store in DB => 
    concurrency safe if user is Admin or holds a lock on the rule being moved.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.setHeaderLabels(["Group / Rule (Part 5)"])
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.load_hierarchy()

    def load_hierarchy(self):
        self.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID")
        grows=c.fetchall()
        self.gid_map={}
        for (gid,gname) in grows:
            top=QTreeWidgetItem([f"{gname} (ID={gid})"])
            top.setData(0,Qt.UserRole,("group",gid))
            self.addTopLevelItem(top)
            self.gid_map[gid]=top

        c.execute("SELECT RULE_ID,RULE_NAME,GROUP_ID,PARENT_RULE_ID FROM BRM_RULES ORDER BY RULE_ID")
        rws=c.fetchall()
        self.rule_map={}
        # store full => so we can do re-parent
        for (rid,rn,gid,pid) in rws:
            self.rule_map[rid]=(rn,gid,pid)

        # only top-level => pid is None => attach to group
        for rid,(rname, g_id, p_id) in self.rule_map.items():
            if not p_id:
                if g_id in self.gid_map:
                    parent_item=self.gid_map[g_id]
                    ch=QTreeWidgetItem([f"Rule {rid}: {rname}"])
                    ch.setData(0,Qt.UserRole,("rule",rid))
                    parent_item.addChild(ch)
        # nested children => optional if we want full nested. For brevity, showing only top-level parent => no recursion here
        self.expandAll()

    def dropEvent(self, event):
        super().dropEvent(event)
        # after Qt reorder => we detect new parent => re-parent in DB
        # in real code => parse entire tree structure => or get itemAt, etc.
        # For brevity => we do a simple approach => re-load
        self.update_db_parents()
        self.load_hierarchy()

    def update_db_parents(self):
        """
        Parse entire tree => for each group => for each child => if child is rule => update rule's PARENT_RULE_ID or GROUP_ID
        """
        top_count=self.topLevelItemCount()
        c=self.connection.cursor()
        for i_ in range(top_count):
            group_item=self.topLevelItem(i_)
            if not group_item:
                continue
            group_data=group_item.data(0,Qt.UserRole)
            if group_data and group_data[0]=="group":
                gid=group_data[1]
                # iterate children
                for ch_idx in range(group_item.childCount()):
                    child=group_item.child(ch_idx)
                    if not child:
                        continue
                    cd=child.data(0,Qt.UserRole)
                    if cd and cd[0]=="rule":
                        rid=cd[1]
                        # set parent_rule_id=null => group_id=gid
                        c.execute("""
                        UPDATE BRM_RULES
                        SET PARENT_RULE_ID=NULL, GROUP_ID=?
                        WHERE RULE_ID=?
                        """,(gid,rid))
        self.connection.commit()

########################################
# ENHANCED LINEAGE GRAPH
########################################
from PyQt5.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsEllipseItem, QGraphicsRectItem, QGraphicsLineItem
from PyQt5.QtGui import QPainter, QPen, QBrush, QTransform

class EnhancedLineageGraphWidget(QGraphicsView):
    """
    Visual, color-coded lineage => BFS => tables => rules => 
    advanced search => highlight or dim => statuses: never ran, pass, fail, in-progress
    2D “brain mapping” style layout with Node coordinate spacing
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.scene=QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.populate_graph()

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()

        # gather rules => BFS => position them
        c=self.connection.cursor()
        c.execute("""
        SELECT R.RULE_ID,R.RULE_NAME,R.PARENT_RULE_ID,R.STATUS,R.RULE_TYPE_ID,
               R.CLUSTER_NAME,R.IS_GLOBAL,R.CRITICAL_RULE,
               (SELECT TOP 1 PASS_FLAG FROM RULE_EXECUTION_LOGS L WHERE L.RULE_ID=R.RULE_ID ORDER BY L.EXECUTION_TIMESTAMP DESC) as last_pass
        FROM BRM_RULES R
        ORDER BY R.RULE_ID
        """)
        rows=c.fetchall()
        if not rows:
            self.scene.addText("No rules found.")
            return

        # build children map
        children={}
        all_ids=set()
        parent_ids=set()
        rule_lookup={}
        for row in rows:
            (rid,rname,pid,stat,rtid,cluster,isg,iscrit,last_pass)=row
            all_ids.add(rid)
            if pid:
                parent_ids.add(pid)
                children.setdefault(pid,[]).append(rid)
            rule_lookup[rid]={
                "RULE_ID":rid,
                "RULE_NAME":rname,
                "PARENT_RULE_ID":pid,
                "STATUS":stat,
                "RULE_TYPE_ID":rtid,
                "CLUSTER_NAME":cluster,
                "IS_GLOBAL":isg,
                "CRITICAL_RULE":iscrit,
                "LAST_PASS_FLAG":last_pass
            }
        roots=[x for x in all_ids if x not in parent_ids]
        # BFS layout
        from collections import deque
        queue=deque()
        for r_ in roots:
            queue.append((r_,0))
        level_map={}
        visited=set()

        while queue:
            (rid, depth)=queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            info=rule_lookup[rid]
            count_here=level_map.get(depth,0)
            level_map[depth]=count_here+1
            x=depth*240
            y=(count_here*120)
            node=self.create_rule_node(info)
            node.setPos(x,y)
            self.scene.addItem(node)
            self.node_map[rid]=node
            if rid in children:
                for ch_ in children[rid]:
                    queue.append((ch_, depth+1))

        # draw edges
        for rid,info in rule_lookup.items():
            pid=info["PARENT_RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(self.node_map[pid], self.node_map[rid], QColor("darkblue"))

        # add table dependencies
        c.execute("SELECT RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME,COLUMN_OP FROM BRM_RULE_TABLE_DEPENDENCIES")
        deps=c.fetchall()
        tbl_map={}
        idx=0
        for row in deps:
            (drid,dbn,tbn,coln,cop)=row
            key=(tbn or "").lower()  # or f"{dbn}.{tbn}"
            if not key:
                continue
            if key not in tbl_map:
                ellipse=LineageTableEllipseItem(key)
                ellipse.setPos(1000, idx*60)
                idx+=1
                self.scene.addItem(ellipse)
                tbl_map[key]=ellipse
            if drid in self.node_map:
                colr=QColor("green") if cop=="READ" else QColor("red")
                self.draw_edge(self.node_map[drid], tbl_map[key], colr)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_rule_node(self, info):
        rt_id=info["RULE_TYPE_ID"]
        stat=str(info["STATUS"] or "").lower()
        if rt_id==1:
            node=QGraphicsRectItem(0,0,140,60)
        else:
            node=QGraphicsEllipseItem(0,0,140,60)

        # fill color
        if stat=="active":
            basecol=QColor("lightgreen")
        elif stat=="inactive":
            basecol=QColor("tomato")
        else:
            basecol=QColor("lightgray")

        # refine by last pass
        lp=info["LAST_PASS_FLAG"]
        if lp==1:  # last execution pass
            basecol=QColor("palegreen")
        elif lp==0:
            basecol=QColor("pink")

        node.setBrush(QBrush(basecol))

        pen=QPen(Qt.black,2)
        if info["CRITICAL_RULE"]==1:
            pen=QPen(QColor("red"),3)
        node.setPen(pen)

        disp=info["RULE_NAME"]
        if info["IS_GLOBAL"]==1:
            disp=f"(G) {disp}"
        node.setToolTip(f"Rule {info['RULE_ID']}: {disp}\nStatus={info['STATUS']}\nLastPass={info['LAST_PASS_FLAG']}")
        return node

    def draw_edge(self, itemA, itemB, color=QColor("darkblue")):
        rA=itemA.sceneBoundingRect()
        rB=itemB.sceneBoundingRect()
        c1=rA.center()
        c2=rB.center()
        line=QGraphicsLineItem(c1.x(),c1.y(), c2.x(),c2.y())
        line.setPen(QPen(color,2))
        self.scene.addItem(line)

    def resetView(self):
        br=self.scene.itemsBoundingRect()
        if br.isValid():
            self.fitInView(br, Qt.KeepAspectRatio)

    def highlight_nodes(self, text):
        """
        Dim all nodes not matching => highlight those matching => e.g. if text is in node tooltip.
        """
        for rid,node in self.node_map.items():
            tip=node.toolTip().lower()
            if text.lower() in tip:
                node.setOpacity(1.0)
            else:
                node.setOpacity(0.2)

    def mouseDoubleClickEvent(self, event):
        item=self.itemAt(event.pos())
        if item:
            tip=item.toolTip()
            QMessageBox.information(self,"Details",f"{tip}")
        super().mouseDoubleClickEvent(event)

class LineageTableEllipseItem(QGraphicsEllipseItem):
    """
    Represents a DB table => color-coded => you can add tooltips for data validations, etc.
    """
    def __init__(self, table_name):
        super().__init__(0,0,110,50)
        self.table_name=table_name
        self.setBrush(QBrush(QColor("lightblue")))
        self.setPen(QPen(Qt.black,2))
        self.setToolTip(f"Table: {table_name} (click for details)")

    def mouseDoubleClickEvent(self, event):
        QMessageBox.information(None,"Table Info",f"Table: {self.table_name}")
        super().mouseDoubleClickEvent(event)
"""
BRM TOOL – PART 6 of 8 (Metrics Dashboard, Control Tables, Group Management, User Management)
No references to old code. Production-level with concurrency & performance stats.
"""

import math

########################################
# METRICS DASHBOARD
########################################
class MetricsDashboardTab(QWidget):
    """
    Show bar chart => rule counts by status, plus performance stats from RULE_EXECUTION_LOGS
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection
        layout=QVBoxLayout(self)

        self.chart=pg.PlotWidget(title="Rule Counts & Performance (Part 6)")
        self.chart.setBackground('w')
        layout.addWidget(self.chart)

        self.perf_chart=pg.PlotWidget(title="Avg Execution Time (ms) by RuleID")
        self.perf_chart.setBackground('w')
        layout.addWidget(self.perf_chart)

        btn=QPushButton("Refresh Metrics")
        btn.clicked.connect(self.load_metrics)
        layout.addWidget(btn)

        self.setLayout(layout)
        self.load_metrics()

    def load_metrics(self):
        c=self.connection.cursor()
        # 1) rule counts by status
        c.execute("SELECT STATUS,COUNT(*) FROM BRM_RULES GROUP BY STATUS")
        rows=c.fetchall()
        statuses=[r[0] for r in rows]
        counts=[r[1] for r in rows]

        self.chart.clear()
        if statuses:
            xvals=range(len(statuses))
            bar_item=pg.BarGraphItem(x=list(xvals), height=counts, width=0.6, brush="skyblue")
            self.chart.addItem(bar_item)
            self.chart.getAxis("bottom").setTicks([list(zip(xvals,statuses))])
            self.chart.setLabel("left","Count")
            self.chart.setLabel("bottom","Status")
            self.chart.showGrid(x=True,y=True)

        # 2) performance => we assume RULE_EXECUTION_LOGS has a column "EXECUTION_TIME_MS"
        # If it doesn't, you'd add it. For demonstration:
        c.execute("""
        SELECT RULE_ID, AVG(EXECUTION_TIME_MS)
        FROM RULE_EXECUTION_LOGS
        WHERE EXECUTION_TIME_MS IS NOT NULL
        GROUP BY RULE_ID
        ORDER BY RULE_ID
        """)
        perf_rows=c.fetchall()
        if perf_rows:
            x_perf=[i for i in range(len(perf_rows))]
            y_perf=[r[1] for r in perf_rows]
            scatter=pg.ScatterPlotItem(x=x_perf,y=y_perf,pen='b',symbol='o')
            self.perf_chart.clear()
            self.perf_chart.addItem(scatter)
            rule_ids_str=[str(r[0]) for r in perf_rows]
            self.perf_chart.getAxis("bottom").setTicks([list(zip(x_perf,rule_ids_str))])
            self.perf_chart.setLabel("left","Avg Time (ms)")
            self.perf_chart.setLabel("bottom","RuleID")
            self.perf_chart.showGrid(x=True,y=True)

########################################
# CONTROL TABLES TAB
########################################
class CtrlTablesTab(QWidget):
    """
    Admin table viewer => pick from known admin tables => show up to 1000 rows.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.table_list=[
            "USERS","BUSINESS_GROUPS","GROUP_PERMISSIONS","BRM_RULE_TYPES",
            "BRM_RULE_GROUPS","BRM_RULES","BRM_RULE_TABLE_DEPENDENCIES","BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE","BRM_GROUP_BACKUPS","BRM_COLUMN_MAPPING","BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS","BUSINESS_GROUP_APPROVERS","BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS","BRM_GLOBAL_CRITICAL_LINKS","RULE_SCHEDULES",
            "BRM_RULE_COMMENTS","DECISION_TABLES","RULE_CONFLICTS","COMPOSITE_RULES",
            "RULE_SNAPSHOTS","RULE_TAGS","DATA_VALIDATIONS","RULE_EXECUTION_LOGS",
            "DATA_VALIDATION_LOGS","BRM_RULE_LOCKS"
        ]

        self.tbl_combo=QComboBox()
        for t_ in self.table_list:
            self.tbl_combo.addItem(t_)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.tbl_combo)

        load_btn=QPushButton("Load Data")
        load_btn.clicked.connect(self.on_load)
        layout.addWidget(load_btn)

        self.data_table=QTableWidget(0,0)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.data_table)

        self.setLayout(layout)

    def on_load(self):
        tbl=self.tbl_combo.currentText()
        if not tbl:
            return
        c=self.connection.cursor()
        try:
            c.execute(f"SELECT TOP 1 * FROM {tbl}")
            colnames=[d[0] for d in c.description]
        except Exception as ex:
            QMessageBox.critical(self,"Error",f"Fetching columns from {tbl}: {ex}")
            return
        try:
            c.execute(f"SELECT TOP 1000 * FROM {tbl}")
            rows=c.fetchall()
        except Exception as ex2:
            QMessageBox.critical(self,"Error",f"Fetching data from {tbl}: {ex2}")
            return

        self.data_table.setRowCount(0)
        self.data_table.setColumnCount(len(colnames))
        self.data_table.setHorizontalHeaderLabels(colnames)
        for row in rows:
            r_ = self.data_table.rowCount()
            self.data_table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.data_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val is not None else ""))

########################################
# GROUP MANAGEMENT TAB
########################################
class GroupManagementTab(QWidget):
    """
    Manage business groups => membership => group perms => approvers => concurrency
    Only visible if user_group=="Admin"
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        if user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Admin Only"))
            self.setLayout(layout)
            return

        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        # groups + membership
        gm_tab=QWidget()
        gm_layout=QVBoxLayout(gm_tab)

        grp_box=QGroupBox("Group Details")
        grp_layout=QVBoxLayout(grp_box)
        self.groups_table=QTableWidget(0,3)
        self.groups_table.setHorizontalHeaderLabels(["GroupName","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        gb_h=QHBoxLayout()
        add_grp=QPushButton("Add Group")
        add_grp.clicked.connect(self.add_group)
        gb_h.addWidget(add_grp)
        ren_grp=QPushButton("Rename Group")
        ren_grp.clicked.connect(self.rename_group)
        gb_h.addWidget(ren_grp)
        del_grp=QPushButton("Delete Group")
        del_grp.clicked.connect(self.delete_group)
        gb_h.addWidget(del_grp)
        gb_h.addStretch()
        grp_layout.addLayout(gb_h)

        gm_layout.addWidget(grp_box)

        memb_box=QGroupBox("Membership")
        memb_layout=QVBoxLayout(memb_box)
        self.users_table=QTableWidget(0,3)
        self.users_table.setHorizontalHeaderLabels(["UserID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        memb_layout.addWidget(self.users_table)

        mb_h=QHBoxLayout()
        add_usr=QPushButton("Add User to Group")
        add_usr.clicked.connect(self.add_user_to_group)
        mb_h.addWidget(add_usr)
        rem_usr=QPushButton("Remove User from Group")
        rem_usr.clicked.connect(self.remove_user_from_group)
        mb_h.addWidget(rem_usr)
        mb_h.addStretch()
        memb_layout.addLayout(mb_h)

        gm_layout.addWidget(memb_box)
        gm_tab.setLayout(gm_layout)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        # permissions
        perm_tab=QWidget()
        perm_layout=QVBoxLayout(perm_tab)
        perm_box=QGroupBox("Group Permissions")
        perm_box_layout=QVBoxLayout(perm_box)

        top_h=QHBoxLayout()
        self.perm_group_combo=QComboBox()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        top_h.addWidget(QLabel("Group:"))
        top_h.addWidget(self.perm_group_combo)
        top_h.addStretch()
        perm_box_layout.addLayout(top_h)

        self.perm_table=QTableWidget(0,1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        ph=QHBoxLayout()
        addp=QPushButton("Add Permission")
        addp.clicked.connect(self.add_permission)
        ph.addWidget(addp)
        remp=QPushButton("Remove Permission")
        remp.clicked.connect(self.remove_permission)
        ph.addWidget(remp)
        ph.addStretch()
        perm_box_layout.addLayout(ph)

        perm_layout.addWidget(perm_box)
        perm_tab.setLayout(perm_layout)
        self.tabs.addTab(perm_tab,"Permissions")

        # approvers
        appr_tab=QWidget()
        appr_layout=QVBoxLayout(appr_tab)

        ah=QHBoxLayout()
        self.appr_group_combo=QComboBox()
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)
        ah.addWidget(QLabel("Group:"))
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table=QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["ApproverID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        ab_h=QHBoxLayout()
        add_ap=QPushButton("Add Approver")
        add_ap.clicked.connect(self.add_approver)
        ab_h.addWidget(add_ap)
        del_ap=QPushButton("Remove Approver")
        del_ap.clicked.connect(self.remove_approver)
        ab_h.addWidget(del_ap)
        ab_h.addStretch()
        appr_layout.addLayout(ab_h)

        appr_tab.setLayout(appr_layout)
        self.tabs.addTab(appr_tab,"Approvers")

        ref_all=QPushButton("Refresh All")
        ref_all.clicked.connect(self.load_data)
        layout.addWidget(ref_all)

        self.setLayout(layout)
        self.load_data()

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_perm_groups()
        self.load_appr_groups()

    def load_groups(self):
        self.groups_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows=c.fetchall()
        for row in rows:
            r_ = self.groups_table.rowCount()
            self.groups_table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.groups_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_group(self):
        rw=self.groups_table.currentRow()
        if rw<0:
            return None
        it=self.groups_table.item(rw,0)
        if not it:
            return None
        return it.text().strip()

    def add_group(self):
        nm,ok=QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not nm.strip():
            return
        desc,ok2=QInputDialog.getText(self,"Description","Optional:")
        if not ok2:
            desc=""
        em,ok3=QInputDialog.getText(self,"Email","Optional:")
        if not ok3:
            em=""
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(nm.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("""
        INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
        VALUES(?,?,?)
        """,(nm.strip(), desc.strip(), em.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Group created.")
        self.load_data()

    def rename_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_nm,ok=QInputDialog.getText(self,"Rename Group",f"New name for '{grp}':")
        if not ok or not new_nm.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_nm.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New name already exists.")
            return
        try:
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_nm.strip(),grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_nm.strip(),grp))
            c.execute("COMMIT")
            QMessageBox.information(self,"Renamed",f"Group '{grp}' => '{new_nm}'.")
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def delete_group(self):
        grp=self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"None","No group selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Deleted",f"Group '{grp}' removed.")
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))
        self.load_data()

    def load_users(self):
        self.users_table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_ = self.users_table.rowCount()
            self.users_table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.users_table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_user(self):
        rw=self.users_table.currentRow()
        if rw<0:
            return None
        it=self.users_table.item(rw,0)
        if not it:
            return None
        return int(it.text())

    def add_user_to_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        grp,ok=QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(uid,))
        ro=c.fetchone()
        if ro and ro[0]==grp.strip():
            QMessageBox.warning(self,"Error","User already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User assigned.")
        self.load_data()

    def remove_user_from_group(self):
        uid=self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm","Remove => user goes to BG1?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Done","User moved to BG1.")
        self.load_data()

    def load_perm_groups(self):
        self.perm_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            self.perm_group_combo.addItem(row[0],row[0])

    def load_permissions(self):
        grp=self.perm_group_combo.currentData()
        self.perm_table.setRowCount(0)
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for row in rows:
            r_ = self.perm_table.rowCount()
            self.perm_table.insertRow(r_)
            self.perm_table.setItem(r_,0,QTableWidgetItem(str(row[0])))

    def add_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        tbl,ok=QInputDialog.getText(self,"Add Permission","Enter table name, e.g. 'dbo.MyTable':")
        if not ok or not tbl.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)",(grp.strip(),tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added","Permission assigned.")
        self.load_permissions()

    def remove_permission(self):
        grp=self.perm_group_combo.currentData()
        if not grp:
            return
        row=self.perm_table.currentRow()
        if row<0:
            return
        it=self.perm_table.item(row,0)
        if not it:
            return
        table_name=it.text().strip()
        confirm=QMessageBox.question(self,"Confirm",f"Remove permission '{table_name}' from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp,table_name))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Permission removed.")
        self.load_permissions()

    def load_appr_groups(self):
        self.appr_group_combo.clear()
        c=self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            self.appr_group_combo.addItem(row[0],row[0])

    def load_approvers(self):
        grp=self.appr_group_combo.currentData()
        self.appr_table.setRowCount(0)
        if not grp:
            return
        c=self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
        rows=c.fetchall()
        for row in rows:
            r_ = self.appr_table.rowCount()
            self.appr_table.insertRow(r_)
            self.appr_table.setItem(r_,0,QTableWidgetItem(str(row[0])))
            self.appr_table.setItem(r_,1,QTableWidgetItem(row[1]))

    def add_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        usr,ok=QInputDialog.getText(self,"Add Approver","Username:")
        if not ok or not usr.strip():
            return
        c=self.connection.cursor()
        c.execute("INSERT INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)",(grp.strip(),usr.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"Approver {usr} added to {grp}.")
        self.load_approvers()

    def remove_approver(self):
        grp=self.appr_group_combo.currentData()
        if not grp:
            return
        row=self.appr_table.currentRow()
        if row<0:
            return
        it=self.appr_table.item(row,0)
        appr_id=int(it.text())
        confirm=QMessageBox.question(self,"Confirm",f"Remove approver {appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Removed","Approver removed.")
        self.load_approvers()

########################################
# USER MANAGEMENT TAB
########################################
class UserManagementTab(QWidget):
    """
    Admin => manage users => add/del => reset pass => concurrency
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection=connection

        layout=QVBoxLayout(self)
        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["UserID","Username","Password","UserGroup"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        bh=QHBoxLayout()
        addb=QPushButton("Add User")
        addb.clicked.connect(self.add_user)
        bh.addWidget(addb)
        delb=QPushButton("Delete User")
        delb.clicked.connect(self.delete_user)
        bh.addWidget(delb)
        passb=QPushButton("Change Password")
        passb.clicked.connect(self.change_pass)
        bh.addWidget(passb)
        bh.addStretch()
        layout.addLayout(bh)

        refb=QPushButton("Refresh")
        refb.clicked.connect(self.load_users)
        layout.addWidget(refb)
        self.setLayout(layout)

        self.load_users()

    def load_users(self):
        self.table.setRowCount(0)
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,PASSWORD,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows=c.fetchall()
        for row in rows:
            r_ = self.table.rowCount()
            self.table.insertRow(r_)
            for col_i,val in enumerate(row):
                self.table.setItem(r_,col_i,QTableWidgetItem(str(val) if val else ""))

    def get_selected_user_id(self):
        sel=self.table.selectedItems()
        if not sel:
            return None
        row=sel[0].row()
        it=self.table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_user(self):
        un,ok=QInputDialog.getText(self,"Add User","Username:")
        if not ok or not un.strip():
            return
        pw,ok2=QInputDialog.getText(self,"Password","Password:")
        if not ok2 or not pw.strip():
            return
        grp,ok3=QInputDialog.getText(self,"Group","(e.g. BG1 or Admin):")
        if not ok3 or not grp.strip():
            return
        c=self.connection.cursor()
        c.execute("SELECT 1 FROM USERS WHERE USERNAME=?",(un.strip(),))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Username in use.")
            return
        c.execute("INSERT INTO USERS(USERNAME,PASSWORD,USER_GROUP) VALUES(?,?,?)",(un.strip(),pw.strip(),grp.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"User {un} created.")
        self.load_users()

    def delete_user(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete user {uid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM USERS WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"User {uid} removed.")
        self.load_users()

    def change_pass(self):
        uid=self.get_selected_user_id()
        if not uid:
            QMessageBox.warning(self,"None","No user selected.")
            return
        pw,ok=QInputDialog.getText(self,"New Password","Password:")
        if not ok or not pw.strip():
            return
        c=self.connection.cursor()
        c.execute("UPDATE USERS SET PASSWORD=? WHERE USER_ID=?",(pw.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Updated",f"Password changed for user {uid}.")
        self.load_users()
"""
BRM TOOL – PART 7 of 8 (Custom Rule Groups + Alerts & Dashboards)
No references to old code or placeholders.
"""

import json
import logging
import re
from datetime import datetime, timedelta

########################################
# CUSTOM RULE GROUPS (Enhanced)
########################################
class CustomRuleGroupEnhancedTab(QWidget):
    """
    Manage custom rule groups => advanced BFS references => backups => concurrency
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)

        top_h=QHBoxLayout()
        self.new_grp_edit=QLineEdit()
        self.new_grp_edit.setPlaceholderText("Enter new custom group name")
        top_h.addWidget(self.new_grp_edit)
        create_btn=QPushButton("Create Group")
        create_btn.clicked.connect(self.create_group)
        top_h.addWidget(create_btn)
        rename_btn=QPushButton("Rename Group")
        rename_btn.clicked.connect(self.rename_group)
        top_h.addWidget(rename_btn)
        del_btn=QPushButton("Delete Group")
        del_btn.clicked.connect(self.delete_group)
        top_h.addWidget(del_btn)
        backup_btn=QPushButton("Backup Group")
        backup_btn.clicked.connect(self.backup_group)
        top_h.addWidget(backup_btn)
        restore_btn=QPushButton("Restore Group")
        restore_btn.clicked.connect(self.restore_group)
        top_h.addWidget(restore_btn)
        top_h.addStretch()
        layout.addLayout(top_h)

        splitter=QtWidgets.QSplitter(Qt.Horizontal)
        self.tree=QTreeWidget()
        self.tree.setHeaderLabels(["CustomGroup / Rule (Part7)"])
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_tree_context)
        splitter.addWidget(self.tree)

        right_widget=QWidget()
        rw_layout=QVBoxLayout(right_widget)
        self.rule_search=QLineEdit()
        self.rule_search.setPlaceholderText("Search rules to assign..")
        self.rule_search.textChanged.connect(self.load_available_rules)
        rw_layout.addWidget(self.rule_search)

        self.rule_list=QListWidget()
        self.rule_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        rw_layout.addWidget(self.rule_list)

        assign_btn=QPushButton("Assign Selected Rule(s)")
        assign_btn.clicked.connect(self.assign_rules)
        rw_layout.addWidget(assign_btn)
        splitter.addWidget(right_widget)
        layout.addWidget(splitter)

        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_group_tree()
        self.load_available_rules()

    def load_group_tree(self):
        self.tree.clear()
        c=self.connection.cursor()
        c.execute("""
        SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
        FROM BRM_CUSTOM_RULE_GROUPS
        ORDER BY CUSTOM_GROUP_ID DESC
        """)
        groups=c.fetchall()
        for (cg_id,cg_name,owner) in groups:
            disp=f"{cg_name} (Owner={owner})"
            g_item=QTreeWidgetItem([disp])
            g_item.setData(0,Qt.UserRole,cg_id)
            g_item.setBackground(0,QBrush(QColor("lightgray")))
            self.tree.addTopLevelItem(g_item)

            c2=self.connection.cursor()
            c2.execute("""
            SELECT R.RULE_ID,R.RULE_NAME,R.IS_GLOBAL,R.CRITICAL_RULE
            FROM BRM_CUSTOM_GROUP_MEMBERS M
            JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
            WHERE M.CUSTOM_GROUP_ID=?
            """,(cg_id,))
            assigned=c2.fetchall()
            for (rid,rn,isg,isc) in assigned:
                txt=f"Rule {rid}: {rn}"
                rr_item=QTreeWidgetItem([txt])
                rr_item.setData(0,Qt.UserRole,rid)
                if isg==1:
                    rr_item.setBackground(0,QBrush(QColor("lightblue")))
                if isc==1:
                    rr_item.setBackground(0,QBrush(QColor("lightcoral")))
                g_item.addChild(rr_item)
        self.tree.expandAll()

    def load_available_rules(self):
        self.rule_list.clear()
        txt=self.rule_search.text().strip()
        c=self.connection.cursor()
        if txt:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """,(f"%{txt}%",f"%{txt}%"))
        else:
            c.execute("""
            SELECT RULE_ID,RULE_NAME,OWNER_GROUP
            FROM BRM_RULES
            ORDER BY RULE_ID DESC
            OFFSET 0 ROWS FETCH NEXT 500 ROWS ONLY
            """)
        rows=c.fetchall()

        c2=self.connection.cursor()
        c2.execute("SELECT DISTINCT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS")
        assigned=set([r[0] for r in c2.fetchall()])

        for (rid,rn,og) in rows:
            if rid in assigned:
                continue
            disp=f"Rule {rid}: {rn} (Owner={og})"
            it=QListWidgetItem(disp)
            it.setData(Qt.UserRole,rid)
            self.rule_list.addItem(it)

    def on_tree_context(self, pos):
        item=self.tree.itemAt(pos)
        if not item:
            return
        parent=item.parent()
        if parent:
            # means it's a rule => can remove from group
            menu=QMenu()
            rem_act=menu.addAction("Remove Rule from Group")
            chosen=menu.exec_(self.tree.viewport().mapToGlobal(pos))
            if chosen==rem_act:
                group_id=parent.data(0,Qt.UserRole)
                rule_id=item.data(0,Qt.UserRole)
                c=self.connection.cursor()
                c.execute("""
                DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(group_id,rule_id))
                self.connection.commit()
                QMessageBox.information(self,"Removed",f"Rule {rule_id} removed.")
                self.refresh_all()

    def create_group(self):
        nm=self.new_grp_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"Error","No group name.")
            return
        c=self.connection.cursor()
        c.execute("""
        INSERT INTO BRM_CUSTOM_RULE_GROUPS(
          CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY,CREATED_TIMESTAMP
        )
        VALUES(?,?,?,GETDATE())
        """,(nm,self.user_group,f"User:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Created",f"Group '{nm}' created.")
        self.new_grp_edit.clear()
        self.refresh_all()

    def get_selected_tree_group(self):
        sel=self.tree.selectedItems()
        if not sel:
            return (None,None)
        it=sel[0]
        parent=it.parent()
        if parent:
            # rule => get parent
            it=parent
        gid=it.data(0,Qt.UserRole)
        disp=it.text(0)
        return (gid,disp)

    def rename_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            QMessageBox.warning(self,"None","No group selected.")
            return
        new_nm,ok=QInputDialog.getText(self,"Rename Group","New name:")
        if not ok or not new_nm.strip():
            return
        c=self.connection.cursor()
        try:
            c.execute("""
            UPDATE BRM_CUSTOM_RULE_GROUPS
            SET CUSTOM_GROUP_NAME=?
            WHERE CUSTOM_GROUP_ID=?
            """,(new_nm.strip(),gid))
            self.connection.commit()
            QMessageBox.information(self,"Renamed",f"Group renamed to '{new_nm}'.")
            self.refresh_all()
        except Exception as ex:
            QMessageBox.critical(self,"Error",str(ex))

    def delete_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete custom group ID={gid}?")
        if confirm!=QMessageBox.Yes:
            return
        c=self.connection.cursor()
        c.execute("DELETE FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        self.connection.commit()
        QMessageBox.information(self,"Deleted",f"Group {gid} removed.")
        self.refresh_all()

    def backup_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            return
        c=self.connection.cursor()
        c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(gid,))
        row=c.fetchone()
        if not row:
            return
        grpname=row[0]
        c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
        arr=[r[0] for r in c.fetchall()]
        backup_data={"group_name":grpname,"members":arr}
        c.execute("""
        SELECT ISNULL(MAX(BACKUP_VERSION),0)+1
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        """,(gid,))
        rv=c.fetchone()
        new_ver=rv[0]
        c.execute("""
        INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(
          CUSTOM_GROUP_ID,BACKUP_TIMESTAMP,BACKUP_VERSION,BACKUP_JSON
        )
        VALUES(?,GETDATE(),?,?)
        """,(gid,new_ver,json.dumps(backup_data)))
        self.connection.commit()
        QMessageBox.information(self,"Backup",f"Backup version {new_ver} created.")
        self.refresh_all()

    def restore_group(self):
        (gid,disp)=self.get_selected_tree_group()
        if not gid:
            return
        c=self.connection.cursor()
        c.execute("""
        SELECT BACKUP_VERSION,BACKUP_TIMESTAMP,BACKUP_JSON
        FROM BRM_CUSTOM_GROUP_BACKUPS
        WHERE CUSTOM_GROUP_ID=?
        ORDER BY BACKUP_VERSION DESC
        """,(gid,))
        rows=c.fetchall()
        if not rows:
            QMessageBox.information(self,"None","No backups found.")
            return
        items=[f"Version {r[0]} (ts={r[1]})" for r in rows]
        sel,ok=QInputDialog.getItem(self,"Restore","Pick version:",items,0,False)
        if not ok or not sel:
            return
        m=re.search(r"Version\s+(\d+)",sel)
        if not m:
            return
        ver=int(m.group(1))
        backup_json=None
        for r_ in rows:
            if r_[0]==ver:
                backup_json=r_[2]
                break
        if not backup_json:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Restore group {gid} => version {ver}?")
        if confirm!=QMessageBox.Yes:
            return
        try:
            data=json.loads(backup_json)
            new_name=data["group_name"]
            members=data["members"]
            c.execute("BEGIN TRANSACTION")
            c.execute("UPDATE BRM_CUSTOM_RULE_GROUPS SET CUSTOM_GROUP_NAME=? WHERE CUSTOM_GROUP_ID=?",(new_name,gid))
            c.execute("DELETE FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?",(gid,))
            for mid in members:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,mid))
            c.execute("COMMIT")
            QMessageBox.information(self,"Restored",f"Group {gid} => ver {ver} restored.")
            self.refresh_all()
        except Exception as ex:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"Error",str(ex))

    def assign_rules(self):
        sel=self.tree.selectedItems()
        if not sel:
            QMessageBox.warning(self,"None","No group selected.")
            return
        g_item=sel[0]
        if g_item.parent():
            g_item=g_item.parent()
        gid=g_item.data(0,Qt.UserRole)
        if not gid:
            return
        sel_rules=self.rule_list.selectedItems()
        if not sel_rules:
            QMessageBox.warning(self,"None","No rules selected in the list.")
            return
        c=self.connection.cursor()
        count=0
        for it in sel_rules:
            rid=it.data(Qt.UserRole)
            try:
                c.execute("""
                INSERT INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                VALUES(?,?)
                """,(gid,rid))
                count+=1
            except:
                pass
        self.connection.commit()
        QMessageBox.information(self,"Assigned",f"{count} rule(s) assigned.")
        self.refresh_all()

########################################
# ALERTS & DASHBOARDS
########################################
class AlertsAndDashboardsTab(QWidget):
    """
    Show old approvals > X days => upcoming schedules => data validations => etc.
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection=connection
        self.user_id=user_id
        self.user_group=user_group

        layout=QVBoxLayout(self)
        self.alert_text=QPlainTextEdit()
        self.alert_text.setReadOnly(True)
        layout.addWidget(self.alert_text)

        check_btn=QPushButton("Check Alerts")
        check_btn.clicked.connect(self.check_alerts)
        layout.addWidget(check_btn)

        self.setLayout(layout)
        self.check_alerts()

    def check_alerts(self):
        lines=[]
        c=self.connection.cursor()
        # old approvals
        c.execute("""
        SELECT A.RULE_ID,A.APPROVAL_STAGE,R.RULE_NAME,
               DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE()) as age
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.APPROVED_FLAG=0
          AND A.APPROVAL_STAGE=(
            SELECT MIN(APPROVAL_STAGE)
            FROM BRM_RULE_APPROVALS
            WHERE RULE_ID=A.RULE_ID AND APPROVED_FLAG=0
          )
          AND DATEDIFF(DAY,ISNULL(A.APPROVED_TIMESTAMP,R.CREATED_TIMESTAMP),GETDATE())>3
        """)
        old_ap=c.fetchall()
        if old_ap:
            lines.append("Approvals older than 3 days:")
            for (rid,stage,rn,age) in old_ap:
                lines.append(f" - Rule {rid} stage={stage}, age={age}, {rn}")
        else:
            lines.append("No old approvals found.")

        lines.append("")

        # upcoming schedules
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled'
          AND SCHEDULE_TIME>=GETDATE()
          AND SCHEDULE_TIME<=DATEADD(HOUR,24,GETDATE())
        ORDER BY SCHEDULE_TIME
        """)
        upc=c.fetchall()
        if upc:
            lines.append("Upcoming Schedules in next 24h:")
            for (sid,rid,ts) in upc:
                lines.append(f" - Schedule {sid}, rule={rid}, time={ts}")
        else:
            lines.append("No upcoming schedules within 24h.")

        # option: data validations due
        lines.append("")
        c.execute("""
        SELECT VALIDATION_ID, PASS_FLAG, MESSAGE, EXEC_TIMESTAMP
        FROM DATA_VALIDATION_LOGS
        WHERE EXEC_TIMESTAMP>=DATEADD(DAY,-1,GETDATE())
        ORDER BY EXEC_TIMESTAMP DESC
        """)
        recent_vals=c.fetchall()
        if recent_vals:
            lines.append("Recent Data Validations (last 1 day):")
            for (vid,pf,msg,ts) in recent_vals:
                lines.append(f" - Val {vid}, pass={pf}, msg={msg}, {ts}")
        else:
            lines.append("No data validations in last day.")

        self.alert_text.setPlainText("\n".join(lines))
"""
BRM TOOL – PART 8 of 8 (Main QMainWindow + Final Integration)
No references to old code. 
"""

import sys
import json
import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QComboBox,
    QPushButton, QLabel, QMessageBox, QDialog, QLineEdit
)
from PyQt5.QtCore import QTimer

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool – Full Integration (Part 8)")
        self.resize(1300,850)

        self.connection=None
        self.user_id=None
        self.logged_in_username=None
        self.user_group=None

        # Step 1 => DB connection
        from .part1 import DatabaseConnectionDialog
        dbdlg=DatabaseConnectionDialog()
        if dbdlg.exec_()==QDialog.Accepted:
            self.connection=dbdlg.get_connection()
            if not self.connection:
                sys.exit(1)
        else:
            sys.exit(0)

        # Step 2 => login
        from .part1 import LoginDialog
        logdlg=LoginDialog(self.connection)
        if logdlg.exec_()!=QDialog.Accepted:
            sys.exit(0)
        self.user_id=logdlg.user_id
        self.user_group=logdlg.user_group

        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        row=c.fetchone()
        if row:
            self.logged_in_username=row[0]
        else:
            self.logged_in_username="UnknownUser"

        # optional onboarding
        from .part1 import OnboardingWizard
        # wiz=OnboardingWizard(self.connection)
        # wiz.exec_()

        self.init_ui()

    def init_ui(self):
        menubar=self.menuBar()
        fileMenu=menubar.addMenu("File")

        # sync metadata
        from .part3 import sync_metadata_improved
        syncAct=QtWidgets.QAction("Sync Metadata",self)
        def do_sync():
            sync_metadata_improved(self.connection)
        syncAct.triggered.connect(do_sync)
        fileMenu.addAction(syncAct)

        # metrics
        metricsAct=QtWidgets.QAction("View Metrics Dashboard",self)
        metricsAct.triggered.connect(self.show_metrics_dialog)
        fileMenu.addAction(metricsAct)

        # schedule
        from .part3 import EnhancedScheduleDialog
        schedAct=QtWidgets.QAction("New Schedule (Dialog)",self)
        def launch_sched():
            dlg=EnhancedScheduleDialog(self.connection,self)
            dlg.exec_()
        schedAct.triggered.connect(launch_sched)
        fileMenu.addAction(schedAct)

        # chain sim
        from .part3 import ChainSimulationDialog, GroupSimulationDialog
        chainAct=QtWidgets.QAction("Simulate Parent Chain BFS",self)
        def do_chain_sim():
            dlg=ChainSimulationDialog(self.connection,self)
            dlg.exec_()
        chainAct.triggered.connect(do_chain_sim)
        fileMenu.addAction(chainAct)

        grpSimAct=QtWidgets.QAction("Simulate Custom Group BFS",self)
        def do_grp_sim():
            dlg=GroupSimulationDialog(self.connection,self)
            dlg.exec_()
        grpSimAct.triggered.connect(do_grp_sim)
        fileMenu.addAction(grpSimAct)

        helpMenu=menubar.addMenu("Help")
        usageAct=QtWidgets.QAction("Show Tips",self)
        def show_help():
            QMessageBox.information(self,"Help",f"BRM Tool – advanced features. Logged in as {self.logged_in_username} / {self.user_group}.")
        usageAct.triggered.connect(show_help)
        helpMenu.addAction(usageAct)

        # Tools
        toolsMenu=menubar.addMenu("Tools")
        from .part4 import AuditLogViewer, GlobalSearchDialog, VersionHistoryDialog
        alAct=QtWidgets.QAction("View Audit Logs",self)
        def launch_al():
            dlg=AuditLogViewer(self.connection,self.user_group,self)
            dlg.exec_()
        alAct.triggered.connect(launch_al)
        toolsMenu.addAction(alAct)

        srAct=QtWidgets.QAction("Global Search",self)
        def launch_gs():
            dlg=GlobalSearchDialog(self.connection,self)
            dlg.exec_()
        srAct.triggered.connect(launch_gs)
        toolsMenu.addAction(srAct)

        verAct=QtWidgets.QAction("Version History (enter rule ID)",self)
        def launch_ver():
            rid,ok=QInputDialog.getInt(self,"Rule ID","Enter rule ID:")
            if ok:
                dlg=VersionHistoryDialog(self.connection,rid,self)
                dlg.exec_()
        verAct.triggered.connect(launch_ver)
        toolsMenu.addAction(verAct)

        # advanced
        advMenu=menubar.addMenu("Advanced")
        from .part3 import DecisionTablesTab, ConflictPriorityManagerTab, CompositeRulesTab, SnapshotManagerTab, TagsManagerTab, DataValidationTab, WhatIfTestTab
        dt_tab=DecisionTablesTab(self.connection)
        cf_tab=ConflictPriorityManagerTab(self.connection)
        co_tab=CompositeRulesTab(self.connection)
        sn_tab=SnapshotManagerTab(self.connection)
        tg_tab=TagsManagerTab(self.connection)
        dv_tab=DataValidationTab(self.connection)
        wi_tab=WhatIfTestTab(self.connection)

        def open_dt():
            self.tabs.addTab(dt_tab,"DecisionTables")
        advMenu.addAction("Open DecisionTables",open_dt)

        def open_cf():
            self.tabs.addTab(cf_tab,"Conflict Priority")
        advMenu.addAction("Open Conflict Priority",open_cf)

        def open_co():
            self.tabs.addTab(co_tab,"Composite Rules")
        advMenu.addAction("Open Composite",open_co)

        def open_sn():
            self.tabs.addTab(sn_tab,"Snapshots")
        advMenu.addAction("Open Snapshots",open_sn)

        def open_tg():
            self.tabs.addTab(tg_tab,"Tags")
        advMenu.addAction("Open Tags",open_tg)

        def open_dv():
            self.tabs.addTab(dv_tab,"Data Validation")
        advMenu.addAction("Open Data Validation",open_dv)

        def open_wi():
            self.tabs.addTab(wi_tab,"WhatIf Testing")
        advMenu.addAction("Open What-If Testing",open_wi)

        cw=QWidget()
        lay=QVBoxLayout(cw)

        # Impersonate
        if self.user_group=="Admin":
            top_h=QHBoxLayout()
            self.switch_combo=QComboBox()
            sw_btn=QPushButton("Switch User")
            sw_btn.clicked.connect(self.on_switch_user)
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(sw_btn)
            top_h.addStretch()
            lay.addLayout(top_h)
            self.load_user_switch_combo()

        self.tabs=QTabWidget()
        lay.addWidget(self.tabs)

        # BRM Dashboard
        from .part4 import RuleDashboard, RuleEditorDialog
        brw=QWidget()
        br_l=QVBoxLayout(brw)
        top_b=QHBoxLayout()

        add_btn=QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        top_b.addWidget(add_btn)

        upd_btn=QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        top_b.addWidget(upd_btn)

        de_btn=QPushButton("Deactivate")
        de_btn.clicked.connect(self.on_deactivate_rule)
        top_b.addWidget(de_btn)

        dl_btn=QPushButton("Delete")
        dl_btn.clicked.connect(self.on_delete_rule)
        top_b.addWidget(dl_btn)

        etl_btn=QPushButton("Run ETL BFS")
        etl_btn.clicked.connect(self.run_etl_bfs)
        top_b.addWidget(etl_btn)

        sim_btn=QPushButton("Sim Single Rule")
        sim_btn.clicked.connect(self.sim_single_rule)
        top_b.addWidget(sim_btn)

        top_b.addStretch()
        br_l.addLayout(top_b)

        self.dashboard=RuleDashboard(self.connection,self.user_id,self.user_group)
        br_l.addWidget(self.dashboard)
        brw.setLayout(br_l)
        self.tabs.addTab(brw,"Business Rules")

        # Approvals
        from .part5 import MultiStepApprovalTab
        self.approv_tab=MultiStepApprovalTab(self.connection,self.logged_in_username,self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # GCR Admin
        from .part5 import GlobalCriticalAdminTab, HierarchyViewTab, EnhancedLineageGraphWidget
        if self.user_group=="Admin":
            self.gcr_tab=GlobalCriticalAdminTab(self,self.connection,self.user_group)
            self.tabs.addTab(self.gcr_tab,"Global/Critical Admin")

        # Hierarchy
        self.hier_tab=HierarchyViewTab(self.connection)
        self.tabs.addTab(self.hier_tab,"Hierarchy")

        # lineage
        lin_tab=QWidget()
        lin_l=QVBoxLayout(lin_tab)
        self.lineage=EnhancedLineageGraphWidget(self.connection)
        lin_l.addWidget(self.lineage)

        search_h=QHBoxLayout()
        self.lineage_search=QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule/table in lineage..")
        sb=QPushButton("Search")
        sb.clicked.connect(self.do_lineage_search)
        rb=QPushButton("Reset View")
        rb.clicked.connect(self.lineage.resetView)
        refb=QPushButton("Refresh Graph")
        refb.clicked.connect(self.lineage.populate_graph)
        search_h.addWidget(self.lineage_search)
        search_h.addWidget(sb)
        search_h.addWidget(rb)
        search_h.addWidget(refb)
        search_h.addStretch()
        lin_l.addLayout(search_h)

        self.tabs.addTab(lin_tab,"Lineage")

        # custom groups
        from .part7 import CustomRuleGroupEnhancedTab, AlertsAndDashboardsTab
        self.cust_grp=CustomRuleGroupEnhancedTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.cust_grp,"Custom Groups")

        # scheduling
        from .part3 import ScheduleManagementTab
        self.sch_tab=ScheduleManagementTab(self.connection)
        self.tabs.addTab(self.sch_tab,"Scheduling")

        # control
        from .part6 import CtrlTablesTab, MetricsDashboardTab, GroupManagementTab, UserManagementTab
        self.ctrl_tab=CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab,"Control Tables")

        # metrics
        self.metrics_tab=MetricsDashboardTab(self.connection)
        self.tabs.addTab(self.metrics_tab,"Metrics")

        # alerts
        self.alert_tab=AlertsAndDashboardsTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.alert_tab,"Alerts/Dashboards")

        # group mgmt
        self.grp_tab=GroupManagementTab(self.connection,self.user_id,self.user_group)
        self.tabs.addTab(self.grp_tab,"Group Management")

        # user mgmt
        if self.user_group=="Admin":
            self.user_tab=UserManagementTab(self.connection)
            self.tabs.addTab(self.user_tab,"User Management")

        cw.setLayout(lay)
        self.setCentralWidget(cw)

        # timers
        self.approv_timer=QTimer(self)
        self.approv_timer.timeout.connect(self.approv_tab.load_approvals)
        self.approv_timer.start(7000)

        self.schedule_timer=QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedules)
        self.schedule_timer.start(60000)

        self.show()

    def load_user_switch_combo(self):
        c=self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            disp=f"{row[1]} ({row[2]})"
            self.switch_combo.addItem(disp,(row[0],row[2]))

    def on_switch_user(self):
        data=self.switch_combo.currentData()
        if not data:
            return
        (new_uid,new_grp)=data
        if new_uid==self.user_id and new_grp==self.user_group:
            return
        self.user_id=new_uid
        self.user_group=new_grp
        c=self.connection.cursor()
        c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
        ro=c.fetchone()
        if ro:
            self.logged_in_username=ro[0]
        else:
            self.logged_in_username="UnknownUser"
        QMessageBox.information(self,"Switched",f"Impersonating {self.logged_in_username} => group {new_grp}")
        self.approv_tab.logged_in_username=self.logged_in_username
        self.approv_tab.user_group=self.user_group
        self.approv_tab.load_approvals()
        self.dashboard.user_id=self.user_id
        self.dashboard.user_group=self.user_group
        self.dashboard.load_rules()

    def on_add_rule(self):
        from .part4 import RuleEditorDialog
        dlg=RuleEditorDialog(self.connection,self.user_group,None,self)
        if dlg.exec_()==QDialog.Accepted:
            self.dashboard.load_rules()

    def on_update_rule(self):
        rids=self.dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=rids[0]
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"NotFound",f"No rule {rid}")
            return
        colnames=[desc[0] for desc in c.description]
        rd=dict(zip(colnames,row))
        from .part4 import RuleEditorDialog
        dlg=RuleEditorDialog(self.connection,self.user_group,rd,self)
        if dlg.exec_()==QDialog.Accepted:
            self.dashboard.load_rules()

    def on_deactivate_rule(self):
        rids=self.dashboard.get_selected_rule_ids()
        if not rids:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Deactivate {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        from .part2_crud import deactivate_rule
        success=0
        fails=[]
        for rid in rids:
            try:
                deactivate_rule(self.connection, rid, "CurrentUser", self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deactivated => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Deactivate",msg)
        self.dashboard.load_rules()

    def on_delete_rule(self):
        rids=self.dashboard.get_selected_rule_ids()
        if not rids:
            return
        confirm=QMessageBox.question(self,"Confirm",f"Delete {len(rids)} rule(s)?")
        if confirm!=QMessageBox.Yes:
            return
        from .part2_crud import delete_rule
        success=0
        fails=[]
        for rid in rids:
            try:
                delete_rule(self.connection, rid, "CurrentUser", self.user_group)
                success+=1
            except Exception as ex:
                fails.append(str(ex))
        msg=f"Deleted => success={success}"
        if fails:
            msg+="\nFails:\n"+("\n".join(fails))
        QMessageBox.information(self,"Delete",msg)
        self.dashboard.load_rules()

    def run_etl_bfs(self):
        from .part2 import advanced_bfs_execute
        (exed,skp)=advanced_bfs_execute(self.connection)
        QMessageBox.information(self,"ETL BFS",f"Executed={exed}\nSkipped={list(skp)}")
        self.dashboard.load_rules()

    def sim_single_rule(self):
        rids=self.dashboard.get_selected_rule_ids()
        if len(rids)!=1:
            QMessageBox.warning(self,"Error","Select exactly 1 rule.")
            return
        rid=rids[0]
        from .part2 import run_single_rule_transaction
        c=self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row=c.fetchone()
        if not row:
            QMessageBox.warning(self,"NotFound",f"No rule {rid}")
            return
        colnames=[desc[0] for desc in c.description]
        rd=dict(zip(colnames,row))
        (ok,msg,rc)=run_single_rule_transaction(self.connection, rd, is_dry_run=True)
        QMessageBox.information(self,"Dry-Run",f"Rule {rid} => {'PASS' if ok else 'FAIL'}, {msg}")

    def show_metrics_dialog(self):
        from .part6 import MetricsDashboardTab
        dlg=QDialog(self)
        dlg.setWindowTitle("Metrics Dashboard")
        dlg.resize(800,600)
        ly=QVBoxLayout(dlg)
        chart=MetricsDashboardTab(self.connection)
        ly.addWidget(chart)
        cb=QPushButton("Close")
        cb.clicked.connect(dlg.close)
        ly.addWidget(cb)
        dlg.exec_()

    def check_schedules(self):
        """
        Called every minute => run scheduled rules if time <= now => store pass/fail => measure time
        """
        now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c=self.connection.cursor()
        c.execute("""
        SELECT SCHEDULE_ID,RULE_ID,SCHEDULE_TIME
        FROM RULE_SCHEDULES
        WHERE STATUS='Scheduled' AND SCHEDULE_TIME<=?
        """,(now,))
        due=c.fetchall()
        for (sch_id,rid,ts) in due:
            c2=self.connection.cursor()
            c2.execute("BEGIN TRANSACTION")
            try:
                # measure performance
                startT=datetime.now()
                c2.execute("SELECT RULE_SQL FROM BRM_RULES WHERE RULE_ID=?",(rid,))
                row=c2.fetchone()
                if row:
                    sql_=row[0] or ""
                    success=False
                    msg=""
                    try:
                        c2.execute(sql_)
                        rowsX=c2.fetchall()
                        if rowsX:
                            val=rowsX[0][0]
                            success=(val==1)
                            msg=f"Returned={val}"
                        else:
                            success=True
                            msg="No rows => pass"
                    except Exception as ex3:
                        msg=str(ex3)
                        success=False
                    if success:
                        c2.execute("COMMIT")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Executed' WHERE SCHEDULE_ID=?",(sch_id,))
                    else:
                        c2.execute("ROLLBACK")
                        c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                    endT=datetime.now()
                    elapsed_ms=(endT-startT).total_seconds()*1000
                    # log
                    c3=self.connection.cursor()
                    c3.execute("""
                    INSERT INTO RULE_EXECUTION_LOGS(
                      RULE_ID,EXECUTION_TIMESTAMP,PASS_FLAG,MESSAGE,RECORD_COUNT,EXECUTION_TIME_MS
                    )
                    VALUES(?,GETDATE(),?,?,?,?)
                    """,(rid,1 if success else 0,msg,1,elapsed_ms))
                    self.connection.commit()
            except Exception as ex2:
                c2.execute("ROLLBACK")
                c2.execute("UPDATE RULE_SCHEDULES SET STATUS='Failed' WHERE SCHEDULE_ID=?",(sch_id,))
                self.connection.commit()
        self.sch_tab.load_schedules()

    def do_lineage_search(self):
        txt=self.lineage_search.text().strip()
        if not txt:
            for rid,node in self.lineage.node_map.items():
                node.setOpacity(1.0)
            return
        self.lineage.highlight_nodes(txt)

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

def main():
    app=QApplication(sys.argv)
    tool=BRMTool()
    tool.show()
    sys.exit(app.exec_())