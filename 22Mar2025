#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 1 of 10
Fully Integrated Codebase

This chunk includes:
  • Top-level imports
  • Basic logging config
  • Some global utility references
  • DatabaseConnectionDialog (fully integrated)
  • OnboardingWizard placeholders
  • Preps for merging subsequent parts
"""

import sys
import os
import re
import json
import math
import csv
import logging
import logging.config
import smtplib
import difflib
import random
import base64
from datetime import datetime, timedelta
from collections import defaultdict, deque
from email.mime.text import MIMEText

import pyodbc
import sqlparse
import numpy as np

# PyQt5
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QTimer, QDateTime, QDate, QTime, pyqtSignal, QPointF
)
from PyQt5.QtGui import (
    QIcon, QFont, QColor, QPainter, QPen, QBrush
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QLabel, QLineEdit, QPlainTextEdit, QTableWidget, QTableWidgetItem,
    QPushButton, QMessageBox, QFileDialog, QInputDialog, QComboBox,
    QCalendarWidget, QTimeEdit, QSplitter, QListWidget, QListWidgetItem,
    QTreeWidget, QTreeWidgetItem, QMenu, QDockWidget, QProgressDialog,
    QWizard, QWizardPage, QTabWidget, QCheckBox, QRadioButton, QGroupBox,
    QSpinBox, QDoubleSpinBox, QFormLayout, QScrollArea, QTextEdit
)

import pyqtgraph as pg
try:
    from sklearn.linear_model import LinearRegression
except ImportError:
    # If not installed, some anomaly detection or forecasting stubs won't function
    pass

# -------------------------------------------------------------------
# Logging
# -------------------------------------------------------------------
LOG_FILE = os.getenv("BRM_LOG_FILE", "brm_master.log")
LOG_LEVEL = os.getenv("BRM_LOG_LEVEL", "DEBUG")

logging.basicConfig(
    filename=LOG_FILE,
    level=LOG_LEVEL,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)
logger = logging.getLogger("brm_master")


# -------------------------------------------------------------------
# Database Connection Dialog
# -------------------------------------------------------------------
class DatabaseConnectionDialog(QtWidgets.QDialog):
    """
    Lets user select an ODBC DSN or custom connection string, 
    then tests it to form a pyodbc connection.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.connection = None
        self.setWindowTitle("Database Connection – BRM")
        self.resize(420, 200)

        layout = QVBoxLayout(self)
        lbl = QLabel("Select DSN or enter custom ODBC connection string:")
        layout.addWidget(lbl)

        self.dsn_combo = QComboBox()
        try:
            dsn_dict = pyodbc.dataSources()
            for dsn_name, driver in dsn_dict.items():
                if "SQL SERVER" in driver.upper():
                    self.dsn_combo.addItem(f"{dsn_name} ({driver})", dsn_name)
        except Exception as ex:
            logger.error(f"Error listing DSNs: {ex}")
        layout.addWidget(self.dsn_combo)

        self.custom_edit = QLineEdit()
        self.custom_edit.setPlaceholderText("Or paste custom ODBC string here...")
        layout.addWidget(self.custom_edit)

        btns = QHBoxLayout()
        ok_btn = QPushButton("Connect")
        ok_btn.clicked.connect(self.accept)
        canc_btn = QPushButton("Cancel")
        canc_btn.clicked.connect(self.reject)
        btns.addWidget(ok_btn)
        btns.addWidget(canc_btn)
        layout.addLayout(btns)

    def get_connection(self):
        """
        Attempt connection. Returns pyodbc.Connection or None.
        """
        custom_str = self.custom_edit.text().strip()
        if custom_str:
            conn_str = custom_str
        else:
            dsn_sel = self.dsn_combo.currentData()
            if not dsn_sel:
                QMessageBox.warning(self, "Error", "No DSN or custom string provided.")
                return None
            conn_str = f"DSN={dsn_sel};Trusted_Connection=yes;"

        try:
            test_conn = pyodbc.connect(conn_str)
            logger.info("DB connection success.")
            return test_conn
        except Exception as ex:
            logger.error(f"DB connection failed: {ex}")
            QMessageBox.critical(self, "Connection Error", str(ex))
            return None

    def accept(self):
        test = self.get_connection()
        if test:
            self.connection = test
            super().accept()
        else:
            # remain
            pass


# Placeholder for OnboardingWizard reference; real code in a later chunk
class OnboardingWizard(QDialog):
    """
    Multi-step wizard for brand-new or restructured users. 
    Real code will be in chunk #... 
    """
    def __init__(self, connection, user_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.current_step = 0
        self.setWindowTitle("Onboarding Wizard - Placeholder")
        self.resize(400, 300)
        layout = QVBoxLayout(self)
        self.label = QLabel("This is a placeholder for the real OnboardingWizard (see later chunk).")
        layout.addWidget(self.label)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
        self.setLayout(layout)
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 2 of 10
Fully Integrated Codebase

This chunk focuses on:
  • Basic login dialog with RBAC references
  • ACL / Permissions helper
  • Audit logging function
  • Collab manager (threaded, mention-based)
  • LockManager with forced/unforced locks
  • Some BFS placeholders
"""

import re
import json
from PyQt5.QtWidgets import QDialog, QLabel, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit, QCheckBox, QMessageBox, QComboBox
from PyQt5.QtCore import Qt, QTimer

# We continue using the same logger from part 1:
logger = logging.getLogger("brm_master")


##################################################
# Audit Log
##################################################
def insert_audit_log(conn, action, table_name, record_id, actor, old_data=None, new_data=None):
    """
    Insert a record into BRM_AUDIT_LOG with optional JSON old/new data.
    """
    try:
        c = conn.cursor()
        c.execute("""
            INSERT INTO BRM_AUDIT_LOG(
              ACTION, TABLE_NAME, RECORD_ID, ACTION_BY,
              OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
            )
            VALUES(?,?,?,?,?,?,GETDATE())
        """, (
            action,
            table_name,
            str(record_id) if record_id else None,
            actor,
            json.dumps(old_data) if old_data else None,
            json.dumps(new_data) if new_data else None
        ))
        conn.commit()
        logger.debug(f"[AUDIT] action={action}, table={table_name}, record={record_id}, actor={actor}")
    except Exception as ex:
        logger.error(f"[AUDIT] Error: {ex}")


##################################################
# RBAC / Permissions
##################################################
def check_user_permissions(conn, user_id, action_type, resource_name):
    """
    Example ACL check, for a user to do 'EDIT_RULE', 'APPROVE', 'VIEW', etc. on some resource_name (table, rule, etc.)
    This is a simplified version that references a GROUP_PERMISSIONS table plus the user’s group from USERS table.
    """
    try:
        c = conn.cursor()
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if not row:
            return False
        user_grp = row[0]
        # If user_grp == 'Admin', allow everything
        if user_grp == "Admin":
            return True

        # For demonstration, we do minimal approach
        c.execute("""
            SELECT ALLOWS_ACTION
            FROM GROUP_PERMISSIONS
            WHERE GROUP_NAME=? AND (TARGET_TABLE=? OR TARGET_TABLE='*ANY*')
        """, (user_grp, resource_name))
        perms = [r[0] for r in c.fetchall()]
        # If action_type in the perms we have => allow
        # (This is simplistic: ALLOWS_ACTION might match 'EDIT_RULE' or 'VIEW', etc.)
        return (action_type in perms)
    except Exception as ex:
        logger.error(f"Permission check error: {ex}")
        return False


##################################################
# Lock Manager
##################################################
class LockManager:
    """
    Manages concurrency locks on rules:
      - auto_unlock_expired_locks
      - rule_current_lock_owner
      - lock_rule_for_edit
      - unlock_rule_for_edit
    With optional forced unlock by admin or same user.
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1 AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            rc = c.rowcount
            conn.commit()
            if rc > 0:
                logger.info(f"[LOCK] Auto-unlocked {rc} expired locks.")
        except Exception as ex:
            logger.error(f"[LOCK] auto unlock error: {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        LockManager.auto_unlock_expired_locks(conn)
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, lock_ts, exp_ts, f_flag = row
        # check expiry
        now = datetime.now()
        if exp_ts and now > exp_ts:
            try:
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except:
                pass
            return None
        return (locked_by, lock_ts, exp_ts, f_flag)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_mins=30):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        c = conn.cursor()
        now = datetime.now()
        exp_ts = now + timedelta(minutes=lock_mins)

        if info:
            (locked_by, _, old_exp, f_flag) = info
            if locked_by == user_id:
                # refresh
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, exp_ts, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"[LOCK] Refreshed lock for rule {rule_id} by {user_id}, force={force}")
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} locked by {locked_by}")
                else:
                    # forcibly unlock
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP,
                          EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
                        ) VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, exp_ts, 1))
                    conn.commit()
                    logger.info(f"[LOCK] Forced lock for rule {rule_id} by {user_id}")
        else:
            # no lock => insert
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP,
                  FORCE_LOCK, ACTIVE_LOCK
                ) VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, exp_ts, 1 if force else 0))
            conn.commit()
            logger.debug(f"[LOCK] New lock for rule {rule_id} by {user_id}, force={force}")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return
        locked_by, lts, ets, ff = info
        if locked_by != user_id and not force:
            raise ValueError(f"Cannot unlock rule {rule_id}, locked by {locked_by}.")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"[LOCK] Unlocked rule {rule_id} by {user_id}, force={force}")


##################################################
# Dry-run BFS placeholders
##################################################
def dry_run_rule_sql(conn, sql_text):
    """
    Minimal demonstration: run in transaction, if first col=1 => PASS, else FAIL.
    Return (bool, message)
    """
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success = False
    msg = ""
    try:
        c.execute(sql_text)
        rows = []
        try:
            rows = c.fetchall()
        except:
            pass
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned => {val}"
        else:
            success = True
            msg = "No rows => PASS"
        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg)


##################################################
# Collaboration Manager (Threaded, Mentions)
##################################################
class CollaborationManager(QtCore.QObject):
    """
    Polls a DB table (COLLABORATION_LOGS) for new messages, signals them out,
    detects @mentions if needed.
    """
    newMessage = QtCore.pyqtSignal(dict)

    def __init__(self, connection, poll_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.poll_ms = poll_ms
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.timer.start(self.poll_ms)
        self.last_timestamp = None

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE_ID, THREAD_ID, MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE_ID, THREAD_ID, MESSAGE, SENDER, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)
            rows = c.fetchall()
            for r in rows:
                mid, thrd, msg, sender, ts = r
                payload = {
                    "message_id": mid,
                    "thread_id": thrd,
                    "message": msg,
                    "sender": sender,
                    "timestamp": ts
                }
                self.newMessage.emit(payload)
                self.check_for_mentions(msg, sender)
                self.last_timestamp = ts
        except Exception as ex:
            logger.error(f"Collab polling error: {ex}")

    def check_for_mentions(self, message, sender):
        # e.g., @username
        if not message or "@" not in message:
            return
        pattern = r'@(\w+)'
        matches = re.findall(pattern, message)
        if matches:
            logger.debug(f"Mentions: {matches} from {sender}")
            # Optionally do email or direct notifications
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 3 of 10
Fully Integrated Codebase

This chunk includes:
  • Data validation logic
  • BFS-based rule execution with conflict and critical/global skipping
  • Basic decision table execution approach
  • Rule execution logs insertion
  • Conflict resolution placeholders
"""

import json
import re
import logging
from datetime import datetime, timedelta
from collections import defaultdict, deque

from PyQt5.QtWidgets import QMessageBox

logger = logging.getLogger("brm_master")


##################################################
# Data Validations
##################################################
def run_data_validations(conn):
    """
    Executes data validations from a DATA_VALIDATIONS table,
    logs results in DATA_VALIDATION_LOGS.
    
    For each validation row (table_name, column_name, validation_type, params):
      - 'NOT NULL'
      - 'RANGE' -> uses min=X;max=Y
      - 'UNIQUE'
      … possibly more.

    On fail, logs into DATA_VALIDATION_LOGS with FAIL, else PASS.
    """
    c = conn.cursor()
    try:
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        rows = c.fetchall()
    except Exception as ex:
        logger.error(f"[VALIDATION] Error fetching validations: {ex}")
        return

    for (vid, tbl, col, vtype, prm) in rows:
        result_flag = "PASS"
        details = ""
        try:
            if vtype.upper() == "NOT NULL":
                q = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(q)
                n_ = c.fetchone()[0]
                if n_ > 0:
                    result_flag = "FAIL"
                    details = f"{n_} NULL(s) in {col}"
                else:
                    details = f"No NULLs in {col}"
            elif vtype.upper() == "RANGE":
                # parse params => e.g. min=1;max=100
                parts = prm.split(";")
                min_val = None
                max_val = None
                for p_ in parts:
                    p_ = p_.strip().lower()
                    if p_.startswith("min="):
                        min_val = float(p_.split("=")[1])
                    elif p_.startswith("max="):
                        max_val = float(p_.split("=")[1])
                if min_val is None or max_val is None:
                    result_flag = "FAIL"
                    details = "Invalid param for RANGE"
                else:
                    q = f"""
                        SELECT COUNT(*) 
                        FROM {tbl}
                        WHERE TRY_CAST({col} as float) NOT BETWEEN {min_val} AND {max_val}
                    """
                    c.execute(q)
                    n_ = c.fetchone()[0]
                    if n_ > 0:
                        result_flag = "FAIL"
                        details = f"{n_} out-of-range"
                    else:
                        details = f"All in [{min_val},{max_val}]"
            elif vtype.upper() == "UNIQUE":
                q = f"""
                    SELECT COUNT(*) FROM (
                      SELECT {col}, COUNT(*) AS cnt
                      FROM {tbl}
                      GROUP BY {col}
                      HAVING COUNT(*)>1
                    ) as subq
                """
                c.execute(q)
                n_ = c.fetchone()[0]
                if n_ > 0:
                    result_flag = "FAIL"
                    details = f"{n_} duplicates found for {col}"
                else:
                    details = f"All unique in {col}"
            else:
                result_flag = "FAIL"
                details = f"Unknown validation type: {vtype}"
        except Exception as ex2:
            result_flag = "FAIL"
            details = f"Error => {ex2}"

        # log the outcome
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(
                  VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP
                )
                VALUES(?,?,?,GETDATE())
            """, (vid, result_flag, details))
            conn.commit()
        except Exception as logex:
            logger.error(f"[VALIDATION] Could not log result for {vid}: {logex}")


##################################################
# Decision Table Execution
##################################################
def execute_decision_table(conn, dt_id, dry_run=True):
    """
    Finds DECISION_QUERY from DECISION_TABLES,
    runs it in a transaction. If first col=1 => PASS.
    Always rollback if dry_run or fail.

    Returns (ok_bool, message_str, record_count).
    """
    c = conn.cursor()
    c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c.fetchone()
    if not row:
        return (False, f"DecisionTable {dt_id} not found", 0)

    query_ = row[0] or ""
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success = False
    msg = ""
    r_count = 0
    try:
        c.execute(query_)
        rows = []
        try:
            rows = c.fetchall()
        except:
            pass
        r_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"DT returned => {val}"
        else:
            success = True
            msg = "No rows => PASS"
        c.execute("ROLLBACK")  # always if dry_run
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, r_count)


##################################################
# BFS Rule Execution with skipping
##################################################
def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    """
    Insert a record into RULE_EXECUTION_LOGS, capturing pass/fail state.
    """
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG, MESSAGE,
              RECORD_COUNT, EXECUTION_TIME_MS, CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"[EXEC_LOG] insertion error => {ex}")


def load_rule_relationships(conn):
    """
    Builds adjacency from:
     1) BRM_RULES(PARENT_RULE_ID)
     2) RULE_CONFLICTS
     3) BRM_GLOBAL_CRITICAL_LINKS
     4) COMPOSITE_RULES references
    Returns (adjacency_dict, root_rules, parent_map).
    """
    c = conn.cursor()
    adjacency = {}
    parent_map = {}
    all_ids = set()

    # Basic parent->child
    try:
        c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
        rows = c.fetchall()
        child_ids = set()
        for (rid, pid) in rows:
            all_ids.add(rid)
            if pid:
                adjacency.setdefault(pid, set()).add(rid)
                parent_map[rid] = pid
                child_ids.add(rid)
        roots = [x for x in all_ids if x not in child_ids]
    except Exception as ex:
        logger.error(f"[BFS] Error base adjacency => {ex}")
        adjacency = {}
        roots = []
        parent_map = {}

    # Conflicts => make it symmetrical
    try:
        c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
        confs = c.fetchall()
        for (r1, r2) in confs:
            adjacency.setdefault(r1, set()).add(r2)
            adjacency.setdefault(r2, set()).add(r1)
    except:
        pass

    # Global/critical links
    try:
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        gcrs = c.fetchall()
        for (parent_r, tgt_r) in gcrs:
            adjacency.setdefault(parent_r, set()).add(tgt_r)
    except:
        pass

    # Composite references => search "RuleX" in LOGIC_EXPR
    try:
        c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
        comp_rows = c.fetchall()
        pat = re.compile(r"Rule(\d+)")
        for (cid, expr) in comp_rows:
            if expr:
                matches = pat.findall(expr)
                for m_ in matches:
                    try:
                        sub_id = int(m_)
                        adjacency.setdefault(sub_id, set()).add(cid)
                    except:
                        pass
    except:
        pass

    return (adjacency, roots, parent_map)


def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    Execute a single rule. If OPERATION_TYPE=DECISION_TABLE => call that logic.
    Else use RULE_SQL.
    Return (ok_bool, message, record_count).
    """
    op_type = rule_info.get("OPERATION_TYPE", "OTHER")
    if op_type.upper() == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False, "Missing DECISION_TABLE_ID", 0)
        return execute_decision_table(conn, dt_id, dry_run=is_dry_run)
    else:
        rule_sql = rule_info.get("RULE_SQL", "")
        c = conn.cursor()
        try:
            c.execute("BEGIN TRANSACTION")
        except:
            pass
        success = False
        msg = ""
        r_count = 0
        try:
            c.execute(rule_sql)
            rows = []
            try:
                rows = c.fetchall()
            except:
                pass
            if rows:
                r_count = len(rows)
                val = rows[0][0]
                success = (val == 1)
                msg = f"Returned => {val}"
            else:
                success = True
                msg = "No rows => PASS"
            if is_dry_run or not success:
                c.execute("ROLLBACK")
            else:
                c.execute("COMMIT")
        except Exception as ex:
            try:
                c.execute("ROLLBACK")
            except:
                pass
            success = False
            msg = str(ex)
        return (success, msg, r_count)


def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch_ in adjacency[cur]:
                if ch_ not in skipped:
                    stack.append(ch_)


def execute_rules_unified_bfs(conn, dry_run=False, user_id=None):
    """
    BFS-based rule execution:
      1) run_data_validations
      2) adjacency from load_rule_relationships
      3) from each root rule, BFS
      4) if fail and rule is critical/global => skip entire subtree
      5) log each run in RULE_EXECUTION_LOGS
    Return (executed_list, skipped_list).
    """
    # run validations first
    run_data_validations(conn)

    adjacency, roots, p_map = load_rule_relationships(conn)
    # load rule data
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [d[0] for d in c.description]
    rule_map = {}
    for row in rows:
        d_ = dict(zip(colnames, row))
        rid_ = d_["RULE_ID"]
        rule_map[rid_] = d_

    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        # ACL check if user_id is provided
        if user_id and rid in rule_map:
            # e.g., check permission to EXECUTE
            rule_obj = rule_map[rid]
            r_name = rule_obj.get("RULE_NAME", "")
            # if not check_user_permissions(conn, user_id, 'EXECUTE', r_name):
            #    skipped.add(rid)
            #    continue
            # For brevity, skip or keep simple.

        if rid not in rule_map:
            skipped.add(rid)
            continue

        info_ = rule_map[rid]
        ok, msg, rcount = run_single_rule_in_transaction(conn, info_, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rcount)
        if ok:
            executed.append(rid)
            # push adjacency
            if rid in adjacency:
                for child_r in adjacency[rid]:
                    if child_r not in skipped:
                        queue.append(child_r)
        else:
            # if CRITICAL_RULE=1 or IS_GLOBAL=1 => skip entire subtree
            is_crit = (info_.get("CRITICAL_RULE", 0) == 1 or info_.get("IS_GLOBAL", 0) == 1)
            if is_crit and rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            else:
                # skip direct children
                if rid in adjacency:
                    for ch in adjacency[rid]:
                        skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)

    return (executed, list(skipped))


##################################################
# Conflict Resolution Stubs
##################################################
def build_conflict_map(conn):
    """
    Returns a dict with conflict_id -> { 'rule1': rid1, 'rule2': rid2, 'priority': p, ... }
    For a visual conflict map or triage approach.
    """
    c = conn.cursor()
    conflict_data = {}
    try:
        c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
        rows = c.fetchall()
        for row in rows:
            cfid, r1, r2, prio = row
            conflict_data[cfid] = {
                "rule1": r1,
                "rule2": r2,
                "priority": prio
            }
    except Exception as ex:
        logger.error(f"build_conflict_map error => {ex}")
    return conflict_data


def resolve_conflict_voting(conflict_id, winning_rule_id, actor):
    """
    Example of a function to handle conflict triage by 'vote' picking which rule is the winner.
    Not fully implemented here. 
    """
    logger.info(f"Conflict {conflict_id} resolved by picking rule {winning_rule_id}, actor={actor}")
    # Could update RULE_CONFLICTS or log the resolution
    pass
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 4 of 10
Fully Integrated Codebase

This chunk covers:
  • Collaboration Manager (threaded chat + mention detection)
  • Lock Manager (advanced concurrency with force unlock, expiry)
  • Approvals foundation (table + logic for multi-step or parallel)
  • Basic ACL checks placeholder
"""

import os
import re
import json
import logging
from datetime import datetime, timedelta
from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QObject
from PyQt5.QtWidgets import QMessageBox

logger = logging.getLogger("brm_master")


#######################################
# COLLABORATION MANAGER
#######################################
class CollaborationManager(QObject):
    """
    Polls collaboration messages from a DB table (COLLABORATION_LOGS).
    Provides mention-based detection and threaded approach expansions.

    newMessage signal => emits a dict like:
        {
          "message_id": int,
          "message": str,
          "sender": str,
          "thread_id": int or None,
          "timestamp": datetime,
          "mentions": [list_of_usernames]
        }
    """
    newMessage = pyqtSignal(dict)

    def __init__(self, connection, poll_interval_ms=5000, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.last_timestamp = None
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.poll_messages)
        self.timer.start(poll_interval_ms)

    def poll_messages(self):
        c = self.connection.cursor()
        try:
            if self.last_timestamp:
                c.execute("""
                    SELECT MESSAGE_ID, MESSAGE, SENDER, THREAD_ID, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    WHERE TIMESTAMP > ?
                    ORDER BY TIMESTAMP ASC
                """, (self.last_timestamp,))
            else:
                c.execute("""
                    SELECT MESSAGE_ID, MESSAGE, SENDER, THREAD_ID, TIMESTAMP
                    FROM COLLABORATION_LOGS
                    ORDER BY TIMESTAMP ASC
                """)

            rows = c.fetchall()
            if rows:
                for (msg_id, msg_text, sender, thr_id, ts) in rows:
                    payload = {
                        "message_id": msg_id,
                        "message": msg_text,
                        "sender": sender,
                        "thread_id": thr_id,
                        "timestamp": ts
                    }
                    # parse mentions
                    pattern = r"@(\w+)"
                    found = re.findall(pattern, msg_text)
                    if found:
                        payload["mentions"] = found
                    self.newMessage.emit(payload)
                    self.last_timestamp = ts
        except Exception as ex:
            logger.warning(f"[CollabManager] poll error: {ex}")


#######################################
# LOCK MANAGER
#######################################
class LockManager:
    """
    Provides advanced concurrency locks for BRM_RULES:
      • auto_unlock_expired_locks(conn)
      • rule_current_lock_owner(conn, rule_id)
      • lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_mins=30)
      • unlock_rule_for_edit(conn, rule_id, user_id, force=False)
    """

    @staticmethod
    def auto_unlock_expired_locks(conn):
        now = datetime.now()
        c = conn.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_LOCKS
                SET ACTIVE_LOCK=0
                WHERE ACTIVE_LOCK=1
                  AND EXPIRY_TIMESTAMP < ?
            """, (now,))
            n_ = c.rowcount
            conn.commit()
            if n_ > 0:
                logger.info(f"[LockManager] auto-unlocked {n_} expired locks.")
        except Exception as ex:
            logger.error(f"[LockManager] auto_unlock_expired_locks error => {ex}")

    @staticmethod
    def rule_current_lock_owner(conn, rule_id):
        c = conn.cursor()
        c.execute("""
            SELECT LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK
            FROM BRM_RULE_LOCKS
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return None
        locked_by, ts, expiry, f_ = row
        now = datetime.now()
        if expiry and now > expiry:
            # expired => clear it
            try:
                c2 = conn.cursor()
                c2.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET ACTIVE_LOCK=0
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (rule_id,))
                conn.commit()
            except:
                pass
            return None
        return (locked_by, ts, expiry, f_)

    @staticmethod
    def lock_rule_for_edit(conn, rule_id, user_id, force=False, lock_minutes=30):
        """
        If locked by another user => raise unless force=True.
        If locked by same user => refresh lock.
        If not locked => create new lock row.
        """
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        now = datetime.now()
        expiry = now + timedelta(minutes=lock_minutes)

        c = conn.cursor()

        if info:
            (locked_by, old_ts, old_exp, old_force) = info
            if locked_by == user_id:
                # refresh
                c.execute("""
                    UPDATE BRM_RULE_LOCKS
                    SET LOCK_TIMESTAMP=?, EXPIRY_TIMESTAMP=?, FORCE_LOCK=?
                    WHERE RULE_ID=? AND ACTIVE_LOCK=1
                """, (now, expiry, 1 if force else 0, rule_id))
                conn.commit()
                logger.debug(f"[LockManager] lock refreshed => rule {rule_id} user={user_id}")
                return
            else:
                if not force:
                    raise ValueError(f"Rule {rule_id} is locked by user {locked_by}.")
                else:
                    # forcibly unlock
                    c.execute("""
                        UPDATE BRM_RULE_LOCKS
                        SET ACTIVE_LOCK=0
                        WHERE RULE_ID=? AND ACTIVE_LOCK=1
                    """, (rule_id,))
                    c.execute("""
                        INSERT INTO BRM_RULE_LOCKS(
                          RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
                        )
                        VALUES(?,?,?,?,?,1)
                    """, (rule_id, user_id, now, expiry, 1))
                    conn.commit()
                    logger.info(f"[LockManager] forcibly locked => rule {rule_id} by {user_id}")
        else:
            # not locked => create new
            c.execute("""
                INSERT INTO BRM_RULE_LOCKS(
                  RULE_ID, LOCKED_BY, LOCK_TIMESTAMP, EXPIRY_TIMESTAMP, FORCE_LOCK, ACTIVE_LOCK
                )
                VALUES(?,?,?,?,?,1)
            """, (rule_id, user_id, now, expiry, 1 if force else 0))
            conn.commit()
            logger.debug(f"[LockManager] rule {rule_id} locked by user={user_id}, force={force}")

    @staticmethod
    def unlock_rule_for_edit(conn, rule_id, user_id, force=False):
        LockManager.auto_unlock_expired_locks(conn)
        info = LockManager.rule_current_lock_owner(conn, rule_id)
        if not info:
            return
        (locked_by, ts, exp, f_) = info
        if locked_by != user_id and not force:
            raise ValueError(f"Cannot unlock. Rule {rule_id} is locked by {locked_by}")
        c = conn.cursor()
        c.execute("""
            UPDATE BRM_RULE_LOCKS
            SET ACTIVE_LOCK=0
            WHERE RULE_ID=? AND ACTIVE_LOCK=1
        """, (rule_id,))
        conn.commit()
        logger.debug(f"[LockManager] rule {rule_id} unlocked by user={user_id}, force={force}")


#######################################
# APPROVALS FOUNDATION
#######################################
def create_multistep_approvals(conn, rule_id, creator):
    """
    Minimal example: based on some config, insert rows into BRM_RULE_APPROVALS
    with default stage=1, user=creator’s group, etc.
    Expand for parallel or multi-stage logic as needed.
    """
    c = conn.cursor()
    try:
        # remove old approvals
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_id,))
        # stage 1 => the rule owner group
        c.execute("""
            SELECT OWNER_GROUP
            FROM BRM_RULES
            WHERE RULE_ID=?
        """, (rule_id,))
        row = c.fetchone()
        if not row:
            return
        grp_ = row[0]
        c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(
              RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, IS_PARALLEL_GROUP
            )
            VALUES(?,?,?,?,?,0)
        """, (rule_id, grp_, creator, 0, 1))
        conn.commit()
        logger.debug(f"[Approvals] Created basic single-stage approval => rule={rule_id}, group={grp_}")
    except Exception as ex:
        conn.rollback()
        logger.error(f"[Approvals] Error => {ex}")


#######################################
# Basic ACL checks (placeholder)
#######################################
def check_user_permissions(conn, user_id, action_type, resource_name):
    """
    Simple approach: if user is Admin => always True.
    Else check GROUP_PERMISSIONS or some table.

    Return True/False.
    """
    c = conn.cursor()
    try:
        c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if not row:
            return False
        ug_ = row[0]
        if ug_ == "Admin":
            return True

        # minimal approach: see if there's a row in GROUP_PERMISSIONS
        c.execute("""
            SELECT COUNT(*)
            FROM GROUP_PERMISSIONS
            WHERE GROUP_NAME=? AND TARGET_TABLE=? AND ALLOWS_ACTION=?
        """, (ug_, resource_name, action_type))
        rc = c.fetchone()[0]
        return (rc > 0)
    except:
        return False
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 5 of 10
Fully Integrated Codebase

This chunk covers:
  • BFS-based rule execution (unified approach)
  • Decision table execution stubs
  • Data validations run
  • Insert rule execution logs
  • Basic BFS adjacency building for parent–child, conflicts, etc.
"""

import logging
import json
import re
from datetime import datetime
from collections import defaultdict, deque

logger = logging.getLogger("brm_master")


#######################################
# DATA VALIDATIONS
#######################################
def run_data_validations(conn):
    """
    Fetch validations from DATA_VALIDATIONS table, run them, log outcomes to DATA_VALIDATION_LOGS.
    Example validations: NOT NULL, RANGE, UNIQUE, etc.
    """
    c = conn.cursor()
    try:
        c.execute("""
            SELECT VALIDATION_ID, TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS
            FROM DATA_VALIDATIONS
        """)
        rows = c.fetchall()
    except Exception as ex:
        logger.error(f"[DataValidation] Error fetching validations => {ex}")
        return

    for (val_id, tbl, col, vtype, params) in rows:
        result_flag = "PASS"
        details = ""
        try:
            if vtype.upper() == "NOT NULL":
                q = f"SELECT COUNT(*) FROM {tbl} WHERE {col} IS NULL"
                c.execute(q)
                cnt = c.fetchone()[0]
                if cnt > 0:
                    result_flag = "FAIL"
                    details = f"{cnt} NULL(s) found in {col}"
                else:
                    details = "No NULLs found"
            elif vtype.upper() == "RANGE":
                # parse min=??;max=??
                minv, maxv = None, None
                if params:
                    for part in params.split(";"):
                        part = part.strip().lower()
                        if part.startswith("min="):
                            minv = float(part.split("=")[1])
                        elif part.startswith("max="):
                            maxv = float(part.split("=")[1])
                if minv is None or maxv is None:
                    result_flag = "FAIL"
                    details = "Invalid RANGE params"
                else:
                    q = f"""
                        SELECT COUNT(*)
                        FROM {tbl}
                        WHERE TRY_CAST({col} as float) < {minv}
                           OR TRY_CAST({col} as float) > {maxv}
                    """
                    c.execute(q)
                    cnt = c.fetchone()[0]
                    if cnt > 0:
                        result_flag = "FAIL"
                        details = f"{cnt} row(s) out of [{minv}, {maxv}]"
                    else:
                        details = f"All in range [{minv}, {maxv}]"
            elif vtype.upper() == "UNIQUE":
                q = f"""
                    SELECT COUNT(*)
                    FROM (
                       SELECT {col}, COUNT(*) as c
                       FROM {tbl}
                       GROUP BY {col}
                       HAVING COUNT(*)>1
                    ) duplicates
                """
                c.execute(q)
                dcnt = c.fetchone()[0]
                if dcnt > 0:
                    result_flag = "FAIL"
                    details = f"{dcnt} duplicate(s) in {col}"
                else:
                    details = f"{col} is unique"
            else:
                result_flag = "FAIL"
                details = f"Unknown validation type {vtype}"
        except Exception as e2:
            result_flag = "FAIL"
            details = f"Execution error => {e2}"

        # log
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATION_LOGS(
                  VALIDATION_ID, RESULT_FLAG, DETAILS, VALIDATION_TIMESTAMP
                )
                VALUES(?,?,?,GETDATE())
            """, (val_id, result_flag, details))
            conn.commit()
        except Exception as e3:
            logger.error(f"[DataValidation] Log error => {e3}")


#######################################
# DECISION TABLE EXECUTION
#######################################
def execute_decision_table(conn, dt_id, dry_run=True):
    """
    For a DECISION_TABLES row, we have DECISION_QUERY that returns 1 => PASS or 0 => FAIL.
    We run it in a transaction. If dry_run=True, we roll back.
    Return (bool_success, message, record_count).
    """
    c = conn.cursor()
    c.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
    row = c.fetchone()
    if not row:
        return (False, f"DecisionTable {dt_id} not found", 0)
    dt_query = row[0]
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success = False
    msg = ""
    rcount = 0
    try:
        c.execute(dt_query)
        results = []
        try:
            results = c.fetchall()
        except:
            pass
        rcount = len(results)
        if results:
            val = results[0][0]
            success = (val == 1)
            msg = f"Decision returned: {val}"
        else:
            success = True
            msg = "No rows => PASS"
        if dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = str(ex)
    return (success, msg, rcount)


#######################################
# BFS RULE EXECUTION – ADJACENCY
#######################################
def load_rule_relationships(conn):
    """
    Build adjacency from:
      - PARENT_RULE_ID (BRM_RULES table)
      - RULE_CONFLICTS (two-way edges)
      - BRM_GLOBAL_CRITICAL_LINKS
      - COMPOSITE_RULES references

    Returns (adjacency: dict{parent->set(child)}, roots: list, parent_map).
    """
    c = conn.cursor()

    adjacency = {}
    parent_map = {}
    all_ids = set()

    try:
        # parent->child
        c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
        rows = c.fetchall()
        child_ids = set()
        for (rid, pid) in rows:
            all_ids.add(rid)
            if pid:
                adjacency.setdefault(pid, set()).add(rid)
                child_ids.add(rid)
                parent_map[rid] = pid
        # roots
        roots = [r for r in all_ids if r not in child_ids]
    except Exception as ex:
        logger.error(f"[BFS] load_rule_relationships error => {ex}")
        adjacency = {}
        roots = []

    # conflicts => symmetrical adjacency
    try:
        c.execute("SELECT RULE_ID1, RULE_ID2 FROM RULE_CONFLICTS")
        crows = c.fetchall()
        for (r1, r2) in crows:
            adjacency.setdefault(r1, set()).add(r2)
            adjacency.setdefault(r2, set()).add(r1)
            all_ids.update([r1, r2])
    except:
        pass

    # global-critical
    try:
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
        grows = c.fetchall()
        for (gr, tgt) in grows:
            adjacency.setdefault(gr, set()).add(tgt)
            all_ids.update([gr, tgt])
    except:
        pass

    # composite
    try:
        c.execute("SELECT COMPOSITE_RULE_ID, LOGIC_EXPR FROM COMPOSITE_RULES")
        comp_rows = c.fetchall()
        pat = re.compile(r"Rule(\d+)")
        for (comp_id, expr) in comp_rows:
            if expr:
                matches = pat.findall(expr)
                for m in matches:
                    try:
                        sub_id = int(m)
                        adjacency.setdefault(sub_id, set()).add(comp_id)
                        all_ids.update([sub_id, comp_id])
                    except:
                        pass
    except:
        pass

    # re-derive roots in case new adjacency introduced
    # anything not in child_ids but is in all_ids => root
    # (some nodes might be only conflict adjacency, etc.)
    child_ids2 = set(parent_map.keys())
    for parent, children in adjacency.items():
        for ch2 in children:
            child_ids2.add(ch2)
    new_roots = [x for x in all_ids if x not in child_ids2]

    # unify final
    return (adjacency, new_roots, parent_map)


#######################################
# RUN SINGLE RULE
#######################################
def run_single_rule_in_transaction(conn, rule_info, is_dry_run=False):
    """
    If OPERATION_TYPE=DECISION_TABLE => call execute_decision_table
    else => run RULE_SQL, check if returns row => first col=1 => PASS.
    Return (ok_bool, msg_str, record_count).
    """
    op_type = (rule_info.get("OPERATION_TYPE") or "").upper()
    if op_type == "DECISION_TABLE":
        dt_id = rule_info.get("DECISION_TABLE_ID")
        if not dt_id:
            return (False, "No DECISION_TABLE_ID found", 0)
        return execute_decision_table(conn, dt_id, dry_run=is_dry_run)

    rule_sql = rule_info.get("RULE_SQL") or ""
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass
    success = False
    msg = ""
    rec_count = 0
    try:
        c.execute(rule_sql)
        rows = []
        try:
            rows = c.fetchall()
        except:
            pass
        rec_count = len(rows)
        if rows:
            val = rows[0][0]
            success = (val == 1)
            msg = f"Returned => {val}"
        else:
            success = True
            msg = "No rows => PASS"

        if is_dry_run or not success:
            c.execute("ROLLBACK")
        else:
            c.execute("COMMIT")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = f"Exception => {ex}"
    return (success, msg, rec_count)


#######################################
# INSERT RULE EXECUTION LOG
#######################################
def insert_rule_execution_log(conn, rule_id, pass_flag, message, record_count):
    c = conn.cursor()
    try:
        c.execute("""
            INSERT INTO RULE_EXECUTION_LOGS(
              RULE_ID, EXECUTION_TIMESTAMP, PASS_FLAG,
              MESSAGE, RECORD_COUNT, EXECUTION_TIME_MS,
              CPU_USAGE, MEM_USAGE
            )
            VALUES(?, GETDATE(), ?, ?, ?, 0, 0, 0)
        """, (rule_id, 1 if pass_flag else 0, message, record_count))
        conn.commit()
    except Exception as ex:
        logger.error(f"[RULE_EXEC_LOG] error => {ex}")


#######################################
# UNIFIED BFS EXECUTION
#######################################
def execute_rules_unified_bfs(conn, dry_run=False, user_id=None):
    """
    1) run_data_validations
    2) build adjacency, find roots
    3) BFS from each root
       - run single rule
       - if fail & CRITICAL/GLOBAL => skip subtree
    Returns (executed_list, skipped_list).
    Optionally do user_id => check ACL if needed.
    """
    run_data_validations(conn)
    adjacency, roots, parent_map = load_rule_relationships(conn)

    # load all rules
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [desc[0] for desc in c.description]
    rule_map = {}
    for row in rows:
        d_ = dict(zip(colnames, row))
        rid = d_["RULE_ID"]
        rule_map[rid] = d_

    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue
        # optional ACL check
        if user_id:
            # ... check if user can execute
            pass

        info = rule_map[rid]
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)

        if ok:
            executed.append(rid)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            # CRITICAL or GLOBAL => skip subtree
            is_crit = (info.get("CRITICAL_RULE", 0) == 1 or info.get("IS_GLOBAL", 0) == 1)
            if rid in adjacency:
                for child_id in adjacency[rid]:
                    skip_all_descendants(child_id, adjacency, skipped)
            if is_crit:
                # might skip entire BFS or partial
                pass
            skipped.add(rid)

    return (executed, list(skipped))


def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur not in skipped:
            skipped.add(cur)
            if cur in adjacency:
                for ch in adjacency[cur]:
                    if ch not in skipped:
                        stack.append(ch)
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 6 of 10
Fully Integrated Codebase

This chunk covers:
  • Advanced approval flows (multi-step, parallel vs. serial)
  • Approvals Tab UI (show pending approvals, approve/reject)
  • Visual Approval Pipeline Dialog
  • Example logic for finalizing approvals if all steps done
"""

import logging
from datetime import datetime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTableWidget,
    QTableWidgetItem, QPushButton, QLineEdit, QMessageBox, QInputDialog
)
from PyQt5.QtCore import Qt

logger = logging.getLogger("brm_master")


###################################
# CREATE MULTISTEP APPROVALS
###################################
def create_multistep_approvals(conn, rule_id, created_by):
    """
    Example function to populate BRM_RULE_APPROVALS for a given rule.
    Real logic might consider if the rule references sensitive data, or if rule is global/critical, etc.
    This is a simplified placeholder that just creates 2 stages:
      stage=1 => group=BG1
      stage=2 => group=BG2
    Parallel approvals are possible by adding multiple rows with same stage.
    """
    c = conn.cursor()
    try:
        # remove existing
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_id,))
        # stage 1
        c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, IS_PARALLEL_GROUP, COMMENT)
            VALUES(?,?,?,?,?,?,?)
        """, (
            rule_id, "BG1", created_by, 0, 1, 0, None
        ))
        # stage 2
        c.execute("""
            INSERT INTO BRM_RULE_APPROVALS(RULE_ID, GROUP_NAME, USERNAME, APPROVED_FLAG, APPROVAL_STAGE, IS_PARALLEL_GROUP, COMMENT)
            VALUES(?,?,?,?,?,?,?)
        """, (
            rule_id, "BG2", created_by, 0, 2, 0, None
        ))
        conn.commit()
        logger.debug(f"Multistep approvals created for rule {rule_id}.")
    except Exception as ex:
        conn.rollback()
        logger.error(f"Error creating approvals => {ex}")


###################################
# CHECK APPROVAL COMPLETENESS
###################################
def check_approval_completeness(conn, rule_id):
    """
    Evaluate if the rule's approvals are completed or if there's a rejection.
    Return a status string: "APPROVED", "REJECTED", or "IN_PROGRESS".
    For parallel approvals, we assume that any group with the same stage must all be approved to move forward.
    """
    c = conn.cursor()
    # check if any row is REJECTED => entire rule is REJECTED
    c.execute("""
        SELECT COUNT(*) FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=? AND APPROVED_FLAG=2
    """, (rule_id,))
    rejected_count = c.fetchone()[0]
    if rejected_count > 0:
        return "REJECTED"

    # check if all approvals are done => if any 0 => IN_PROGRESS
    c.execute("""
        SELECT COUNT(*)
        FROM BRM_RULE_APPROVALS
        WHERE RULE_ID=? AND APPROVED_FLAG=0
    """, (rule_id,))
    pending = c.fetchone()[0]
    if pending == 0:
        return "APPROVED"

    return "IN_PROGRESS"


###################################
# MULTI-STEP APPROVAL TAB
###################################
class MultiStepApprovalsTab(QWidget):
    """
    Displays pending approvals for the current user. 
    Allows Approve/Reject. 
    Optionally shows a button to open an approval pipeline dialog.
    """

    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 8)
        self.table.setHorizontalHeaderLabels([
            "RuleID", "Group", "Stage", "Approved?", "RuleName",
            "Approve", "Reject", "Comment"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_approvals)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_approvals()

    def load_approvals(self):
        """
        Load approvals where approved_flag=0 for the current user or group. 
        For example, user might match a group or direct username if it’s so configured.
        """
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            query = """
                SELECT A.RULE_ID, A.GROUP_NAME, A.APPROVAL_STAGE, A.APPROVED_FLAG, R.RULE_NAME
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.APPROVED_FLAG=0
                  AND (A.USERNAME=? OR A.GROUP_NAME=?)
                ORDER BY A.RULE_ID, A.APPROVAL_STAGE
            """
            # If your design is that approvals are per group or per user, you might adapt logic
            c.execute(query, (self.logged_in_username, self.user_group))
            rows = c.fetchall()
            self.table.setRowCount(len(rows))
            for i, row in enumerate(rows):
                (rid, grp, stg, appr_f, rname) = row
                self.table.setItem(i, 0, QTableWidgetItem(str(rid)))
                self.table.setItem(i, 1, QTableWidgetItem(str(grp)))
                self.table.setItem(i, 2, QTableWidgetItem(str(stg)))
                self.table.setItem(i, 3, QTableWidgetItem(str(appr_f)))
                self.table.setItem(i, 4, QTableWidgetItem(str(rname)))

                # Approve/Reject buttons
                approve_btn = QPushButton("Approve")
                approve_btn.clicked.connect(lambda _, row_i=i: self.do_approve(row_i))
                self.table.setCellWidget(i, 5, approve_btn)

                reject_btn = QPushButton("Reject")
                reject_btn.clicked.connect(lambda _, row_i=i: self.do_reject(row_i))
                self.table.setCellWidget(i, 6, reject_btn)

                # comment (optional)
                cmt_box = QLineEdit()
                self.table.setCellWidget(i, 7, cmt_box)

        except Exception as ex:
            QMessageBox.critical(self, "Error", f"Error loading approvals => {ex}")

    def do_approve(self, row_idx):
        rid_item = self.table.item(row_idx, 0)
        grp_item = self.table.item(row_idx, 1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        group_nm = grp_item.text()
        cmt_box = self.table.cellWidget(row_idx, 7)
        comment = cmt_box.text().strip() if cmt_box else ""

        c = self.connection.cursor()
        try:
            # set approved
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND GROUP_NAME=? AND APPROVED_FLAG=0
            """, (comment, rule_id, group_nm))
            # check if final => set rule active or partial
            status = check_approval_completeness(self.connection, rule_id)
            if status == "APPROVED":
                c.execute("""
                    UPDATE BRM_RULES
                    SET STATUS='ACTIVE', APPROVAL_STATUS='APPROVED'
                    WHERE RULE_ID=?
                """, (rule_id,))
            elif status == "REJECTED":
                c.execute("""
                    UPDATE BRM_RULES
                    SET STATUS='INACTIVE', APPROVAL_STATUS='REJECTED'
                    WHERE RULE_ID=?
                """, (rule_id,))
            else:
                c.execute("""
                    UPDATE BRM_RULES
                    SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
                    WHERE RULE_ID=?
                """, (rule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Approved", f"Rule {rule_id} approved.")
            self.load_approvals()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def do_reject(self, row_idx):
        rid_item = self.table.item(row_idx, 0)
        grp_item = self.table.item(row_idx, 1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        group_nm = grp_item.text()
        cmt_box = self.table.cellWidget(row_idx, 7)
        comment = cmt_box.text().strip() if cmt_box else ""

        conf = QMessageBox.question(self, "Confirm", f"Reject rule {rule_id}?")
        if conf != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE BRM_RULE_APPROVALS
                SET APPROVED_FLAG=2, APPROVED_TIMESTAMP=GETDATE(), COMMENT=?
                WHERE RULE_ID=? AND GROUP_NAME=? AND APPROVED_FLAG=0
            """, (comment, rule_id, group_nm))
            # set rule => REJECTED
            c.execute("""
                UPDATE BRM_RULES
                SET STATUS='INACTIVE', APPROVAL_STATUS='REJECTED'
                WHERE RULE_ID=?
            """, (rule_id,))
            self.connection.commit()
            QMessageBox.information(self, "Rejected", f"Rule {rule_id} was rejected.")
            self.load_approvals()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))


###################################
# VISUAL APPROVAL PIPELINE
###################################
from PyQt5.QtWidgets import QDialog, QScrollArea, QFrame, QFormLayout
from PyQt5.QtGui import QFont

class ApprovalPipelineDialog(QDialog):
    """
    Display the multi-step (serial/parallel) approval pipeline for a rule, 
    color-coded by approved_flag, with comments.
    """

    def __init__(self, connection, rule_id, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_id = rule_id
        self.setWindowTitle(f"Approval Pipeline – Rule {rule_id}")
        self.resize(600, 400)

        self.main_layout = QVBoxLayout(self)
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.container = QWidget()
        self.container_layout = QVBoxLayout(self.container)
        self.scroll.setWidget(self.container)

        self.main_layout.addWidget(self.scroll)
        self.setLayout(self.main_layout)

        self.load_pipeline()

    def load_pipeline(self):
        self.container_layout.setSpacing(20)
        # fetch approvals for the rule, group by stage
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT APPROVAL_STAGE, GROUP_NAME, USERNAME, APPROVED_FLAG, ISNULL(COMMENT,'') as COMMENT, APPROVED_TIMESTAMP
                FROM BRM_RULE_APPROVALS
                WHERE RULE_ID=?
                ORDER BY APPROVAL_STAGE, GROUP_NAME, USERNAME
            """, (self.rule_id,))
            rows = c.fetchall()
            if not rows:
                self.container_layout.addWidget(QLabel("No approvals found."))
                return

            # group by stage
            from collections import defaultdict
            stage_map = defaultdict(list)
            for r_ in rows:
                stg = r_[0]
                stage_map[stg].append(r_)

            for stg_no in sorted(stage_map.keys()):
                # Create a frame for each stage
                stage_frame = QFrame()
                stage_frame.setFrameStyle(QFrame.Panel | QFrame.Raised)
                sf_layout = QVBoxLayout(stage_frame)

                stg_lbl = QLabel(f"Stage {stg_no}")
                stg_lbl.setFont(QFont("Arial", 12, QFont.Bold))
                sf_layout.addWidget(stg_lbl)

                # For each parallel approver in that stage
                for approval_row in stage_map[stg_no]:
                    # (stage, group, user, flag, comment, ts)
                    a_stg, a_grp, a_user, a_flag, a_comment, a_ts = approval_row
                    if a_flag == 0:
                        color = "#FFFACD"  # yellow => pending
                        status_txt = "Pending"
                    elif a_flag == 1:
                        color = "#CCFFCC"  # green => approved
                        status_txt = "Approved"
                    else:
                        color = "#FFC0CB"  # pink => rejected
                        status_txt = "Rejected"

                    item_frame = QFrame()
                    item_frame.setStyleSheet(f"background-color: {color}; border: 1px solid #AAA;")
                    if a_ts:
                        st2 = str(a_ts)
                    else:
                        st2 = "N/A"
                    content_str = (f"{a_grp}/{a_user} => {status_txt}\n"
                                   f"Time: {st2}\n"
                                   f"Comment: {a_comment}")
                    lbl = QLabel(content_str)
                    lbl.setWordWrap(True)
                    layout_ = QVBoxLayout(item_frame)
                    layout_.addWidget(lbl)
                    sf_layout.addWidget(item_frame)

                self.container_layout.addWidget(stage_frame)

        except Exception as ex:
            self.container_layout.addWidget(QLabel(f"Error => {ex}"))
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 7 of 10
Fully Integrated Codebase

This chunk covers:
  • The advanced Scheduling system (dialog + tab)
  • Chain / Group Simulation dialogs for “What-If” BFS dry-run
  • The DecisionTablesTab for managing decision tables
  • ConflictPriorityManagerTab expansions
  • CompositeRulesTab for advanced logic combining multiple rules
"""

import logging
from datetime import datetime, timedelta
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QLineEdit, QPlainTextEdit, QTableWidget, QTableWidgetItem,
    QComboBox, QMessageBox, QInputDialog, QDialog, QCalendarWidget, QTimeEdit,
    QFileDialog
)
from PyQt5.QtCore import Qt
logger = logging.getLogger("brm_master")


############################################
# SCHEDULE DIALOG
############################################
class EnhancedScheduleDialog(QDialog):
    """
    A scheduling dialog that allows the user to select a rule, pick a date/time,
    optionally run validations, and then insert a record in RULE_SCHEDULES.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Schedule a Rule Execution")
        self.resize(400, 280)

        main_layout = QVBoxLayout(self)
        # Form-like approach
        from PyQt5.QtWidgets import QFormLayout
        form = QFormLayout()

        # Load rules
        self.rule_combo = QComboBox()
        try:
            c = self.connection.cursor()
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for (rid, rname) in c.fetchall():
                self.rule_combo.addItem(f"{rid} - {rname}", rid)
        except Exception as ex:
            logger.error(f"Error loading rules for scheduling => {ex}")
        form.addRow("Select Rule:", self.rule_combo)

        self.calendar = QCalendarWidget()
        self.calendar.setGridVisible(True)
        form.addRow(QLabel("Pick Date:"), self.calendar)

        self.time_edit = QTimeEdit()
        form.addRow(QLabel("Pick Time:"), self.time_edit)

        self.run_val_cb = QComboBox()
        self.run_val_cb.addItems(["Yes", "No"])
        form.addRow("Run Data Validations first?", self.run_val_cb)

        main_layout.addLayout(form)

        btn_h = QHBoxLayout()
        schedule_btn = QPushButton("Schedule")
        schedule_btn.clicked.connect(self.do_schedule)
        btn_h.addWidget(schedule_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(cancel_btn)
        btn_h.addStretch()
        main_layout.addLayout(btn_h)
        self.setLayout(main_layout)

    def do_schedule(self):
        c = self.connection.cursor()
        rule_id = self.rule_combo.currentData()
        d = self.calendar.selectedDate()
        t = self.time_edit.time()
        dt_str = f"{d.toString('yyyy-MM-dd')} {t.toString('HH:mm:ss')}"
        run_val_flag = 1 if self.run_val_cb.currentText() == "Yes" else 0
        try:
            c.execute("""
                INSERT INTO RULE_SCHEDULES(RULE_ID, SCHEDULE_TIME, STATUS, CREATED_TIMESTAMP, RUN_DATA_VALIDATIONS)
                VALUES(?,?, 'Scheduled', GETDATE(), ?)
            """, (rule_id, dt_str, run_val_flag))
            self.connection.commit()
            QMessageBox.information(self, "Scheduled", f"Rule {rule_id} scheduled at {dt_str}")
            self.accept()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))


############################################
# SCHEDULE MANAGEMENT TAB
############################################
class ScheduleManagementTab(QWidget):
    """
    Displays rows from RULE_SCHEDULES.
    Provides basic refresh, add, update, delete.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "SchedID", "RuleID", "ScheduleTime", "Status", "RunVal?", "Actions"
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_h = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_schedules)
        add_btn = QPushButton("Add Schedule")
        add_btn.clicked.connect(self.add_schedule)
        btn_h.addWidget(refresh_btn)
        btn_h.addWidget(add_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_schedules()

    def load_schedules(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SCHEDULE_ID, RULE_ID, SCHEDULE_TIME, STATUS, RUN_DATA_VALIDATIONS
                FROM RULE_SCHEDULES
                ORDER BY SCHEDULE_TIME DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_i = self.table.rowCount()
                self.table.insertRow(r_i)
                for col_i in range(5):
                    val = row[col_i]
                    self.table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))
                # Action cell
                action_widget = QWidget()
                from PyQt5.QtWidgets import QHBoxLayout
                a_layout = QHBoxLayout(action_widget)
                a_layout.setContentsMargins(0,0,0,0)
                upd_btn = QPushButton("Update")
                upd_btn.clicked.connect(lambda _, row_index=r_i: self.update_schedule(row_index))
                del_btn = QPushButton("Delete")
                del_btn.clicked.connect(lambda _, row_index=r_i: self.delete_schedule(row_index))
                a_layout.addWidget(upd_btn)
                a_layout.addWidget(del_btn)
                a_layout.addStretch()
                self.table.setCellWidget(r_i, 5, action_widget)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_schedule(self):
        dlg = EnhancedScheduleDialog(self.connection, self)
        if dlg.exec_() == QDialog.Accepted:
            self.load_schedules()

    def update_schedule(self, row_index):
        sched_id_item = self.table.item(row_index, 0)
        if not sched_id_item:
            return
        sched_id = int(sched_id_item.text())
        new_dt, ok = QInputDialog.getText(self, "Update Schedule", "Enter new datetime (YYYY-MM-DD HH:mm:ss):")
        if not ok or not new_dt.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                UPDATE RULE_SCHEDULES
                SET SCHEDULE_TIME=?
                WHERE SCHEDULE_ID=?
            """, (new_dt.strip(), sched_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", f"Schedule {sched_id} updated.")
            self.load_schedules()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def delete_schedule(self, row_index):
        sched_id_item = self.table.item(row_index, 0)
        if not sched_id_item:
            return
        sched_id = int(sched_id_item.text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete schedule {sched_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SCHEDULES WHERE SCHEDULE_ID=?", (sched_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", f"Schedule {sched_id} removed.")
            self.load_schedules()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))


############################################
# CHAIN SIMULATION DIALOG
############################################
def simulate_chain_bfs(conn, parent_rule_id):
    """
    BFS from a parent rule. Dry-run each rule. Return (executed, skipped).
    For demonstration, we assume if a rule fails => skip child rules. 
    If rule is critical => skip entire subtree.
    """
    from collections import deque
    c = conn.cursor()
    # build adjacency
    adjacency = {}
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    for (rid, pid) in rows:
        if pid:
            adjacency.setdefault(pid, []).append(rid)

    # load all rules in a map
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID, CRITICAL_RULE, IS_GLOBAL FROM BRM_RULES")
    rmap = {}
    rdata = c.fetchall()
    for row in rdata:
        rid, rsql, op_type, dt_id, crit_flag, global_flag = row
        rmap[rid] = (rsql, op_type, dt_id, crit_flag, global_flag)

    executed = []
    skipped = set()
    queue = deque([parent_rule_id])
    from your_brm_code_part2 import dry_run_rule_sql, execute_decision_table  # or from integrated location

    while queue:
        rid = queue.popleft()
        if rid in skipped or rid not in rmap:
            continue
        (rsql, op_type, dt_id, crit_f, glob_f) = rmap[rid]
        # Dry-run
        if op_type.upper() == "DECISION_TABLE":
            ok, msg, rec_count = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, rsql)
            rec_count = 0
        if ok:
            executed.append(rid)
            # add children
            if rid in adjacency:
                for ch in adjacency[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            # if critical => skip subtree
            if crit_f == 1 or glob_f == 1:
                # skip all adjacency from rid
                skip_stack = [rid]
                while skip_stack:
                    x_ = skip_stack.pop()
                    skipped.add(x_)
                    if x_ in adjacency:
                        skip_stack.extend(adjacency[x_])
            else:
                # skip children
                if rid in adjacency:
                    skip_stack2 = adjacency[rid][:]
                    while skip_stack2:
                        x_ = skip_stack2.pop()
                        skipped.add(x_)
                        if x_ in adjacency:
                            skip_stack2.extend(adjacency[x_])
                skipped.add(rid)

    return (executed, list(skipped))


class ChainSimulationDialog(QDialog):
    """
    Let user pick a parent rule, run BFS dry-run, then show results.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Chain Simulation (BFS Dry-run)")
        self.resize(560, 400)
        from PyQt5.QtWidgets import QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QPlainTextEdit, QPushButton

        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            rows = c.fetchall()
            for (rid, rname) in rows:
                self.rule_combo.addItem(f"{rid} - {rname}", rid)
        except:
            pass
        top_h.addWidget(QLabel("Select Parent Rule:"))
        top_h.addWidget(self.rule_combo)
        layout.addLayout(top_h)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_h = QHBoxLayout()
        sim_btn = QPushButton("Simulate BFS")
        sim_btn.clicked.connect(self.do_sim)
        btn_h.addWidget(sim_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_sim(self):
        rid = self.rule_combo.currentData()
        executed, skipped = simulate_chain_bfs(self.connection, rid)
        msg = (f"Executed rules => {executed}\n\nSkipped => {skipped}")
        self.result_text.setPlainText(msg)


############################################
# GROUP SIMULATION DIALOG
############################################
def simulate_custom_group_rules(conn, custom_group_id):
    """
    Dry-run each rule in a custom group individually.
    Return (passed_list, failed_list).
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID FROM BRM_CUSTOM_GROUP_MEMBERS WHERE CUSTOM_GROUP_ID=?", (custom_group_id,))
    rule_ids = [r[0] for r in c.fetchall()]

    # load rule info
    c.execute("SELECT RULE_ID, RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES")
    data = c.fetchall()
    rmap = {}
    for row in data:
        rmap[row[0]] = (row[1], row[2].upper(), row[3])
    from your_brm_code_part2 import dry_run_rule_sql, execute_decision_table  # or integrated

    passed = []
    failed = []
    for r_ in rule_ids:
        if r_ not in rmap:
            failed.append(r_)
            continue
        (sql_, op_type, dt_id) = rmap[r_]
        if op_type == "DECISION_TABLE":
            ok, msg, rec_count = execute_decision_table(conn, dt_id, dry_run=True)
        else:
            ok, msg = dry_run_rule_sql(conn, sql_)
            rec_count = 0
        if ok:
            passed.append(r_)
        else:
            failed.append(r_)
    return (passed, failed)


class GroupSimulationDialog(QDialog):
    """
    Let user pick a custom group, do a dry-run for all rules, show pass/fail sets.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Custom Group Simulation")
        self.resize(580, 400)

        from PyQt5.QtWidgets import QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QPlainTextEdit, QPushButton
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.grp_combo = QComboBox()
        c = self.connection.cursor()
        try:
            c.execute("SELECT CUSTOM_GROUP_ID, CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS ORDER BY CUSTOM_GROUP_ID")
            for row in c.fetchall():
                cid, cname = row
                self.grp_combo.addItem(f"{cid} - {cname}", cid)
        except:
            pass
        top_h.addWidget(QLabel("Select Group:"))
        top_h.addWidget(self.grp_combo)
        layout.addLayout(top_h)

        self.result_text = QPlainTextEdit()
        self.result_text.setReadOnly(True)
        layout.addWidget(self.result_text)

        btn_h = QHBoxLayout()
        run_btn = QPushButton("Simulate")
        run_btn.clicked.connect(self.do_sim)
        btn_h.addWidget(run_btn)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        btn_h.addWidget(close_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)

    def do_sim(self):
        cid = self.grp_combo.currentData()
        passed, failed = simulate_custom_group_rules(self.connection, cid)
        msg = f"Group simulation:\nPassed => {passed}\nFailed => {failed}"
        self.result_text.setPlainText(msg)


############################################
# DECISION TABLES TAB
############################################
class DecisionTablesTab(QWidget):
    """
    Manage decision tables: listing, add, delete, run test.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["DT_ID", "Name", "Description"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add DT")
        add_btn.clicked.connect(self.add_dt)
        del_btn = QPushButton("Delete DT")
        del_btn.clicked.connect(self.delete_dt)
        run_btn = QPushButton("Run DT")
        run_btn.clicked.connect(self.run_dt)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_dt)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(del_btn)
        btn_h.addWidget(run_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_dt()

    def load_dt(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT DECISION_TABLE_ID, TABLE_NAME, DESCRIPTION
                FROM DECISION_TABLES
                ORDER BY DECISION_TABLE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.table.rowCount()
                self.table.insertRow(r_idx)
                for col_i, val in enumerate(row):
                    self.table.setItem(r_idx, col_i, QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_dt(self):
        name, ok = QInputDialog.getText(self, "Add Decision Table", "Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self, "Description", "Optional Desc:")
        if not ok2:
            desc = ""
        query_text, ok3 = QInputDialog.getMultiLineText(self, "Decision Query", "SQL returning 1 or 0:")
        if not ok3 or not query_text.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DECISION_TABLES(TABLE_NAME, DESCRIPTION, DECISION_QUERY, CREATED_TIMESTAMP)
                VALUES(?,?,?,GETDATE())
            """, (name.strip(), desc.strip(), query_text.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Decision Table created.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_dt(self):
        row = self.table.currentRow()
        if row < 0:
            return
        dt_id = int(self.table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete Decision Table {dt_id}?")
        if confirm != QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Decision Table removed.")
            self.load_dt()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def run_dt(self):
        row = self.table.currentRow()
        if row < 0:
            return
        dt_id = int(self.table.item(row, 0).text())
        # do dry-run
        from your_brm_code_part2 import execute_decision_table  # or integrated
        ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        txt = f"Decision Table {dt_id} => PASS={ok}, message='{msg}', recCount={rec_count}"
        QMessageBox.information(self, "DT Execution", txt)


############################################
# CONFLICT PRIORITY MANAGER TAB
############################################
class ConflictPriorityManagerTab(QWidget):
    """
    Manages RULE_CONFLICTS. We can set priorities, delete, or open a conflict visual approach.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["ConflictID","Rule1","Rule2","Priority"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Conflict")
        add_btn.clicked.connect(self.add_conflict)
        set_btn = QPushButton("Set Priority")
        set_btn.clicked.connect(self.set_priority)
        del_btn = QPushButton("Delete Conflict")
        del_btn.clicked.connect(self.delete_conflict)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_conflicts)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(set_btn)
        btn_h.addWidget(del_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_conflicts()

    def load_conflicts(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT CONFLICT_ID, RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS ORDER BY CONFLICT_ID")
            rows = c.fetchall()
            for row in rows:
                r_i = self.table.rowCount()
                self.table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.table.setItem(r_i, col_i, QTableWidgetItem(str(val)))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_conflict(self):
        r1, ok1 = QInputDialog.getInt(self, "Add Conflict", "RuleID1:")
        if not ok1:
            return
        r2, ok2 = QInputDialog.getInt(self, "Add Conflict", "RuleID2:")
        if not ok2:
            return
        prio, ok3 = QInputDialog.getInt(self, "Set Priority", "Priority:", 1)
        if not ok3:
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_CONFLICTS(RULE_ID1, RULE_ID2, PRIORITY) VALUES(?,?,?)", (r1,r2,prio))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Conflict added.")
            self.load_conflicts()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def set_priority(self):
        row = self.table.currentRow()
        if row < 0:
            return
        cf_id = int(self.table.item(row, 0).text())
        new_prio, ok = QInputDialog.getInt(self, "Set Priority", f"New priority for Conflict {cf_id}:", 1)
        if not ok:
            return
        c = self.connection.cursor()
        try:
            c.execute("UPDATE RULE_CONFLICTS SET PRIORITY=? WHERE CONFLICT_ID=?", (new_prio, cf_id))
            self.connection.commit()
            QMessageBox.information(self, "Updated", "Conflict priority updated.")
            self.load_conflicts()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def delete_conflict(self):
        row = self.table.currentRow()
        if row < 0:
            return
        cf_id = int(self.table.item(row,0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete conflict {cf_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_CONFLICTS WHERE CONFLICT_ID=?", (cf_id,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Conflict removed.")
            self.load_conflicts()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))


############################################
# COMPOSITE RULES TAB
############################################
class CompositeRulesTab(QWidget):
    """
    Manages “COMPOSITE_RULES”: multi-rule logic expressions or aggregator logic.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["CompRuleID","Name","LogicExpr","ActionOnPass"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Composite")
        add_btn.clicked.connect(self.add_composite)
        del_btn = QPushButton("Delete Composite")
        del_btn.clicked.connect(self.delete_composite)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_composites)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(del_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_composites()

    def load_composites(self):
        self.table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT COMPOSITE_RULE_ID, CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS
                FROM COMPOSITE_RULES
                ORDER BY COMPOSITE_RULE_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_i = self.table.rowCount()
                self.table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_composite(self):
        nm, ok = QInputDialog.getText(self, "Add Composite", "Name:")
        if not ok or not nm.strip():
            return
        expr, ok2 = QInputDialog.getMultiLineText(self, "Logic Expression", "ex: 'Rule10==PASS AND Rule20==PASS'")
        if not ok2:
            expr = ""
        act, ok3 = QInputDialog.getText(self, "ActionOnPass", "Optional action, e.g. 'SendAlert'")
        if not ok3:
            act = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COMPOSITE_RULES(CRULE_NAME, LOGIC_EXPR, ACTION_ON_PASS)
                VALUES(?,?,?)
            """, (nm.strip(), expr.strip(), act.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Composite rule added.")
            self.load_composites()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def delete_composite(self):
        row = self.table.currentRow()
        if row < 0:
            return
        cid = int(self.table.item(row, 0).text())
        conf = QMessageBox.question(self, "Confirm", f"Delete composite rule {cid}?")
        if conf!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM COMPOSITE_RULES WHERE COMPOSITE_RULE_ID=?", (cid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Composite rule removed.")
            self.load_composites()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 8 of 10
Fully Integrated Codebase

This chunk covers:
  • SnapshotManagerTab with snapshot comparison and rollback previews
  • TagsManagerTab for rule tagging
  • DataValidationTab for in-DB validations (NOT NULL, RANGE, UNIQUE, etc.)
  • WhatIfTestTab for interactive “mini data” or CSV-based rule test
  • CollaborationTab for threaded discussion or mention-based messaging
"""

import logging
import json
import csv
import re
from datetime import datetime
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QTableWidget, QTableWidgetItem, QInputDialog, QPlainTextEdit,
    QMessageBox, QFileDialog, QListWidget, QListWidgetItem, QFormLayout,
    QCheckBox, QTextEdit
)
from PyQt5.QtCore import Qt
logger = logging.getLogger("brm_master")


#######################################################
# SNAPSHOT MANAGER TAB
#######################################################
class SnapshotManagerTab(QWidget):
    """
    Manages rule snapshots: listing, create, delete, compare, 
    with optional “dry-run rollback” or partial rollback approach.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.ss_table = QTableWidget(0, 5)
        self.ss_table.setHorizontalHeaderLabels(["SnapID", "Name", "CreatedBy", "CreatedTS", "Actions"])
        self.ss_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.ss_table)

        btn_h = QHBoxLayout()
        take_btn = QPushButton("Take Snapshot")
        take_btn.clicked.connect(self.take_snapshot)
        btn_h.addWidget(take_btn)

        compare_btn = QPushButton("Compare Snapshots")
        compare_btn.clicked.connect(self.compare_snapshots)
        btn_h.addWidget(compare_btn)

        del_btn = QPushButton("Delete Snapshot")
        del_btn.clicked.connect(self.delete_snapshot)
        btn_h.addWidget(del_btn)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_snapshots)
        btn_h.addWidget(ref_btn)

        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_snapshots()

    def load_snapshots(self):
        self.ss_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT SNAPSHOT_ID, SNAPSHOT_NAME, CREATED_BY, CREATED_TIMESTAMP
                FROM RULE_SNAPSHOTS
                ORDER BY SNAPSHOT_ID DESC
            """)
            rows = c.fetchall()
            for row in rows:
                r_idx = self.ss_table.rowCount()
                self.ss_table.insertRow(r_idx)
                sid, sname, cby, cts = row
                self.ss_table.setItem(r_idx, 0, QTableWidgetItem(str(sid)))
                self.ss_table.setItem(r_idx, 1, QTableWidgetItem(str(sname)))
                self.ss_table.setItem(r_idx, 2, QTableWidgetItem(str(cby)))
                self.ss_table.setItem(r_idx, 3, QTableWidgetItem(str(cts)))

                # Actions
                action_widget = QWidget()
                from PyQt5.QtWidgets import QHBoxLayout
                a_layout = QHBoxLayout(action_widget)
                a_layout.setContentsMargins(0,0,0,0)
                rest_btn = QPushButton("Restore")
                rest_btn.clicked.connect(lambda _, x=sid: self.restore_snapshot(x))
                a_layout.addWidget(rest_btn)
                a_layout.addStretch()
                self.ss_table.setCellWidget(r_idx, 4, action_widget)
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def take_snapshot(self):
        name, ok = QInputDialog.getText(self, "Snapshot", "Enter snapshot name:")
        if not ok or not name.strip():
            return
        c = self.connection.cursor()
        try:
            # build JSON from BRM_RULES
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [desc[0] for desc in c.description]
            data = [dict(zip(colnames, r)) for r in rows]
            snap_json = json.dumps(data, indent=2)
            c.execute("""
                INSERT INTO RULE_SNAPSHOTS(SNAPSHOT_NAME, CREATED_BY, SNAPSHOT_JSON)
                VALUES(?,?,?)
            """, (name.strip(), "SnapshotUser", snap_json))
            self.connection.commit()
            QMessageBox.information(self, "Snapshot", "Snapshot created.")
            self.load_snapshots()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def delete_snapshot(self):
        row = self.ss_table.currentRow()
        if row<0:
            return
        sid = int(self.ss_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Delete snapshot {sid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (sid,))
            self.connection.commit()
            QMessageBox.information(self, "Deleted", "Snapshot removed.")
            self.load_snapshots()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def compare_snapshots(self):
        dlg = SnapshotCompareDialog(self.connection, self)
        dlg.exec_()

    def restore_snapshot(self, snap_id):
        confirm = QMessageBox.question(self, "Restore", f"Restore snapshot {snap_id}? This might override rule definitions.")
        if confirm!=QMessageBox.Yes:
            return
        # minimal partial example
        c = self.connection.cursor()
        try:
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (snap_id,))
            row = c.fetchone()
            if row:
                snap_json = row[0]
                data = json.loads(snap_json)
                # partial restore logic or "dry-run" approach
                # for demonstration, just show a message
                QMessageBox.information(self, "Restored", "Snapshot restore is not fully implemented. This is a placeholder.")
            else:
                QMessageBox.warning(self, "Not found", f"Snapshot {snap_id} not found.")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


class SnapshotCompareDialog(QDialog):
    """
    A small wizard or dialog to pick two snapshots or snapshot vs current and do a JSON diff.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Compare Snapshots")
        self.resize(600,400)
        layout = QVBoxLayout(self)

        from PyQt5.QtWidgets import QFormLayout, QComboBox
        form = QFormLayout()
        self.snap1_combo = QComboBox()
        self.snap2_combo = QComboBox()
        self.populate_snapshots(self.snap1_combo)
        self.populate_snapshots(self.snap2_combo)

        form.addRow("Snapshot A:", self.snap1_combo)
        form.addRow("Snapshot B:", self.snap2_combo)
        layout.addLayout(form)

        btn_h = QHBoxLayout()
        cmp_btn = QPushButton("Compare")
        cmp_btn.clicked.connect(self.do_compare)
        btn_h.addWidget(cmp_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.result_edit = QPlainTextEdit()
        self.result_edit.setReadOnly(True)
        layout.addWidget(self.result_edit)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn, alignment=Qt.AlignRight)

        self.setLayout(layout)

    def populate_snapshots(self, combo):
        c = self.connection.cursor()
        combo.addItem("(CURRENT)", None)
        try:
            c.execute("SELECT SNAPSHOT_ID, SNAPSHOT_NAME FROM RULE_SNAPSHOTS ORDER BY SNAPSHOT_ID DESC")
            for row in c.fetchall():
                sid, sname = row
                combo.addItem(f"{sid} - {sname}", sid)
        except Exception as ex:
            logger.error(f"Populate snapshots error: {ex}")

    def do_compare(self):
        sid1 = self.snap1_combo.currentData()
        sid2 = self.snap2_combo.currentData()
        try:
            data1 = self.get_snapshot_data(sid1)
            data2 = self.get_snapshot_data(sid2)
            import difflib, json
            txt1 = json.dumps(data1, indent=2, sort_keys=True)
            txt2 = json.dumps(data2, indent=2, sort_keys=True)
            lines1 = txt1.splitlines()
            lines2 = txt2.splitlines()
            diff = difflib.unified_diff(lines1, lines2, fromfile="SnapA", tofile="SnapB", lineterm="")
            diff_text = "\n".join(diff)
            if not diff_text.strip():
                diff_text = "(No differences found.)"
            self.result_edit.setPlainText(diff_text)
        except Exception as ex:
            QMessageBox.critical(self, "Compare Error", str(ex))

    def get_snapshot_data(self, sid):
        if sid is None:
            # current
            c = self.connection.cursor()
            c.execute("SELECT * FROM BRM_RULES")
            rows = c.fetchall()
            colnames = [d[0] for d in c.description]
            data = [dict(zip(colnames, r)) for r in rows]
            return data
        else:
            c = self.connection.cursor()
            c.execute("SELECT SNAPSHOT_JSON FROM RULE_SNAPSHOTS WHERE SNAPSHOT_ID=?", (sid,))
            row = c.fetchone()
            if row and row[0]:
                return json.loads(row[0])
            return []


#######################################################
# TAGS MANAGER TAB
#######################################################
class TagsManagerTab(QWidget):
    """
    Manages rule tags. Each rule can have multiple tags in RULE_TAGS.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.tags_table = QTableWidget(0,3)
        self.tags_table.setHorizontalHeaderLabels(["TagID","RuleID","TagName"])
        self.tags_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tags_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Tag")
        add_btn.clicked.connect(self.add_tag)
        remove_btn = QPushButton("Remove Tag")
        remove_btn.clicked.connect(self.remove_tag)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_tags)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(remove_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_tags()

    def load_tags(self):
        self.tags_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("SELECT TAG_ID, RULE_ID, TAG_NAME FROM RULE_TAGS ORDER BY TAG_ID DESC")
            rows = c.fetchall()
            for row in rows:
                r_i = self.tags_table.rowCount()
                self.tags_table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.tags_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_tag(self):
        rule_id, ok = QInputDialog.getInt(self, "Add Tag", "RuleID:")
        if not ok:
            return
        tag_name, ok2 = QInputDialog.getText(self, "Tag Name", "Enter Tag:")
        if not ok2 or not tag_name.strip():
            return
        c = self.connection.cursor()
        try:
            c.execute("INSERT INTO RULE_TAGS(RULE_ID, TAG_NAME) VALUES(?,?)", (rule_id, tag_name.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", f"Tag '{tag_name}' added to rule {rule_id}.")
            self.load_tags()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def remove_tag(self):
        row = self.tags_table.currentRow()
        if row < 0:
            return
        tag_id = int(self.tags_table.item(row, 0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove tag {tag_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM RULE_TAGS WHERE TAG_ID=?", (tag_id,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", "Tag removed.")
            self.load_tags()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))


#######################################################
# DATA VALIDATION TAB
#######################################################
class DataValidationTab(QWidget):
    """
    Displays the in-DB validations from DATA_VALIDATIONS
    and allows running them on demand or removing/adding them.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.dv_table = QTableWidget(0,6)
        self.dv_table.setHorizontalHeaderLabels([
            "ValID", "TableName", "ColumnName", "ValType", "Params", "LastResult"
        ])
        self.dv_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.dv_table)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Validation")
        add_btn.clicked.connect(self.add_validation)
        rem_btn = QPushButton("Remove Validation")
        rem_btn.clicked.connect(self.remove_validation)
        run_btn = QPushButton("Run All Validations")
        run_btn.clicked.connect(self.run_all)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_validations)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(rem_btn)
        btn_h.addWidget(run_btn)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_validations()

    def load_validations(self):
        self.dv_table.setRowCount(0)
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT V.VALIDATION_ID, V.TABLE_NAME, V.COLUMN_NAME, V.VALIDATION_TYPE,
                       V.PARAMS,
                       (
                         SELECT TOP 1 DETAILS
                         FROM DATA_VALIDATION_LOGS L
                         WHERE L.VALIDATION_ID=V.VALIDATION_ID
                         ORDER BY L.VALIDATION_TIMESTAMP DESC
                       ) AS LAST_RESULT
                FROM DATA_VALIDATIONS V
                ORDER BY V.VALIDATION_ID
            """)
            rows = c.fetchall()
            for row in rows:
                r_i = self.dv_table.rowCount()
                self.dv_table.insertRow(r_i)
                for col_i, val in enumerate(row):
                    self.dv_table.setItem(r_i, col_i, QTableWidgetItem(str(val) if val else ""))
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def add_validation(self):
        tbl, ok = QInputDialog.getText(self, "Add Validation", "Table name:")
        if not ok or not tbl.strip():
            return
        col_, ok2 = QInputDialog.getText(self, "Add Validation", "Column name:")
        if not ok2 or not col_.strip():
            return
        vtype, ok3 = QInputDialog.getText(self, "Validation Type", "e.g. NOT NULL, RANGE, UNIQUE:")
        if not ok3 or not vtype.strip():
            return
        params, ok4 = QInputDialog.getText(self, "Params", "e.g. min=0;max=100 (optional)")
        if not ok4:
            params = ""
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO DATA_VALIDATIONS(TABLE_NAME, COLUMN_NAME, VALIDATION_TYPE, PARAMS, CREATED_TIMESTAMP)
                VALUES(?,?,?,?,GETDATE())
            """, (tbl.strip(), col_.strip(), vtype.strip(), params.strip()))
            self.connection.commit()
            QMessageBox.information(self, "Added", "Data validation created.")
            self.load_validations()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def remove_validation(self):
        row = self.dv_table.currentRow()
        if row<0:
            return
        vid = int(self.dv_table.item(row,0).text())
        confirm = QMessageBox.question(self, "Confirm", f"Remove validation {vid}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM DATA_VALIDATIONS WHERE VALIDATION_ID=?", (vid,))
            self.connection.commit()
            QMessageBox.information(self, "Removed", f"Validation {vid} removed.")
            self.load_validations()
        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", str(ex))

    def run_all(self):
        try:
            from your_brm_code_part2 import run_data_validations  # or integrated
            run_data_validations(self.connection)
            QMessageBox.information(self, "Executed", "All validations run. See logs for details.")
            self.load_validations()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))


#######################################################
# WHAT-IF TEST TAB
#######################################################
class WhatIfTestTab(QWidget):
    """
    Let user pick a rule, optionally upload CSV or type sample data, then do a dry-run.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.csv_path = None

        layout = QVBoxLayout(self)

        from PyQt5.QtWidgets import QHBoxLayout, QLabel, QComboBox, QPushButton, QPlainTextEdit, QFileDialog

        top_h = QHBoxLayout()
        self.rule_combo = QComboBox()
        c = self.connection.cursor()
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
            for row in c.fetchall():
                self.rule_combo.addItem(f"{row[0]} - {row[1]}", row[0])
        except:
            pass
        top_h.addWidget(QLabel("Select Rule:"))
        top_h.addWidget(self.rule_combo)

        csv_btn = QPushButton("Upload CSV")
        csv_btn.clicked.connect(self.pick_csv)
        top_h.addWidget(csv_btn)

        run_btn = QPushButton("Run Dry-run")
        run_btn.clicked.connect(self.run_test)
        top_h.addWidget(run_btn)

        top_h.addStretch()
        layout.addLayout(top_h)

        self.output_edit = QPlainTextEdit()
        self.output_edit.setReadOnly(True)
        layout.addWidget(self.output_edit)

        self.setLayout(layout)

    def pick_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select CSV", "", "CSV Files (*.csv)")
        if path:
            self.csv_path = path
            QMessageBox.information(self, "Selected CSV", f"CSV file: {path}")

    def run_test(self):
        rid = self.rule_combo.currentData()
        c = self.connection.cursor()
        c.execute("SELECT RULE_SQL, OPERATION_TYPE, DECISION_TABLE_ID FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = c.fetchone()
        if not row:
            self.output_edit.setPlainText("Rule not found.")
            return
        rule_sql, op_type, dt_id = row
        if op_type.upper()=="DECISION_TABLE":
            from your_brm_code_part2 import execute_decision_table
            ok, msg, rec_count = execute_decision_table(self.connection, dt_id, dry_run=True)
        else:
            from your_brm_code_part2 import dry_run_rule_sql
            ok, msg = dry_run_rule_sql(self.connection, rule_sql)
            rec_count = 0
        txt = (f"Rule {rid} => PASS={ok}\n"
               f"Message='{msg}'\nRecords={rec_count}\nCSV='{self.csv_path}' (not truly used yet).")
        self.output_edit.setPlainText(txt)


#######################################################
# COLLABORATION TAB
#######################################################
class CollaborationTab(QWidget):
    """
    Show a messages list from COLLABORATION_LOGS, plus input box to post new messages.
    Optionally detect @mentions or threads.
    """
    from PyQt5.QtCore import pyqtSignal
    newMessage = pyqtSignal(dict)

    def __init__(self, connection, collaboration_manager, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.collab_mgr = collaboration_manager  # an instance of CollaborationManager or ThreadedCollaborationManager
        layout = QVBoxLayout(self)

        from PyQt5.QtWidgets import QListWidget, QLineEdit, QPushButton, QHBoxLayout

        self.messages_list = QListWidget()
        layout.addWidget(self.messages_list)

        input_h = QHBoxLayout()
        self.msg_edit = QLineEdit()
        self.msg_edit.setPlaceholderText("Type message... use @username to mention.")
        input_h.addWidget(self.msg_edit)
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        input_h.addWidget(send_btn)
        layout.addLayout(input_h)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_messages)
        layout.addWidget(ref_btn)

        self.setLayout(layout)
        self.load_messages()

        if self.collab_mgr:
            self.collab_mgr.newMessage.connect(self.handle_new_msg)

    def load_messages(self):
        self.messages_list.clear()
        c = self.connection.cursor()
        try:
            c.execute("""
                SELECT MESSAGE_ID, RULE_ID, MESSAGE, SENDER, TIMESTAMP
                FROM COLLABORATION_LOGS
                ORDER BY TIMESTAMP DESC
            """)
            rows = c.fetchall()
            for row in rows:
                msg_id, rule_id, msg, sender, ts = row
                self.messages_list.addItem(f"[{ts}] {sender}: {msg}")
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))

    def handle_new_msg(self, payload):
        ts = payload.get("timestamp", "")
        rule_id = payload.get("rule_id", "")
        sender = payload.get("sender", "")
        message = payload.get("message", "")
        self.messages_list.insertItem(0, f"[{ts}] {sender}: {message}")

    def send_message(self):
        msg = self.msg_edit.text().strip()
        if not msg:
            return
        sender = "CurrentUser"
        c = self.connection.cursor()
        try:
            c.execute("""
                INSERT INTO COLLABORATION_LOGS(RULE_ID, MESSAGE, SENDER, TIMESTAMP)
                VALUES(NULL, ?, ?, GETDATE())
            """, (msg, sender))
            self.connection.commit()
            self.msg_edit.clear()
            self.load_messages()
        except Exception as ex:
            QMessageBox.critical(self, "Error", str(ex))
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 9 of 10
Fully Integrated Codebase

This chunk covers:
  • TaskNotificationCenter for a unified “My Tasks” or “Inbox” approach
  • Enhanced BFS Execution with conflict checks (execute_rules_unified_bfs_with_conflicts)
  • Possibly advanced AIOps hooks for anomaly detection or auto-healing
  • ImpersonationWidget for admin user switch
  • Additional expansions to the MainWindow to embed these new tabs/functionalities
"""

import logging
import math
from datetime import datetime
from collections import defaultdict, deque
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTableWidget,
    QTableWidgetItem, QMessageBox, QLabel
)
from PyQt5.QtCore import Qt

logger = logging.getLogger("brm_master")


###############################################################################
# TASK & NOTIFICATION CENTER
###############################################################################
class TaskNotificationCenter(QWidget):
    """
    Provides a consolidated “My Tasks” or “Inbox” approach that includes:
      - Approvals pending (from BRM_RULE_APPROVALS)
      - Conflicts to resolve (from RULE_CONFLICTS) if user is responsible
      - Possibly data validation alerts, stale locks, or collaboration mentions
      - Approve/Reject buttons or quick actions
    """

    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        layout = QVBoxLayout(self)

        # Table for tasks
        self.tasks_table = QTableWidget(0, 5)
        self.tasks_table.setHorizontalHeaderLabels(["TaskID", "Type", "Description", "Created", "Actions"])
        self.tasks_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.tasks_table)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh Tasks")
        ref_btn.clicked.connect(self.load_tasks)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_tasks()

    def load_tasks(self):
        self.tasks_table.setRowCount(0)
        c = self.connection.cursor()

        # For demonstration, we’ll unify approvals + conflicts. 
        # In real usage, you might have a “TASKS” table, or you gather from each area. 

        rowData = []

        # 1) Approvals
        try:
            c.execute("""
                SELECT A.RULE_ID, 'APPROVAL', 
                       CONCAT('Rule ', R.RULE_NAME, ' awaiting approval, stage=', A.APPROVAL_STAGE),
                       A.CREATED_TIMESTAMP
                FROM BRM_RULE_APPROVALS A
                JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
                WHERE A.APPROVED_FLAG=0 
                  AND (A.GROUP_NAME=? OR ? IN ('Admin','GlobalApprovers'))
                ORDER BY A.CREATED_TIMESTAMP DESC
            """, (self.user_group, self.user_group))
            approvals = c.fetchall()
            for (rule_id, ttype, desc, ctime) in approvals:
                # store as (task_id, type, desc, created, action)
                rowData.append((str(rule_id), ttype, desc, str(ctime), ""))
        except Exception as ex:
            logger.error(f"Error loading approvals for tasks: {ex}")

        # 2) Conflicts: e.g., if user_group is “Admin” or certain conflict-responsible group
        #   we can show conflicts with high priority
        if self.user_group.lower() in ("admin","riskmanager","globalapprovers"):
            try:
                c.execute("""
                    SELECT C.CONFLICT_ID, 'CONFLICT',
                           CONCAT('Conflict between R1=', R1.RULE_NAME, ' and R2=', R2.RULE_NAME, ' (prio=', C.PRIORITY, ')'),
                           GETDATE()
                    FROM RULE_CONFLICTS C
                    JOIN BRM_RULES R1 ON C.RULE_ID1=R1.RULE_ID
                    JOIN BRM_RULES R2 ON C.RULE_ID2=R2.RULE_ID
                    WHERE C.PRIORITY>=1
                """)
                conflicts = c.fetchall()
                for (cfid, ttype, desc, now_) in conflicts:
                    rowData.append((str(cfid), ttype, desc, str(now_), ""))
            except Exception as ex:
                logger.error(f"Error loading conflicts for tasks: {ex}")

        # 3) Possibly stale locks, mentions, etc. 
        # For brevity, we skip or do partial.

        self.tasks_table.setRowCount(len(rowData))
        for i, r_ in enumerate(rowData):
            for col_i in range(4):
                self.tasks_table.setItem(i, col_i, QTableWidgetItem(r_[col_i]))
            # Action cell
            from PyQt5.QtWidgets import QWidget, QHBoxLayout, QPushButton
            action_widget = QWidget()
            ah = QHBoxLayout(action_widget)
            ah.setContentsMargins(0,0,0,0)
            # minimal “Open” or “Acknowledge”
            open_btn = QPushButton("Open/Action")
            open_btn.clicked.connect(lambda _, idx=i: self.handle_task_action(idx))
            ah.addWidget(open_btn)
            ah.addStretch()
            self.tasks_table.setCellWidget(i, 4, action_widget)

    def handle_task_action(self, row_i):
        task_id_item = self.tasks_table.item(row_i, 0)
        task_type_item = self.tasks_table.item(row_i, 1)
        if not task_id_item or not task_type_item:
            return
        tid = task_id_item.text()
        ttype = task_type_item.text()
        # you might open the relevant tab or dialog
        QMessageBox.information(self, "Task Action", f"Opening {ttype} detail for ID={tid}")


###############################################################################
# EXTENDED BFS WITH CONFLICTS & APPROVAL CHECKS
###############################################################################

def execute_rules_unified_bfs_with_conflicts(conn, user_id=None, dry_run=False):
    """
    BFS that also checks RULE_CONFLICTS. 
    If two rules conflict at run-time, 
    we apply conflict priority or skip the lower priority rule.
    Additionally, we can incorporate multi-step approvals to see if a rule 
    is even “APPROVED” before running it.
    """
    from your_brm_code_part2 import run_data_validations, insert_rule_execution_log
    from your_brm_code_part2 import run_single_rule_in_transaction
    run_data_validations(conn)

    adjacency, roots, parent_map = load_rule_relationships_plus_conflicts(conn)
    rule_map = get_all_rules_map(conn)
    # conflict_map => r1: [(r2, prio), (r3, prio)...]
    conflict_map = build_conflict_map_for_execution(conn)

    executed = []
    skipped = set()
    queue = list(roots)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_map:
            skipped.add(rid)
            continue

        # check if rule is APPROVED
        if not is_rule_approved(conn, rid):
            logger.debug(f"Skipping rule {rid} => not fully approved.")
            skipped.add(rid)
            continue

        # check conflicts
        if rid in conflict_map:
            for (other_rid, prio) in conflict_map[rid]:
                # if other rid is not run yet, we see if we skip or run
                # for demonstration: skip the lower priority rule
                if other_rid not in executed and other_rid not in skipped:
                    # compare rid vs. other_rid => whichever has higher priority wins
                    # naive approach => if prio>=5 => rid “wins”, skip other, else skip rid
                    if prio>=5:
                        logger.debug(f"Conflict => skipping {other_rid} because {rid} has prio={prio}.")
                        skipped.add(other_rid)
                    else:
                        logger.debug(f"Conflict => skipping {rid} because otherR {other_rid} has higher or equal prio.")
                        skipped.add(rid)
                        break

        if rid in skipped:
            continue

        # run the rule
        info = rule_map[rid]
        ok, msg, rec_count = run_single_rule_in_transaction(conn, info, is_dry_run=dry_run)
        insert_rule_execution_log(conn, rid, ok, msg, rec_count)
        if ok:
            executed.append(rid)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            is_crit = (info.get("CRITICAL_RULE", 0)==1 or info.get("IS_GLOBAL",0)==1)
            if is_crit and rid in adjacency:
                skip_all_descendants(rid, adjacency, skipped)
            if rid in adjacency:
                for ch in adjacency[rid]:
                    skip_all_descendants(ch, adjacency, skipped)
            skipped.add(rid)

    return (executed, list(skipped))


def load_rule_relationships_plus_conflicts(conn):
    """
    Similar to load_rule_relationships but also merges conflict adjacency 
    so BFS sees them. We can store them in a separate map or unify them.
    """
    adjacency = {}
    parent_map = {}
    c = conn.cursor()
    c.execute("SELECT RULE_ID, PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()
    all_ids = set()
    child_ids = set()
    for (rid, pid) in rows:
        all_ids.add(rid)
        if pid:
            adjacency.setdefault(pid, set()).add(rid)
            child_ids.add(rid)
            parent_map[rid] = pid
    roots = [r for r in all_ids if r not in child_ids]

    # For BFS, we might add conflict edges as well, but interpret them differently. 
    # Typically we store conflicts separately (like conflict_map).
    return (adjacency, roots, parent_map)


def get_all_rules_map(conn):
    """
    Return a dict: RULE_ID -> row data from BRM_RULES.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    colnames = [d[0] for d in c.description]
    out = {}
    for row in rows:
        drow = dict(zip(colnames, row))
        out[drow["RULE_ID"]] = drow
    return out


def build_conflict_map_for_execution(conn):
    """
    Return conflict_map => r1: [(r2, prio), ...], r2: [(r1, prio), ...].
    """
    c = conn.cursor()
    c.execute("SELECT RULE_ID1, RULE_ID2, PRIORITY FROM RULE_CONFLICTS")
    rows = c.fetchall()
    conflict_map = {}
    for (r1, r2, prio) in rows:
        conflict_map.setdefault(r1, []).append((r2, prio))
        conflict_map.setdefault(r2, []).append((r1, prio))
    return conflict_map


def is_rule_approved(conn, rule_id):
    """
    Check if a rule is fully approved (no pending or rejected approvals).
    For a multi-step or parallel approval scenario:
      if any approvals are pending => not fully approved
      if any approvals are rejected => rule is REJECTED
    """
    c = conn.cursor()
    try:
        # If we see any REJECT => overall rejected => returns false
        c.execute("SELECT COUNT(*) FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND APPROVED_FLAG=2", (rule_id,))
        rej = c.fetchone()[0]
        if rej>0:
            return False
        # If we see any pending => not fully approved
        c.execute("SELECT COUNT(*) FROM BRM_RULE_APPROVALS WHERE RULE_ID=? AND APPROVED_FLAG=0", (rule_id,))
        pen = c.fetchone()[0]
        if pen>0:
            return False
        return True
    except:
        return False


def skip_all_descendants(start_id, adjacency, skipped):
    stack = [start_id]
    while stack:
        cur = stack.pop()
        if cur in skipped:
            continue
        skipped.add(cur)
        if cur in adjacency:
            for ch in adjacency[cur]:
                if ch not in skipped:
                    stack.append(ch)

###############################################################################
# AIOps Hooks – Anomaly Detection & Auto-Healing
###############################################################################
def detect_rule_execution_anomalies(conn):
    """
    Basic example: if a rule's fail rate > X% or average exec time > threshold => anomaly
    Return list of (rule_id, reason).
    """
    c = conn.cursor()
    anomalies = []
    try:
        c.execute("""
            SELECT RULE_ID, 
                   SUM(CASE WHEN PASS_FLAG=0 THEN 1 ELSE 0 END)*1.0 / COUNT(*) as fail_rate,
                   AVG(EXECUTION_TIME_MS) as avg_ms
            FROM RULE_EXECUTION_LOGS
            WHERE EXECUTION_TIMESTAMP >= DATEADD(DAY, -7, GETDATE())
            GROUP BY RULE_ID
        """)
        rows = c.fetchall()
        for (rid, fail_rate, avg_ms) in rows:
            if fail_rate > 0.2:  # 20% threshold
                anomalies.append((rid, f"High fail rate {fail_rate*100:.1f}% in last 7 days"))
            elif avg_ms>3000:
                anomalies.append((rid, f"High exec time {avg_ms} ms >3000"))
    except Exception as ex:
        logger.error(f"Error in anomaly detection: {ex}")
    return anomalies

def auto_heal_or_escalate(conn, anomalies):
    """
    If we identify known patterns, attempt auto-healing or escalate. 
    E.g. if stale lock => forcibly unlock. If data mismatch => alert. 
    """
    for (rid, reason) in anomalies:
        # naive approach => if reason includes 'fail rate', we just log an escalation
        if "fail rate" in reason.lower():
            logger.info(f"Escalating rule {rid} due to: {reason}")
        elif "exec time" in reason.lower():
            logger.info(f"Possible performance tuning needed for rule {rid}: {reason}")
        # you could do force unlock or re-parse etc.

###############################################################################
# IMPERSONATION WIDGET
###############################################################################
class ImpersonationWidget(QWidget):
    """
    Allows an admin to switch user context. 
    This can be used for debugging or simulating approvals from different groups. 
    When changed, it triggers a signal so main app can reload permissions.
    """
    from PyQt5.QtCore import pyqtSignal
    impersonationChanged = pyqtSignal(int, str)  # user_id, user_group

    def __init__(self, connection, current_user_id, current_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.current_user_id = current_user_id
        self.current_group = current_group

        layout = QHBoxLayout(self)
        self.lbl = QLabel("Impersonate:")
        self.combo = QTableWidget()  # or QComboBox
        # For demonstration, let's do a QComboBox approach
        from PyQt5.QtWidgets import QComboBox
        self.combo = QComboBox()

        self.reload_btn = QPushButton("Switch")

        layout.addWidget(self.lbl)
        layout.addWidget(self.combo)
        layout.addWidget(self.reload_btn)
        self.setLayout(layout)

        self.load_users()
        self.reload_btn.clicked.connect(self.switch_user)

    def load_users(self):
        c = self.connection.cursor()
        try:
            c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
            for (uid, uname, ugrp) in c.fetchall():
                self.combo.addItem(f"{uname} ({ugrp})", (uid, ugrp))
        except Exception as ex:
            logger.error(f"Error loading user list for impersonation: {ex}")

    def switch_user(self):
        data = self.combo.currentData()
        if data:
            uid, grp = data
            if uid==self.current_user_id:
                QMessageBox.information(self, "No Change", "Already impersonating this user.")
                return
            self.current_user_id = uid
            self.current_group = grp
            logger.info(f"Switched impersonation => UID={uid}, group={grp}")
            self.impersonationChanged.emit(uid, grp)
            QMessageBox.information(self, "Switched", f"Now impersonating user {uid}, group {grp}.")
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
BRM MASTER – PART 10 of 10
Fully Integrated Codebase

This final chunk shows how all parts come together in a single “BRMMasterApp.py” 
to run the application. It merges references to all classes, organizes them 
in a single or multi-file structure, and demonstrates the main entry point. 

You can merge Part 1..10 into a single file or keep them as a multi-file project 
(e.g., brm_master/*.py). Here we showcase a single file approach for simplicity.

Steps:
  1) DatabaseConnectionDialog & LoginDialog for DB + user authentication.
  2) OnboardingWizard check (optional).
  3) Launch a QMainWindow with tabs for:
       • BusinessRulesTab (advanced)
       • MultiStepApprovalTab
       • ConflictPriorityManagerTab
       • GlobalCriticalAdminTab
       • CustomRuleGroupsTab
       • SchedulingTab
       • MetricsDashboardTab (enhanced)
       • TaskNotificationCenter or “My Tasks” tab
       • HierarchyViewTab (drag-and-drop)
       • EnhancedLineageGraphTab
       • SnapshotManagerTab
       • DataValidationTab
       • CollaborationTab (threaded / mention-based)
       • Admin tabs: GroupManagement, UserManagement, etc.
     plus any additional features you desire.

We also show how ImpersonationWidget or AIOps anomaly detection might be integrated. 
"""
import sys
import os
import logging
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QTabWidget, 
    QMessageBox, QAction, QMenuBar, QDockWidget
)
from PyQt5.QtGui import QIcon

# --------------------------------------------------------------------------
# You would import all the classes from the previous parts here. 
# For demonstration, we assume they are in the same file. 
# In a real project, you'd do:
# from brm_master_part1 import DatabaseConnectionDialog, ...
# from brm_master_part2 import ...
# etc.
# --------------------------------------------------------------------------

logger = logging.getLogger("brm_master")


class BRMMainWindow(QMainWindow):
    """
    Our advanced main window that loads all tabs. 
    You can add or remove tabs based on your actual final design.
    """
    def __init__(self, connection, user_id, user_group):
        super().__init__()
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        self.setWindowTitle("BRM Master – Future-Ready Edition")
        self.setWindowIcon(QIcon("icons/brm_icon.png"))  # If you have an icon
        self.resize(1400, 900)

        # Central widget = tab container
        self.tab_container = QTabWidget()
        self.setCentralWidget(self.tab_container)

        # Example: adding advanced tabs from prior code
        #   1) BusinessRulesTab (with advanced wizard button)
        from PyQt5.QtWidgets import QWidget
        from your_brm_code_business_rules import BusinessRulesTab  # hypothetical import
        self.rules_tab = BusinessRulesTab(self.connection, self.user_id, self.user_group)
        self.tab_container.addTab(self.rules_tab, "Business Rules")

        #   2) Approvals
        from your_brm_code_approvals import EnhancedApprovalsTab  # hypothetical
        self.approvals_tab = EnhancedApprovalsTab(self.connection, "CurrentUserName", self.user_group)
        self.tab_container.addTab(self.approvals_tab, "Approvals")

        #   3) Conflict Priority
        from your_brm_code_conflict import ConflictPriorityManagerTab
        self.conflicts_tab = ConflictPriorityManagerTab(self.connection)
        self.tab_container.addTab(self.conflicts_tab, "Conflicts")

        #   4) Task Center
        from your_brm_code_part9 import TaskNotificationCenter
        self.task_center = TaskNotificationCenter(self.connection, self.user_id, self.user_group)
        self.tab_container.addTab(self.task_center, "My Tasks")

        #   5) Metrics (Advanced)
        from your_brm_code_metrics import AdvancedMetricsTab
        self.metrics_tab = AdvancedMetricsTab(self.connection)
        self.tab_container.addTab(self.metrics_tab, "Metrics")

        #   6) Collaboration
        from your_brm_code_collab import CollaborationTab  # or your advanced version
        self.collab_tab = CollaborationTab(self.connection, "CollaborationManager", self)
        self.tab_container.addTab(self.collab_tab, "Collaboration")

        #   7) Hierarchy
        from your_brm_code_hierarchy import HierarchyViewTab
        self.hierarchy_tab = HierarchyViewTab(self.connection)
        self.tab_container.addTab(self.hierarchy_tab, "Hierarchy")

        #   8) Global/Critical Admin
        from your_brm_code_gcr_admin import GlobalCriticalAdminTab
        self.gcr_tab = GlobalCriticalAdminTab(self.connection, self.user_group)
        self.tab_container.addTab(self.gcr_tab, "Global/Critical")

        #   9) Snapshots
        from your_brm_code_snapshots import SnapshotManagerTab
        self.snapshots_tab = SnapshotManagerTab(self.connection)
        self.tab_container.addTab(self.snapshots_tab, "Snapshots")

        #   10) Data Validation
        from your_brm_code_validations import DataValidationTab
        self.validation_tab = DataValidationTab(self.connection)
        self.tab_container.addTab(self.validation_tab, "Data Validations")

        #   11) Scheduling
        from your_brm_code_scheduling import ScheduleManagementTab
        self.sched_tab = ScheduleManagementTab(self.connection)
        self.tab_container.addTab(self.sched_tab, "Scheduling")

        #   12) Admin tabs – Group Mgr, User Mgr
        from your_brm_code_admin import GroupManagementTab, UserManagementTab
        self.group_mgr_tab = GroupManagementTab(self.connection, self.user_id, self.user_group)
        self.user_mgr_tab = UserManagementTab(self.connection)
        # We might add them in a separate QTabWidget or a sub-menu
        # For demonstration, we add them here:
        self.tab_container.addTab(self.group_mgr_tab, "Group Mgmt (Admin)")
        self.tab_container.addTab(self.user_mgr_tab, "User Mgmt (Admin)")

        # Menubar or toolbar for impersonation, anomalies, etc.
        self.build_menus()

    def build_menus(self):
        menubar = self.menuBar() if self.menuBar() else QMenuBar(self)
        self.setMenuBar(menubar)

        # Example: Tools -> Impersonate, AIOps, etc.
        tools_menu = menubar.addMenu("Tools")

        # Impersonation
        from your_brm_code_part9 import ImpersonationWidget
        self.impersonation_action = QAction("Impersonate User...", self)
        self.impersonation_action.triggered.connect(self.open_impersonation)
        tools_menu.addAction(self.impersonation_action)

        # AIOps/Anomaly
        self.aiops_action = QAction("Run Anomaly Detection", self)
        self.aiops_action.triggered.connect(self.run_anomalies)
        tools_menu.addAction(self.aiops_action)

    def open_impersonation(self):
        from your_brm_code_part9 import ImpersonationWidget
        # Minimal approach => show a dialog with the impersonation widget
        from PyQt5.QtWidgets import QDialog, QVBoxLayout
        dlg = QDialog(self)
        dlg.setWindowTitle("Impersonation")
        layout = QVBoxLayout(dlg)
        iw = ImpersonationWidget(self.connection, self.user_id, self.user_group)
        iw.impersonationChanged.connect(self.handle_impersonation_change)
        layout.addWidget(iw)
        dlg.setLayout(layout)
        dlg.exec_()

    def handle_impersonation_change(self, new_uid, new_grp):
        # update main window state
        self.user_id = new_uid
        self.user_group = new_grp
        QMessageBox.information(self, "Impersonation", f"Now acting as user {new_uid}, group {new_grp}. Reloading tabs might be required.")

    def run_anomalies(self):
        from your_brm_code_part9 import detect_rule_execution_anomalies, auto_heal_or_escalate
        anomalies = detect_rule_execution_anomalies(self.connection)
        if not anomalies:
            QMessageBox.information(self, "AIOps", "No anomalies detected.")
        else:
            msg = "Anomalies detected:\n"
            for (rid, reason) in anomalies:
                msg += f" • Rule {rid}: {reason}\n"
            QMessageBox.warning(self, "AIOps – Detected Anomalies", msg)
            # Possibly auto-heal or escalate
            auto_heal_or_escalate(self.connection, anomalies)


def main():
    import logging
    from PyQt5.QtWidgets import QApplication, QDialog

    logging.basicConfig(level=logging.DEBUG, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")

    app = QApplication(sys.argv)
    app.setApplicationName("BRM Master Next-Gen")

    # 1) DB Connection
    from your_brm_code_part1 import DatabaseConnectionDialog
    db_dialog = DatabaseConnectionDialog()
    if db_dialog.exec_() != QDialog.Accepted:
        sys.exit(0)
    conn = db_dialog.get_connection()
    if not conn:
        sys.exit(1)

    # 2) Login
    from your_brm_code_part1 import LoginDialog
    login_dlg = LoginDialog(conn)
    if login_dlg.exec_() != QDialog.Accepted:
        sys.exit(0)
    user_id = login_dlg.user_id
    user_grp = login_dlg.user_group
    if not user_id:
        sys.exit(1)

    # (Optional) Onboarding
    from your_brm_code_part1 import OnboardingWizard, UserState
    ustate = UserState(user_id, login_dlg.username, user_grp)
    try:
        # check if already onboarding completed
        c = conn.cursor()
        c.execute("SELECT ONBOARDING_COMPLETE FROM USERS WHERE USER_ID=?", (user_id,))
        row = c.fetchone()
        if row and row[0]!=1:
            wiz = OnboardingWizard(conn, ustate)
            wiz.exec_()
    except:
        pass

    # 3) Launch main window
    mainwin = BRMMainWindow(conn, user_id, user_grp)
    mainwin.show()

    sys.exit(app.exec_())


if __name__ == "__main__":
    main()


#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import re
import json
import logging
import pyodbc
import sqlparse
from datetime import datetime, timedelta

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QFormLayout, QGroupBox,
    QLineEdit, QComboBox, QDateTimeEdit, QLabel, QPlainTextEdit,
    QCheckBox, QPushButton, QMessageBox, QSpinBox
)

logger = logging.getLogger("brm_master")

##############################################################################
# Helper BFS Logic (Single-Rule Dry-Run or Minimal BFS)
##############################################################################

def detect_operation_type(sql_text: str) -> str:
    """
    Return one of: INSERT, UPDATE, DELETE, SELECT, or OTHER.
    Enhanced: Strip leading comments/whitespace before determining operation.
    """
    # Remove comments
    cleaned = re.sub(r'(--.*?$)|(/\*.*?\*/)', '', sql_text or '', flags=re.MULTILINE | re.DOTALL).lstrip()
    up = cleaned.upper()
    if up.startswith("INSERT"):
        return "INSERT"
    elif up.startswith("UPDATE"):
        return "UPDATE"
    elif up.startswith("DELETE"):
        return "DELETE"
    elif up.startswith("SELECT"):
        return "SELECT"
    else:
        return "OTHER"


def run_single_rule_in_transaction(conn, rule_sql, is_decision_table=False, dt_id=None):
    """
    Demonstrates how to do a single-rule “dry-run”:
     1. Open transaction
     2. Execute the SQL or Decision Table query
     3. If first col in first row == 1 => PASS, else FAIL
     4. ROLLBACK always for a “dry-run”
    Returns (bool pass_flag, str message).
    """
    c = conn.cursor()
    try:
        c.execute("BEGIN TRANSACTION")
    except:
        pass

    success = False
    msg = ""
    try:
        if is_decision_table and dt_id:
            # Hypothetical: fetch DECISION_QUERY from DECISION_TABLES:
            c2 = conn.cursor()
            c2.execute("SELECT DECISION_QUERY FROM DECISION_TABLES WHERE DECISION_TABLE_ID=?", (dt_id,))
            row = c2.fetchone()
            if not row:
                success = False
                msg = f"Decision table {dt_id} not found."
            else:
                query = row[0]
                c.execute(query)
                results = c.fetchall()
                if results:
                    val = results[0][0]
                    success = (val == 1)
                    msg = f"Decision table returned => {val}"
                else:
                    # If no rows, treat as PASS
                    success = True
                    msg = "No rows => PASS"
        else:
            # Normal SQL
            c.execute(rule_sql)
            try:
                rows = c.fetchall()
            except:
                rows = []
            if rows:
                val = rows[0][0]
                success = (val == 1)
                msg = f"Returned => {val}"
            else:
                success = True
                msg = "No rows => PASS"

        c.execute("ROLLBACK")
    except Exception as ex:
        try:
            c.execute("ROLLBACK")
        except:
            pass
        success = False
        msg = f"Exception: {ex}"

    return (success, msg)


##############################################################################
# SinglePageAddRuleDialog – with BFS “dry-run” and unified Impact Level
##############################################################################

class SinglePageAddRuleDialog(QtWidgets.QDialog):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        
        self.setWindowTitle("Add New Rule – Single-Page Form")
        self.resize(700, 620)

        main_layout = QVBoxLayout(self)
        
        ################################################################
        # 1) Basic info group
        ################################################################
        basic_group = QGroupBox("Basic Info")
        basic_layout = QFormLayout(basic_group)

        self.rule_name_edit = QLineEdit()
        self.rule_name_edit.setPlaceholderText("Enter a descriptive rule name")

        self.owner_combo = QComboBox()
        # Example: populate from DB
        #   e.g. SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_ID
        #   for each row: self.owner_combo.addItem(f"{gname} (ID={gid})", gid)
        #
        # For demonstration, let’s add some placeholders:
        self.owner_combo.addItem("Finance Dept (ID=101)", 101)
        self.owner_combo.addItem("Risk Dept (ID=202)", 202)
        self.owner_combo.addItem("Admin Group (ID=999)", 999)

        self.start_date_edit = QDateTimeEdit(QtCore.QDateTime.currentDateTime())
        self.start_date_edit.setCalendarPopup(True)
        self.end_date_edit = QDateTimeEdit(QtCore.QDateTime.currentDateTime().addDays(30))
        self.end_date_edit.setCalendarPopup(True)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","UPSERT","INSERT_ONLY"])

        basic_layout.addRow("Rule Name:", self.rule_name_edit)
        basic_layout.addRow("Owner Group:", self.owner_combo)

        # Effective Dates side by side
        date_h = QHBoxLayout()
        date_h.addWidget(QLabel("Start:"))
        date_h.addWidget(self.start_date_edit)
        date_h.addWidget(QLabel("End:"))
        date_h.addWidget(self.end_date_edit)
        basic_layout.addRow("Effective Dates:", date_h)

        basic_layout.addRow("CDC Type:", self.cdc_combo)
        
        main_layout.addWidget(basic_group)

        ################################################################
        # 2) Parent & Impact group
        ################################################################
        flags_group = QGroupBox("Hierarchy & Impact")
        flags_layout = QFormLayout(flags_group)
        
        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("(No Parent)", None)
        # Example placeholder items
        self.parent_rule_combo.addItem("Rule 10 – Parent ABC", 10)
        self.parent_rule_combo.addItem("Rule 99 – Parent XYZ", 99)

        # Single combo for Impact Level
        self.impact_level_combo = QComboBox()
        self.impact_level_combo.addItems([
            "Non‐Critical (Local)",
            "Critical – Group",
            "Critical – Cluster",
            "Critical – Global",
            "Global (Non‐Critical)"
        ])

        # row1 => parent
        row1_h = QHBoxLayout()
        row1_h.addWidget(QLabel("Parent Rule:"))
        row1_h.addWidget(self.parent_rule_combo)
        flags_layout.addRow(row1_h)

        # row2 => impact
        row2_h = QHBoxLayout()
        row2_h.addWidget(QLabel("Impact Level:"))
        row2_h.addWidget(self.impact_level_combo)
        flags_layout.addRow(row2_h)
        
        main_layout.addWidget(flags_group)
        
        ################################################################
        # 3) SQL vs. Decision Table group
        ################################################################
        logic_group = QGroupBox("Rule Logic")
        logic_layout = QVBoxLayout(logic_group)

        self.use_dt_cb = QCheckBox("Use Decision Table instead of SQL?")
        self.use_dt_cb.stateChanged.connect(self.toggle_dt_usage)
        logic_layout.addWidget(self.use_dt_cb)

        self.dt_combo = QComboBox()
        self.dt_combo.setEnabled(False)
        # Example placeholders:
        self.dt_combo.addItem("DT #1 – TableName: 'LoanRiskSegments'", 1)
        self.dt_combo.addItem("DT #2 – TableName: 'CreditThresholds'", 2)
        logic_layout.addWidget(self.dt_combo)

        self.sql_edit = QPlainTextEdit()
        self.sql_edit.setPlaceholderText("Enter rule SQL here (return 1 for PASS, 0 for FAIL, etc.)")
        logic_layout.addWidget(self.sql_edit)

        self.linter_label = QLabel("(No warnings)")
        logic_layout.addWidget(self.linter_label)

        main_layout.addWidget(logic_group)

        ################################################################
        # 4) Description / Comments group
        ################################################################
        desc_group = QGroupBox("Description / Comments")
        desc_layout = QVBoxLayout(desc_group)
        self.desc_edit = QPlainTextEdit()
        desc_layout.addWidget(self.desc_edit)
        main_layout.addWidget(desc_group)

        ################################################################
        # 5) Buttons: Dry-run, OK, Cancel
        ################################################################
        btn_h = QHBoxLayout()

        self.dryrun_btn = QPushButton("Dry-run")
        self.dryrun_btn.clicked.connect(self.handle_dry_run)
        btn_h.addWidget(self.dryrun_btn)

        btn_h.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self.accept_dialog)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_h.addWidget(ok_btn)
        btn_h.addWidget(cancel_btn)

        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)

        # Optionally: if you were updating an existing rule, you'd call a load_data(...) method
        # to fill fields with the existing DB record.


    ################################################################
    # Toggle DT usage
    ################################################################
    def toggle_dt_usage(self, state):
        is_checked = (state == Qt.Checked)
        self.dt_combo.setEnabled(is_checked)
        self.sql_edit.setEnabled(not is_checked)


    ################################################################
    # BFS or single-rule "dry-run" simulation
    ################################################################
    def handle_dry_run(self):
        """
        Gathers data from the dialog:
         - If “Use Decision Table” is checked => run single dt_id
         - Otherwise => run single rule_sql
         Then calls run_single_rule_in_transaction(...) with a transaction-based dry-run.
        Displays pass/fail in a message box.
        """
        use_dt = self.use_dt_cb.isChecked()
        if use_dt:
            dt_id = self.dt_combo.currentData()
            if not dt_id:
                QMessageBox.warning(self, "No Decision Table", "Please select a Decision Table first.")
                return
            success, msg = run_single_rule_in_transaction(
                conn=self.connection,
                rule_sql=None,  # not used if is_decision_table=True
                is_decision_table=True,
                dt_id=dt_id
            )
        else:
            rule_sql = self.sql_edit.toPlainText().strip()
            if not rule_sql:
                QMessageBox.warning(self, "SQL Missing", "Please enter SQL or use Decision Table.")
                return
            success, msg = run_single_rule_in_transaction(
                conn=self.connection,
                rule_sql=rule_sql,
                is_decision_table=False
            )

        # Show result in a message box
        if success:
            QMessageBox.information(self, "Dry-run Result", f"PASS => {msg}")
        else:
            QMessageBox.warning(self, "Dry-run Result", f"FAIL => {msg}")


    ################################################################
    # Insert or update the rule in DB (unified Impact => global/crit fields)
    ################################################################
    def accept_dialog(self):
        # Validate
        rule_name = self.rule_name_edit.text().strip()
        if not rule_name:
            QMessageBox.warning(self, "Validation", "Rule name is required.")
            return

        chosen_impact = self.impact_level_combo.currentText()
        # Translate “Impact Level” to is_global / critical / scope
        is_global = 0
        crit_rule = 0
        crit_scope = "NONE"

        if chosen_impact == "Non‐Critical (Local)":
            is_global = 0
            crit_rule = 0
            crit_scope = "NONE"
        elif chosen_impact == "Critical – Group":
            is_global = 0
            crit_rule = 1
            crit_scope = "GROUP"
        elif chosen_impact == "Critical – Cluster":
            is_global = 0
            crit_rule = 1
            crit_scope = "CLUSTER"
        elif chosen_impact == "Critical – Global":
            is_global = 1
            crit_rule = 1
            crit_scope = "GLOBAL"
        elif chosen_impact == "Global (Non‐Critical)":
            is_global = 1
            crit_rule = 0
            crit_scope = "GLOBAL"  # or “NONE”, depending on BFS logic

        # Grab the rest
        owner_group_id = self.owner_combo.currentData()  # if we stored group_id
        parent_rule_id = self.parent_rule_combo.currentData()
        cdc_type = self.cdc_combo.currentText()
        start_dt = self.start_date_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
        end_dt = self.end_date_edit.dateTime().toString("yyyy-MM-dd HH:mm:ss")

        use_dt = self.use_dt_cb.isChecked()
        if use_dt:
            dt_id = self.dt_combo.currentData()
            rule_sql = None
        else:
            dt_id = None
            rule_sql = self.sql_edit.toPlainText().strip()

        description = self.desc_edit.toPlainText().strip()

        # Insert (or update) in DB
        try:
            c = self.connection.cursor()
            # For demonstration: an INSERT
            c.execute("""
                INSERT INTO BRM_RULES(
                  RULE_NAME, GROUP_ID, PARENT_RULE_ID,
                  EFFECTIVE_START_DATE, EFFECTIVE_END_DATE,
                  CDC_TYPE, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE,
                  RULE_SQL, DECISION_TABLE_ID, DESCRIPTION,
                  CREATED_TIMESTAMP, APPROVAL_STATUS, STATUS
                )
                VALUES(?,?,?,?,?,?,?,?,?,?,?,?,GETDATE(),'APPROVAL_IN_PROGRESS','INACTIVE')
            """, (
                rule_name,
                owner_group_id if owner_group_id else None,
                parent_rule_id if parent_rule_id else None,
                start_dt, end_dt,
                cdc_type,
                is_global,
                crit_rule,
                crit_scope,
                rule_sql,
                dt_id,
                description
            ))
            self.connection.commit()

            QMessageBox.information(self, "Saved", f"Rule '{rule_name}' inserted.\nImpact Level: {chosen_impact}")
            self.accept()

        except Exception as ex:
            self.connection.rollback()
            QMessageBox.critical(self, "Error", f"Failed to save rule:\n{ex}")
